var e=Object.create,t=Object.defineProperty,n=Object.getOwnPropertyDescriptor,r=Object.getOwnPropertyNames,i=Object.getPrototypeOf,a=Object.prototype.hasOwnProperty,o=(e,t)=>()=>(e&&(t=e(e=0)),t),s=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),c=e=>{let n={};for(var r in e)t(n,r,{get:e[r],enumerable:!0});return n},l=(e,i,o,s)=>{if(i&&typeof i==`object`||typeof i==`function`)for(var c=r(i),l=0,u=c.length,d;l<u;l++)d=c[l],!a.call(e,d)&&d!==o&&t(e,d,{get:(e=>i[e]).bind(null,d),enumerable:!(s=n(i,d))||s.enumerable});return e},u=(n,r,a)=>(a=n==null?{}:e(i(n)),l(r||!n||!n.__esModule?t(a,`default`,{value:n,enumerable:!0}):a,n)),d=e=>l(t({},`__esModule`,{value:!0}),e);(function(){let e=document.createElement(`link`).relList;if(e&&e.supports&&e.supports(`modulepreload`))return;for(let e of document.querySelectorAll(`link[rel="modulepreload"]`))n(e);new MutationObserver(e=>{for(let t of e)if(t.type===`childList`)for(let e of t.addedNodes)e.tagName===`LINK`&&e.rel===`modulepreload`&&n(e)}).observe(document,{childList:!0,subtree:!0});function t(e){let t={};return e.integrity&&(t.integrity=e.integrity),e.referrerPolicy&&(t.referrerPolicy=e.referrerPolicy),e.crossOrigin===`use-credentials`?t.credentials=`include`:e.crossOrigin===`anonymous`?t.credentials=`omit`:t.credentials=`same-origin`,t}function n(e){if(e.ep)return;e.ep=!0;let n=t(e);fetch(e.href,n)}})();var f=s((e=>{var t=Symbol.for(`react.transitional.element`),n=Symbol.for(`react.portal`),r=Symbol.for(`react.fragment`),i=Symbol.for(`react.strict_mode`),a=Symbol.for(`react.profiler`),o=Symbol.for(`react.consumer`),s=Symbol.for(`react.context`),c=Symbol.for(`react.forward_ref`),l=Symbol.for(`react.suspense`),u=Symbol.for(`react.memo`),d=Symbol.for(`react.lazy`),f=Symbol.for(`react.activity`),p=Symbol.iterator;function m(e){return typeof e!=`object`||!e?null:(e=p&&e[p]||e[`@@iterator`],typeof e==`function`?e:null)}var h={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},g=Object.assign,_={};function v(e,t,n){this.props=e,this.context=t,this.refs=_,this.updater=n||h}v.prototype.isReactComponent={},v.prototype.setState=function(e,t){if(typeof e!=`object`&&typeof e!=`function`&&e!=null)throw Error(`takes an object of state variables to update or a function which returns an object of state variables.`);this.updater.enqueueSetState(this,e,t,`setState`)},v.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,`forceUpdate`)};function y(){}y.prototype=v.prototype;function b(e,t,n){this.props=e,this.context=t,this.refs=_,this.updater=n||h}var x=b.prototype=new y;x.constructor=b,g(x,v.prototype),x.isPureReactComponent=!0;var S=Array.isArray;function C(){}var w={H:null,A:null,T:null,S:null},T=Object.prototype.hasOwnProperty;function ee(e,n,r){var i=r.ref;return{$$typeof:t,type:e,key:n,ref:i===void 0?null:i,props:r}}function E(e,t){return ee(e.type,t,e.props)}function te(e){return typeof e==`object`&&!!e&&e.$$typeof===t}function ne(e){var t={"=":`=0`,":":`=2`};return`$`+e.replace(/[=:]/g,function(e){return t[e]})}var re=/\/+/g;function ie(e,t){return typeof e==`object`&&e&&e.key!=null?ne(``+e.key):t.toString(36)}function ae(e){switch(e.status){case`fulfilled`:return e.value;case`rejected`:throw e.reason;default:switch(typeof e.status==`string`?e.then(C,C):(e.status=`pending`,e.then(function(t){e.status===`pending`&&(e.status=`fulfilled`,e.value=t)},function(t){e.status===`pending`&&(e.status=`rejected`,e.reason=t)})),e.status){case`fulfilled`:return e.value;case`rejected`:throw e.reason}}throw e}function oe(e,r,i,a,o){var s=typeof e;(s===`undefined`||s===`boolean`)&&(e=null);var c=!1;if(e===null)c=!0;else switch(s){case`bigint`:case`string`:case`number`:c=!0;break;case`object`:switch(e.$$typeof){case t:case n:c=!0;break;case d:return c=e._init,oe(c(e._payload),r,i,a,o)}}if(c)return o=o(e),c=a===``?`.`+ie(e,0):a,S(o)?(i=``,c!=null&&(i=c.replace(re,`$&/`)+`/`),oe(o,r,i,``,function(e){return e})):o!=null&&(te(o)&&(o=E(o,i+(o.key==null||e&&e.key===o.key?``:(``+o.key).replace(re,`$&/`)+`/`)+c)),r.push(o)),1;c=0;var l=a===``?`.`:a+`:`;if(S(e))for(var u=0;u<e.length;u++)a=e[u],s=l+ie(a,u),c+=oe(a,r,i,s,o);else if(u=m(e),typeof u==`function`)for(e=u.call(e),u=0;!(a=e.next()).done;)a=a.value,s=l+ie(a,u++),c+=oe(a,r,i,s,o);else if(s===`object`){if(typeof e.then==`function`)return oe(ae(e),r,i,a,o);throw r=String(e),Error(`Objects are not valid as a React child (found: `+(r===`[object Object]`?`object with keys {`+Object.keys(e).join(`, `)+`}`:r)+`). If you meant to render a collection of children, use an array instead.`)}return c}function se(e,t,n){if(e==null)return e;var r=[],i=0;return oe(e,r,``,``,function(e){return t.call(n,e,i++)}),r}function ce(e){if(e._status===-1){var t=e._result;t=t(),t.then(function(t){(e._status===0||e._status===-1)&&(e._status=1,e._result=t)},function(t){(e._status===0||e._status===-1)&&(e._status=2,e._result=t)}),e._status===-1&&(e._status=0,e._result=t)}if(e._status===1)return e._result.default;throw e._result}var le=typeof reportError==`function`?reportError:function(e){if(typeof window==`object`&&typeof window.ErrorEvent==`function`){var t=new window.ErrorEvent(`error`,{bubbles:!0,cancelable:!0,message:typeof e==`object`&&e&&typeof e.message==`string`?String(e.message):String(e),error:e});if(!window.dispatchEvent(t))return}else if(typeof process==`object`&&typeof process.emit==`function`){process.emit(`uncaughtException`,e);return}console.error(e)},ue={map:se,forEach:function(e,t,n){se(e,function(){t.apply(this,arguments)},n)},count:function(e){var t=0;return se(e,function(){t++}),t},toArray:function(e){return se(e,function(e){return e})||[]},only:function(e){if(!te(e))throw Error(`React.Children.only expected to receive a single React element child.`);return e}};e.Activity=f,e.Children=ue,e.Component=v,e.Fragment=r,e.Profiler=a,e.PureComponent=b,e.StrictMode=i,e.Suspense=l,e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=w,e.__COMPILER_RUNTIME={__proto__:null,c:function(e){return w.H.useMemoCache(e)}},e.cache=function(e){return function(){return e.apply(null,arguments)}},e.cacheSignal=function(){return null},e.cloneElement=function(e,t,n){if(e==null)throw Error(`The argument must be a React element, but you passed `+e+`.`);var r=g({},e.props),i=e.key;if(t!=null)for(a in t.key!==void 0&&(i=``+t.key),t)!T.call(t,a)||a===`key`||a===`__self`||a===`__source`||a===`ref`&&t.ref===void 0||(r[a]=t[a]);var a=arguments.length-2;if(a===1)r.children=n;else if(1<a){for(var o=Array(a),s=0;s<a;s++)o[s]=arguments[s+2];r.children=o}return ee(e.type,i,r)},e.createContext=function(e){return e={$$typeof:s,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null},e.Provider=e,e.Consumer={$$typeof:o,_context:e},e},e.createElement=function(e,t,n){var r,i={},a=null;if(t!=null)for(r in t.key!==void 0&&(a=``+t.key),t)T.call(t,r)&&r!==`key`&&r!==`__self`&&r!==`__source`&&(i[r]=t[r]);var o=arguments.length-2;if(o===1)i.children=n;else if(1<o){for(var s=Array(o),c=0;c<o;c++)s[c]=arguments[c+2];i.children=s}if(e&&e.defaultProps)for(r in o=e.defaultProps,o)i[r]===void 0&&(i[r]=o[r]);return ee(e,a,i)},e.createRef=function(){return{current:null}},e.forwardRef=function(e){return{$$typeof:c,render:e}},e.isValidElement=te,e.lazy=function(e){return{$$typeof:d,_payload:{_status:-1,_result:e},_init:ce}},e.memo=function(e,t){return{$$typeof:u,type:e,compare:t===void 0?null:t}},e.startTransition=function(e){var t=w.T,n={};w.T=n;try{var r=e(),i=w.S;i!==null&&i(n,r),typeof r==`object`&&r&&typeof r.then==`function`&&r.then(C,le)}catch(e){le(e)}finally{t!==null&&n.types!==null&&(t.types=n.types),w.T=t}},e.unstable_useCacheRefresh=function(){return w.H.useCacheRefresh()},e.use=function(e){return w.H.use(e)},e.useActionState=function(e,t,n){return w.H.useActionState(e,t,n)},e.useCallback=function(e,t){return w.H.useCallback(e,t)},e.useContext=function(e){return w.H.useContext(e)},e.useDebugValue=function(){},e.useDeferredValue=function(e,t){return w.H.useDeferredValue(e,t)},e.useEffect=function(e,t){return w.H.useEffect(e,t)},e.useEffectEvent=function(e){return w.H.useEffectEvent(e)},e.useId=function(){return w.H.useId()},e.useImperativeHandle=function(e,t,n){return w.H.useImperativeHandle(e,t,n)},e.useInsertionEffect=function(e,t){return w.H.useInsertionEffect(e,t)},e.useLayoutEffect=function(e,t){return w.H.useLayoutEffect(e,t)},e.useMemo=function(e,t){return w.H.useMemo(e,t)},e.useOptimistic=function(e,t){return w.H.useOptimistic(e,t)},e.useReducer=function(e,t,n){return w.H.useReducer(e,t,n)},e.useRef=function(e){return w.H.useRef(e)},e.useState=function(e){return w.H.useState(e)},e.useSyncExternalStore=function(e,t,n){return w.H.useSyncExternalStore(e,t,n)},e.useTransition=function(){return w.H.useTransition()},e.version=`19.2.0`})),p=s(((e,t)=>{t.exports=f()})),m=s((e=>{function t(e,t){var n=e.length;e.push(t);a:for(;0<n;){var r=n-1>>>1,a=e[r];if(0<i(a,t))e[r]=t,e[n]=a,n=r;else break a}}function n(e){return e.length===0?null:e[0]}function r(e){if(e.length===0)return null;var t=e[0],n=e.pop();if(n!==t){e[0]=n;a:for(var r=0,a=e.length,o=a>>>1;r<o;){var s=2*(r+1)-1,c=e[s],l=s+1,u=e[l];if(0>i(c,n))l<a&&0>i(u,c)?(e[r]=u,e[l]=n,r=l):(e[r]=c,e[s]=n,r=s);else if(l<a&&0>i(u,n))e[r]=u,e[l]=n,r=l;else break a}}return t}function i(e,t){var n=e.sortIndex-t.sortIndex;return n===0?e.id-t.id:n}if(e.unstable_now=void 0,typeof performance==`object`&&typeof performance.now==`function`){var a=performance;e.unstable_now=function(){return a.now()}}else{var o=Date,s=o.now();e.unstable_now=function(){return o.now()-s}}var c=[],l=[],u=1,d=null,f=3,p=!1,m=!1,h=!1,g=!1,_=typeof setTimeout==`function`?setTimeout:null,v=typeof clearTimeout==`function`?clearTimeout:null,y=typeof setImmediate<`u`?setImmediate:null;function b(e){for(var i=n(l);i!==null;){if(i.callback===null)r(l);else if(i.startTime<=e)r(l),i.sortIndex=i.expirationTime,t(c,i);else break;i=n(l)}}function x(e){if(h=!1,b(e),!m)if(n(c)!==null)m=!0,S||(S=!0,te());else{var t=n(l);t!==null&&ie(x,t.startTime-e)}}var S=!1,C=-1,w=5,T=-1;function ee(){return g?!0:!(e.unstable_now()-T<w)}function E(){if(g=!1,S){var t=e.unstable_now();T=t;var i=!0;try{a:{m=!1,h&&(h=!1,v(C),C=-1),p=!0;var a=f;try{b:{for(b(t),d=n(c);d!==null&&!(d.expirationTime>t&&ee());){var o=d.callback;if(typeof o==`function`){d.callback=null,f=d.priorityLevel;var s=o(d.expirationTime<=t);if(t=e.unstable_now(),typeof s==`function`){d.callback=s,b(t),i=!0;break b}d===n(c)&&r(c),b(t)}else r(c);d=n(c)}if(d!==null)i=!0;else{var u=n(l);u!==null&&ie(x,u.startTime-t),i=!1}}break a}finally{d=null,f=a,p=!1}i=void 0}}finally{i?te():S=!1}}}var te;if(typeof y==`function`)te=function(){y(E)};else if(typeof MessageChannel<`u`){var ne=new MessageChannel,re=ne.port2;ne.port1.onmessage=E,te=function(){re.postMessage(null)}}else te=function(){_(E,0)};function ie(t,n){C=_(function(){t(e.unstable_now())},n)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(e){e.callback=null},e.unstable_forceFrameRate=function(e){0>e||125<e?console.error(`forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported`):w=0<e?Math.floor(1e3/e):5},e.unstable_getCurrentPriorityLevel=function(){return f},e.unstable_next=function(e){switch(f){case 1:case 2:case 3:var t=3;break;default:t=f}var n=f;f=t;try{return e()}finally{f=n}},e.unstable_requestPaint=function(){g=!0},e.unstable_runWithPriority=function(e,t){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var n=f;f=e;try{return t()}finally{f=n}},e.unstable_scheduleCallback=function(r,i,a){var o=e.unstable_now();switch(typeof a==`object`&&a?(a=a.delay,a=typeof a==`number`&&0<a?o+a:o):a=o,r){case 1:var s=-1;break;case 2:s=250;break;case 5:s=1073741823;break;case 4:s=1e4;break;default:s=5e3}return s=a+s,r={id:u++,callback:i,priorityLevel:r,startTime:a,expirationTime:s,sortIndex:-1},a>o?(r.sortIndex=a,t(l,r),n(c)===null&&r===n(l)&&(h?(v(C),C=-1):h=!0,ie(x,a-o))):(r.sortIndex=s,t(c,r),m||p||(m=!0,S||(S=!0,te()))),r},e.unstable_shouldYield=ee,e.unstable_wrapCallback=function(e){var t=f;return function(){var n=f;f=t;try{return e.apply(this,arguments)}finally{f=n}}}})),h=s(((e,t)=>{t.exports=m()})),g=s((e=>{var t=p();function n(e){var t=`https://react.dev/errors/`+e;if(1<arguments.length){t+=`?args[]=`+encodeURIComponent(arguments[1]);for(var n=2;n<arguments.length;n++)t+=`&args[]=`+encodeURIComponent(arguments[n])}return`Minified React error #`+e+`; visit `+t+` for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`}function r(){}var i={d:{f:r,r:function(){throw Error(n(522))},D:r,C:r,L:r,m:r,X:r,S:r,M:r},p:0,findDOMNode:null},a=Symbol.for(`react.portal`);function o(e,t,n){var r=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:a,key:r==null?null:``+r,children:e,containerInfo:t,implementation:n}}var s=t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function c(e,t){if(e===`font`)return``;if(typeof t==`string`)return t===`use-credentials`?t:``}e.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=i,e.createPortal=function(e,t){var r=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!t||t.nodeType!==1&&t.nodeType!==9&&t.nodeType!==11)throw Error(n(299));return o(e,t,null,r)},e.flushSync=function(e){var t=s.T,n=i.p;try{if(s.T=null,i.p=2,e)return e()}finally{s.T=t,i.p=n,i.d.f()}},e.preconnect=function(e,t){typeof e==`string`&&(t?(t=t.crossOrigin,t=typeof t==`string`?t===`use-credentials`?t:``:void 0):t=null,i.d.C(e,t))},e.prefetchDNS=function(e){typeof e==`string`&&i.d.D(e)},e.preinit=function(e,t){if(typeof e==`string`&&t&&typeof t.as==`string`){var n=t.as,r=c(n,t.crossOrigin),a=typeof t.integrity==`string`?t.integrity:void 0,o=typeof t.fetchPriority==`string`?t.fetchPriority:void 0;n===`style`?i.d.S(e,typeof t.precedence==`string`?t.precedence:void 0,{crossOrigin:r,integrity:a,fetchPriority:o}):n===`script`&&i.d.X(e,{crossOrigin:r,integrity:a,fetchPriority:o,nonce:typeof t.nonce==`string`?t.nonce:void 0})}},e.preinitModule=function(e,t){if(typeof e==`string`)if(typeof t==`object`&&t){if(t.as==null||t.as===`script`){var n=c(t.as,t.crossOrigin);i.d.M(e,{crossOrigin:n,integrity:typeof t.integrity==`string`?t.integrity:void 0,nonce:typeof t.nonce==`string`?t.nonce:void 0})}}else t??i.d.M(e)},e.preload=function(e,t){if(typeof e==`string`&&typeof t==`object`&&t&&typeof t.as==`string`){var n=t.as,r=c(n,t.crossOrigin);i.d.L(e,n,{crossOrigin:r,integrity:typeof t.integrity==`string`?t.integrity:void 0,nonce:typeof t.nonce==`string`?t.nonce:void 0,type:typeof t.type==`string`?t.type:void 0,fetchPriority:typeof t.fetchPriority==`string`?t.fetchPriority:void 0,referrerPolicy:typeof t.referrerPolicy==`string`?t.referrerPolicy:void 0,imageSrcSet:typeof t.imageSrcSet==`string`?t.imageSrcSet:void 0,imageSizes:typeof t.imageSizes==`string`?t.imageSizes:void 0,media:typeof t.media==`string`?t.media:void 0})}},e.preloadModule=function(e,t){if(typeof e==`string`)if(t){var n=c(t.as,t.crossOrigin);i.d.m(e,{as:typeof t.as==`string`&&t.as!==`script`?t.as:void 0,crossOrigin:n,integrity:typeof t.integrity==`string`?t.integrity:void 0})}else i.d.m(e)},e.requestFormReset=function(e){i.d.r(e)},e.unstable_batchedUpdates=function(e,t){return e(t)},e.useFormState=function(e,t,n){return s.H.useFormState(e,t,n)},e.useFormStatus=function(){return s.H.useHostTransitionStatus()},e.version=`19.2.0`})),_=s(((e,t)=>{function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>`u`||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!=`function`))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}n(),t.exports=g()})),v=s((e=>{var t=h(),n=p(),r=_();function i(e){var t=`https://react.dev/errors/`+e;if(1<arguments.length){t+=`?args[]=`+encodeURIComponent(arguments[1]);for(var n=2;n<arguments.length;n++)t+=`&args[]=`+encodeURIComponent(arguments[n])}return`Minified React error #`+e+`; visit `+t+` for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`}function a(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11)}function o(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do t=e,t.flags&4098&&(n=t.return),e=t.return;while(e)}return t.tag===3?n:null}function s(e){if(e.tag===13){var t=e.memoizedState;if(t===null&&(e=e.alternate,e!==null&&(t=e.memoizedState)),t!==null)return t.dehydrated}return null}function c(e){if(e.tag===31){var t=e.memoizedState;if(t===null&&(e=e.alternate,e!==null&&(t=e.memoizedState)),t!==null)return t.dehydrated}return null}function l(e){if(o(e)!==e)throw Error(i(188))}function u(e){var t=e.alternate;if(!t){if(t=o(e),t===null)throw Error(i(188));return t===e?e:null}for(var n=e,r=t;;){var a=n.return;if(a===null)break;var s=a.alternate;if(s===null){if(r=a.return,r!==null){n=r;continue}break}if(a.child===s.child){for(s=a.child;s;){if(s===n)return l(a),e;if(s===r)return l(a),t;s=s.sibling}throw Error(i(188))}if(n.return!==r.return)n=a,r=s;else{for(var c=!1,u=a.child;u;){if(u===n){c=!0,n=a,r=s;break}if(u===r){c=!0,r=a,n=s;break}u=u.sibling}if(!c){for(u=s.child;u;){if(u===n){c=!0,n=s,r=a;break}if(u===r){c=!0,r=s,n=a;break}u=u.sibling}if(!c)throw Error(i(189))}}if(n.alternate!==r)throw Error(i(190))}if(n.tag!==3)throw Error(i(188));return n.stateNode.current===n?e:t}function d(e){var t=e.tag;if(t===5||t===26||t===27||t===6)return e;for(e=e.child;e!==null;){if(t=d(e),t!==null)return t;e=e.sibling}return null}var f=Object.assign,m=Symbol.for(`react.element`),g=Symbol.for(`react.transitional.element`),v=Symbol.for(`react.portal`),y=Symbol.for(`react.fragment`),b=Symbol.for(`react.strict_mode`),x=Symbol.for(`react.profiler`),S=Symbol.for(`react.consumer`),C=Symbol.for(`react.context`),w=Symbol.for(`react.forward_ref`),T=Symbol.for(`react.suspense`),ee=Symbol.for(`react.suspense_list`),E=Symbol.for(`react.memo`),te=Symbol.for(`react.lazy`),ne=Symbol.for(`react.activity`),re=Symbol.for(`react.memo_cache_sentinel`),ie=Symbol.iterator;function ae(e){return typeof e!=`object`||!e?null:(e=ie&&e[ie]||e[`@@iterator`],typeof e==`function`?e:null)}var oe=Symbol.for(`react.client.reference`);function se(e){if(e==null)return null;if(typeof e==`function`)return e.$$typeof===oe?null:e.displayName||e.name||null;if(typeof e==`string`)return e;switch(e){case y:return`Fragment`;case x:return`Profiler`;case b:return`StrictMode`;case T:return`Suspense`;case ee:return`SuspenseList`;case ne:return`Activity`}if(typeof e==`object`)switch(e.$$typeof){case v:return`Portal`;case C:return e.displayName||`Context`;case S:return(e._context.displayName||`Context`)+`.Consumer`;case w:var t=e.render;return e=e.displayName,e||=(e=t.displayName||t.name||``,e===``?`ForwardRef`:`ForwardRef(`+e+`)`),e;case E:return t=e.displayName||null,t===null?se(e.type)||`Memo`:t;case te:t=e._payload,e=e._init;try{return se(e(t))}catch{}}return null}var ce=Array.isArray,le=n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,ue=r.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,de={pending:!1,data:null,method:null,action:null},D=[],fe=-1;function pe(e){return{current:e}}function O(e){0>fe||(e.current=D[fe],D[fe]=null,fe--)}function me(e,t){fe++,D[fe]=e.current,e.current=t}var he=pe(null),ge=pe(null),_e=pe(null),ve=pe(null);function ye(e,t){switch(me(_e,t),me(ge,e),me(he,null),t.nodeType){case 9:case 11:e=(e=t.documentElement)&&(e=e.namespaceURI)?ff(e):0;break;default:if(e=t.tagName,t=t.namespaceURI)t=ff(t),e=pf(t,e);else switch(e){case`svg`:e=1;break;case`math`:e=2;break;default:e=0}}O(he),me(he,e)}function be(){O(he),O(ge),O(_e)}function xe(e){e.memoizedState!==null&&me(ve,e);var t=he.current,n=pf(t,e.type);t!==n&&(me(ge,e),me(he,n))}function Se(e){ge.current===e&&(O(he),O(ge)),ve.current===e&&(O(ve),xp._currentValue=de)}var Ce,we;function Te(e){if(Ce===void 0)try{throw Error()}catch(e){var t=e.stack.trim().match(/\n( *(at )?)/);Ce=t&&t[1]||``,we=-1<e.stack.indexOf(`
    at`)?` (<anonymous>)`:-1<e.stack.indexOf(`@`)?`@unknown:0:0`:``}return`
`+Ce+e+we}var Ee=!1;function De(e,t){if(!e||Ee)return``;Ee=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var r={DetermineComponentFrameRoot:function(){try{if(t){var n=function(){throw Error()};if(Object.defineProperty(n.prototype,`props`,{set:function(){throw Error()}}),typeof Reflect==`object`&&Reflect.construct){try{Reflect.construct(n,[])}catch(e){var r=e}Reflect.construct(e,[],n)}else{try{n.call()}catch(e){r=e}e.call(n.prototype)}}else{try{throw Error()}catch(e){r=e}(n=e())&&typeof n.catch==`function`&&n.catch(function(){})}}catch(e){if(e&&r&&typeof e.stack==`string`)return[e.stack,r.stack]}return[null,null]}};r.DetermineComponentFrameRoot.displayName=`DetermineComponentFrameRoot`;var i=Object.getOwnPropertyDescriptor(r.DetermineComponentFrameRoot,`name`);i&&i.configurable&&Object.defineProperty(r.DetermineComponentFrameRoot,`name`,{value:`DetermineComponentFrameRoot`});var a=r.DetermineComponentFrameRoot(),o=a[0],s=a[1];if(o&&s){var c=o.split(`
`),l=s.split(`
`);for(i=r=0;r<c.length&&!c[r].includes(`DetermineComponentFrameRoot`);)r++;for(;i<l.length&&!l[i].includes(`DetermineComponentFrameRoot`);)i++;if(r===c.length||i===l.length)for(r=c.length-1,i=l.length-1;1<=r&&0<=i&&c[r]!==l[i];)i--;for(;1<=r&&0<=i;r--,i--)if(c[r]!==l[i]){if(r!==1||i!==1)do if(r--,i--,0>i||c[r]!==l[i]){var u=`
`+c[r].replace(` at new `,` at `);return e.displayName&&u.includes(`<anonymous>`)&&(u=u.replace(`<anonymous>`,e.displayName)),u}while(1<=r&&0<=i);break}}}finally{Ee=!1,Error.prepareStackTrace=n}return(n=e?e.displayName||e.name:``)?Te(n):``}function Oe(e,t){switch(e.tag){case 26:case 27:case 5:return Te(e.type);case 16:return Te(`Lazy`);case 13:return e.child!==t&&t!==null?Te(`Suspense Fallback`):Te(`Suspense`);case 19:return Te(`SuspenseList`);case 0:case 15:return De(e.type,!1);case 11:return De(e.type.render,!1);case 1:return De(e.type,!0);case 31:return Te(`Activity`);default:return``}}function ke(e){try{var t=``,n=null;do t+=Oe(e,n),n=e,e=e.return;while(e);return t}catch(e){return`
Error generating stack: `+e.message+`
`+e.stack}}var Ae=Object.prototype.hasOwnProperty,je=t.unstable_scheduleCallback,Me=t.unstable_cancelCallback,Ne=t.unstable_shouldYield,Pe=t.unstable_requestPaint,Fe=t.unstable_now,Ie=t.unstable_getCurrentPriorityLevel,Le=t.unstable_ImmediatePriority,Re=t.unstable_UserBlockingPriority,ze=t.unstable_NormalPriority,Be=t.unstable_LowPriority,Ve=t.unstable_IdlePriority,He=t.log,Ue=t.unstable_setDisableYieldValue,We=null,Ge=null;function Ke(e){if(typeof He==`function`&&Ue(e),Ge&&typeof Ge.setStrictMode==`function`)try{Ge.setStrictMode(We,e)}catch{}}var qe=Math.clz32?Math.clz32:Xe,Je=Math.log,Ye=Math.LN2;function Xe(e){return e>>>=0,e===0?32:31-(Je(e)/Ye|0)|0}var Ze=256,Qe=262144,$e=4194304;function k(e){var t=e&42;if(t!==0)return t;switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:return e&261888;case 262144:case 524288:case 1048576:case 2097152:return e&3932160;case 4194304:case 8388608:case 16777216:case 33554432:return e&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return e}}function et(e,t,n){var r=e.pendingLanes;if(r===0)return 0;var i=0,a=e.suspendedLanes,o=e.pingedLanes;e=e.warmLanes;var s=r&134217727;return s===0?(s=r&~a,s===0?o===0?n||(n=r&~e,n!==0&&(i=k(n))):i=k(o):i=k(s)):(r=s&~a,r===0?(o&=s,o===0?n||(n=s&~e,n!==0&&(i=k(n))):i=k(o)):i=k(r)),i===0?0:t!==0&&t!==i&&(t&a)===0&&(a=i&-i,n=t&-t,a>=n||a===32&&n&4194048)?t:i}function tt(e,t){return(e.pendingLanes&~(e.suspendedLanes&~e.pingedLanes)&t)===0}function nt(e,t){switch(e){case 1:case 2:case 4:case 8:case 64:return t+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function rt(){var e=$e;return $e<<=1,!($e&62914560)&&($e=4194304),e}function it(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function at(e,t){e.pendingLanes|=t,t!==268435456&&(e.suspendedLanes=0,e.pingedLanes=0,e.warmLanes=0)}function ot(e,t,n,r,i,a){var o=e.pendingLanes;e.pendingLanes=n,e.suspendedLanes=0,e.pingedLanes=0,e.warmLanes=0,e.expiredLanes&=n,e.entangledLanes&=n,e.errorRecoveryDisabledLanes&=n,e.shellSuspendCounter=0;var s=e.entanglements,c=e.expirationTimes,l=e.hiddenUpdates;for(n=o&~n;0<n;){var u=31-qe(n),d=1<<u;s[u]=0,c[u]=-1;var f=l[u];if(f!==null)for(l[u]=null,u=0;u<f.length;u++){var p=f[u];p!==null&&(p.lane&=-536870913)}n&=~d}r!==0&&st(e,r,0),a!==0&&i===0&&e.tag!==0&&(e.suspendedLanes|=a&~(o&~t))}function st(e,t,n){e.pendingLanes|=t,e.suspendedLanes&=~t;var r=31-qe(t);e.entangledLanes|=t,e.entanglements[r]=e.entanglements[r]|1073741824|n&261930}function ct(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var r=31-qe(n),i=1<<r;i&t|e[r]&t&&(e[r]|=t),n&=~i}}function lt(e,t){var n=t&-t;return n=n&42?1:ut(n),(n&(e.suspendedLanes|t))===0?n:0}function ut(e){switch(e){case 2:e=1;break;case 8:e=4;break;case 32:e=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:e=128;break;case 268435456:e=134217728;break;default:e=0}return e}function dt(e){return e&=-e,2<e?8<e?e&134217727?32:268435456:8:2}function ft(){var e=ue.p;return e===0?(e=window.event,e===void 0?32:Lp(e.type)):e}function pt(e,t){var n=ue.p;try{return ue.p=e,t()}finally{ue.p=n}}var mt=Math.random().toString(36).slice(2),ht=`__reactFiber$`+mt,gt=`__reactProps$`+mt,_t=`__reactContainer$`+mt,vt=`__reactEvents$`+mt,yt=`__reactListeners$`+mt,bt=`__reactHandles$`+mt,xt=`__reactResources$`+mt,St=`__reactMarker$`+mt;function Ct(e){delete e[ht],delete e[gt],delete e[vt],delete e[yt],delete e[bt]}function wt(e){var t=e[ht];if(t)return t;for(var n=e.parentNode;n;){if(t=n[_t]||n[ht]){if(n=t.alternate,t.child!==null||n!==null&&n.child!==null)for(e=Ff(e);e!==null;){if(n=e[ht])return n;e=Ff(e)}return t}e=n,n=e.parentNode}return null}function Tt(e){if(e=e[ht]||e[_t]){var t=e.tag;if(t===5||t===6||t===13||t===31||t===26||t===27||t===3)return e}return null}function Et(e){var t=e.tag;if(t===5||t===26||t===27||t===6)return e.stateNode;throw Error(i(33))}function Dt(e){var t=e[xt];return t||=e[xt]={hoistableStyles:new Map,hoistableScripts:new Map},t}function Ot(e){e[St]=!0}var kt=new Set,At={};function jt(e,t){Mt(e,t),Mt(e+`Capture`,t)}function Mt(e,t){for(At[e]=t,e=0;e<t.length;e++)kt.add(t[e])}var Nt=RegExp(`^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$`),Pt={},Ft={};function It(e){return Ae.call(Ft,e)?!0:Ae.call(Pt,e)?!1:Nt.test(e)?Ft[e]=!0:(Pt[e]=!0,!1)}function Lt(e,t,n){if(It(t))if(n===null)e.removeAttribute(t);else{switch(typeof n){case`undefined`:case`function`:case`symbol`:e.removeAttribute(t);return;case`boolean`:var r=t.toLowerCase().slice(0,5);if(r!==`data-`&&r!==`aria-`){e.removeAttribute(t);return}}e.setAttribute(t,``+n)}}function Rt(e,t,n){if(n===null)e.removeAttribute(t);else{switch(typeof n){case`undefined`:case`function`:case`symbol`:case`boolean`:e.removeAttribute(t);return}e.setAttribute(t,``+n)}}function zt(e,t,n,r){if(r===null)e.removeAttribute(n);else{switch(typeof r){case`undefined`:case`function`:case`symbol`:case`boolean`:e.removeAttribute(n);return}e.setAttributeNS(t,n,``+r)}}function Bt(e){switch(typeof e){case`bigint`:case`boolean`:case`number`:case`string`:case`undefined`:return e;case`object`:return e;default:return``}}function Vt(e){var t=e.type;return(e=e.nodeName)&&e.toLowerCase()===`input`&&(t===`checkbox`||t===`radio`)}function Ht(e,t,n){var r=Object.getOwnPropertyDescriptor(e.constructor.prototype,t);if(!e.hasOwnProperty(t)&&r!==void 0&&typeof r.get==`function`&&typeof r.set==`function`){var i=r.get,a=r.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return i.call(this)},set:function(e){n=``+e,a.call(this,e)}}),Object.defineProperty(e,t,{enumerable:r.enumerable}),{getValue:function(){return n},setValue:function(e){n=``+e},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}function Ut(e){if(!e._valueTracker){var t=Vt(e)?`checked`:`value`;e._valueTracker=Ht(e,t,``+e[t])}}function Wt(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),r=``;return e&&(r=Vt(e)?e.checked?`true`:`false`:e.value),e=r,e===n?!1:(t.setValue(e),!0)}function Gt(e){if(e||=typeof document<`u`?document:void 0,e===void 0)return null;try{return e.activeElement||e.body}catch{return e.body}}var Kt=/[\n"\\]/g;function qt(e){return e.replace(Kt,function(e){return`\\`+e.charCodeAt(0).toString(16)+` `})}function Jt(e,t,n,r,i,a,o,s){e.name=``,o!=null&&typeof o!=`function`&&typeof o!=`symbol`&&typeof o!=`boolean`?e.type=o:e.removeAttribute(`type`),t==null?o!==`submit`&&o!==`reset`||e.removeAttribute(`value`):o===`number`?(t===0&&e.value===``||e.value!=t)&&(e.value=``+Bt(t)):e.value!==``+Bt(t)&&(e.value=``+Bt(t)),t==null?n==null?r!=null&&e.removeAttribute(`value`):Xt(e,o,Bt(n)):Xt(e,o,Bt(t)),i==null&&a!=null&&(e.defaultChecked=!!a),i!=null&&(e.checked=i&&typeof i!=`function`&&typeof i!=`symbol`),s!=null&&typeof s!=`function`&&typeof s!=`symbol`&&typeof s!=`boolean`?e.name=``+Bt(s):e.removeAttribute(`name`)}function Yt(e,t,n,r,i,a,o,s){if(a!=null&&typeof a!=`function`&&typeof a!=`symbol`&&typeof a!=`boolean`&&(e.type=a),t!=null||n!=null){if(!(a!==`submit`&&a!==`reset`||t!=null)){Ut(e);return}n=n==null?``:``+Bt(n),t=t==null?n:``+Bt(t),s||t===e.value||(e.value=t),e.defaultValue=t}r??=i,r=typeof r!=`function`&&typeof r!=`symbol`&&!!r,e.checked=s?e.checked:!!r,e.defaultChecked=!!r,o!=null&&typeof o!=`function`&&typeof o!=`symbol`&&typeof o!=`boolean`&&(e.name=o),Ut(e)}function Xt(e,t,n){t===`number`&&Gt(e.ownerDocument)===e||e.defaultValue===``+n||(e.defaultValue=``+n)}function Zt(e,t,n,r){if(e=e.options,t){t={};for(var i=0;i<n.length;i++)t[`$`+n[i]]=!0;for(n=0;n<e.length;n++)i=t.hasOwnProperty(`$`+e[n].value),e[n].selected!==i&&(e[n].selected=i),i&&r&&(e[n].defaultSelected=!0)}else{for(n=``+Bt(n),t=null,i=0;i<e.length;i++){if(e[i].value===n){e[i].selected=!0,r&&(e[i].defaultSelected=!0);return}t!==null||e[i].disabled||(t=e[i])}t!==null&&(t.selected=!0)}}function Qt(e,t,n){if(t!=null&&(t=``+Bt(t),t!==e.value&&(e.value=t),n==null)){e.defaultValue!==t&&(e.defaultValue=t);return}e.defaultValue=n==null?``:``+Bt(n)}function $t(e,t,n,r){if(t==null){if(r!=null){if(n!=null)throw Error(i(92));if(ce(r)){if(1<r.length)throw Error(i(93));r=r[0]}n=r}n??=``,t=n}n=Bt(t),e.defaultValue=n,r=e.textContent,r===n&&r!==``&&r!==null&&(e.value=r),Ut(e)}function en(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&n.nodeType===3){n.nodeValue=t;return}}e.textContent=t}var tn=new Set(`animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp`.split(` `));function nn(e,t,n){var r=t.indexOf(`--`)===0;n==null||typeof n==`boolean`||n===``?r?e.setProperty(t,``):t===`float`?e.cssFloat=``:e[t]=``:r?e.setProperty(t,n):typeof n!=`number`||n===0||tn.has(t)?t===`float`?e.cssFloat=n:e[t]=(``+n).trim():e[t]=n+`px`}function rn(e,t,n){if(t!=null&&typeof t!=`object`)throw Error(i(62));if(e=e.style,n!=null){for(var r in n)!n.hasOwnProperty(r)||t!=null&&t.hasOwnProperty(r)||(r.indexOf(`--`)===0?e.setProperty(r,``):r===`float`?e.cssFloat=``:e[r]=``);for(var a in t)r=t[a],t.hasOwnProperty(a)&&n[a]!==r&&nn(e,a,r)}else for(var o in t)t.hasOwnProperty(o)&&nn(e,o,t[o])}function an(e){if(e.indexOf(`-`)===-1)return!1;switch(e){case`annotation-xml`:case`color-profile`:case`font-face`:case`font-face-src`:case`font-face-uri`:case`font-face-format`:case`font-face-name`:case`missing-glyph`:return!1;default:return!0}}var on=new Map([[`acceptCharset`,`accept-charset`],[`htmlFor`,`for`],[`httpEquiv`,`http-equiv`],[`crossOrigin`,`crossorigin`],[`accentHeight`,`accent-height`],[`alignmentBaseline`,`alignment-baseline`],[`arabicForm`,`arabic-form`],[`baselineShift`,`baseline-shift`],[`capHeight`,`cap-height`],[`clipPath`,`clip-path`],[`clipRule`,`clip-rule`],[`colorInterpolation`,`color-interpolation`],[`colorInterpolationFilters`,`color-interpolation-filters`],[`colorProfile`,`color-profile`],[`colorRendering`,`color-rendering`],[`dominantBaseline`,`dominant-baseline`],[`enableBackground`,`enable-background`],[`fillOpacity`,`fill-opacity`],[`fillRule`,`fill-rule`],[`floodColor`,`flood-color`],[`floodOpacity`,`flood-opacity`],[`fontFamily`,`font-family`],[`fontSize`,`font-size`],[`fontSizeAdjust`,`font-size-adjust`],[`fontStretch`,`font-stretch`],[`fontStyle`,`font-style`],[`fontVariant`,`font-variant`],[`fontWeight`,`font-weight`],[`glyphName`,`glyph-name`],[`glyphOrientationHorizontal`,`glyph-orientation-horizontal`],[`glyphOrientationVertical`,`glyph-orientation-vertical`],[`horizAdvX`,`horiz-adv-x`],[`horizOriginX`,`horiz-origin-x`],[`imageRendering`,`image-rendering`],[`letterSpacing`,`letter-spacing`],[`lightingColor`,`lighting-color`],[`markerEnd`,`marker-end`],[`markerMid`,`marker-mid`],[`markerStart`,`marker-start`],[`overlinePosition`,`overline-position`],[`overlineThickness`,`overline-thickness`],[`paintOrder`,`paint-order`],[`panose-1`,`panose-1`],[`pointerEvents`,`pointer-events`],[`renderingIntent`,`rendering-intent`],[`shapeRendering`,`shape-rendering`],[`stopColor`,`stop-color`],[`stopOpacity`,`stop-opacity`],[`strikethroughPosition`,`strikethrough-position`],[`strikethroughThickness`,`strikethrough-thickness`],[`strokeDasharray`,`stroke-dasharray`],[`strokeDashoffset`,`stroke-dashoffset`],[`strokeLinecap`,`stroke-linecap`],[`strokeLinejoin`,`stroke-linejoin`],[`strokeMiterlimit`,`stroke-miterlimit`],[`strokeOpacity`,`stroke-opacity`],[`strokeWidth`,`stroke-width`],[`textAnchor`,`text-anchor`],[`textDecoration`,`text-decoration`],[`textRendering`,`text-rendering`],[`transformOrigin`,`transform-origin`],[`underlinePosition`,`underline-position`],[`underlineThickness`,`underline-thickness`],[`unicodeBidi`,`unicode-bidi`],[`unicodeRange`,`unicode-range`],[`unitsPerEm`,`units-per-em`],[`vAlphabetic`,`v-alphabetic`],[`vHanging`,`v-hanging`],[`vIdeographic`,`v-ideographic`],[`vMathematical`,`v-mathematical`],[`vectorEffect`,`vector-effect`],[`vertAdvY`,`vert-adv-y`],[`vertOriginX`,`vert-origin-x`],[`vertOriginY`,`vert-origin-y`],[`wordSpacing`,`word-spacing`],[`writingMode`,`writing-mode`],[`xmlnsXlink`,`xmlns:xlink`],[`xHeight`,`x-height`]]),sn=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function cn(e){return sn.test(``+e)?`javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')`:e}function ln(){}var un=null;function dn(e){return e=e.target||e.srcElement||window,e.correspondingUseElement&&(e=e.correspondingUseElement),e.nodeType===3?e.parentNode:e}var fn=null,pn=null;function mn(e){var t=Tt(e);if(t&&(e=t.stateNode)){var n=e[gt]||null;a:switch(e=t.stateNode,t.type){case`input`:if(Jt(e,n.value,n.defaultValue,n.defaultValue,n.checked,n.defaultChecked,n.type,n.name),t=n.name,n.type===`radio`&&t!=null){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll(`input[name="`+qt(``+t)+`"][type="radio"]`),t=0;t<n.length;t++){var r=n[t];if(r!==e&&r.form===e.form){var a=r[gt]||null;if(!a)throw Error(i(90));Jt(r,a.value,a.defaultValue,a.defaultValue,a.checked,a.defaultChecked,a.type,a.name)}}for(t=0;t<n.length;t++)r=n[t],r.form===e.form&&Wt(r)}break a;case`textarea`:Qt(e,n.value,n.defaultValue);break a;case`select`:t=n.value,t!=null&&Zt(e,!!n.multiple,t,!1)}}}var hn=!1;function gn(e,t,n){if(hn)return e(t,n);hn=!0;try{return e(t)}finally{if(hn=!1,(fn!==null||pn!==null)&&(Ru(),fn&&(t=fn,e=pn,pn=fn=null,mn(t),e)))for(t=0;t<e.length;t++)mn(e[t])}}function _n(e,t){var n=e.stateNode;if(n===null)return null;var r=n[gt]||null;if(r===null)return null;n=r[t];a:switch(t){case`onClick`:case`onClickCapture`:case`onDoubleClick`:case`onDoubleClickCapture`:case`onMouseDown`:case`onMouseDownCapture`:case`onMouseMove`:case`onMouseMoveCapture`:case`onMouseUp`:case`onMouseUpCapture`:case`onMouseEnter`:(r=!r.disabled)||(e=e.type,r=!(e===`button`||e===`input`||e===`select`||e===`textarea`)),e=!r;break a;default:e=!1}if(e)return null;if(n&&typeof n!=`function`)throw Error(i(231,t,typeof n));return n}var vn=!(typeof window>`u`||window.document===void 0||window.document.createElement===void 0),yn=!1;if(vn)try{var bn={};Object.defineProperty(bn,`passive`,{get:function(){yn=!0}}),window.addEventListener(`test`,bn,bn),window.removeEventListener(`test`,bn,bn)}catch{yn=!1}var xn=null,Sn=null,Cn=null;function wn(){if(Cn)return Cn;var e,t=Sn,n=t.length,r,i=`value`in xn?xn.value:xn.textContent,a=i.length;for(e=0;e<n&&t[e]===i[e];e++);var o=n-e;for(r=1;r<=o&&t[n-r]===i[a-r];r++);return Cn=i.slice(e,1<r?1-r:void 0)}function Tn(e){var t=e.keyCode;return`charCode`in e?(e=e.charCode,e===0&&t===13&&(e=13)):e=t,e===10&&(e=13),32<=e||e===13?e:0}function En(){return!0}function Dn(){return!1}function On(e){function t(t,n,r,i,a){for(var o in this._reactName=t,this._targetInst=r,this.type=n,this.nativeEvent=i,this.target=a,this.currentTarget=null,e)e.hasOwnProperty(o)&&(t=e[o],this[o]=t?t(i):i[o]);return this.isDefaultPrevented=(i.defaultPrevented==null?!1===i.returnValue:i.defaultPrevented)?En:Dn,this.isPropagationStopped=Dn,this}return f(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():typeof e.returnValue!=`unknown`&&(e.returnValue=!1),this.isDefaultPrevented=En)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():typeof e.cancelBubble!=`unknown`&&(e.cancelBubble=!0),this.isPropagationStopped=En)},persist:function(){},isPersistent:En}),t}var kn={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},An=On(kn),jn=f({},kn,{view:0,detail:0}),Mn=On(jn),Nn,Pn,Fn,In=f({},jn,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Qn,button:0,buttons:0,relatedTarget:function(e){return e.relatedTarget===void 0?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return`movementX`in e?e.movementX:(e!==Fn&&(Fn&&e.type===`mousemove`?(Nn=e.screenX-Fn.screenX,Pn=e.screenY-Fn.screenY):Pn=Nn=0,Fn=e),Nn)},movementY:function(e){return`movementY`in e?e.movementY:Pn}}),Ln=On(In),Rn=f({},In,{dataTransfer:0}),zn=On(Rn),Bn=f({},jn,{relatedTarget:0}),Vn=On(Bn),Hn=f({},kn,{animationName:0,elapsedTime:0,pseudoElement:0}),Un=On(Hn),Wn=f({},kn,{clipboardData:function(e){return`clipboardData`in e?e.clipboardData:window.clipboardData}}),Gn=On(Wn),Kn=f({},kn,{data:0}),qn=On(Kn),Jn={Esc:`Escape`,Spacebar:` `,Left:`ArrowLeft`,Up:`ArrowUp`,Right:`ArrowRight`,Down:`ArrowDown`,Del:`Delete`,Win:`OS`,Menu:`ContextMenu`,Apps:`ContextMenu`,Scroll:`ScrollLock`,MozPrintableKey:`Unidentified`},Yn={8:`Backspace`,9:`Tab`,12:`Clear`,13:`Enter`,16:`Shift`,17:`Control`,18:`Alt`,19:`Pause`,20:`CapsLock`,27:`Escape`,32:` `,33:`PageUp`,34:`PageDown`,35:`End`,36:`Home`,37:`ArrowLeft`,38:`ArrowUp`,39:`ArrowRight`,40:`ArrowDown`,45:`Insert`,46:`Delete`,112:`F1`,113:`F2`,114:`F3`,115:`F4`,116:`F5`,117:`F6`,118:`F7`,119:`F8`,120:`F9`,121:`F10`,122:`F11`,123:`F12`,144:`NumLock`,145:`ScrollLock`,224:`Meta`},Xn={Alt:`altKey`,Control:`ctrlKey`,Meta:`metaKey`,Shift:`shiftKey`};function Zn(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):(e=Xn[e])?!!t[e]:!1}function Qn(){return Zn}var $n=f({},jn,{key:function(e){if(e.key){var t=Jn[e.key]||e.key;if(t!==`Unidentified`)return t}return e.type===`keypress`?(e=Tn(e),e===13?`Enter`:String.fromCharCode(e)):e.type===`keydown`||e.type===`keyup`?Yn[e.keyCode]||`Unidentified`:``},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Qn,charCode:function(e){return e.type===`keypress`?Tn(e):0},keyCode:function(e){return e.type===`keydown`||e.type===`keyup`?e.keyCode:0},which:function(e){return e.type===`keypress`?Tn(e):e.type===`keydown`||e.type===`keyup`?e.keyCode:0}}),er=On($n),tr=f({},In,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),nr=On(tr),rr=f({},jn,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Qn}),ir=On(rr),ar=f({},kn,{propertyName:0,elapsedTime:0,pseudoElement:0}),or=On(ar),sr=f({},In,{deltaX:function(e){return`deltaX`in e?e.deltaX:`wheelDeltaX`in e?-e.wheelDeltaX:0},deltaY:function(e){return`deltaY`in e?e.deltaY:`wheelDeltaY`in e?-e.wheelDeltaY:`wheelDelta`in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),cr=On(sr),lr=f({},kn,{newState:0,oldState:0}),ur=On(lr),dr=[9,13,27,32],fr=vn&&`CompositionEvent`in window,pr=null;vn&&`documentMode`in document&&(pr=document.documentMode);var mr=vn&&`TextEvent`in window&&!pr,hr=vn&&(!fr||pr&&8<pr&&11>=pr),gr=` `,_r=!1;function vr(e,t){switch(e){case`keyup`:return dr.indexOf(t.keyCode)!==-1;case`keydown`:return t.keyCode!==229;case`keypress`:case`mousedown`:case`focusout`:return!0;default:return!1}}function yr(e){return e=e.detail,typeof e==`object`&&`data`in e?e.data:null}var br=!1;function xr(e,t){switch(e){case`compositionend`:return yr(t);case`keypress`:return t.which===32?(_r=!0,gr):null;case`textInput`:return e=t.data,e===gr&&_r?null:e;default:return null}}function Sr(e,t){if(br)return e===`compositionend`||!fr&&vr(e,t)?(e=wn(),Cn=Sn=xn=null,br=!1,e):null;switch(e){case`paste`:return null;case`keypress`:if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case`compositionend`:return hr&&t.locale!==`ko`?null:t.data;default:return null}}var Cr={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function wr(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t===`input`?!!Cr[e.type]:t===`textarea`}function Tr(e,t,n,r){fn?pn?pn.push(r):pn=[r]:fn=r,t=Jd(t,`onChange`),0<t.length&&(n=new An(`onChange`,`change`,null,n,r),e.push({event:n,listeners:t}))}var Er=null,Dr=null;function Or(e){Bd(e,0)}function kr(e){var t=Et(e);if(Wt(t))return e}function Ar(e,t){if(e===`change`)return t}var jr=!1;if(vn){var Mr;if(vn){var Nr=`oninput`in document;if(!Nr){var Pr=document.createElement(`div`);Pr.setAttribute(`oninput`,`return;`),Nr=typeof Pr.oninput==`function`}Mr=Nr}else Mr=!1;jr=Mr&&(!document.documentMode||9<document.documentMode)}function Fr(){Er&&(Er.detachEvent(`onpropertychange`,Ir),Dr=Er=null)}function Ir(e){if(e.propertyName===`value`&&kr(Dr)){var t=[];Tr(t,Dr,e,dn(e)),gn(Or,t)}}function Lr(e,t,n){e===`focusin`?(Fr(),Er=t,Dr=n,Er.attachEvent(`onpropertychange`,Ir)):e===`focusout`&&Fr()}function Rr(e){if(e===`selectionchange`||e===`keyup`||e===`keydown`)return kr(Dr)}function zr(e,t){if(e===`click`)return kr(t)}function Br(e,t){if(e===`input`||e===`change`)return kr(t)}function Vr(e,t){return e===t&&(e!==0||1/e==1/t)||e!==e&&t!==t}var Hr=typeof Object.is==`function`?Object.is:Vr;function Ur(e,t){if(Hr(e,t))return!0;if(typeof e!=`object`||!e||typeof t!=`object`||!t)return!1;var n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return!1;for(r=0;r<n.length;r++){var i=n[r];if(!Ae.call(t,i)||!Hr(e[i],t[i]))return!1}return!0}function Wr(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function Gr(e,t){var n=Wr(e);e=0;for(var r;n;){if(n.nodeType===3){if(r=e+n.textContent.length,e<=t&&r>=t)return{node:n,offset:t-e};e=r}a:{for(;n;){if(n.nextSibling){n=n.nextSibling;break a}n=n.parentNode}n=void 0}n=Wr(n)}}function Kr(e,t){return e&&t?e===t?!0:e&&e.nodeType===3?!1:t&&t.nodeType===3?Kr(e,t.parentNode):`contains`in e?e.contains(t):e.compareDocumentPosition?!!(e.compareDocumentPosition(t)&16):!1:!1}function qr(e){e=e!=null&&e.ownerDocument!=null&&e.ownerDocument.defaultView!=null?e.ownerDocument.defaultView:window;for(var t=Gt(e.document);t instanceof e.HTMLIFrameElement;){try{var n=typeof t.contentWindow.location.href==`string`}catch{n=!1}if(n)e=t.contentWindow;else break;t=Gt(e.document)}return t}function Jr(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&(t===`input`&&(e.type===`text`||e.type===`search`||e.type===`tel`||e.type===`url`||e.type===`password`)||t===`textarea`||e.contentEditable===`true`)}var Yr=vn&&`documentMode`in document&&11>=document.documentMode,Xr=null,Zr=null,Qr=null,$r=!1;function ei(e,t,n){var r=n.window===n?n.document:n.nodeType===9?n:n.ownerDocument;$r||Xr==null||Xr!==Gt(r)||(r=Xr,`selectionStart`in r&&Jr(r)?r={start:r.selectionStart,end:r.selectionEnd}:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection(),r={anchorNode:r.anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset}),Qr&&Ur(Qr,r)||(Qr=r,r=Jd(Zr,`onSelect`),0<r.length&&(t=new An(`onSelect`,`select`,null,t,n),e.push({event:t,listeners:r}),t.target=Xr)))}function ti(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n[`Webkit`+e]=`webkit`+t,n[`Moz`+e]=`moz`+t,n}var ni={animationend:ti(`Animation`,`AnimationEnd`),animationiteration:ti(`Animation`,`AnimationIteration`),animationstart:ti(`Animation`,`AnimationStart`),transitionrun:ti(`Transition`,`TransitionRun`),transitionstart:ti(`Transition`,`TransitionStart`),transitioncancel:ti(`Transition`,`TransitionCancel`),transitionend:ti(`Transition`,`TransitionEnd`)},ri={},ii={};vn&&(ii=document.createElement(`div`).style,`AnimationEvent`in window||(delete ni.animationend.animation,delete ni.animationiteration.animation,delete ni.animationstart.animation),`TransitionEvent`in window||delete ni.transitionend.transition);function ai(e){if(ri[e])return ri[e];if(!ni[e])return e;var t=ni[e],n;for(n in t)if(t.hasOwnProperty(n)&&n in ii)return ri[e]=t[n];return e}var oi=ai(`animationend`),si=ai(`animationiteration`),ci=ai(`animationstart`),A=ai(`transitionrun`),li=ai(`transitionstart`),ui=ai(`transitioncancel`),di=ai(`transitionend`),fi=new Map,pi=`abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel`.split(` `);pi.push(`scrollEnd`);function mi(e,t){fi.set(e,t),jt(t,[e])}var hi=typeof reportError==`function`?reportError:function(e){if(typeof window==`object`&&typeof window.ErrorEvent==`function`){var t=new window.ErrorEvent(`error`,{bubbles:!0,cancelable:!0,message:typeof e==`object`&&e&&typeof e.message==`string`?String(e.message):String(e),error:e});if(!window.dispatchEvent(t))return}else if(typeof process==`object`&&typeof process.emit==`function`){process.emit(`uncaughtException`,e);return}console.error(e)},gi=[],_i=0,vi=0;function yi(){for(var e=_i,t=vi=_i=0;t<e;){var n=gi[t];gi[t++]=null;var r=gi[t];gi[t++]=null;var i=gi[t];gi[t++]=null;var a=gi[t];if(gi[t++]=null,r!==null&&i!==null){var o=r.pending;o===null?i.next=i:(i.next=o.next,o.next=i),r.pending=i}a!==0&&Ci(n,i,a)}}function bi(e,t,n,r){gi[_i++]=e,gi[_i++]=t,gi[_i++]=n,gi[_i++]=r,vi|=r,e.lanes|=r,e=e.alternate,e!==null&&(e.lanes|=r)}function xi(e,t,n,r){return bi(e,t,n,r),wi(e)}function Si(e,t){return bi(e,null,null,t),wi(e)}function Ci(e,t,n){e.lanes|=n;var r=e.alternate;r!==null&&(r.lanes|=n);for(var i=!1,a=e.return;a!==null;)a.childLanes|=n,r=a.alternate,r!==null&&(r.childLanes|=n),a.tag===22&&(e=a.stateNode,e===null||e._visibility&1||(i=!0)),e=a,a=a.return;return e.tag===3?(a=e.stateNode,i&&t!==null&&(i=31-qe(n),e=a.hiddenUpdates,r=e[i],r===null?e[i]=[t]:r.push(t),t.lane=n|536870912),a):null}function wi(e){if(50<ku)throw ku=0,Au=null,Error(i(185));for(var t=e.return;t!==null;)e=t,t=e.return;return e.tag===3?e.stateNode:null}var Ti={};function Ei(e,t,n,r){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Di(e,t,n,r){return new Ei(e,t,n,r)}function Oi(e){return e=e.prototype,!(!e||!e.isReactComponent)}function ki(e,t){var n=e.alternate;return n===null?(n=Di(e.tag,t,e.key,e.mode),n.elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=e.flags&65011712,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=t===null?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n.refCleanup=e.refCleanup,n}function Ai(e,t){e.flags&=65011714;var n=e.alternate;return n===null?(e.childLanes=0,e.lanes=t,e.child=null,e.subtreeFlags=0,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null,e.stateNode=null):(e.childLanes=n.childLanes,e.lanes=n.lanes,e.child=n.child,e.subtreeFlags=0,e.deletions=null,e.memoizedProps=n.memoizedProps,e.memoizedState=n.memoizedState,e.updateQueue=n.updateQueue,e.type=n.type,t=n.dependencies,e.dependencies=t===null?null:{lanes:t.lanes,firstContext:t.firstContext}),e}function ji(e,t,n,r,a,o){var s=0;if(r=e,typeof e==`function`)Oi(e)&&(s=1);else if(typeof e==`string`)s=fp(e,n,he.current)?26:e===`html`||e===`head`||e===`body`?27:5;else a:switch(e){case ne:return e=Di(31,n,t,a),e.elementType=ne,e.lanes=o,e;case y:return Mi(n.children,a,o,t);case b:s=8,a|=24;break;case x:return e=Di(12,n,t,a|2),e.elementType=x,e.lanes=o,e;case T:return e=Di(13,n,t,a),e.elementType=T,e.lanes=o,e;case ee:return e=Di(19,n,t,a),e.elementType=ee,e.lanes=o,e;default:if(typeof e==`object`&&e)switch(e.$$typeof){case C:s=10;break a;case S:s=9;break a;case w:s=11;break a;case E:s=14;break a;case te:s=16,r=null;break a}s=29,n=Error(i(130,e===null?`null`:typeof e,``)),r=null}return t=Di(s,n,t,a),t.elementType=e,t.type=r,t.lanes=o,t}function Mi(e,t,n,r){return e=Di(7,e,r,t),e.lanes=n,e}function Ni(e,t,n){return e=Di(6,e,null,t),e.lanes=n,e}function Pi(e){var t=Di(18,null,null,0);return t.stateNode=e,t}function Fi(e,t,n){return t=Di(4,e.children===null?[]:e.children,e.key,t),t.lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}var Ii=new WeakMap;function Li(e,t){if(typeof e==`object`&&e){var n=Ii.get(e);return n===void 0?(t={value:e,source:t,stack:ke(t)},Ii.set(e,t),t):n}return{value:e,source:t,stack:ke(t)}}var Ri=[],zi=0,Bi=null,Vi=0,Hi=[],Ui=0,Wi=null,Gi=1,Ki=``;function qi(e,t){Ri[zi++]=Vi,Ri[zi++]=Bi,Bi=e,Vi=t}function Ji(e,t,n){Hi[Ui++]=Gi,Hi[Ui++]=Ki,Hi[Ui++]=Wi,Wi=e;var r=Gi;e=Ki;var i=32-qe(r)-1;r&=~(1<<i),n+=1;var a=32-qe(t)+i;if(30<a){var o=i-i%5;a=(r&(1<<o)-1).toString(32),r>>=o,i-=o,Gi=1<<32-qe(t)+i|n<<i|r,Ki=a+e}else Gi=1<<a|n<<i|r,Ki=e}function Yi(e){e.return!==null&&(qi(e,1),Ji(e,1,0))}function Xi(e){for(;e===Bi;)Bi=Ri[--zi],Ri[zi]=null,Vi=Ri[--zi],Ri[zi]=null;for(;e===Wi;)Wi=Hi[--Ui],Hi[Ui]=null,Ki=Hi[--Ui],Hi[Ui]=null,Gi=Hi[--Ui],Hi[Ui]=null}function Zi(e,t){Hi[Ui++]=Gi,Hi[Ui++]=Ki,Hi[Ui++]=Wi,Gi=t.id,Ki=t.overflow,Wi=e}var Qi=null,$i=null,ea=!1,ta=null,j=!1,na=Error(i(519));function ra(e){var t=Error(i(418,1<arguments.length&&arguments[1]!==void 0&&arguments[1]?`text`:`HTML`,``));throw la(Li(t,e)),na}function ia(e){var t=e.stateNode,n=e.type,r=e.memoizedProps;switch(t[ht]=e,t[gt]=r,n){case`dialog`:Vd(`cancel`,t),Vd(`close`,t);break;case`iframe`:case`object`:case`embed`:Vd(`load`,t);break;case`video`:case`audio`:for(n=0;n<Rd.length;n++)Vd(Rd[n],t);break;case`source`:Vd(`error`,t);break;case`img`:case`image`:case`link`:Vd(`error`,t),Vd(`load`,t);break;case`details`:Vd(`toggle`,t);break;case`input`:Vd(`invalid`,t),Yt(t,r.value,r.defaultValue,r.checked,r.defaultChecked,r.type,r.name,!0);break;case`select`:Vd(`invalid`,t);break;case`textarea`:Vd(`invalid`,t),$t(t,r.value,r.defaultValue,r.children)}n=r.children,typeof n!=`string`&&typeof n!=`number`&&typeof n!=`bigint`||t.textContent===``+n||!0===r.suppressHydrationWarning||ef(t.textContent,n)?(r.popover!=null&&(Vd(`beforetoggle`,t),Vd(`toggle`,t)),r.onScroll!=null&&Vd(`scroll`,t),r.onScrollEnd!=null&&Vd(`scrollend`,t),r.onClick!=null&&(t.onclick=ln),t=!0):t=!1,t||ra(e,!0)}function aa(e){for(Qi=e.return;Qi;)switch(Qi.tag){case 5:case 31:case 13:j=!1;return;case 27:case 3:j=!0;return;default:Qi=Qi.return}}function oa(e){if(e!==Qi)return!1;if(!ea)return aa(e),ea=!0,!1;var t=e.tag,n;if((n=t!==3&&t!==27)&&((n=t===5)&&(n=e.type,n=!(n!==`form`&&n!==`button`)||mf(e.type,e.memoizedProps)),n=!n),n&&$i&&ra(e),aa(e),t===13){if(e=e.memoizedState,e=e===null?null:e.dehydrated,!e)throw Error(i(317));$i=Pf(e)}else if(t===31){if(e=e.memoizedState,e=e===null?null:e.dehydrated,!e)throw Error(i(317));$i=Pf(e)}else t===27?(t=$i,Sf(e.type)?(e=Nf,Nf=null,$i=e):$i=t):$i=Qi?Mf(e.stateNode.nextSibling):null;return!0}function sa(){$i=Qi=null,ea=!1}function ca(){var e=ta;return e!==null&&(hu===null?hu=e:hu.push.apply(hu,e),ta=null),e}function la(e){ta===null?ta=[e]:ta.push(e)}var ua=pe(null),da=null,fa=null;function pa(e,t,n){me(ua,t._currentValue),t._currentValue=n}function ma(e){e._currentValue=ua.current,O(ua)}function ha(e,t,n){for(;e!==null;){var r=e.alternate;if((e.childLanes&t)===t?r!==null&&(r.childLanes&t)!==t&&(r.childLanes|=t):(e.childLanes|=t,r!==null&&(r.childLanes|=t)),e===n)break;e=e.return}}function ga(e,t,n,r){var a=e.child;for(a!==null&&(a.return=e);a!==null;){var o=a.dependencies;if(o!==null){var s=a.child;o=o.firstContext;a:for(;o!==null;){var c=o;o=a;for(var l=0;l<t.length;l++)if(c.context===t[l]){o.lanes|=n,c=o.alternate,c!==null&&(c.lanes|=n),ha(o.return,n,e),r||(s=null);break a}o=c.next}}else if(a.tag===18){if(s=a.return,s===null)throw Error(i(341));s.lanes|=n,o=s.alternate,o!==null&&(o.lanes|=n),ha(s,n,e),s=null}else s=a.child;if(s!==null)s.return=a;else for(s=a;s!==null;){if(s===e){s=null;break}if(a=s.sibling,a!==null){a.return=s.return,s=a;break}s=s.return}a=s}}function _a(e,t,n,r){e=null;for(var a=t,o=!1;a!==null;){if(!o){if(a.flags&524288)o=!0;else if(a.flags&262144)break}if(a.tag===10){var s=a.alternate;if(s===null)throw Error(i(387));if(s=s.memoizedProps,s!==null){var c=a.type;Hr(a.pendingProps.value,s.value)||(e===null?e=[c]:e.push(c))}}else if(a===ve.current){if(s=a.alternate,s===null)throw Error(i(387));s.memoizedState.memoizedState!==a.memoizedState.memoizedState&&(e===null?e=[xp]:e.push(xp))}a=a.return}e!==null&&ga(t,e,n,r),t.flags|=262144}function va(e){for(e=e.firstContext;e!==null;){if(!Hr(e.context._currentValue,e.memoizedValue))return!0;e=e.next}return!1}function ya(e){da=e,fa=null,e=e.dependencies,e!==null&&(e.firstContext=null)}function ba(e){return xa(da,e)}function M(e,t){return da===null&&ya(e),xa(e,t)}function xa(e,t){var n=t._currentValue;if(t={context:t,memoizedValue:n,next:null},fa===null){if(e===null)throw Error(i(308));fa=t,e.dependencies={lanes:0,firstContext:t},e.flags|=524288}else fa=fa.next=t;return n}var Sa=typeof AbortController<`u`?AbortController:function(){var e=[],t=this.signal={aborted:!1,addEventListener:function(t,n){e.push(n)}};this.abort=function(){t.aborted=!0,e.forEach(function(e){return e()})}},Ca=t.unstable_scheduleCallback,wa=t.unstable_NormalPriority,Ta={$$typeof:C,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function N(){return{controller:new Sa,data:new Map,refCount:0}}function Ea(e){e.refCount--,e.refCount===0&&Ca(wa,function(){e.controller.abort()})}var Da=null,Oa=0,ka=0,Aa=null;function ja(e,t){if(Da===null){var n=Da=[];Oa=0,ka=Ad(),Aa={status:`pending`,value:void 0,then:function(e){n.push(e)}}}return Oa++,t.then(Ma,Ma),t}function Ma(){if(--Oa===0&&Da!==null){Aa!==null&&(Aa.status=`fulfilled`);var e=Da;Da=null,ka=0,Aa=null;for(var t=0;t<e.length;t++)(0,e[t])()}}function Na(e,t){var n=[],r={status:`pending`,value:null,reason:null,then:function(e){n.push(e)}};return e.then(function(){r.status=`fulfilled`,r.value=t;for(var e=0;e<n.length;e++)(0,n[e])(t)},function(e){for(r.status=`rejected`,r.reason=e,e=0;e<n.length;e++)(0,n[e])(void 0)}),r}var Pa=le.S;le.S=function(e,t){vu=Fe(),typeof t==`object`&&t&&typeof t.then==`function`&&ja(e,t),Pa!==null&&Pa(e,t)};var Fa=pe(null);function Ia(){var e=Fa.current;return e===null?$l.pooledCache:e}function La(e,t){t===null?me(Fa,Fa.current):me(Fa,t.pool)}function Ra(){var e=Ia();return e===null?null:{parent:Ta._currentValue,pool:e}}var za=Error(i(460)),Ba=Error(i(474)),Va=Error(i(542)),Ha={then:function(){}};function Ua(e){return e=e.status,e===`fulfilled`||e===`rejected`}function Wa(e,t,n){switch(n=e[n],n===void 0?e.push(t):n!==t&&(t.then(ln,ln),t=n),t.status){case`fulfilled`:return t.value;case`rejected`:throw e=t.reason,Ja(e),e;default:if(typeof t.status==`string`)t.then(ln,ln);else{if(e=$l,e!==null&&100<e.shellSuspendCounter)throw Error(i(482));e=t,e.status=`pending`,e.then(function(e){if(t.status===`pending`){var n=t;n.status=`fulfilled`,n.value=e}},function(e){if(t.status===`pending`){var n=t;n.status=`rejected`,n.reason=e}})}switch(t.status){case`fulfilled`:return t.value;case`rejected`:throw e=t.reason,Ja(e),e}throw Ka=t,za}}function Ga(e){try{var t=e._init;return t(e._payload)}catch(e){throw typeof e==`object`&&e&&typeof e.then==`function`?(Ka=e,za):e}}var Ka=null;function qa(){if(Ka===null)throw Error(i(459));var e=Ka;return Ka=null,e}function Ja(e){if(e===za||e===Va)throw Error(i(483))}var Ya=null,Xa=0;function P(e){var t=Xa;return Xa+=1,Ya===null&&(Ya=[]),Wa(Ya,e,t)}function F(e,t){t=t.props.ref,e.ref=t===void 0?null:t}function Za(e,t){throw t.$$typeof===m?Error(i(525)):(e=Object.prototype.toString.call(t),Error(i(31,e===`[object Object]`?`object with keys {`+Object.keys(t).join(`, `)+`}`:e)))}function Qa(e){function t(t,n){if(e){var r=t.deletions;r===null?(t.deletions=[n],t.flags|=16):r.push(n)}}function n(n,r){if(!e)return null;for(;r!==null;)t(n,r),r=r.sibling;return null}function r(e){for(var t=new Map;e!==null;)e.key===null?t.set(e.index,e):t.set(e.key,e),e=e.sibling;return t}function a(e,t){return e=ki(e,t),e.index=0,e.sibling=null,e}function o(t,n,r){return t.index=r,e?(r=t.alternate,r===null?(t.flags|=67108866,n):(r=r.index,r<n?(t.flags|=67108866,n):r)):(t.flags|=1048576,n)}function s(t){return e&&t.alternate===null&&(t.flags|=67108866),t}function c(e,t,n,r){return t===null||t.tag!==6?(t=Ni(n,e.mode,r),t.return=e,t):(t=a(t,n),t.return=e,t)}function l(e,t,n,r){var i=n.type;return i===y?d(e,t,n.props.children,r,n.key):t!==null&&(t.elementType===i||typeof i==`object`&&i&&i.$$typeof===te&&Ga(i)===t.type)?(t=a(t,n.props),F(t,n),t.return=e,t):(t=ji(n.type,n.key,n.props,null,e.mode,r),F(t,n),t.return=e,t)}function u(e,t,n,r){return t===null||t.tag!==4||t.stateNode.containerInfo!==n.containerInfo||t.stateNode.implementation!==n.implementation?(t=Fi(n,e.mode,r),t.return=e,t):(t=a(t,n.children||[]),t.return=e,t)}function d(e,t,n,r,i){return t===null||t.tag!==7?(t=Mi(n,e.mode,r,i),t.return=e,t):(t=a(t,n),t.return=e,t)}function f(e,t,n){if(typeof t==`string`&&t!==``||typeof t==`number`||typeof t==`bigint`)return t=Ni(``+t,e.mode,n),t.return=e,t;if(typeof t==`object`&&t){switch(t.$$typeof){case g:return n=ji(t.type,t.key,t.props,null,e.mode,n),F(n,t),n.return=e,n;case v:return t=Fi(t,e.mode,n),t.return=e,t;case te:return t=Ga(t),f(e,t,n)}if(ce(t)||ae(t))return t=Mi(t,e.mode,n,null),t.return=e,t;if(typeof t.then==`function`)return f(e,P(t),n);if(t.$$typeof===C)return f(e,M(e,t),n);Za(e,t)}return null}function p(e,t,n,r){var i=t===null?null:t.key;if(typeof n==`string`&&n!==``||typeof n==`number`||typeof n==`bigint`)return i===null?c(e,t,``+n,r):null;if(typeof n==`object`&&n){switch(n.$$typeof){case g:return n.key===i?l(e,t,n,r):null;case v:return n.key===i?u(e,t,n,r):null;case te:return n=Ga(n),p(e,t,n,r)}if(ce(n)||ae(n))return i===null?d(e,t,n,r,null):null;if(typeof n.then==`function`)return p(e,t,P(n),r);if(n.$$typeof===C)return p(e,t,M(e,n),r);Za(e,n)}return null}function m(e,t,n,r,i){if(typeof r==`string`&&r!==``||typeof r==`number`||typeof r==`bigint`)return e=e.get(n)||null,c(t,e,``+r,i);if(typeof r==`object`&&r){switch(r.$$typeof){case g:return e=e.get(r.key===null?n:r.key)||null,l(t,e,r,i);case v:return e=e.get(r.key===null?n:r.key)||null,u(t,e,r,i);case te:return r=Ga(r),m(e,t,n,r,i)}if(ce(r)||ae(r))return e=e.get(n)||null,d(t,e,r,i,null);if(typeof r.then==`function`)return m(e,t,n,P(r),i);if(r.$$typeof===C)return m(e,t,n,M(t,r),i);Za(t,r)}return null}function h(i,a,s,c){for(var l=null,u=null,d=a,h=a=0,g=null;d!==null&&h<s.length;h++){d.index>h?(g=d,d=null):g=d.sibling;var _=p(i,d,s[h],c);if(_===null){d===null&&(d=g);break}e&&d&&_.alternate===null&&t(i,d),a=o(_,a,h),u===null?l=_:u.sibling=_,u=_,d=g}if(h===s.length)return n(i,d),ea&&qi(i,h),l;if(d===null){for(;h<s.length;h++)d=f(i,s[h],c),d!==null&&(a=o(d,a,h),u===null?l=d:u.sibling=d,u=d);return ea&&qi(i,h),l}for(d=r(d);h<s.length;h++)g=m(d,i,h,s[h],c),g!==null&&(e&&g.alternate!==null&&d.delete(g.key===null?h:g.key),a=o(g,a,h),u===null?l=g:u.sibling=g,u=g);return e&&d.forEach(function(e){return t(i,e)}),ea&&qi(i,h),l}function _(a,s,c,l){if(c==null)throw Error(i(151));for(var u=null,d=null,h=s,g=s=0,_=null,v=c.next();h!==null&&!v.done;g++,v=c.next()){h.index>g?(_=h,h=null):_=h.sibling;var y=p(a,h,v.value,l);if(y===null){h===null&&(h=_);break}e&&h&&y.alternate===null&&t(a,h),s=o(y,s,g),d===null?u=y:d.sibling=y,d=y,h=_}if(v.done)return n(a,h),ea&&qi(a,g),u;if(h===null){for(;!v.done;g++,v=c.next())v=f(a,v.value,l),v!==null&&(s=o(v,s,g),d===null?u=v:d.sibling=v,d=v);return ea&&qi(a,g),u}for(h=r(h);!v.done;g++,v=c.next())v=m(h,a,g,v.value,l),v!==null&&(e&&v.alternate!==null&&h.delete(v.key===null?g:v.key),s=o(v,s,g),d===null?u=v:d.sibling=v,d=v);return e&&h.forEach(function(e){return t(a,e)}),ea&&qi(a,g),u}function b(e,r,o,c){if(typeof o==`object`&&o&&o.type===y&&o.key===null&&(o=o.props.children),typeof o==`object`&&o){switch(o.$$typeof){case g:a:{for(var l=o.key;r!==null;){if(r.key===l){if(l=o.type,l===y){if(r.tag===7){n(e,r.sibling),c=a(r,o.props.children),c.return=e,e=c;break a}}else if(r.elementType===l||typeof l==`object`&&l&&l.$$typeof===te&&Ga(l)===r.type){n(e,r.sibling),c=a(r,o.props),F(c,o),c.return=e,e=c;break a}n(e,r);break}else t(e,r);r=r.sibling}o.type===y?(c=Mi(o.props.children,e.mode,c,o.key),c.return=e,e=c):(c=ji(o.type,o.key,o.props,null,e.mode,c),F(c,o),c.return=e,e=c)}return s(e);case v:a:{for(l=o.key;r!==null;){if(r.key===l)if(r.tag===4&&r.stateNode.containerInfo===o.containerInfo&&r.stateNode.implementation===o.implementation){n(e,r.sibling),c=a(r,o.children||[]),c.return=e,e=c;break a}else{n(e,r);break}else t(e,r);r=r.sibling}c=Fi(o,e.mode,c),c.return=e,e=c}return s(e);case te:return o=Ga(o),b(e,r,o,c)}if(ce(o))return h(e,r,o,c);if(ae(o)){if(l=ae(o),typeof l!=`function`)throw Error(i(150));return o=l.call(o),_(e,r,o,c)}if(typeof o.then==`function`)return b(e,r,P(o),c);if(o.$$typeof===C)return b(e,r,M(e,o),c);Za(e,o)}return typeof o==`string`&&o!==``||typeof o==`number`||typeof o==`bigint`?(o=``+o,r!==null&&r.tag===6?(n(e,r.sibling),c=a(r,o),c.return=e,e=c):(n(e,r),c=Ni(o,e.mode,c),c.return=e,e=c),s(e)):n(e,r)}return function(e,t,n,r){try{Xa=0;var i=b(e,t,n,r);return Ya=null,i}catch(t){if(t===za||t===Va)throw t;var a=Di(29,t,null,e.mode);return a.lanes=r,a.return=e,a}}}var $a=Qa(!0),eo=Qa(!1),to=!1;function no(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function ro(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,callbacks:null})}function io(e){return{lane:e,tag:0,payload:null,callback:null,next:null}}function ao(e,t,n){var r=e.updateQueue;if(r===null)return null;if(r=r.shared,Ql&2){var i=r.pending;return i===null?t.next=t:(t.next=i.next,i.next=t),r.pending=t,t=wi(e),Ci(e,null,n),t}return bi(e,r,t,n),wi(e)}function oo(e,t,n){if(t=t.updateQueue,t!==null&&(t=t.shared,n&4194048)){var r=t.lanes;r&=e.pendingLanes,n|=r,t.lanes=n,ct(e,n)}}function so(e,t){var n=e.updateQueue,r=e.alternate;if(r!==null&&(r=r.updateQueue,n===r)){var i=null,a=null;if(n=n.firstBaseUpdate,n!==null){do{var o={lane:n.lane,tag:n.tag,payload:n.payload,callback:null,next:null};a===null?i=a=o:a=a.next=o,n=n.next}while(n!==null);a===null?i=a=t:a=a.next=t}else i=a=t;n={baseState:r.baseState,firstBaseUpdate:i,lastBaseUpdate:a,shared:r.shared,callbacks:r.callbacks},e.updateQueue=n;return}e=n.lastBaseUpdate,e===null?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}var co=!1;function I(){if(co){var e=Aa;if(e!==null)throw e}}function lo(e,t,n,r){co=!1;var i=e.updateQueue;to=!1;var a=i.firstBaseUpdate,o=i.lastBaseUpdate,s=i.shared.pending;if(s!==null){i.shared.pending=null;var c=s,l=c.next;c.next=null,o===null?a=l:o.next=l,o=c;var u=e.alternate;u!==null&&(u=u.updateQueue,s=u.lastBaseUpdate,s!==o&&(s===null?u.firstBaseUpdate=l:s.next=l,u.lastBaseUpdate=c))}if(a!==null){var d=i.baseState;o=0,u=l=c=null,s=a;do{var p=s.lane&-536870913,m=p!==s.lane;if(m?(tu&p)===p:(r&p)===p){p!==0&&p===ka&&(co=!0),u!==null&&(u=u.next={lane:0,tag:s.tag,payload:s.payload,callback:null,next:null});a:{var h=e,g=s;p=t;var _=n;switch(g.tag){case 1:if(h=g.payload,typeof h==`function`){d=h.call(_,d,p);break a}d=h;break a;case 3:h.flags=h.flags&-65537|128;case 0:if(h=g.payload,p=typeof h==`function`?h.call(_,d,p):h,p==null)break a;d=f({},d,p);break a;case 2:to=!0}}p=s.callback,p!==null&&(e.flags|=64,m&&(e.flags|=8192),m=i.callbacks,m===null?i.callbacks=[p]:m.push(p))}else m={lane:p,tag:s.tag,payload:s.payload,callback:s.callback,next:null},u===null?(l=u=m,c=d):u=u.next=m,o|=p;if(s=s.next,s===null){if(s=i.shared.pending,s===null)break;m=s,s=m.next,m.next=null,i.lastBaseUpdate=m,i.shared.pending=null}}while(1);u===null&&(c=d),i.baseState=c,i.firstBaseUpdate=l,i.lastBaseUpdate=u,a===null&&(i.shared.lanes=0),lu|=o,e.lanes=o,e.memoizedState=d}}function L(e,t){if(typeof e!=`function`)throw Error(i(191,e));e.call(t)}function R(e,t){var n=e.callbacks;if(n!==null)for(e.callbacks=null,e=0;e<n.length;e++)L(n[e],t)}var uo=pe(null),z=pe(0);function fo(e,t){e=su,me(z,e),me(uo,t),su=e|t.baseLanes}function po(){me(z,su),me(uo,uo.current)}function mo(){su=z.current,O(uo),O(z)}var ho=pe(null),go=null;function _o(e){var t=e.alternate;me(So,So.current&1),me(ho,e),go===null&&(t===null||uo.current!==null||t.memoizedState!==null)&&(go=e)}function vo(e){me(So,So.current),me(ho,e),go===null&&(go=e)}function yo(e){e.tag===22?(me(So,So.current),me(ho,e),go===null&&(go=e)):bo(e)}function bo(){me(So,So.current),me(ho,ho.current)}function xo(e){O(ho),go===e&&(go=null),O(So)}var So=pe(0);function Co(e){for(var t=e;t!==null;){if(t.tag===13){var n=t.memoizedState;if(n!==null&&(n=n.dehydrated,n===null||kf(n)||Af(n)))return t}else if(t.tag===19&&(t.memoizedProps.revealOrder===`forwards`||t.memoizedProps.revealOrder===`backwards`||t.memoizedProps.revealOrder===`unstable_legacy-backwards`||t.memoizedProps.revealOrder===`together`)){if(t.flags&128)return t}else if(t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var wo=0,To=null,Eo=null,Do=null,Oo=!1,ko=!1,Ao=!1,jo=0,B=0,Mo=null,No=0;function Po(){throw Error(i(321))}function Fo(e,t){if(t===null)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!Hr(e[n],t[n]))return!1;return!0}function Io(e,t,n,r,i,a){return wo=a,To=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,le.H=e===null||e.memoizedState===null?tc:nc,Ao=!1,a=n(r,i),Ao=!1,ko&&(a=Ro(t,n,r,i)),Lo(e),a}function Lo(e){le.H=ec;var t=Eo!==null&&Eo.next!==null;if(wo=0,Do=Eo=To=null,Oo=!1,B=0,Mo=null,t)throw Error(i(300));e===null||vc||(e=e.dependencies,e!==null&&va(e)&&(vc=!0))}function Ro(e,t,n,r){To=e;var a=0;do{if(ko&&(Mo=null),B=0,ko=!1,25<=a)throw Error(i(301));if(a+=1,Do=Eo=null,e.updateQueue!=null){var o=e.updateQueue;o.lastEffect=null,o.events=null,o.stores=null,o.memoCache!=null&&(o.memoCache.index=0)}le.H=rc,o=t(n,r)}while(ko);return o}function zo(){var e=le.H,t=e.useState()[0];return t=typeof t.then==`function`?Ko(t):t,e=e.useState()[0],(Eo===null?null:Eo.memoizedState)!==e&&(To.flags|=1024),t}function Bo(){var e=jo!==0;return jo=0,e}function Vo(e,t,n){t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~n}function Ho(e){if(Oo){for(e=e.memoizedState;e!==null;){var t=e.queue;t!==null&&(t.pending=null),e=e.next}Oo=!1}wo=0,Do=Eo=To=null,ko=!1,B=jo=0,Mo=null}function Uo(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Do===null?To.memoizedState=Do=e:Do=Do.next=e,Do}function Wo(){if(Eo===null){var e=To.alternate;e=e===null?null:e.memoizedState}else e=Eo.next;var t=Do===null?To.memoizedState:Do.next;if(t!==null)Do=t,Eo=e;else{if(e===null)throw To.alternate===null?Error(i(467)):Error(i(310));Eo=e,e={memoizedState:Eo.memoizedState,baseState:Eo.baseState,baseQueue:Eo.baseQueue,queue:Eo.queue,next:null},Do===null?To.memoizedState=Do=e:Do=Do.next=e}return Do}function Go(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function Ko(e){var t=B;return B+=1,Mo===null&&(Mo=[]),e=Wa(Mo,e,t),t=To,(Do===null?t.memoizedState:Do.next)===null&&(t=t.alternate,le.H=t===null||t.memoizedState===null?tc:nc),e}function qo(e){if(typeof e==`object`&&e){if(typeof e.then==`function`)return Ko(e);if(e.$$typeof===C)return ba(e)}throw Error(i(438,String(e)))}function Jo(e){var t=null,n=To.updateQueue;if(n!==null&&(t=n.memoCache),t==null){var r=To.alternate;r!==null&&(r=r.updateQueue,r!==null&&(r=r.memoCache,r!=null&&(t={data:r.data.map(function(e){return e.slice()}),index:0})))}if(t??={data:[],index:0},n===null&&(n=Go(),To.updateQueue=n),n.memoCache=t,n=t.data[t.index],n===void 0)for(n=t.data[t.index]=Array(e),r=0;r<e;r++)n[r]=re;return t.index++,n}function Yo(e,t){return typeof t==`function`?t(e):t}function Xo(e){var t=Wo();return Zo(t,Eo,e)}function Zo(e,t,n){var r=e.queue;if(r===null)throw Error(i(311));r.lastRenderedReducer=n;var a=e.baseQueue,o=r.pending;if(o!==null){if(a!==null){var s=a.next;a.next=o.next,o.next=s}t.baseQueue=a=o,r.pending=null}if(o=e.baseState,a===null)e.memoizedState=o;else{t=a.next;var c=s=null,l=null,u=t,d=!1;do{var f=u.lane&-536870913;if(f===u.lane?(wo&f)===f:(tu&f)===f){var p=u.revertLane;if(p===0)l!==null&&(l=l.next={lane:0,revertLane:0,gesture:null,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null}),f===ka&&(d=!0);else if((wo&p)===p){u=u.next,p===ka&&(d=!0);continue}else f={lane:0,revertLane:u.revertLane,gesture:null,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null},l===null?(c=l=f,s=o):l=l.next=f,To.lanes|=p,lu|=p;f=u.action,Ao&&n(o,f),o=u.hasEagerState?u.eagerState:n(o,f)}else p={lane:f,revertLane:u.revertLane,gesture:u.gesture,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null},l===null?(c=l=p,s=o):l=l.next=p,To.lanes|=f,lu|=f;u=u.next}while(u!==null&&u!==t);if(l===null?s=o:l.next=c,!Hr(o,e.memoizedState)&&(vc=!0,d&&(n=Aa,n!==null)))throw n;e.memoizedState=o,e.baseState=s,e.baseQueue=l,r.lastRenderedState=o}return a===null&&(r.lanes=0),[e.memoizedState,r.dispatch]}function Qo(e){var t=Wo(),n=t.queue;if(n===null)throw Error(i(311));n.lastRenderedReducer=e;var r=n.dispatch,a=n.pending,o=t.memoizedState;if(a!==null){n.pending=null;var s=a=a.next;do o=e(o,s.action),s=s.next;while(s!==a);Hr(o,t.memoizedState)||(vc=!0),t.memoizedState=o,t.baseQueue===null&&(t.baseState=o),n.lastRenderedState=o}return[o,r]}function $o(e,t,n){var r=To,a=Wo(),o=ea;if(o){if(n===void 0)throw Error(i(407));n=n()}else n=t();var s=!Hr((Eo||a).memoizedState,n);if(s&&(a.memoizedState=n,vc=!0),a=a.queue,Es(ns.bind(null,r,a,e),[e]),a.getSnapshot!==t||s||Do!==null&&Do.memoizedState.tag&1){if(r.flags|=2048,xs(9,{destroy:void 0},ts.bind(null,r,a,n,t),null),$l===null)throw Error(i(349));o||wo&127||es(r,t,n)}return n}function es(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},t=To.updateQueue,t===null?(t=Go(),To.updateQueue=t,t.stores=[e]):(n=t.stores,n===null?t.stores=[e]:n.push(e))}function ts(e,t,n,r){t.value=n,t.getSnapshot=r,rs(t)&&os(e)}function ns(e,t,n){return n(function(){rs(t)&&os(e)})}function rs(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!Hr(e,n)}catch{return!0}}function os(e){var t=Si(e,2);t!==null&&Nu(t,e,2)}function ss(e){var t=Uo();if(typeof e==`function`){var n=e;if(e=n(),Ao){Ke(!0);try{n()}finally{Ke(!1)}}}return t.memoizedState=t.baseState=e,t.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Yo,lastRenderedState:e},t}function cs(e,t,n,r){return e.baseState=n,Zo(e,Eo,typeof r==`function`?r:Yo)}function ls(e,t,n,r,a){if(Zs(e))throw Error(i(485));if(e=t.action,e!==null){var o={payload:a,action:e,next:null,isTransition:!0,status:`pending`,value:null,reason:null,listeners:[],then:function(e){o.listeners.push(e)}};le.T===null?o.isTransition=!1:n(!0),r(o),n=t.pending,n===null?(o.next=t.pending=o,us(t,o)):(o.next=n.next,t.pending=n.next=o)}}function us(e,t){var n=t.action,r=t.payload,i=e.state;if(t.isTransition){var a=le.T,o={};le.T=o;try{var s=n(i,r),c=le.S;c!==null&&c(o,s),ds(e,t,s)}catch(n){ps(e,t,n)}finally{a!==null&&o.types!==null&&(a.types=o.types),le.T=a}}else try{a=n(i,r),ds(e,t,a)}catch(n){ps(e,t,n)}}function ds(e,t,n){typeof n==`object`&&n&&typeof n.then==`function`?n.then(function(n){fs(e,t,n)},function(n){return ps(e,t,n)}):fs(e,t,n)}function fs(e,t,n){t.status=`fulfilled`,t.value=n,ms(t),e.state=n,t=e.pending,t!==null&&(n=t.next,n===t?e.pending=null:(n=n.next,t.next=n,us(e,n)))}function ps(e,t,n){var r=e.pending;if(e.pending=null,r!==null){r=r.next;do t.status=`rejected`,t.reason=n,ms(t),t=t.next;while(t!==r)}e.action=null}function ms(e){e=e.listeners;for(var t=0;t<e.length;t++)(0,e[t])()}function hs(e,t){return t}function gs(e,t){if(ea){var n=$l.formState;if(n!==null){a:{var r=To;if(ea){if($i){b:{for(var i=$i,a=j;i.nodeType!==8;){if(!a){i=null;break b}if(i=Mf(i.nextSibling),i===null){i=null;break b}}a=i.data,i=a===`F!`||a===`F`?i:null}if(i){$i=Mf(i.nextSibling),r=i.data===`F!`;break a}}ra(r)}r=!1}r&&(t=n[0])}}return n=Uo(),n.memoizedState=n.baseState=t,r={pending:null,lanes:0,dispatch:null,lastRenderedReducer:hs,lastRenderedState:t},n.queue=r,n=Js.bind(null,To,r),r.dispatch=n,r=ss(!1),a=Xs.bind(null,To,!1,r.queue),r=Uo(),i={state:t,dispatch:null,action:e,pending:null},r.queue=i,n=ls.bind(null,To,i,a,n),i.dispatch=n,r.memoizedState=e,[t,n,!1]}function _s(e){var t=Wo();return vs(t,Eo,e)}function vs(e,t,n){if(t=Zo(e,t,hs)[0],e=Xo(Yo)[0],typeof t==`object`&&t&&typeof t.then==`function`)try{var r=Ko(t)}catch(e){throw e===za?Va:e}else r=t;t=Wo();var i=t.queue,a=i.dispatch;return n!==t.memoizedState&&(To.flags|=2048,xs(9,{destroy:void 0},ys.bind(null,i,n),null)),[r,a,e]}function ys(e,t){e.action=t}function bs(e){var t=Wo(),n=Eo;if(n!==null)return vs(t,n,e);Wo(),t=t.memoizedState,n=Wo();var r=n.queue.dispatch;return n.memoizedState=e,[t,r,!1]}function xs(e,t,n,r){return e={tag:e,create:n,deps:r,inst:t,next:null},t=To.updateQueue,t===null&&(t=Go(),To.updateQueue=t),n=t.lastEffect,n===null?t.lastEffect=e.next=e:(r=n.next,n.next=e,e.next=r,t.lastEffect=e),e}function Ss(){return Wo().memoizedState}function Cs(e,t,n,r){var i=Uo();To.flags|=e,i.memoizedState=xs(1|t,{destroy:void 0},n,r===void 0?null:r)}function ws(e,t,n,r){var i=Wo();r=r===void 0?null:r;var a=i.memoizedState.inst;Eo!==null&&r!==null&&Fo(r,Eo.memoizedState.deps)?i.memoizedState=xs(t,a,n,r):(To.flags|=e,i.memoizedState=xs(1|t,a,n,r))}function Ts(e,t){Cs(8390656,8,e,t)}function Es(e,t){ws(2048,8,e,t)}function Ds(e){To.flags|=4;var t=To.updateQueue;if(t===null)t=Go(),To.updateQueue=t,t.events=[e];else{var n=t.events;n===null?t.events=[e]:n.push(e)}}function Os(e){var t=Wo().memoizedState;return Ds({ref:t,nextImpl:e}),function(){if(Ql&2)throw Error(i(440));return t.impl.apply(void 0,arguments)}}function ks(e,t){return ws(4,2,e,t)}function As(e,t){return ws(4,4,e,t)}function js(e,t){if(typeof t==`function`){e=e();var n=t(e);return function(){typeof n==`function`?n():t(null)}}if(t!=null)return e=e(),t.current=e,function(){t.current=null}}function Ms(e,t,n){n=n==null?null:n.concat([e]),ws(4,4,js.bind(null,t,e),n)}function Ns(){}function Ps(e,t){var n=Wo();t=t===void 0?null:t;var r=n.memoizedState;return t!==null&&Fo(t,r[1])?r[0]:(n.memoizedState=[e,t],e)}function Fs(e,t){var n=Wo();t=t===void 0?null:t;var r=n.memoizedState;if(t!==null&&Fo(t,r[1]))return r[0];if(r=e(),Ao){Ke(!0);try{e()}finally{Ke(!1)}}return n.memoizedState=[r,t],r}function Is(e,t,n){return n===void 0||wo&1073741824&&!(tu&261930)?e.memoizedState=t:(e.memoizedState=n,e=Mu(),To.lanes|=e,lu|=e,n)}function Ls(e,t,n,r){return Hr(n,t)?n:uo.current===null?!(wo&42)||wo&1073741824&&!(tu&261930)?(vc=!0,e.memoizedState=n):(e=Mu(),To.lanes|=e,lu|=e,t):(e=Is(e,n,r),Hr(e,t)||(vc=!0),e)}function Rs(e,t,n,r,i){var a=ue.p;ue.p=a!==0&&8>a?a:8;var o=le.T,s={};le.T=s,Xs(e,!1,t,n);try{var c=i(),l=le.S;if(l!==null&&l(s,c),typeof c==`object`&&c&&typeof c.then==`function`){var u=Na(c,r);Ys(e,t,u,ju(e))}else Ys(e,t,r,ju(e))}catch(n){Ys(e,t,{then:function(){},status:`rejected`,reason:n},ju())}finally{ue.p=a,o!==null&&s.types!==null&&(o.types=s.types),le.T=o}}function zs(){}function Bs(e,t,n,r){if(e.tag!==5)throw Error(i(476));var a=Vs(e).queue;Rs(e,a,t,de,n===null?zs:function(){return Hs(e),n(r)})}function Vs(e){var t=e.memoizedState;if(t!==null)return t;t={memoizedState:de,baseState:de,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Yo,lastRenderedState:de},next:null};var n={};return t.next={memoizedState:n,baseState:n,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Yo,lastRenderedState:n},next:null},e.memoizedState=t,e=e.alternate,e!==null&&(e.memoizedState=t),t}function Hs(e){var t=Vs(e);t.next===null&&(t=e.alternate.memoizedState),Ys(e,t.next.queue,{},ju())}function Us(){return ba(xp)}function Ws(){return Wo().memoizedState}function Gs(){return Wo().memoizedState}function Ks(e){for(var t=e.return;t!==null;){switch(t.tag){case 24:case 3:var n=ju();e=io(n);var r=ao(t,e,n);r!==null&&(Nu(r,t,n),oo(r,t,n)),t={cache:N()},e.payload=t;return}t=t.return}}function qs(e,t,n){var r=ju();n={lane:r,revertLane:0,gesture:null,action:n,hasEagerState:!1,eagerState:null,next:null},Zs(e)?Qs(t,n):(n=xi(e,t,n,r),n!==null&&(Nu(n,e,r),$s(n,t,r)))}function Js(e,t,n){var r=ju();Ys(e,t,n,r)}function Ys(e,t,n,r){var i={lane:r,revertLane:0,gesture:null,action:n,hasEagerState:!1,eagerState:null,next:null};if(Zs(e))Qs(t,i);else{var a=e.alternate;if(e.lanes===0&&(a===null||a.lanes===0)&&(a=t.lastRenderedReducer,a!==null))try{var o=t.lastRenderedState,s=a(o,n);if(i.hasEagerState=!0,i.eagerState=s,Hr(s,o))return bi(e,t,i,0),$l===null&&yi(),!1}catch{}if(n=xi(e,t,i,r),n!==null)return Nu(n,e,r),$s(n,t,r),!0}return!1}function Xs(e,t,n,r){if(r={lane:2,revertLane:Ad(),gesture:null,action:r,hasEagerState:!1,eagerState:null,next:null},Zs(e)){if(t)throw Error(i(479))}else t=xi(e,n,r,2),t!==null&&Nu(t,e,2)}function Zs(e){var t=e.alternate;return e===To||t!==null&&t===To}function Qs(e,t){ko=Oo=!0;var n=e.pending;n===null?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function $s(e,t,n){if(n&4194048){var r=t.lanes;r&=e.pendingLanes,n|=r,t.lanes=n,ct(e,n)}}var ec={readContext:ba,use:qo,useCallback:Po,useContext:Po,useEffect:Po,useImperativeHandle:Po,useLayoutEffect:Po,useInsertionEffect:Po,useMemo:Po,useReducer:Po,useRef:Po,useState:Po,useDebugValue:Po,useDeferredValue:Po,useTransition:Po,useSyncExternalStore:Po,useId:Po,useHostTransitionStatus:Po,useFormState:Po,useActionState:Po,useOptimistic:Po,useMemoCache:Po,useCacheRefresh:Po};ec.useEffectEvent=Po;var tc={readContext:ba,use:qo,useCallback:function(e,t){return Uo().memoizedState=[e,t===void 0?null:t],e},useContext:ba,useEffect:Ts,useImperativeHandle:function(e,t,n){n=n==null?null:n.concat([e]),Cs(4194308,4,js.bind(null,t,e),n)},useLayoutEffect:function(e,t){return Cs(4194308,4,e,t)},useInsertionEffect:function(e,t){Cs(4,2,e,t)},useMemo:function(e,t){var n=Uo();t=t===void 0?null:t;var r=e();if(Ao){Ke(!0);try{e()}finally{Ke(!1)}}return n.memoizedState=[r,t],r},useReducer:function(e,t,n){var r=Uo();if(n!==void 0){var i=n(t);if(Ao){Ke(!0);try{n(t)}finally{Ke(!1)}}}else i=t;return r.memoizedState=r.baseState=i,e={pending:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:i},r.queue=e,e=e.dispatch=qs.bind(null,To,e),[r.memoizedState,e]},useRef:function(e){var t=Uo();return e={current:e},t.memoizedState=e},useState:function(e){e=ss(e);var t=e.queue,n=Js.bind(null,To,t);return t.dispatch=n,[e.memoizedState,n]},useDebugValue:Ns,useDeferredValue:function(e,t){var n=Uo();return Is(n,e,t)},useTransition:function(){var e=ss(!1);return e=Rs.bind(null,To,e.queue,!0,!1),Uo().memoizedState=e,[!1,e]},useSyncExternalStore:function(e,t,n){var r=To,a=Uo();if(ea){if(n===void 0)throw Error(i(407));n=n()}else{if(n=t(),$l===null)throw Error(i(349));tu&127||es(r,t,n)}a.memoizedState=n;var o={value:n,getSnapshot:t};return a.queue=o,Ts(ns.bind(null,r,o,e),[e]),r.flags|=2048,xs(9,{destroy:void 0},ts.bind(null,r,o,n,t),null),n},useId:function(){var e=Uo(),t=$l.identifierPrefix;if(ea){var n=Ki,r=Gi;n=(r&~(1<<32-qe(r)-1)).toString(32)+n,t=`_`+t+`R_`+n,n=jo++,0<n&&(t+=`H`+n.toString(32)),t+=`_`}else n=No++,t=`_`+t+`r_`+n.toString(32)+`_`;return e.memoizedState=t},useHostTransitionStatus:Us,useFormState:gs,useActionState:gs,useOptimistic:function(e){var t=Uo();t.memoizedState=t.baseState=e;var n={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return t.queue=n,t=Xs.bind(null,To,!0,n),n.dispatch=t,[e,t]},useMemoCache:Jo,useCacheRefresh:function(){return Uo().memoizedState=Ks.bind(null,To)},useEffectEvent:function(e){var t=Uo(),n={impl:e};return t.memoizedState=n,function(){if(Ql&2)throw Error(i(440));return n.impl.apply(void 0,arguments)}}},nc={readContext:ba,use:qo,useCallback:Ps,useContext:ba,useEffect:Es,useImperativeHandle:Ms,useInsertionEffect:ks,useLayoutEffect:As,useMemo:Fs,useReducer:Xo,useRef:Ss,useState:function(){return Xo(Yo)},useDebugValue:Ns,useDeferredValue:function(e,t){var n=Wo();return Ls(n,Eo.memoizedState,e,t)},useTransition:function(){var e=Xo(Yo)[0],t=Wo().memoizedState;return[typeof e==`boolean`?e:Ko(e),t]},useSyncExternalStore:$o,useId:Ws,useHostTransitionStatus:Us,useFormState:_s,useActionState:_s,useOptimistic:function(e,t){var n=Wo();return cs(n,Eo,e,t)},useMemoCache:Jo,useCacheRefresh:Gs};nc.useEffectEvent=Os;var rc={readContext:ba,use:qo,useCallback:Ps,useContext:ba,useEffect:Es,useImperativeHandle:Ms,useInsertionEffect:ks,useLayoutEffect:As,useMemo:Fs,useReducer:Qo,useRef:Ss,useState:function(){return Qo(Yo)},useDebugValue:Ns,useDeferredValue:function(e,t){var n=Wo();return Eo===null?Is(n,e,t):Ls(n,Eo.memoizedState,e,t)},useTransition:function(){var e=Qo(Yo)[0],t=Wo().memoizedState;return[typeof e==`boolean`?e:Ko(e),t]},useSyncExternalStore:$o,useId:Ws,useHostTransitionStatus:Us,useFormState:bs,useActionState:bs,useOptimistic:function(e,t){var n=Wo();return Eo===null?(n.baseState=e,[e,n.queue.dispatch]):cs(n,Eo,e,t)},useMemoCache:Jo,useCacheRefresh:Gs};rc.useEffectEvent=Os;function ic(e,t,n,r){t=e.memoizedState,n=n(r,t),n=n==null?t:f({},t,n),e.memoizedState=n,e.lanes===0&&(e.updateQueue.baseState=n)}var ac={enqueueSetState:function(e,t,n){e=e._reactInternals;var r=ju(),i=io(r);i.payload=t,n!=null&&(i.callback=n),t=ao(e,i,r),t!==null&&(Nu(t,e,r),oo(t,e,r))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var r=ju(),i=io(r);i.tag=1,i.payload=t,n!=null&&(i.callback=n),t=ao(e,i,r),t!==null&&(Nu(t,e,r),oo(t,e,r))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=ju(),r=io(n);r.tag=2,t!=null&&(r.callback=t),t=ao(e,r,n),t!==null&&(Nu(t,e,n),oo(t,e,n))}};function oc(e,t,n,r,i,a,o){return e=e.stateNode,typeof e.shouldComponentUpdate==`function`?e.shouldComponentUpdate(r,a,o):t.prototype&&t.prototype.isPureReactComponent?!Ur(n,r)||!Ur(i,a):!0}function sc(e,t,n,r){e=t.state,typeof t.componentWillReceiveProps==`function`&&t.componentWillReceiveProps(n,r),typeof t.UNSAFE_componentWillReceiveProps==`function`&&t.UNSAFE_componentWillReceiveProps(n,r),t.state!==e&&ac.enqueueReplaceState(t,t.state,null)}function cc(e,t){var n=t;if(`ref`in t)for(var r in n={},t)r!==`ref`&&(n[r]=t[r]);if(e=e.defaultProps)for(var i in n===t&&(n=f({},n)),e)n[i]===void 0&&(n[i]=e[i]);return n}function lc(e){hi(e)}function uc(e){console.error(e)}function dc(e){hi(e)}function fc(e,t){try{var n=e.onUncaughtError;n(t.value,{componentStack:t.stack})}catch(e){setTimeout(function(){throw e})}}function pc(e,t,n){try{var r=e.onCaughtError;r(n.value,{componentStack:n.stack,errorBoundary:t.tag===1?t.stateNode:null})}catch(e){setTimeout(function(){throw e})}}function mc(e,t,n){return n=io(n),n.tag=3,n.payload={element:null},n.callback=function(){fc(e,t)},n}function hc(e){return e=io(e),e.tag=3,e}function gc(e,t,n,r){var i=n.type.getDerivedStateFromError;if(typeof i==`function`){var a=r.value;e.payload=function(){return i(a)},e.callback=function(){pc(t,n,r)}}var o=n.stateNode;o!==null&&typeof o.componentDidCatch==`function`&&(e.callback=function(){pc(t,n,r),typeof i!=`function`&&(xu===null?xu=new Set([this]):xu.add(this));var e=r.stack;this.componentDidCatch(r.value,{componentStack:e===null?``:e})})}function V(e,t,n,r,a){if(n.flags|=32768,typeof r==`object`&&r&&typeof r.then==`function`){if(t=n.alternate,t!==null&&_a(t,n,a,!0),n=ho.current,n!==null){switch(n.tag){case 31:case 13:return go===null?Gu():n.alternate===null&&cu===0&&(cu=3),n.flags&=-257,n.flags|=65536,n.lanes=a,r===Ha?n.flags|=16384:(t=n.updateQueue,t===null?n.updateQueue=new Set([r]):t.add(r),ud(e,r,a)),!1;case 22:return n.flags|=65536,r===Ha?n.flags|=16384:(t=n.updateQueue,t===null?(t={transitions:null,markerInstances:null,retryQueue:new Set([r])},n.updateQueue=t):(n=t.retryQueue,n===null?t.retryQueue=new Set([r]):n.add(r)),ud(e,r,a)),!1}throw Error(i(435,n.tag))}return ud(e,r,a),Gu(),!1}if(ea)return t=ho.current,t===null?(r!==na&&(t=Error(i(423),{cause:r}),la(Li(t,n))),e=e.current.alternate,e.flags|=65536,a&=-a,e.lanes|=a,r=Li(r,n),a=mc(e.stateNode,r,a),so(e,a),cu!==4&&(cu=2)):(!(t.flags&65536)&&(t.flags|=256),t.flags|=65536,t.lanes=a,r!==na&&(e=Error(i(422),{cause:r}),la(Li(e,n)))),!1;var o=Error(i(520),{cause:r});if(o=Li(o,n),mu===null?mu=[o]:mu.push(o),cu!==4&&(cu=2),t===null)return!0;r=Li(r,n),n=t;do{switch(n.tag){case 3:return n.flags|=65536,e=a&-a,n.lanes|=e,e=mc(n.stateNode,r,e),so(n,e),!1;case 1:if(t=n.type,o=n.stateNode,!(n.flags&128)&&(typeof t.getDerivedStateFromError==`function`||o!==null&&typeof o.componentDidCatch==`function`&&(xu===null||!xu.has(o))))return n.flags|=65536,a&=-a,n.lanes|=a,a=hc(a),gc(a,e,n,r),so(n,a),!1}n=n.return}while(n!==null);return!1}var _c=Error(i(461)),vc=!1;function yc(e,t,n,r){t.child=e===null?eo(t,null,n,r):$a(t,e.child,n,r)}function bc(e,t,n,r,i){n=n.render;var a=t.ref;if(`ref`in r){var o={};for(var s in r)s!==`ref`&&(o[s]=r[s])}else o=r;return ya(t),r=Io(e,t,n,o,a,i),s=Bo(),e!==null&&!vc?(Vo(e,t,i),Hc(e,t,i)):(ea&&s&&Yi(t),t.flags|=1,yc(e,t,r,i),t.child)}function xc(e,t,n,r,i){if(e===null){var a=n.type;return typeof a==`function`&&!Oi(a)&&a.defaultProps===void 0&&n.compare===null?(t.tag=15,t.type=a,Sc(e,t,a,r,i)):(e=ji(n.type,null,r,t,t.mode,i),e.ref=t.ref,e.return=t,t.child=e)}if(a=e.child,!Uc(e,i)){var o=a.memoizedProps;if(n=n.compare,n=n===null?Ur:n,n(o,r)&&e.ref===t.ref)return Hc(e,t,i)}return t.flags|=1,e=ki(a,r),e.ref=t.ref,e.return=t,t.child=e}function Sc(e,t,n,r,i){if(e!==null){var a=e.memoizedProps;if(Ur(a,r)&&e.ref===t.ref)if(vc=!1,t.pendingProps=r=a,Uc(e,i))e.flags&131072&&(vc=!0);else return t.lanes=e.lanes,Hc(e,t,i)}return kc(e,t,n,r,i)}function Cc(e,t,n,r){var i=r.children,a=e===null?null:e.memoizedState;if(e===null&&t.stateNode===null&&(t.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),r.mode===`hidden`){if(t.flags&128){if(a=a===null?n:a.baseLanes|n,e!==null){for(r=t.child=e.child,i=0;r!==null;)i=i|r.lanes|r.childLanes,r=r.sibling;r=i&~a}else r=0,t.child=null;return H(e,t,a,n,r)}if(n&536870912)t.memoizedState={baseLanes:0,cachePool:null},e!==null&&La(t,a===null?null:a.cachePool),a===null?po():fo(t,a),yo(t);else return r=t.lanes=536870912,H(e,t,a===null?n:a.baseLanes|n,n,r)}else a===null?(e!==null&&La(t,null),po(),bo(t)):(La(t,a.cachePool),fo(t,a),bo(t),t.memoizedState=null);return yc(e,t,i,n),t.child}function wc(e,t){return e!==null&&e.tag===22||t.stateNode!==null||(t.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),t.sibling}function H(e,t,n,r,i){var a=Ia();return a=a===null?null:{parent:Ta._currentValue,pool:a},t.memoizedState={baseLanes:n,cachePool:a},e!==null&&La(t,null),po(),yo(t),e!==null&&_a(e,t,r,!0),t.childLanes=i,null}function Tc(e,t){return t=Lc({mode:t.mode,children:t.children},e.mode),t.ref=e.ref,e.child=t,t.return=e,t}function Ec(e,t,n){return $a(t,e.child,null,n),e=Tc(t,t.pendingProps),e.flags|=2,xo(t),t.memoizedState=null,e}function Dc(e,t,n){var r=t.pendingProps,a=(t.flags&128)!=0;if(t.flags&=-129,e===null){if(ea){if(r.mode===`hidden`)return e=Tc(t,r),t.lanes=536870912,wc(null,e);if(vo(t),(e=$i)?(e=Of(e,j),e=e!==null&&e.data===`&`?e:null,e!==null&&(t.memoizedState={dehydrated:e,treeContext:Wi===null?null:{id:Gi,overflow:Ki},retryLane:536870912,hydrationErrors:null},n=Pi(e),n.return=t,t.child=n,Qi=t,$i=null)):e=null,e===null)throw ra(t);return t.lanes=536870912,null}return Tc(t,r)}var o=e.memoizedState;if(o!==null){var s=o.dehydrated;if(vo(t),a)if(t.flags&256)t.flags&=-257,t=Ec(e,t,n);else if(t.memoizedState!==null)t.child=e.child,t.flags|=128,t=null;else throw Error(i(558));else if(vc||_a(e,t,n,!1),a=(n&e.childLanes)!==0,vc||a){if(r=$l,r!==null&&(s=lt(r,n),s!==0&&s!==o.retryLane))throw o.retryLane=s,Si(e,s),Nu(r,e,s),_c;Gu(),t=Ec(e,t,n)}else e=o.treeContext,$i=Mf(s.nextSibling),Qi=t,ea=!0,ta=null,j=!1,e!==null&&Zi(t,e),t=Tc(t,r),t.flags|=4096;return t}return e=ki(e.child,{mode:r.mode,children:r.children}),e.ref=t.ref,t.child=e,e.return=t,e}function Oc(e,t){var n=t.ref;if(n===null)e!==null&&e.ref!==null&&(t.flags|=4194816);else{if(typeof n!=`function`&&typeof n!=`object`)throw Error(i(284));(e===null||e.ref!==n)&&(t.flags|=4194816)}}function kc(e,t,n,r,i){return ya(t),n=Io(e,t,n,r,void 0,i),r=Bo(),e!==null&&!vc?(Vo(e,t,i),Hc(e,t,i)):(ea&&r&&Yi(t),t.flags|=1,yc(e,t,n,i),t.child)}function Ac(e,t,n,r,i,a){return ya(t),t.updateQueue=null,n=Ro(t,r,n,i),Lo(e),r=Bo(),e!==null&&!vc?(Vo(e,t,a),Hc(e,t,a)):(ea&&r&&Yi(t),t.flags|=1,yc(e,t,n,a),t.child)}function jc(e,t,n,r,i){if(ya(t),t.stateNode===null){var a=Ti,o=n.contextType;typeof o==`object`&&o&&(a=ba(o)),a=new n(r,a),t.memoizedState=a.state!==null&&a.state!==void 0?a.state:null,a.updater=ac,t.stateNode=a,a._reactInternals=t,a=t.stateNode,a.props=r,a.state=t.memoizedState,a.refs={},no(t),o=n.contextType,a.context=typeof o==`object`&&o?ba(o):Ti,a.state=t.memoizedState,o=n.getDerivedStateFromProps,typeof o==`function`&&(ic(t,n,o,r),a.state=t.memoizedState),typeof n.getDerivedStateFromProps==`function`||typeof a.getSnapshotBeforeUpdate==`function`||typeof a.UNSAFE_componentWillMount!=`function`&&typeof a.componentWillMount!=`function`||(o=a.state,typeof a.componentWillMount==`function`&&a.componentWillMount(),typeof a.UNSAFE_componentWillMount==`function`&&a.UNSAFE_componentWillMount(),o!==a.state&&ac.enqueueReplaceState(a,a.state,null),lo(t,r,a,i),I(),a.state=t.memoizedState),typeof a.componentDidMount==`function`&&(t.flags|=4194308),r=!0}else if(e===null){a=t.stateNode;var s=t.memoizedProps,c=cc(n,s);a.props=c;var l=a.context,u=n.contextType;o=Ti,typeof u==`object`&&u&&(o=ba(u));var d=n.getDerivedStateFromProps;u=typeof d==`function`||typeof a.getSnapshotBeforeUpdate==`function`,s=t.pendingProps!==s,u||typeof a.UNSAFE_componentWillReceiveProps!=`function`&&typeof a.componentWillReceiveProps!=`function`||(s||l!==o)&&sc(t,a,r,o),to=!1;var f=t.memoizedState;a.state=f,lo(t,r,a,i),I(),l=t.memoizedState,s||f!==l||to?(typeof d==`function`&&(ic(t,n,d,r),l=t.memoizedState),(c=to||oc(t,n,c,r,f,l,o))?(u||typeof a.UNSAFE_componentWillMount!=`function`&&typeof a.componentWillMount!=`function`||(typeof a.componentWillMount==`function`&&a.componentWillMount(),typeof a.UNSAFE_componentWillMount==`function`&&a.UNSAFE_componentWillMount()),typeof a.componentDidMount==`function`&&(t.flags|=4194308)):(typeof a.componentDidMount==`function`&&(t.flags|=4194308),t.memoizedProps=r,t.memoizedState=l),a.props=r,a.state=l,a.context=o,r=c):(typeof a.componentDidMount==`function`&&(t.flags|=4194308),r=!1)}else{a=t.stateNode,ro(e,t),o=t.memoizedProps,u=cc(n,o),a.props=u,d=t.pendingProps,f=a.context,l=n.contextType,c=Ti,typeof l==`object`&&l&&(c=ba(l)),s=n.getDerivedStateFromProps,(l=typeof s==`function`||typeof a.getSnapshotBeforeUpdate==`function`)||typeof a.UNSAFE_componentWillReceiveProps!=`function`&&typeof a.componentWillReceiveProps!=`function`||(o!==d||f!==c)&&sc(t,a,r,c),to=!1,f=t.memoizedState,a.state=f,lo(t,r,a,i),I();var p=t.memoizedState;o!==d||f!==p||to||e!==null&&e.dependencies!==null&&va(e.dependencies)?(typeof s==`function`&&(ic(t,n,s,r),p=t.memoizedState),(u=to||oc(t,n,u,r,f,p,c)||e!==null&&e.dependencies!==null&&va(e.dependencies))?(l||typeof a.UNSAFE_componentWillUpdate!=`function`&&typeof a.componentWillUpdate!=`function`||(typeof a.componentWillUpdate==`function`&&a.componentWillUpdate(r,p,c),typeof a.UNSAFE_componentWillUpdate==`function`&&a.UNSAFE_componentWillUpdate(r,p,c)),typeof a.componentDidUpdate==`function`&&(t.flags|=4),typeof a.getSnapshotBeforeUpdate==`function`&&(t.flags|=1024)):(typeof a.componentDidUpdate!=`function`||o===e.memoizedProps&&f===e.memoizedState||(t.flags|=4),typeof a.getSnapshotBeforeUpdate!=`function`||o===e.memoizedProps&&f===e.memoizedState||(t.flags|=1024),t.memoizedProps=r,t.memoizedState=p),a.props=r,a.state=p,a.context=c,r=u):(typeof a.componentDidUpdate!=`function`||o===e.memoizedProps&&f===e.memoizedState||(t.flags|=4),typeof a.getSnapshotBeforeUpdate!=`function`||o===e.memoizedProps&&f===e.memoizedState||(t.flags|=1024),r=!1)}return a=r,Oc(e,t),r=(t.flags&128)!=0,a||r?(a=t.stateNode,n=r&&typeof n.getDerivedStateFromError!=`function`?null:a.render(),t.flags|=1,e!==null&&r?(t.child=$a(t,e.child,null,i),t.child=$a(t,null,n,i)):yc(e,t,n,i),t.memoizedState=a.state,e=t.child):e=Hc(e,t,i),e}function Mc(e,t,n,r){return sa(),t.flags|=256,yc(e,t,n,r),t.child}var U={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function Nc(e){return{baseLanes:e,cachePool:Ra()}}function Pc(e,t,n){return e=e===null?0:e.childLanes&~n,t&&(e|=fu),e}function Fc(e,t,n){var r=t.pendingProps,a=!1,o=(t.flags&128)!=0,s;if((s=o)||(s=e!==null&&e.memoizedState===null?!1:(So.current&2)!=0),s&&(a=!0,t.flags&=-129),s=(t.flags&32)!=0,t.flags&=-33,e===null){if(ea){if(a?_o(t):bo(t),(e=$i)?(e=Of(e,j),e=e!==null&&e.data!==`&`?e:null,e!==null&&(t.memoizedState={dehydrated:e,treeContext:Wi===null?null:{id:Gi,overflow:Ki},retryLane:536870912,hydrationErrors:null},n=Pi(e),n.return=t,t.child=n,Qi=t,$i=null)):e=null,e===null)throw ra(t);return Af(e)?t.lanes=32:t.lanes=536870912,null}var c=r.children;return r=r.fallback,a?(bo(t),a=t.mode,c=Lc({mode:`hidden`,children:c},a),r=Mi(r,a,n,null),c.return=t,r.return=t,c.sibling=r,t.child=c,r=t.child,r.memoizedState=Nc(n),r.childLanes=Pc(e,s,n),t.memoizedState=U,wc(null,r)):(_o(t),Ic(t,c))}var l=e.memoizedState;if(l!==null&&(c=l.dehydrated,c!==null)){if(o)t.flags&256?(_o(t),t.flags&=-257,t=Rc(e,t,n)):t.memoizedState===null?(bo(t),c=r.fallback,a=t.mode,r=Lc({mode:`visible`,children:r.children},a),c=Mi(c,a,n,null),c.flags|=2,r.return=t,c.return=t,r.sibling=c,t.child=r,$a(t,e.child,null,n),r=t.child,r.memoizedState=Nc(n),r.childLanes=Pc(e,s,n),t.memoizedState=U,t=wc(null,r)):(bo(t),t.child=e.child,t.flags|=128,t=null);else if(_o(t),Af(c)){if(s=c.nextSibling&&c.nextSibling.dataset,s)var u=s.dgst;s=u,r=Error(i(419)),r.stack=``,r.digest=s,la({value:r,source:null,stack:null}),t=Rc(e,t,n)}else if(vc||_a(e,t,n,!1),s=(n&e.childLanes)!==0,vc||s){if(s=$l,s!==null&&(r=lt(s,n),r!==0&&r!==l.retryLane))throw l.retryLane=r,Si(e,r),Nu(s,e,r),_c;kf(c)||Gu(),t=Rc(e,t,n)}else kf(c)?(t.flags|=192,t.child=e.child,t=null):(e=l.treeContext,$i=Mf(c.nextSibling),Qi=t,ea=!0,ta=null,j=!1,e!==null&&Zi(t,e),t=Ic(t,r.children),t.flags|=4096);return t}return a?(bo(t),c=r.fallback,a=t.mode,l=e.child,u=l.sibling,r=ki(l,{mode:`hidden`,children:r.children}),r.subtreeFlags=l.subtreeFlags&65011712,u===null?(c=Mi(c,a,n,null),c.flags|=2):c=ki(u,c),c.return=t,r.return=t,r.sibling=c,t.child=r,wc(null,r),r=t.child,c=e.child.memoizedState,c===null?c=Nc(n):(a=c.cachePool,a===null?a=Ra():(l=Ta._currentValue,a=a.parent===l?a:{parent:l,pool:l}),c={baseLanes:c.baseLanes|n,cachePool:a}),r.memoizedState=c,r.childLanes=Pc(e,s,n),t.memoizedState=U,wc(e.child,r)):(_o(t),n=e.child,e=n.sibling,n=ki(n,{mode:`visible`,children:r.children}),n.return=t,n.sibling=null,e!==null&&(s=t.deletions,s===null?(t.deletions=[e],t.flags|=16):s.push(e)),t.child=n,t.memoizedState=null,n)}function Ic(e,t){return t=Lc({mode:`visible`,children:t},e.mode),t.return=e,e.child=t}function Lc(e,t){return e=Di(22,e,null,t),e.lanes=0,e}function Rc(e,t,n){return $a(t,e.child,null,n),e=Ic(t,t.pendingProps.children),e.flags|=2,t.memoizedState=null,e}function zc(e,t,n){e.lanes|=t;var r=e.alternate;r!==null&&(r.lanes|=t),ha(e.return,t,n)}function Bc(e,t,n,r,i,a){var o=e.memoizedState;o===null?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:r,tail:n,tailMode:i,treeForkCount:a}:(o.isBackwards=t,o.rendering=null,o.renderingStartTime=0,o.last=r,o.tail=n,o.tailMode=i,o.treeForkCount=a)}function Vc(e,t,n){var r=t.pendingProps,i=r.revealOrder,a=r.tail;r=r.children;var o=So.current,s=(o&2)!=0;if(s?(o=o&1|2,t.flags|=128):o&=1,me(So,o),yc(e,t,r,n),r=ea?Vi:0,!s&&e!==null&&e.flags&128)a:for(e=t.child;e!==null;){if(e.tag===13)e.memoizedState!==null&&zc(e,n,t);else if(e.tag===19)zc(e,n,t);else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===t)break a;for(;e.sibling===null;){if(e.return===null||e.return===t)break a;e=e.return}e.sibling.return=e.return,e=e.sibling}switch(i){case`forwards`:for(n=t.child,i=null;n!==null;)e=n.alternate,e!==null&&Co(e)===null&&(i=n),n=n.sibling;n=i,n===null?(i=t.child,t.child=null):(i=n.sibling,n.sibling=null),Bc(t,!1,i,n,a,r);break;case`backwards`:case`unstable_legacy-backwards`:for(n=null,i=t.child,t.child=null;i!==null;){if(e=i.alternate,e!==null&&Co(e)===null){t.child=i;break}e=i.sibling,i.sibling=n,n=i,i=e}Bc(t,!0,n,null,a,r);break;case`together`:Bc(t,!1,null,null,void 0,r);break;default:t.memoizedState=null}return t.child}function Hc(e,t,n){if(e!==null&&(t.dependencies=e.dependencies),lu|=t.lanes,(n&t.childLanes)===0)if(e!==null){if(_a(e,t,n,!1),(n&t.childLanes)===0)return null}else return null;if(e!==null&&t.child!==e.child)throw Error(i(153));if(t.child!==null){for(e=t.child,n=ki(e,e.pendingProps),t.child=n,n.return=t;e.sibling!==null;)e=e.sibling,n=n.sibling=ki(e,e.pendingProps),n.return=t;n.sibling=null}return t.child}function Uc(e,t){return(e.lanes&t)===0?(e=e.dependencies,!!(e!==null&&va(e))):!0}function Wc(e,t,n){switch(t.tag){case 3:ye(t,t.stateNode.containerInfo),pa(t,Ta,e.memoizedState.cache),sa();break;case 27:case 5:xe(t);break;case 4:ye(t,t.stateNode.containerInfo);break;case 10:pa(t,t.type,t.memoizedProps.value);break;case 31:if(t.memoizedState!==null)return t.flags|=128,vo(t),null;break;case 13:var r=t.memoizedState;if(r!==null)return r.dehydrated===null?(n&t.child.childLanes)===0?(_o(t),e=Hc(e,t,n),e===null?null:e.sibling):Fc(e,t,n):(_o(t),t.flags|=128,null);_o(t);break;case 19:var i=(e.flags&128)!=0;if(r=(n&t.childLanes)!==0,r||=(_a(e,t,n,!1),(n&t.childLanes)!==0),i){if(r)return Vc(e,t,n);t.flags|=128}if(i=t.memoizedState,i!==null&&(i.rendering=null,i.tail=null,i.lastEffect=null),me(So,So.current),r)break;return null;case 22:return t.lanes=0,Cc(e,t,n,t.pendingProps);case 24:pa(t,Ta,e.memoizedState.cache)}return Hc(e,t,n)}function Gc(e,t,n){if(e!==null)if(e.memoizedProps!==t.pendingProps)vc=!0;else{if(!Uc(e,n)&&!(t.flags&128))return vc=!1,Wc(e,t,n);vc=!!(e.flags&131072)}else vc=!1,ea&&t.flags&1048576&&Ji(t,Vi,t.index);switch(t.lanes=0,t.tag){case 16:a:{var r=t.pendingProps;if(e=Ga(t.elementType),t.type=e,typeof e==`function`)Oi(e)?(r=cc(e,r),t.tag=1,t=jc(null,t,e,r,n)):(t.tag=0,t=kc(null,t,e,r,n));else{if(e!=null){var a=e.$$typeof;if(a===w){t.tag=11,t=bc(null,t,e,r,n);break a}else if(a===E){t.tag=14,t=xc(null,t,e,r,n);break a}}throw t=se(e)||e,Error(i(306,t,``))}}return t;case 0:return kc(e,t,t.type,t.pendingProps,n);case 1:return r=t.type,a=cc(r,t.pendingProps),jc(e,t,r,a,n);case 3:a:{if(ye(t,t.stateNode.containerInfo),e===null)throw Error(i(387));r=t.pendingProps;var o=t.memoizedState;a=o.element,ro(e,t),lo(t,r,null,n);var s=t.memoizedState;if(r=s.cache,pa(t,Ta,r),r!==o.cache&&ga(t,[Ta],n,!0),I(),r=s.element,o.isDehydrated)if(o={element:r,isDehydrated:!1,cache:s.cache},t.updateQueue.baseState=o,t.memoizedState=o,t.flags&256){t=Mc(e,t,r,n);break a}else if(r!==a){a=Li(Error(i(424)),t),la(a),t=Mc(e,t,r,n);break a}else{switch(e=t.stateNode.containerInfo,e.nodeType){case 9:e=e.body;break;default:e=e.nodeName===`HTML`?e.ownerDocument.body:e}for($i=Mf(e.firstChild),Qi=t,ea=!0,ta=null,j=!0,n=eo(t,null,r,n),t.child=n;n;)n.flags=n.flags&-3|4096,n=n.sibling}else{if(sa(),r===a){t=Hc(e,t,n);break a}yc(e,t,r,n)}t=t.child}return t;case 26:return Oc(e,t),e===null?(n=$f(t.type,null,t.pendingProps,null))?t.memoizedState=n:ea||(n=t.type,e=t.pendingProps,r=df(_e.current).createElement(n),r[ht]=t,r[gt]=e,rf(r,n,e),Ot(r),t.stateNode=r):t.memoizedState=$f(t.type,e.memoizedProps,t.pendingProps,e.memoizedState),null;case 27:return xe(t),e===null&&ea&&(r=t.stateNode=If(t.type,t.pendingProps,_e.current),Qi=t,j=!0,a=$i,Sf(t.type)?(Nf=a,$i=Mf(r.firstChild)):$i=a),yc(e,t,t.pendingProps.children,n),Oc(e,t),e===null&&(t.flags|=4194304),t.child;case 5:return e===null&&ea&&((a=r=$i)&&(r=Ef(r,t.type,t.pendingProps,j),r===null?a=!1:(t.stateNode=r,Qi=t,$i=Mf(r.firstChild),j=!1,a=!0)),a||ra(t)),xe(t),a=t.type,o=t.pendingProps,s=e===null?null:e.memoizedProps,r=o.children,mf(a,o)?r=null:s!==null&&mf(a,s)&&(t.flags|=32),t.memoizedState!==null&&(a=Io(e,t,zo,null,null,n),xp._currentValue=a),Oc(e,t),yc(e,t,r,n),t.child;case 6:return e===null&&ea&&((e=n=$i)&&(n=Df(n,t.pendingProps,j),n===null?e=!1:(t.stateNode=n,Qi=t,$i=null,e=!0)),e||ra(t)),null;case 13:return Fc(e,t,n);case 4:return ye(t,t.stateNode.containerInfo),r=t.pendingProps,e===null?t.child=$a(t,null,r,n):yc(e,t,r,n),t.child;case 11:return bc(e,t,t.type,t.pendingProps,n);case 7:return yc(e,t,t.pendingProps,n),t.child;case 8:return yc(e,t,t.pendingProps.children,n),t.child;case 12:return yc(e,t,t.pendingProps.children,n),t.child;case 10:return r=t.pendingProps,pa(t,t.type,r.value),yc(e,t,r.children,n),t.child;case 9:return a=t.type._context,r=t.pendingProps.children,ya(t),a=ba(a),r=r(a),t.flags|=1,yc(e,t,r,n),t.child;case 14:return xc(e,t,t.type,t.pendingProps,n);case 15:return Sc(e,t,t.type,t.pendingProps,n);case 19:return Vc(e,t,n);case 31:return Dc(e,t,n);case 22:return Cc(e,t,n,t.pendingProps);case 24:return ya(t),r=ba(Ta),e===null?(a=Ia(),a===null&&(a=$l,o=N(),a.pooledCache=o,o.refCount++,o!==null&&(a.pooledCacheLanes|=n),a=o),t.memoizedState={parent:r,cache:a},no(t),pa(t,Ta,a)):((e.lanes&n)!==0&&(ro(e,t),lo(t,null,null,n),I()),a=e.memoizedState,o=t.memoizedState,a.parent===r?(r=o.cache,pa(t,Ta,r),r!==a.cache&&ga(t,[Ta],n,!0)):(a={parent:r,cache:r},t.memoizedState=a,t.lanes===0&&(t.memoizedState=t.updateQueue.baseState=a),pa(t,Ta,r))),yc(e,t,t.pendingProps.children,n),t.child;case 29:throw t.pendingProps}throw Error(i(156,t.tag))}function Kc(e){e.flags|=4}function qc(e,t,n,r,i){if((t=(e.mode&32)!=0)&&(t=!1),t){if(e.flags|=16777216,(i&335544128)===i)if(e.stateNode.complete)e.flags|=8192;else if(Hu())e.flags|=8192;else throw Ka=Ha,Ba}else e.flags&=-16777217}function Jc(e,t){if(t.type!==`stylesheet`||t.state.loading&4)e.flags&=-16777217;else if(e.flags|=16777216,!pp(t))if(Hu())e.flags|=8192;else throw Ka=Ha,Ba}function Yc(e,t){t!==null&&(e.flags|=4),e.flags&16384&&(t=e.tag===22?536870912:rt(),e.lanes|=t,pu|=t)}function Xc(e,t){if(!ea)switch(e.tailMode){case`hidden`:t=e.tail;for(var n=null;t!==null;)t.alternate!==null&&(n=t),t=t.sibling;n===null?e.tail=null:n.sibling=null;break;case`collapsed`:n=e.tail;for(var r=null;n!==null;)n.alternate!==null&&(r=n),n=n.sibling;r===null?t||e.tail===null?e.tail=null:e.tail.sibling=null:r.sibling=null}}function Zc(e){var t=e.alternate!==null&&e.alternate.child===e.child,n=0,r=0;if(t)for(var i=e.child;i!==null;)n|=i.lanes|i.childLanes,r|=i.subtreeFlags&65011712,r|=i.flags&65011712,i.return=e,i=i.sibling;else for(i=e.child;i!==null;)n|=i.lanes|i.childLanes,r|=i.subtreeFlags,r|=i.flags,i.return=e,i=i.sibling;return e.subtreeFlags|=r,e.childLanes=n,t}function Qc(e,t,n){var r=t.pendingProps;switch(Xi(t),t.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Zc(t),null;case 1:return Zc(t),null;case 3:return n=t.stateNode,r=null,e!==null&&(r=e.memoizedState.cache),t.memoizedState.cache!==r&&(t.flags|=2048),ma(Ta),be(),n.pendingContext&&=(n.context=n.pendingContext,null),(e===null||e.child===null)&&(oa(t)?Kc(t):e===null||e.memoizedState.isDehydrated&&!(t.flags&256)||(t.flags|=1024,ca())),Zc(t),null;case 26:var a=t.type,o=t.memoizedState;return e===null?(Kc(t),o===null?(Zc(t),qc(t,a,null,r,n)):(Zc(t),Jc(t,o))):o?o===e.memoizedState?(Zc(t),t.flags&=-16777217):(Kc(t),Zc(t),Jc(t,o)):(e=e.memoizedProps,e!==r&&Kc(t),Zc(t),qc(t,a,e,r,n)),null;case 27:if(Se(t),n=_e.current,a=t.type,e!==null&&t.stateNode!=null)e.memoizedProps!==r&&Kc(t);else{if(!r){if(t.stateNode===null)throw Error(i(166));return Zc(t),null}e=he.current,oa(t)?ia(t,e):(e=If(a,r,n),t.stateNode=e,Kc(t))}return Zc(t),null;case 5:if(Se(t),a=t.type,e!==null&&t.stateNode!=null)e.memoizedProps!==r&&Kc(t);else{if(!r){if(t.stateNode===null)throw Error(i(166));return Zc(t),null}if(o=he.current,oa(t))ia(t,o);else{var s=df(_e.current);switch(o){case 1:o=s.createElementNS(`http://www.w3.org/2000/svg`,a);break;case 2:o=s.createElementNS(`http://www.w3.org/1998/Math/MathML`,a);break;default:switch(a){case`svg`:o=s.createElementNS(`http://www.w3.org/2000/svg`,a);break;case`math`:o=s.createElementNS(`http://www.w3.org/1998/Math/MathML`,a);break;case`script`:o=s.createElement(`div`),o.innerHTML=`<script><\/script>`,o=o.removeChild(o.firstChild);break;case`select`:o=typeof r.is==`string`?s.createElement(`select`,{is:r.is}):s.createElement(`select`),r.multiple?o.multiple=!0:r.size&&(o.size=r.size);break;default:o=typeof r.is==`string`?s.createElement(a,{is:r.is}):s.createElement(a)}}o[ht]=t,o[gt]=r;a:for(s=t.child;s!==null;){if(s.tag===5||s.tag===6)o.appendChild(s.stateNode);else if(s.tag!==4&&s.tag!==27&&s.child!==null){s.child.return=s,s=s.child;continue}if(s===t)break a;for(;s.sibling===null;){if(s.return===null||s.return===t)break a;s=s.return}s.sibling.return=s.return,s=s.sibling}t.stateNode=o;a:switch(rf(o,a,r),a){case`button`:case`input`:case`select`:case`textarea`:r=!!r.autoFocus;break a;case`img`:r=!0;break a;default:r=!1}r&&Kc(t)}}return Zc(t),qc(t,t.type,e===null?null:e.memoizedProps,t.pendingProps,n),null;case 6:if(e&&t.stateNode!=null)e.memoizedProps!==r&&Kc(t);else{if(typeof r!=`string`&&t.stateNode===null)throw Error(i(166));if(e=_e.current,oa(t)){if(e=t.stateNode,n=t.memoizedProps,r=null,a=Qi,a!==null)switch(a.tag){case 27:case 5:r=a.memoizedProps}e[ht]=t,e=!!(e.nodeValue===n||r!==null&&!0===r.suppressHydrationWarning||ef(e.nodeValue,n)),e||ra(t,!0)}else e=df(e).createTextNode(r),e[ht]=t,t.stateNode=e}return Zc(t),null;case 31:if(n=t.memoizedState,e===null||e.memoizedState!==null){if(r=oa(t),n!==null){if(e===null){if(!r)throw Error(i(318));if(e=t.memoizedState,e=e===null?null:e.dehydrated,!e)throw Error(i(557));e[ht]=t}else sa(),!(t.flags&128)&&(t.memoizedState=null),t.flags|=4;Zc(t),e=!1}else n=ca(),e!==null&&e.memoizedState!==null&&(e.memoizedState.hydrationErrors=n),e=!0;if(!e)return t.flags&256?(xo(t),t):(xo(t),null);if(t.flags&128)throw Error(i(558))}return Zc(t),null;case 13:if(r=t.memoizedState,e===null||e.memoizedState!==null&&e.memoizedState.dehydrated!==null){if(a=oa(t),r!==null&&r.dehydrated!==null){if(e===null){if(!a)throw Error(i(318));if(a=t.memoizedState,a=a===null?null:a.dehydrated,!a)throw Error(i(317));a[ht]=t}else sa(),!(t.flags&128)&&(t.memoizedState=null),t.flags|=4;Zc(t),a=!1}else a=ca(),e!==null&&e.memoizedState!==null&&(e.memoizedState.hydrationErrors=a),a=!0;if(!a)return t.flags&256?(xo(t),t):(xo(t),null)}return xo(t),t.flags&128?(t.lanes=n,t):(n=r!==null,e=e!==null&&e.memoizedState!==null,n&&(r=t.child,a=null,r.alternate!==null&&r.alternate.memoizedState!==null&&r.alternate.memoizedState.cachePool!==null&&(a=r.alternate.memoizedState.cachePool.pool),o=null,r.memoizedState!==null&&r.memoizedState.cachePool!==null&&(o=r.memoizedState.cachePool.pool),o!==a&&(r.flags|=2048)),n!==e&&n&&(t.child.flags|=8192),Yc(t,t.updateQueue),Zc(t),null);case 4:return be(),e===null&&Wd(t.stateNode.containerInfo),Zc(t),null;case 10:return ma(t.type),Zc(t),null;case 19:if(O(So),r=t.memoizedState,r===null)return Zc(t),null;if(a=(t.flags&128)!=0,o=r.rendering,o===null)if(a)Xc(r,!1);else{if(cu!==0||e!==null&&e.flags&128)for(e=t.child;e!==null;){if(o=Co(e),o!==null){for(t.flags|=128,Xc(r,!1),e=o.updateQueue,t.updateQueue=e,Yc(t,e),t.subtreeFlags=0,e=n,n=t.child;n!==null;)Ai(n,e),n=n.sibling;return me(So,So.current&1|2),ea&&qi(t,r.treeForkCount),t.child}e=e.sibling}r.tail!==null&&Fe()>yu&&(t.flags|=128,a=!0,Xc(r,!1),t.lanes=4194304)}else{if(!a)if(e=Co(o),e!==null){if(t.flags|=128,a=!0,e=e.updateQueue,t.updateQueue=e,Yc(t,e),Xc(r,!0),r.tail===null&&r.tailMode===`hidden`&&!o.alternate&&!ea)return Zc(t),null}else 2*Fe()-r.renderingStartTime>yu&&n!==536870912&&(t.flags|=128,a=!0,Xc(r,!1),t.lanes=4194304);r.isBackwards?(o.sibling=t.child,t.child=o):(e=r.last,e===null?t.child=o:e.sibling=o,r.last=o)}return r.tail===null?(Zc(t),null):(e=r.tail,r.rendering=e,r.tail=e.sibling,r.renderingStartTime=Fe(),e.sibling=null,n=So.current,me(So,a?n&1|2:n&1),ea&&qi(t,r.treeForkCount),e);case 22:case 23:return xo(t),mo(),r=t.memoizedState!==null,e===null?r&&(t.flags|=8192):e.memoizedState!==null!==r&&(t.flags|=8192),r?n&536870912&&!(t.flags&128)&&(Zc(t),t.subtreeFlags&6&&(t.flags|=8192)):Zc(t),n=t.updateQueue,n!==null&&Yc(t,n.retryQueue),n=null,e!==null&&e.memoizedState!==null&&e.memoizedState.cachePool!==null&&(n=e.memoizedState.cachePool.pool),r=null,t.memoizedState!==null&&t.memoizedState.cachePool!==null&&(r=t.memoizedState.cachePool.pool),r!==n&&(t.flags|=2048),e!==null&&O(Fa),null;case 24:return n=null,e!==null&&(n=e.memoizedState.cache),t.memoizedState.cache!==n&&(t.flags|=2048),ma(Ta),Zc(t),null;case 25:return null;case 30:return null}throw Error(i(156,t.tag))}function $c(e,t){switch(Xi(t),t.tag){case 1:return e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 3:return ma(Ta),be(),e=t.flags,e&65536&&!(e&128)?(t.flags=e&-65537|128,t):null;case 26:case 27:case 5:return Se(t),null;case 31:if(t.memoizedState!==null){if(xo(t),t.alternate===null)throw Error(i(340));sa()}return e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 13:if(xo(t),e=t.memoizedState,e!==null&&e.dehydrated!==null){if(t.alternate===null)throw Error(i(340));sa()}return e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 19:return O(So),null;case 4:return be(),null;case 10:return ma(t.type),null;case 22:case 23:return xo(t),mo(),e!==null&&O(Fa),e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 24:return ma(Ta),null;case 25:return null;default:return null}}function el(e,t){switch(Xi(t),t.tag){case 3:ma(Ta),be();break;case 26:case 27:case 5:Se(t);break;case 4:be();break;case 31:t.memoizedState!==null&&xo(t);break;case 13:xo(t);break;case 19:O(So);break;case 10:ma(t.type);break;case 22:case 23:xo(t),mo(),e!==null&&O(Fa);break;case 24:ma(Ta)}}function tl(e,t){try{var n=t.updateQueue,r=n===null?null:n.lastEffect;if(r!==null){var i=r.next;n=i;do{if((n.tag&e)===e){r=void 0;var a=n.create,o=n.inst;r=a(),o.destroy=r}n=n.next}while(n!==i)}}catch(e){ld(t,t.return,e)}}function nl(e,t,n){try{var r=t.updateQueue,i=r===null?null:r.lastEffect;if(i!==null){var a=i.next;r=a;do{if((r.tag&e)===e){var o=r.inst,s=o.destroy;if(s!==void 0){o.destroy=void 0,i=t;var c=n,l=s;try{l()}catch(e){ld(i,c,e)}}}r=r.next}while(r!==a)}}catch(e){ld(t,t.return,e)}}function rl(e){var t=e.updateQueue;if(t!==null){var n=e.stateNode;try{R(t,n)}catch(t){ld(e,e.return,t)}}}function il(e,t,n){n.props=cc(e.type,e.memoizedProps),n.state=e.memoizedState;try{n.componentWillUnmount()}catch(n){ld(e,t,n)}}function al(e,t){try{var n=e.ref;if(n!==null){switch(e.tag){case 26:case 27:case 5:var r=e.stateNode;break;case 30:r=e.stateNode;break;default:r=e.stateNode}typeof n==`function`?e.refCleanup=n(r):n.current=r}}catch(n){ld(e,t,n)}}function ol(e,t){var n=e.ref,r=e.refCleanup;if(n!==null)if(typeof r==`function`)try{r()}catch(n){ld(e,t,n)}finally{e.refCleanup=null,e=e.alternate,e!=null&&(e.refCleanup=null)}else if(typeof n==`function`)try{n(null)}catch(n){ld(e,t,n)}else n.current=null}function sl(e){var t=e.type,n=e.memoizedProps,r=e.stateNode;try{a:switch(t){case`button`:case`input`:case`select`:case`textarea`:n.autoFocus&&r.focus();break a;case`img`:n.src?r.src=n.src:n.srcSet&&(r.srcset=n.srcSet)}}catch(t){ld(e,e.return,t)}}function cl(e,t,n){try{var r=e.stateNode;af(r,e.type,n,t),r[gt]=t}catch(t){ld(e,e.return,t)}}function ll(e){return e.tag===5||e.tag===3||e.tag===26||e.tag===27&&Sf(e.type)||e.tag===4}function ul(e){a:for(;;){for(;e.sibling===null;){if(e.return===null||ll(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;e.tag!==5&&e.tag!==6&&e.tag!==18;){if(e.tag===27&&Sf(e.type)||e.flags&2||e.child===null||e.tag===4)continue a;e.child.return=e,e=e.child}if(!(e.flags&2))return e.stateNode}}function dl(e,t,n){var r=e.tag;if(r===5||r===6)e=e.stateNode,t?(n.nodeType===9?n.body:n.nodeName===`HTML`?n.ownerDocument.body:n).insertBefore(e,t):(t=n.nodeType===9?n.body:n.nodeName===`HTML`?n.ownerDocument.body:n,t.appendChild(e),n=n._reactRootContainer,n!=null||t.onclick!==null||(t.onclick=ln));else if(r!==4&&(r===27&&Sf(e.type)&&(n=e.stateNode,t=null),e=e.child,e!==null))for(dl(e,t,n),e=e.sibling;e!==null;)dl(e,t,n),e=e.sibling}function fl(e,t,n){var r=e.tag;if(r===5||r===6)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(r!==4&&(r===27&&Sf(e.type)&&(n=e.stateNode),e=e.child,e!==null))for(fl(e,t,n),e=e.sibling;e!==null;)fl(e,t,n),e=e.sibling}function pl(e){var t=e.stateNode,n=e.memoizedProps;try{for(var r=e.type,i=t.attributes;i.length;)t.removeAttributeNode(i[0]);rf(t,r,n),t[ht]=e,t[gt]=n}catch(t){ld(e,e.return,t)}}var ml=!1,hl=!1,gl=!1,_l=typeof WeakSet==`function`?WeakSet:Set,vl=null;function yl(e,t){if(e=e.containerInfo,lf=Ap,e=qr(e),Jr(e)){if(`selectionStart`in e)var n={start:e.selectionStart,end:e.selectionEnd};else a:{n=(n=e.ownerDocument)&&n.defaultView||window;var r=n.getSelection&&n.getSelection();if(r&&r.rangeCount!==0){n=r.anchorNode;var a=r.anchorOffset,o=r.focusNode;r=r.focusOffset;try{n.nodeType,o.nodeType}catch{n=null;break a}var s=0,c=-1,l=-1,u=0,d=0,f=e,p=null;b:for(;;){for(var m;f!==n||a!==0&&f.nodeType!==3||(c=s+a),f!==o||r!==0&&f.nodeType!==3||(l=s+r),f.nodeType===3&&(s+=f.nodeValue.length),(m=f.firstChild)!==null;)p=f,f=m;for(;;){if(f===e)break b;if(p===n&&++u===a&&(c=s),p===o&&++d===r&&(l=s),(m=f.nextSibling)!==null)break;f=p,p=f.parentNode}f=m}n=c===-1||l===-1?null:{start:c,end:l}}else n=null}n||={start:0,end:0}}else n=null;for(uf={focusedElem:e,selectionRange:n},Ap=!1,vl=t;vl!==null;)if(t=vl,e=t.child,t.subtreeFlags&1028&&e!==null)e.return=t,vl=e;else for(;vl!==null;){switch(t=vl,o=t.alternate,e=t.flags,t.tag){case 0:if(e&4&&(e=t.updateQueue,e=e===null?null:e.events,e!==null))for(n=0;n<e.length;n++)a=e[n],a.ref.impl=a.nextImpl;break;case 11:case 15:break;case 1:if(e&1024&&o!==null){e=void 0,n=t,a=o.memoizedProps,o=o.memoizedState,r=n.stateNode;try{var h=cc(n.type,a);e=r.getSnapshotBeforeUpdate(h,o),r.__reactInternalSnapshotBeforeUpdate=e}catch(e){ld(n,n.return,e)}}break;case 3:if(e&1024){if(e=t.stateNode.containerInfo,n=e.nodeType,n===9)Tf(e);else if(n===1)switch(e.nodeName){case`HEAD`:case`HTML`:case`BODY`:Tf(e);break;default:e.textContent=``}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if(e&1024)throw Error(i(163))}if(e=t.sibling,e!==null){e.return=t.return,vl=e;break}vl=t.return}}function bl(e,t,n){var r=n.flags;switch(n.tag){case 0:case 11:case 15:Fl(e,n),r&4&&tl(5,n);break;case 1:if(Fl(e,n),r&4)if(e=n.stateNode,t===null)try{e.componentDidMount()}catch(e){ld(n,n.return,e)}else{var i=cc(n.type,t.memoizedProps);t=t.memoizedState;try{e.componentDidUpdate(i,t,e.__reactInternalSnapshotBeforeUpdate)}catch(e){ld(n,n.return,e)}}r&64&&rl(n),r&512&&al(n,n.return);break;case 3:if(Fl(e,n),r&64&&(e=n.updateQueue,e!==null)){if(t=null,n.child!==null)switch(n.child.tag){case 27:case 5:t=n.child.stateNode;break;case 1:t=n.child.stateNode}try{R(e,t)}catch(e){ld(n,n.return,e)}}break;case 27:t===null&&r&4&&pl(n);case 26:case 5:Fl(e,n),t===null&&r&4&&sl(n),r&512&&al(n,n.return);break;case 12:Fl(e,n);break;case 31:Fl(e,n),r&4&&El(e,n);break;case 13:Fl(e,n),r&4&&Dl(e,n),r&64&&(e=n.memoizedState,e!==null&&(e=e.dehydrated,e!==null&&(n=pd.bind(null,n),jf(e,n))));break;case 22:if(r=n.memoizedState!==null||ml,!r){t=t!==null&&t.memoizedState!==null||hl,i=ml;var a=hl;ml=r,(hl=t)&&!a?Ll(e,n,(n.subtreeFlags&8772)!=0):Fl(e,n),ml=i,hl=a}break;case 30:break;default:Fl(e,n)}}function xl(e){var t=e.alternate;t!==null&&(e.alternate=null,xl(t)),e.child=null,e.deletions=null,e.sibling=null,e.tag===5&&(t=e.stateNode,t!==null&&Ct(t)),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}var Sl=null,Cl=!1;function wl(e,t,n){for(n=n.child;n!==null;)Tl(e,t,n),n=n.sibling}function Tl(e,t,n){if(Ge&&typeof Ge.onCommitFiberUnmount==`function`)try{Ge.onCommitFiberUnmount(We,n)}catch{}switch(n.tag){case 26:hl||ol(n,t),wl(e,t,n),n.memoizedState?n.memoizedState.count--:n.stateNode&&(n=n.stateNode,n.parentNode.removeChild(n));break;case 27:hl||ol(n,t);var r=Sl,i=Cl;Sf(n.type)&&(Sl=n.stateNode,Cl=!1),wl(e,t,n),Lf(n.stateNode),Sl=r,Cl=i;break;case 5:hl||ol(n,t);case 6:if(r=Sl,i=Cl,Sl=null,wl(e,t,n),Sl=r,Cl=i,Sl!==null)if(Cl)try{(Sl.nodeType===9?Sl.body:Sl.nodeName===`HTML`?Sl.ownerDocument.body:Sl).removeChild(n.stateNode)}catch(e){ld(n,t,e)}else try{Sl.removeChild(n.stateNode)}catch(e){ld(n,t,e)}break;case 18:Sl!==null&&(Cl?(e=Sl,Cf(e.nodeType===9?e.body:e.nodeName===`HTML`?e.ownerDocument.body:e,n.stateNode),nm(e)):Cf(Sl,n.stateNode));break;case 4:r=Sl,i=Cl,Sl=n.stateNode.containerInfo,Cl=!0,wl(e,t,n),Sl=r,Cl=i;break;case 0:case 11:case 14:case 15:nl(2,n,t),hl||nl(4,n,t),wl(e,t,n);break;case 1:hl||(ol(n,t),r=n.stateNode,typeof r.componentWillUnmount==`function`&&il(n,t,r)),wl(e,t,n);break;case 21:wl(e,t,n);break;case 22:hl=(r=hl)||n.memoizedState!==null,wl(e,t,n),hl=r;break;default:wl(e,t,n)}}function El(e,t){if(t.memoizedState===null&&(e=t.alternate,e!==null&&(e=e.memoizedState,e!==null))){e=e.dehydrated;try{nm(e)}catch(e){ld(t,t.return,e)}}}function Dl(e,t){if(t.memoizedState===null&&(e=t.alternate,e!==null&&(e=e.memoizedState,e!==null&&(e=e.dehydrated,e!==null))))try{nm(e)}catch(e){ld(t,t.return,e)}}function Ol(e){switch(e.tag){case 31:case 13:case 19:var t=e.stateNode;return t===null&&(t=e.stateNode=new _l),t;case 22:return e=e.stateNode,t=e._retryCache,t===null&&(t=e._retryCache=new _l),t;default:throw Error(i(435,e.tag))}}function kl(e,t){var n=Ol(e);t.forEach(function(t){if(!n.has(t)){n.add(t);var r=md.bind(null,e,t);t.then(r,r)}})}function Al(e,t){var n=t.deletions;if(n!==null)for(var r=0;r<n.length;r++){var a=n[r],o=e,s=t,c=s;a:for(;c!==null;){switch(c.tag){case 27:if(Sf(c.type)){Sl=c.stateNode,Cl=!1;break a}break;case 5:Sl=c.stateNode,Cl=!1;break a;case 3:case 4:Sl=c.stateNode.containerInfo,Cl=!0;break a}c=c.return}if(Sl===null)throw Error(i(160));Tl(o,s,a),Sl=null,Cl=!1,o=a.alternate,o!==null&&(o.return=null),a.return=null}if(t.subtreeFlags&13886)for(t=t.child;t!==null;)Ml(t,e),t=t.sibling}var jl=null;function Ml(e,t){var n=e.alternate,r=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:Al(t,e),Nl(e),r&4&&(nl(3,e,e.return),tl(3,e),nl(5,e,e.return));break;case 1:Al(t,e),Nl(e),r&512&&(hl||n===null||ol(n,n.return)),r&64&&ml&&(e=e.updateQueue,e!==null&&(r=e.callbacks,r!==null&&(n=e.shared.hiddenCallbacks,e.shared.hiddenCallbacks=n===null?r:n.concat(r))));break;case 26:var a=jl;if(Al(t,e),Nl(e),r&512&&(hl||n===null||ol(n,n.return)),r&4){var o=n===null?null:n.memoizedState;if(r=e.memoizedState,n===null)if(r===null)if(e.stateNode===null){a:{r=e.type,n=e.memoizedProps,a=a.ownerDocument||a;b:switch(r){case`title`:o=a.getElementsByTagName(`title`)[0],(!o||o[St]||o[ht]||o.namespaceURI===`http://www.w3.org/2000/svg`||o.hasAttribute(`itemprop`))&&(o=a.createElement(r),a.head.insertBefore(o,a.querySelector(`head > title`))),rf(o,r,n),o[ht]=e,Ot(o),r=o;break a;case`link`:var s=up(`link`,`href`,a).get(r+(n.href||``));if(s){for(var c=0;c<s.length;c++)if(o=s[c],o.getAttribute(`href`)===(n.href==null||n.href===``?null:n.href)&&o.getAttribute(`rel`)===(n.rel==null?null:n.rel)&&o.getAttribute(`title`)===(n.title==null?null:n.title)&&o.getAttribute(`crossorigin`)===(n.crossOrigin==null?null:n.crossOrigin)){s.splice(c,1);break b}}o=a.createElement(r),rf(o,r,n),a.head.appendChild(o);break;case`meta`:if(s=up(`meta`,`content`,a).get(r+(n.content||``))){for(c=0;c<s.length;c++)if(o=s[c],o.getAttribute(`content`)===(n.content==null?null:``+n.content)&&o.getAttribute(`name`)===(n.name==null?null:n.name)&&o.getAttribute(`property`)===(n.property==null?null:n.property)&&o.getAttribute(`http-equiv`)===(n.httpEquiv==null?null:n.httpEquiv)&&o.getAttribute(`charset`)===(n.charSet==null?null:n.charSet)){s.splice(c,1);break b}}o=a.createElement(r),rf(o,r,n),a.head.appendChild(o);break;default:throw Error(i(468,r))}o[ht]=e,Ot(o),r=o}e.stateNode=r}else dp(a,e.type,e.stateNode);else e.stateNode=K(a,r,e.memoizedProps);else o===r?r===null&&e.stateNode!==null&&cl(e,e.memoizedProps,n.memoizedProps):(o===null?n.stateNode!==null&&(n=n.stateNode,n.parentNode.removeChild(n)):o.count--,r===null?dp(a,e.type,e.stateNode):K(a,r,e.memoizedProps))}break;case 27:Al(t,e),Nl(e),r&512&&(hl||n===null||ol(n,n.return)),n!==null&&r&4&&cl(e,e.memoizedProps,n.memoizedProps);break;case 5:if(Al(t,e),Nl(e),r&512&&(hl||n===null||ol(n,n.return)),e.flags&32){a=e.stateNode;try{en(a,``)}catch(t){ld(e,e.return,t)}}r&4&&e.stateNode!=null&&(a=e.memoizedProps,cl(e,a,n===null?a:n.memoizedProps)),r&1024&&(gl=!0);break;case 6:if(Al(t,e),Nl(e),r&4){if(e.stateNode===null)throw Error(i(162));r=e.memoizedProps,n=e.stateNode;try{n.nodeValue=r}catch(t){ld(e,e.return,t)}}break;case 3:if(lp=null,a=jl,jl=Bf(t.containerInfo),Al(t,e),jl=a,Nl(e),r&4&&n!==null&&n.memoizedState.isDehydrated)try{nm(t.containerInfo)}catch(t){ld(e,e.return,t)}gl&&(gl=!1,Pl(e));break;case 4:r=jl,jl=Bf(e.stateNode.containerInfo),Al(t,e),Nl(e),jl=r;break;case 12:Al(t,e),Nl(e);break;case 31:Al(t,e),Nl(e),r&4&&(r=e.updateQueue,r!==null&&(e.updateQueue=null,kl(e,r)));break;case 13:Al(t,e),Nl(e),e.child.flags&8192&&e.memoizedState!==null!=(n!==null&&n.memoizedState!==null)&&(_u=Fe()),r&4&&(r=e.updateQueue,r!==null&&(e.updateQueue=null,kl(e,r)));break;case 22:a=e.memoizedState!==null;var l=n!==null&&n.memoizedState!==null,u=ml,d=hl;if(ml=u||a,hl=d||l,Al(t,e),hl=d,ml=u,Nl(e),r&8192)a:for(t=e.stateNode,t._visibility=a?t._visibility&-2:t._visibility|1,a&&(n===null||l||ml||hl||Il(e)),n=null,t=e;;){if(t.tag===5||t.tag===26){if(n===null){l=n=t;try{if(o=l.stateNode,a)s=o.style,typeof s.setProperty==`function`?s.setProperty(`display`,`none`,`important`):s.display=`none`;else{c=l.stateNode;var f=l.memoizedProps.style,p=f!=null&&f.hasOwnProperty(`display`)?f.display:null;c.style.display=p==null||typeof p==`boolean`?``:(``+p).trim()}}catch(e){ld(l,l.return,e)}}}else if(t.tag===6){if(n===null){l=t;try{l.stateNode.nodeValue=a?``:l.memoizedProps}catch(e){ld(l,l.return,e)}}}else if(t.tag===18){if(n===null){l=t;try{var m=l.stateNode;a?wf(m,!0):wf(l.stateNode,!1)}catch(e){ld(l,l.return,e)}}}else if((t.tag!==22&&t.tag!==23||t.memoizedState===null||t===e)&&t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break a;for(;t.sibling===null;){if(t.return===null||t.return===e)break a;n===t&&(n=null),t=t.return}n===t&&(n=null),t.sibling.return=t.return,t=t.sibling}r&4&&(r=e.updateQueue,r!==null&&(n=r.retryQueue,n!==null&&(r.retryQueue=null,kl(e,n))));break;case 19:Al(t,e),Nl(e),r&4&&(r=e.updateQueue,r!==null&&(e.updateQueue=null,kl(e,r)));break;case 30:break;case 21:break;default:Al(t,e),Nl(e)}}function Nl(e){var t=e.flags;if(t&2){try{for(var n,r=e.return;r!==null;){if(ll(r)){n=r;break}r=r.return}if(n==null)throw Error(i(160));switch(n.tag){case 27:var a=n.stateNode,o=ul(e);fl(e,o,a);break;case 5:var s=n.stateNode;n.flags&32&&(en(s,``),n.flags&=-33);var c=ul(e);fl(e,c,s);break;case 3:case 4:var l=n.stateNode.containerInfo,u=ul(e);dl(e,u,l);break;default:throw Error(i(161))}}catch(t){ld(e,e.return,t)}e.flags&=-3}t&4096&&(e.flags&=-4097)}function Pl(e){if(e.subtreeFlags&1024)for(e=e.child;e!==null;){var t=e;Pl(t),t.tag===5&&t.flags&1024&&t.stateNode.reset(),e=e.sibling}}function Fl(e,t){if(t.subtreeFlags&8772)for(t=t.child;t!==null;)bl(e,t.alternate,t),t=t.sibling}function Il(e){for(e=e.child;e!==null;){var t=e;switch(t.tag){case 0:case 11:case 14:case 15:nl(4,t,t.return),Il(t);break;case 1:ol(t,t.return);var n=t.stateNode;typeof n.componentWillUnmount==`function`&&il(t,t.return,n),Il(t);break;case 27:Lf(t.stateNode);case 26:case 5:ol(t,t.return),Il(t);break;case 22:t.memoizedState===null&&Il(t);break;case 30:Il(t);break;default:Il(t)}e=e.sibling}}function Ll(e,t,n){for(n&&=(t.subtreeFlags&8772)!=0,t=t.child;t!==null;){var r=t.alternate,i=e,a=t,o=a.flags;switch(a.tag){case 0:case 11:case 15:Ll(i,a,n),tl(4,a);break;case 1:if(Ll(i,a,n),r=a,i=r.stateNode,typeof i.componentDidMount==`function`)try{i.componentDidMount()}catch(e){ld(r,r.return,e)}if(r=a,i=r.updateQueue,i!==null){var s=r.stateNode;try{var c=i.shared.hiddenCallbacks;if(c!==null)for(i.shared.hiddenCallbacks=null,i=0;i<c.length;i++)L(c[i],s)}catch(e){ld(r,r.return,e)}}n&&o&64&&rl(a),al(a,a.return);break;case 27:pl(a);case 26:case 5:Ll(i,a,n),n&&r===null&&o&4&&sl(a),al(a,a.return);break;case 12:Ll(i,a,n);break;case 31:Ll(i,a,n),n&&o&4&&El(i,a);break;case 13:Ll(i,a,n),n&&o&4&&Dl(i,a);break;case 22:a.memoizedState===null&&Ll(i,a,n),al(a,a.return);break;case 30:break;default:Ll(i,a,n)}t=t.sibling}}function Rl(e,t){var n=null;e!==null&&e.memoizedState!==null&&e.memoizedState.cachePool!==null&&(n=e.memoizedState.cachePool.pool),e=null,t.memoizedState!==null&&t.memoizedState.cachePool!==null&&(e=t.memoizedState.cachePool.pool),e!==n&&(e!=null&&e.refCount++,n!=null&&Ea(n))}function zl(e,t){e=null,t.alternate!==null&&(e=t.alternate.memoizedState.cache),t=t.memoizedState.cache,t!==e&&(t.refCount++,e!=null&&Ea(e))}function W(e,t,n,r){if(t.subtreeFlags&10256)for(t=t.child;t!==null;)G(e,t,n,r),t=t.sibling}function G(e,t,n,r){var i=t.flags;switch(t.tag){case 0:case 11:case 15:W(e,t,n,r),i&2048&&tl(9,t);break;case 1:W(e,t,n,r);break;case 3:W(e,t,n,r),i&2048&&(e=null,t.alternate!==null&&(e=t.alternate.memoizedState.cache),t=t.memoizedState.cache,t!==e&&(t.refCount++,e!=null&&Ea(e)));break;case 12:if(i&2048){W(e,t,n,r),e=t.stateNode;try{var a=t.memoizedProps,o=a.id,s=a.onPostCommit;typeof s==`function`&&s(o,t.alternate===null?`mount`:`update`,e.passiveEffectDuration,-0)}catch(e){ld(t,t.return,e)}}else W(e,t,n,r);break;case 31:W(e,t,n,r);break;case 13:W(e,t,n,r);break;case 23:break;case 22:a=t.stateNode,o=t.alternate,t.memoizedState===null?a._visibility&2?W(e,t,n,r):(a._visibility|=2,Bl(e,t,n,r,(t.subtreeFlags&10256)!=0||!1)):a._visibility&2?W(e,t,n,r):Vl(e,t),i&2048&&Rl(o,t);break;case 24:W(e,t,n,r),i&2048&&zl(t.alternate,t);break;default:W(e,t,n,r)}}function Bl(e,t,n,r,i){for(i&&=(t.subtreeFlags&10256)!=0||!1,t=t.child;t!==null;){var a=e,o=t,s=n,c=r,l=o.flags;switch(o.tag){case 0:case 11:case 15:Bl(a,o,s,c,i),tl(8,o);break;case 23:break;case 22:var u=o.stateNode;o.memoizedState===null?(u._visibility|=2,Bl(a,o,s,c,i)):u._visibility&2?Bl(a,o,s,c,i):Vl(a,o),i&&l&2048&&Rl(o.alternate,o);break;case 24:Bl(a,o,s,c,i),i&&l&2048&&zl(o.alternate,o);break;default:Bl(a,o,s,c,i)}t=t.sibling}}function Vl(e,t){if(t.subtreeFlags&10256)for(t=t.child;t!==null;){var n=e,r=t,i=r.flags;switch(r.tag){case 22:Vl(n,r),i&2048&&Rl(r.alternate,r);break;case 24:Vl(n,r),i&2048&&zl(r.alternate,r);break;default:Vl(n,r)}t=t.sibling}}var Hl=8192;function Ul(e,t,n){if(e.subtreeFlags&Hl)for(e=e.child;e!==null;)Wl(e,t,n),e=e.sibling}function Wl(e,t,n){switch(e.tag){case 26:Ul(e,t,n),e.flags&Hl&&e.memoizedState!==null&&mp(n,jl,e.memoizedState,e.memoizedProps);break;case 5:Ul(e,t,n);break;case 3:case 4:var r=jl;jl=Bf(e.stateNode.containerInfo),Ul(e,t,n),jl=r;break;case 22:e.memoizedState===null&&(r=e.alternate,r!==null&&r.memoizedState!==null?(r=Hl,Hl=16777216,Ul(e,t,n),Hl=r):Ul(e,t,n));break;default:Ul(e,t,n)}}function Gl(e){var t=e.alternate;if(t!==null&&(e=t.child,e!==null)){t.child=null;do t=e.sibling,e.sibling=null,e=t;while(e!==null)}}function Kl(e){var t=e.deletions;if(e.flags&16){if(t!==null)for(var n=0;n<t.length;n++){var r=t[n];vl=r,Yl(r,e)}Gl(e)}if(e.subtreeFlags&10256)for(e=e.child;e!==null;)ql(e),e=e.sibling}function ql(e){switch(e.tag){case 0:case 11:case 15:Kl(e),e.flags&2048&&nl(9,e,e.return);break;case 3:Kl(e);break;case 12:Kl(e);break;case 22:var t=e.stateNode;e.memoizedState!==null&&t._visibility&2&&(e.return===null||e.return.tag!==13)?(t._visibility&=-3,Jl(e)):Kl(e);break;default:Kl(e)}}function Jl(e){var t=e.deletions;if(e.flags&16){if(t!==null)for(var n=0;n<t.length;n++){var r=t[n];vl=r,Yl(r,e)}Gl(e)}for(e=e.child;e!==null;){switch(t=e,t.tag){case 0:case 11:case 15:nl(8,t,t.return),Jl(t);break;case 22:n=t.stateNode,n._visibility&2&&(n._visibility&=-3,Jl(t));break;default:Jl(t)}e=e.sibling}}function Yl(e,t){for(;vl!==null;){var n=vl;switch(n.tag){case 0:case 11:case 15:nl(8,n,t);break;case 23:case 22:if(n.memoizedState!==null&&n.memoizedState.cachePool!==null){var r=n.memoizedState.cachePool.pool;r!=null&&r.refCount++}break;case 24:Ea(n.memoizedState.cache)}if(r=n.child,r!==null)r.return=n,vl=r;else a:for(n=e;vl!==null;){r=vl;var i=r.sibling,a=r.return;if(xl(r),r===n){vl=null;break a}if(i!==null){i.return=a,vl=i;break a}vl=a}}}var Xl={getCacheForType:function(e){var t=ba(Ta),n=t.data.get(e);return n===void 0&&(n=e(),t.data.set(e,n)),n},cacheSignal:function(){return ba(Ta).controller.signal}},Zl=typeof WeakMap==`function`?WeakMap:Map,Ql=0,$l=null,eu=null,tu=0,nu=0,ru=null,iu=!1,au=!1,ou=!1,su=0,cu=0,lu=0,uu=0,du=0,fu=0,pu=0,mu=null,hu=null,gu=!1,_u=0,vu=0,yu=1/0,bu=null,xu=null,Su=0,Cu=null,wu=null,Tu=0,Eu=0,Du=null,Ou=null,ku=0,Au=null;function ju(){return Ql&2&&tu!==0?tu&-tu:le.T===null?ft():Ad()}function Mu(){if(fu===0)if(!(tu&536870912)||ea){var e=Qe;Qe<<=1,!(Qe&3932160)&&(Qe=262144),fu=e}else fu=536870912;return e=ho.current,e!==null&&(e.flags|=32),fu}function Nu(e,t,n){(e===$l&&(nu===2||nu===9)||e.cancelPendingCommit!==null)&&(Bu(e,0),Lu(e,tu,fu,!1)),at(e,n),(!(Ql&2)||e!==$l)&&(e===$l&&(!(Ql&2)&&(uu|=n),cu===4&&Lu(e,tu,fu,!1)),Sd(e))}function Pu(e,t,n){if(Ql&6)throw Error(i(327));var r=!n&&(t&127)==0&&(t&e.expiredLanes)===0||tt(e,t),a=r?Ju(e,t):Ku(e,t,!0),o=r;do{if(a===0){au&&!r&&Lu(e,t,0,!1);break}else{if(n=e.current.alternate,o&&!Iu(n)){a=Ku(e,t,!1),o=!1;continue}if(a===2){if(o=t,e.errorRecoveryDisabledLanes&o)var s=0;else s=e.pendingLanes&-536870913,s=s===0?s&536870912?536870912:0:s;if(s!==0){t=s;a:{var c=e;a=mu;var l=c.current.memoizedState.isDehydrated;if(l&&(Bu(c,s).flags|=256),s=Ku(c,s,!1),s!==2){if(ou&&!l){c.errorRecoveryDisabledLanes|=o,uu|=o,a=4;break a}o=hu,hu=a,o!==null&&(hu===null?hu=o:hu.push.apply(hu,o))}a=s}if(o=!1,a!==2)continue}}if(a===1){Bu(e,0),Lu(e,t,0,!0);break}a:{switch(r=e,o=a,o){case 0:case 1:throw Error(i(345));case 4:if((t&4194048)!==t)break;case 6:Lu(r,t,fu,!iu);break a;case 2:hu=null;break;case 3:case 5:break;default:throw Error(i(329))}if((t&62914560)===t&&(a=_u+300-Fe(),10<a)){if(Lu(r,t,fu,!iu),et(r,0,!0)!==0)break a;Tu=t,r.timeoutHandle=_f(Fu.bind(null,r,n,hu,bu,gu,t,fu,uu,pu,iu,o,`Throttled`,-0,0),a);break a}Fu(r,n,hu,bu,gu,t,fu,uu,pu,iu,o,null,-0,0)}}break}while(1);Sd(e)}function Fu(e,t,n,r,i,a,o,s,c,l,u,d,f,p){if(e.timeoutHandle=-1,d=t.subtreeFlags,d&8192||(d&16785408)==16785408){d={stylesheets:null,count:0,imgCount:0,imgBytes:0,suspenseyImages:[],waitingForImages:!0,waitingForViewTransition:!1,unsuspend:ln},Wl(t,a,d);var m=(a&62914560)===a?_u-Fe():(a&4194048)===a?vu-Fe():0;if(m=gp(d,m),m!==null){Tu=a,e.cancelPendingCommit=m(td.bind(null,e,t,a,n,r,i,o,s,c,u,d,null,f,p)),Lu(e,a,o,!l);return}}td(e,t,a,n,r,i,o,s,c)}function Iu(e){for(var t=e;;){var n=t.tag;if((n===0||n===11||n===15)&&t.flags&16384&&(n=t.updateQueue,n!==null&&(n=n.stores,n!==null)))for(var r=0;r<n.length;r++){var i=n[r],a=i.getSnapshot;i=i.value;try{if(!Hr(a(),i))return!1}catch{return!1}}if(n=t.child,t.subtreeFlags&16384&&n!==null)n.return=t,t=n;else{if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}function Lu(e,t,n,r){t&=~du,t&=~uu,e.suspendedLanes|=t,e.pingedLanes&=~t,r&&(e.warmLanes|=t),r=e.expirationTimes;for(var i=t;0<i;){var a=31-qe(i),o=1<<a;r[a]=-1,i&=~o}n!==0&&st(e,n,t)}function Ru(){return Ql&6?!0:(Cd(0,!1),!1)}function zu(){if(eu!==null){if(nu===0)var e=eu.return;else e=eu,fa=da=null,Ho(e),Ya=null,Xa=0,e=eu;for(;e!==null;)el(e.alternate,e),e=e.return;eu=null}}function Bu(e,t){var n=e.timeoutHandle;n!==-1&&(e.timeoutHandle=-1,vf(n)),n=e.cancelPendingCommit,n!==null&&(e.cancelPendingCommit=null,n()),Tu=0,zu(),$l=e,eu=n=ki(e.current,null),tu=t,nu=0,ru=null,iu=!1,au=tt(e,t),ou=!1,pu=fu=du=uu=lu=cu=0,hu=mu=null,gu=!1,t&8&&(t|=t&32);var r=e.entangledLanes;if(r!==0)for(e=e.entanglements,r&=t;0<r;){var i=31-qe(r),a=1<<i;t|=e[i],r&=~a}return su=t,yi(),n}function Vu(e,t){To=null,le.H=ec,t===za||t===Va?(t=qa(),nu=3):t===Ba?(t=qa(),nu=4):nu=t===_c?8:typeof t==`object`&&t&&typeof t.then==`function`?6:1,ru=t,eu===null&&(cu=1,fc(e,Li(t,e.current)))}function Hu(){var e=ho.current;return e===null?!0:(tu&4194048)===tu?go===null:(tu&62914560)===tu||tu&536870912?e===go:!1}function Uu(){var e=le.H;return le.H=ec,e===null?ec:e}function Wu(){var e=le.A;return le.A=Xl,e}function Gu(){cu=4,iu||(tu&4194048)!==tu&&ho.current!==null||(au=!0),!(lu&134217727)&&!(uu&134217727)||$l===null||Lu($l,tu,fu,!1)}function Ku(e,t,n){var r=Ql;Ql|=2;var i=Uu(),a=Wu();($l!==e||tu!==t)&&(bu=null,Bu(e,t)),t=!1;var o=cu;a:do try{if(nu!==0&&eu!==null){var s=eu,c=ru;switch(nu){case 8:zu(),o=6;break a;case 3:case 2:case 9:case 6:ho.current===null&&(t=!0);var l=nu;if(nu=0,ru=null,Qu(e,s,c,l),n&&au){o=0;break a}break;default:l=nu,nu=0,ru=null,Qu(e,s,c,l)}}qu(),o=cu;break}catch(t){Vu(e,t)}while(1);return t&&e.shellSuspendCounter++,fa=da=null,Ql=r,le.H=i,le.A=a,eu===null&&($l=null,tu=0,yi()),o}function qu(){for(;eu!==null;)Xu(eu)}function Ju(e,t){var n=Ql;Ql|=2;var r=Uu(),a=Wu();$l!==e||tu!==t?(bu=null,yu=Fe()+500,Bu(e,t)):au=tt(e,t);a:do try{if(nu!==0&&eu!==null){t=eu;var o=ru;b:switch(nu){case 1:nu=0,ru=null,Qu(e,t,o,1);break;case 2:case 9:if(Ua(o)){nu=0,ru=null,Zu(t);break}t=function(){nu!==2&&nu!==9||$l!==e||(nu=7),Sd(e)},o.then(t,t);break a;case 3:nu=7;break a;case 4:nu=5;break a;case 7:Ua(o)?(nu=0,ru=null,Zu(t)):(nu=0,ru=null,Qu(e,t,o,7));break;case 5:var s=null;switch(eu.tag){case 26:s=eu.memoizedState;case 5:case 27:var c=eu;if(s?pp(s):c.stateNode.complete){nu=0,ru=null;var l=c.sibling;if(l!==null)eu=l;else{var u=c.return;u===null?eu=null:(eu=u,$u(u))}break b}}nu=0,ru=null,Qu(e,t,o,5);break;case 6:nu=0,ru=null,Qu(e,t,o,6);break;case 8:zu(),cu=6;break a;default:throw Error(i(462))}}Yu();break}catch(t){Vu(e,t)}while(1);return fa=da=null,le.H=r,le.A=a,Ql=n,eu===null?($l=null,tu=0,yi(),cu):0}function Yu(){for(;eu!==null&&!Ne();)Xu(eu)}function Xu(e){var t=Gc(e.alternate,e,su);e.memoizedProps=e.pendingProps,t===null?$u(e):eu=t}function Zu(e){var t=e,n=t.alternate;switch(t.tag){case 15:case 0:t=Ac(n,t,t.pendingProps,t.type,void 0,tu);break;case 11:t=Ac(n,t,t.pendingProps,t.type.render,t.ref,tu);break;case 5:Ho(t);default:el(n,t),t=eu=Ai(t,su),t=Gc(n,t,su)}e.memoizedProps=e.pendingProps,t===null?$u(e):eu=t}function Qu(e,t,n,r){fa=da=null,Ho(t),Ya=null,Xa=0;var i=t.return;try{if(V(e,i,t,n,tu)){cu=1,fc(e,Li(n,e.current)),eu=null;return}}catch(t){if(i!==null)throw eu=i,t;cu=1,fc(e,Li(n,e.current)),eu=null;return}t.flags&32768?(ea||r===1?e=!0:au||tu&536870912?e=!1:(iu=e=!0,(r===2||r===9||r===3||r===6)&&(r=ho.current,r!==null&&r.tag===13&&(r.flags|=16384))),ed(t,e)):$u(t)}function $u(e){var t=e;do{if(t.flags&32768){ed(t,iu);return}e=t.return;var n=Qc(t.alternate,t,su);if(n!==null){eu=n;return}if(t=t.sibling,t!==null){eu=t;return}eu=t=e}while(t!==null);cu===0&&(cu=5)}function ed(e,t){do{var n=$c(e.alternate,e);if(n!==null){n.flags&=32767,eu=n;return}if(n=e.return,n!==null&&(n.flags|=32768,n.subtreeFlags=0,n.deletions=null),!t&&(e=e.sibling,e!==null)){eu=e;return}eu=e=n}while(e!==null);cu=6,eu=null}function td(e,t,n,r,a,o,s,c,l){e.cancelPendingCommit=null;do od();while(Su!==0);if(Ql&6)throw Error(i(327));if(t!==null){if(t===e.current)throw Error(i(177));if(o=t.lanes|t.childLanes,o|=vi,ot(e,n,o,s,c,l),e===$l&&(eu=$l=null,tu=0),wu=t,Cu=e,Tu=n,Eu=o,Du=a,Ou=r,t.subtreeFlags&10256||t.flags&10256?(e.callbackNode=null,e.callbackPriority=0,hd(ze,function(){return sd(),null})):(e.callbackNode=null,e.callbackPriority=0),r=(t.flags&13878)!=0,t.subtreeFlags&13878||r){r=le.T,le.T=null,a=ue.p,ue.p=2,s=Ql,Ql|=4;try{yl(e,t,n)}finally{Ql=s,ue.p=a,le.T=r}}Su=1,nd(),rd(),id()}}function nd(){if(Su===1){Su=0;var e=Cu,t=wu,n=(t.flags&13878)!=0;if(t.subtreeFlags&13878||n){n=le.T,le.T=null;var r=ue.p;ue.p=2;var i=Ql;Ql|=4;try{Ml(t,e);var a=uf,o=qr(e.containerInfo),s=a.focusedElem,c=a.selectionRange;if(o!==s&&s&&s.ownerDocument&&Kr(s.ownerDocument.documentElement,s)){if(c!==null&&Jr(s)){var l=c.start,u=c.end;if(u===void 0&&(u=l),`selectionStart`in s)s.selectionStart=l,s.selectionEnd=Math.min(u,s.value.length);else{var d=s.ownerDocument||document,f=d&&d.defaultView||window;if(f.getSelection){var p=f.getSelection(),m=s.textContent.length,h=Math.min(c.start,m),g=c.end===void 0?h:Math.min(c.end,m);!p.extend&&h>g&&(o=g,g=h,h=o);var _=Gr(s,h),v=Gr(s,g);if(_&&v&&(p.rangeCount!==1||p.anchorNode!==_.node||p.anchorOffset!==_.offset||p.focusNode!==v.node||p.focusOffset!==v.offset)){var y=d.createRange();y.setStart(_.node,_.offset),p.removeAllRanges(),h>g?(p.addRange(y),p.extend(v.node,v.offset)):(y.setEnd(v.node,v.offset),p.addRange(y))}}}}for(d=[],p=s;p=p.parentNode;)p.nodeType===1&&d.push({element:p,left:p.scrollLeft,top:p.scrollTop});for(typeof s.focus==`function`&&s.focus(),s=0;s<d.length;s++){var b=d[s];b.element.scrollLeft=b.left,b.element.scrollTop=b.top}}Ap=!!lf,uf=lf=null}finally{Ql=i,ue.p=r,le.T=n}}e.current=t,Su=2}}function rd(){if(Su===2){Su=0;var e=Cu,t=wu,n=(t.flags&8772)!=0;if(t.subtreeFlags&8772||n){n=le.T,le.T=null;var r=ue.p;ue.p=2;var i=Ql;Ql|=4;try{bl(e,t.alternate,t)}finally{Ql=i,ue.p=r,le.T=n}}Su=3}}function id(){if(Su===4||Su===3){Su=0,Pe();var e=Cu,t=wu,n=Tu,r=Ou;t.subtreeFlags&10256||t.flags&10256?Su=5:(Su=0,wu=Cu=null,ad(e,e.pendingLanes));var i=e.pendingLanes;if(i===0&&(xu=null),dt(n),t=t.stateNode,Ge&&typeof Ge.onCommitFiberRoot==`function`)try{Ge.onCommitFiberRoot(We,t,void 0,(t.current.flags&128)==128)}catch{}if(r!==null){t=le.T,i=ue.p,ue.p=2,le.T=null;try{for(var a=e.onRecoverableError,o=0;o<r.length;o++){var s=r[o];a(s.value,{componentStack:s.stack})}}finally{le.T=t,ue.p=i}}Tu&3&&od(),Sd(e),i=e.pendingLanes,n&261930&&i&42?e===Au?ku++:(ku=0,Au=e):ku=0,Cd(0,!1)}}function ad(e,t){(e.pooledCacheLanes&=t)===0&&(t=e.pooledCache,t!=null&&(e.pooledCache=null,Ea(t)))}function od(){return nd(),rd(),id(),sd()}function sd(){if(Su!==5)return!1;var e=Cu,t=Eu;Eu=0;var n=dt(Tu),r=le.T,a=ue.p;try{ue.p=32>n?32:n,le.T=null,n=Du,Du=null;var o=Cu,s=Tu;if(Su=0,wu=Cu=null,Tu=0,Ql&6)throw Error(i(331));var c=Ql;if(Ql|=4,ql(o.current),G(o,o.current,s,n),Ql=c,Cd(0,!1),Ge&&typeof Ge.onPostCommitFiberRoot==`function`)try{Ge.onPostCommitFiberRoot(We,o)}catch{}return!0}finally{ue.p=a,le.T=r,ad(e,t)}}function cd(e,t,n){t=Li(n,t),t=mc(e.stateNode,t,2),e=ao(e,t,2),e!==null&&(at(e,2),Sd(e))}function ld(e,t,n){if(e.tag===3)cd(e,e,n);else for(;t!==null;){if(t.tag===3){cd(t,e,n);break}else if(t.tag===1){var r=t.stateNode;if(typeof t.type.getDerivedStateFromError==`function`||typeof r.componentDidCatch==`function`&&(xu===null||!xu.has(r))){e=Li(n,e),n=hc(2),r=ao(t,n,2),r!==null&&(gc(n,r,t,e),at(r,2),Sd(r));break}}t=t.return}}function ud(e,t,n){var r=e.pingCache;if(r===null){r=e.pingCache=new Zl;var i=new Set;r.set(t,i)}else i=r.get(t),i===void 0&&(i=new Set,r.set(t,i));i.has(n)||(ou=!0,i.add(n),e=dd.bind(null,e,t,n),t.then(e,e))}function dd(e,t,n){var r=e.pingCache;r!==null&&r.delete(t),e.pingedLanes|=e.suspendedLanes&n,e.warmLanes&=~n,$l===e&&(tu&n)===n&&(cu===4||cu===3&&(tu&62914560)===tu&&300>Fe()-_u?!(Ql&2)&&Bu(e,0):du|=n,pu===tu&&(pu=0)),Sd(e)}function fd(e,t){t===0&&(t=rt()),e=Si(e,t),e!==null&&(at(e,t),Sd(e))}function pd(e){var t=e.memoizedState,n=0;t!==null&&(n=t.retryLane),fd(e,n)}function md(e,t){var n=0;switch(e.tag){case 31:case 13:var r=e.stateNode,a=e.memoizedState;a!==null&&(n=a.retryLane);break;case 19:r=e.stateNode;break;case 22:r=e.stateNode._retryCache;break;default:throw Error(i(314))}r!==null&&r.delete(t),fd(e,n)}function hd(e,t){return je(e,t)}var gd=null,_d=null,vd=!1,yd=!1,bd=!1,xd=0;function Sd(e){e!==_d&&e.next===null&&(_d===null?gd=_d=e:_d=_d.next=e),yd=!0,vd||(vd=!0,kd())}function Cd(e,t){if(!bd&&yd){bd=!0;do for(var n=!1,r=gd;r!==null;){if(!t)if(e!==0){var i=r.pendingLanes;if(i===0)var a=0;else{var o=r.suspendedLanes,s=r.pingedLanes;a=(1<<31-qe(42|e)+1)-1,a&=i&~(o&~s),a=a&201326741?a&201326741|1:a?a|2:0}a!==0&&(n=!0,Od(r,a))}else a=tu,a=et(r,r===$l?a:0,r.cancelPendingCommit!==null||r.timeoutHandle!==-1),!(a&3)||tt(r,a)||(n=!0,Od(r,a));r=r.next}while(n);bd=!1}}function wd(){Td()}function Td(){yd=vd=!1;var e=0;xd!==0&&gf()&&(e=xd);for(var t=Fe(),n=null,r=gd;r!==null;){var i=r.next,a=Ed(r,t);a===0?(r.next=null,n===null?gd=i:n.next=i,i===null&&(_d=n)):(n=r,(e!==0||a&3)&&(yd=!0)),r=i}Su!==0&&Su!==5||Cd(e,!1),xd!==0&&(xd=0)}function Ed(e,t){for(var n=e.suspendedLanes,r=e.pingedLanes,i=e.expirationTimes,a=e.pendingLanes&-62914561;0<a;){var o=31-qe(a),s=1<<o,c=i[o];c===-1?((s&n)===0||(s&r)!==0)&&(i[o]=nt(s,t)):c<=t&&(e.expiredLanes|=s),a&=~s}if(t=$l,n=tu,n=et(e,e===t?n:0,e.cancelPendingCommit!==null||e.timeoutHandle!==-1),r=e.callbackNode,n===0||e===t&&(nu===2||nu===9)||e.cancelPendingCommit!==null)return r!==null&&r!==null&&Me(r),e.callbackNode=null,e.callbackPriority=0;if(!(n&3)||tt(e,n)){if(t=n&-n,t===e.callbackPriority)return t;switch(r!==null&&Me(r),dt(n)){case 2:case 8:n=Re;break;case 32:n=ze;break;case 268435456:n=Ve;break;default:n=ze}return r=Dd.bind(null,e),n=je(n,r),e.callbackPriority=t,e.callbackNode=n,t}return r!==null&&r!==null&&Me(r),e.callbackPriority=2,e.callbackNode=null,2}function Dd(e,t){if(Su!==0&&Su!==5)return e.callbackNode=null,e.callbackPriority=0,null;var n=e.callbackNode;if(od()&&e.callbackNode!==n)return null;var r=tu;return r=et(e,e===$l?r:0,e.cancelPendingCommit!==null||e.timeoutHandle!==-1),r===0?null:(Pu(e,r,t),Ed(e,Fe()),e.callbackNode!=null&&e.callbackNode===n?Dd.bind(null,e):null)}function Od(e,t){if(od())return null;Pu(e,t,!0)}function kd(){bf(function(){Ql&6?je(Le,wd):Td()})}function Ad(){if(xd===0){var e=ka;e===0&&(e=Ze,Ze<<=1,!(Ze&261888)&&(Ze=256)),xd=e}return xd}function jd(e){return e==null||typeof e==`symbol`||typeof e==`boolean`?null:typeof e==`function`?e:cn(``+e)}function Md(e,t){var n=t.ownerDocument.createElement(`input`);return n.name=t.name,n.value=t.value,e.id&&n.setAttribute(`form`,e.id),t.parentNode.insertBefore(n,t),e=new FormData(e),n.parentNode.removeChild(n),e}function Nd(e,t,n,r,i){if(t===`submit`&&n&&n.stateNode===i){var a=jd((i[gt]||null).action),o=r.submitter;o&&(t=(t=o[gt]||null)?jd(t.formAction):o.getAttribute(`formAction`),t!==null&&(a=t,o=null));var s=new An(`action`,`action`,null,r,i);e.push({event:s,listeners:[{instance:null,listener:function(){if(r.defaultPrevented){if(xd!==0){var e=o?Md(i,o):new FormData(i);Bs(n,{pending:!0,data:e,method:i.method,action:a},null,e)}}else typeof a==`function`&&(s.preventDefault(),e=o?Md(i,o):new FormData(i),Bs(n,{pending:!0,data:e,method:i.method,action:a},a,e))},currentTarget:i}]})}}for(var Pd=0;Pd<pi.length;Pd++){var Fd=pi[Pd],Id=Fd.toLowerCase(),Ld=Fd[0].toUpperCase()+Fd.slice(1);mi(Id,`on`+Ld)}mi(oi,`onAnimationEnd`),mi(si,`onAnimationIteration`),mi(ci,`onAnimationStart`),mi(`dblclick`,`onDoubleClick`),mi(`focusin`,`onFocus`),mi(`focusout`,`onBlur`),mi(A,`onTransitionRun`),mi(li,`onTransitionStart`),mi(ui,`onTransitionCancel`),mi(di,`onTransitionEnd`),Mt(`onMouseEnter`,[`mouseout`,`mouseover`]),Mt(`onMouseLeave`,[`mouseout`,`mouseover`]),Mt(`onPointerEnter`,[`pointerout`,`pointerover`]),Mt(`onPointerLeave`,[`pointerout`,`pointerover`]),jt(`onChange`,`change click focusin focusout input keydown keyup selectionchange`.split(` `)),jt(`onSelect`,`focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange`.split(` `)),jt(`onBeforeInput`,[`compositionend`,`keypress`,`textInput`,`paste`]),jt(`onCompositionEnd`,`compositionend focusout keydown keypress keyup mousedown`.split(` `)),jt(`onCompositionStart`,`compositionstart focusout keydown keypress keyup mousedown`.split(` `)),jt(`onCompositionUpdate`,`compositionupdate focusout keydown keypress keyup mousedown`.split(` `));var Rd=`abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting`.split(` `),zd=new Set(`beforetoggle cancel close invalid load scroll scrollend toggle`.split(` `).concat(Rd));function Bd(e,t){t=(t&4)!=0;for(var n=0;n<e.length;n++){var r=e[n],i=r.event;r=r.listeners;a:{var a=void 0;if(t)for(var o=r.length-1;0<=o;o--){var s=r[o],c=s.instance,l=s.currentTarget;if(s=s.listener,c!==a&&i.isPropagationStopped())break a;a=s,i.currentTarget=l;try{a(i)}catch(e){hi(e)}i.currentTarget=null,a=c}else for(o=0;o<r.length;o++){if(s=r[o],c=s.instance,l=s.currentTarget,s=s.listener,c!==a&&i.isPropagationStopped())break a;a=s,i.currentTarget=l;try{a(i)}catch(e){hi(e)}i.currentTarget=null,a=c}}}}function Vd(e,t){var n=t[vt];n===void 0&&(n=t[vt]=new Set);var r=e+`__bubble`;n.has(r)||(Gd(t,e,2,!1),n.add(r))}function Hd(e,t,n){var r=0;t&&(r|=4),Gd(n,e,r,t)}var Ud=`_reactListening`+Math.random().toString(36).slice(2);function Wd(e){if(!e[Ud]){e[Ud]=!0,kt.forEach(function(t){t!==`selectionchange`&&(zd.has(t)||Hd(t,!1,e),Hd(t,!0,e))});var t=e.nodeType===9?e:e.ownerDocument;t===null||t[Ud]||(t[Ud]=!0,Hd(`selectionchange`,!1,t))}}function Gd(e,t,n,r){switch(Lp(t)){case 2:var i=jp;break;case 8:i=Mp;break;default:i=Np}n=i.bind(null,t,n,e),i=void 0,!yn||t!==`touchstart`&&t!==`touchmove`&&t!==`wheel`||(i=!0),r?i===void 0?e.addEventListener(t,n,!0):e.addEventListener(t,n,{capture:!0,passive:i}):i===void 0?e.addEventListener(t,n,!1):e.addEventListener(t,n,{passive:i})}function Kd(e,t,n,r,i){var a=r;if(!(t&1)&&!(t&2)&&r!==null)a:for(;;){if(r===null)return;var s=r.tag;if(s===3||s===4){var c=r.stateNode.containerInfo;if(c===i)break;if(s===4)for(s=r.return;s!==null;){var l=s.tag;if((l===3||l===4)&&s.stateNode.containerInfo===i)return;s=s.return}for(;c!==null;){if(s=wt(c),s===null)return;if(l=s.tag,l===5||l===6||l===26||l===27){r=a=s;continue a}c=c.parentNode}}r=r.return}gn(function(){var r=a,i=dn(n),s=[];a:{var c=fi.get(e);if(c!==void 0){var l=An,u=e;switch(e){case`keypress`:if(Tn(n)===0)break a;case`keydown`:case`keyup`:l=er;break;case`focusin`:u=`focus`,l=Vn;break;case`focusout`:u=`blur`,l=Vn;break;case`beforeblur`:case`afterblur`:l=Vn;break;case`click`:if(n.button===2)break a;case`auxclick`:case`dblclick`:case`mousedown`:case`mousemove`:case`mouseup`:case`mouseout`:case`mouseover`:case`contextmenu`:l=Ln;break;case`drag`:case`dragend`:case`dragenter`:case`dragexit`:case`dragleave`:case`dragover`:case`dragstart`:case`drop`:l=zn;break;case`touchcancel`:case`touchend`:case`touchmove`:case`touchstart`:l=ir;break;case oi:case si:case ci:l=Un;break;case di:l=or;break;case`scroll`:case`scrollend`:l=Mn;break;case`wheel`:l=cr;break;case`copy`:case`cut`:case`paste`:l=Gn;break;case`gotpointercapture`:case`lostpointercapture`:case`pointercancel`:case`pointerdown`:case`pointermove`:case`pointerout`:case`pointerover`:case`pointerup`:l=nr;break;case`toggle`:case`beforetoggle`:l=ur}var d=(t&4)!=0,f=!d&&(e===`scroll`||e===`scrollend`),p=d?c===null?null:c+`Capture`:c;d=[];for(var m=r,h;m!==null;){var g=m;if(h=g.stateNode,g=g.tag,g!==5&&g!==26&&g!==27||h===null||p===null||(g=_n(m,p),g!=null&&d.push(qd(m,g,h))),f)break;m=m.return}0<d.length&&(c=new l(c,u,null,n,i),s.push({event:c,listeners:d}))}}if(!(t&7)){a:{if(c=e===`mouseover`||e===`pointerover`,l=e===`mouseout`||e===`pointerout`,c&&n!==un&&(u=n.relatedTarget||n.fromElement)&&(wt(u)||u[_t]))break a;if((l||c)&&(c=i.window===i?i:(c=i.ownerDocument)?c.defaultView||c.parentWindow:window,l?(u=n.relatedTarget||n.toElement,l=r,u=u?wt(u):null,u!==null&&(f=o(u),d=u.tag,u!==f||d!==5&&d!==27&&d!==6)&&(u=null)):(l=null,u=r),l!==u)){if(d=Ln,g=`onMouseLeave`,p=`onMouseEnter`,m=`mouse`,(e===`pointerout`||e===`pointerover`)&&(d=nr,g=`onPointerLeave`,p=`onPointerEnter`,m=`pointer`),f=l==null?c:Et(l),h=u==null?c:Et(u),c=new d(g,m+`leave`,l,n,i),c.target=f,c.relatedTarget=h,g=null,wt(i)===r&&(d=new d(p,m+`enter`,u,n,i),d.target=h,d.relatedTarget=f,g=d),f=g,l&&u)b:{for(d=Yd,p=l,m=u,h=0,g=p;g;g=d(g))h++;g=0;for(var _=m;_;_=d(_))g++;for(;0<h-g;)p=d(p),h--;for(;0<g-h;)m=d(m),g--;for(;h--;){if(p===m||m!==null&&p===m.alternate){d=p;break b}p=d(p),m=d(m)}d=null}else d=null;l!==null&&Xd(s,c,l,d,!1),u!==null&&f!==null&&Xd(s,f,u,d,!0)}}a:{if(c=r?Et(r):window,l=c.nodeName&&c.nodeName.toLowerCase(),l===`select`||l===`input`&&c.type===`file`)var v=Ar;else if(wr(c))if(jr)v=Br;else{v=Rr;var y=Lr}else l=c.nodeName,!l||l.toLowerCase()!==`input`||c.type!==`checkbox`&&c.type!==`radio`?r&&an(r.elementType)&&(v=Ar):v=zr;if(v&&=v(e,r)){Tr(s,v,n,i);break a}y&&y(e,c,r),e===`focusout`&&r&&c.type===`number`&&r.memoizedProps.value!=null&&Xt(c,`number`,c.value)}switch(y=r?Et(r):window,e){case`focusin`:(wr(y)||y.contentEditable===`true`)&&(Xr=y,Zr=r,Qr=null);break;case`focusout`:Qr=Zr=Xr=null;break;case`mousedown`:$r=!0;break;case`contextmenu`:case`mouseup`:case`dragend`:$r=!1,ei(s,n,i);break;case`selectionchange`:if(Yr)break;case`keydown`:case`keyup`:ei(s,n,i)}var b;if(fr)b:{switch(e){case`compositionstart`:var x=`onCompositionStart`;break b;case`compositionend`:x=`onCompositionEnd`;break b;case`compositionupdate`:x=`onCompositionUpdate`;break b}x=void 0}else br?vr(e,n)&&(x=`onCompositionEnd`):e===`keydown`&&n.keyCode===229&&(x=`onCompositionStart`);x&&(hr&&n.locale!==`ko`&&(br||x!==`onCompositionStart`?x===`onCompositionEnd`&&br&&(b=wn()):(xn=i,Sn=`value`in xn?xn.value:xn.textContent,br=!0)),y=Jd(r,x),0<y.length&&(x=new qn(x,e,null,n,i),s.push({event:x,listeners:y}),b?x.data=b:(b=yr(n),b!==null&&(x.data=b)))),(b=mr?xr(e,n):Sr(e,n))&&(x=Jd(r,`onBeforeInput`),0<x.length&&(y=new qn(`onBeforeInput`,`beforeinput`,null,n,i),s.push({event:y,listeners:x}),y.data=b)),Nd(s,e,r,n,i)}Bd(s,t)})}function qd(e,t,n){return{instance:e,listener:t,currentTarget:n}}function Jd(e,t){for(var n=t+`Capture`,r=[];e!==null;){var i=e,a=i.stateNode;if(i=i.tag,i!==5&&i!==26&&i!==27||a===null||(i=_n(e,n),i!=null&&r.unshift(qd(e,i,a)),i=_n(e,t),i!=null&&r.push(qd(e,i,a))),e.tag===3)return r;e=e.return}return[]}function Yd(e){if(e===null)return null;do e=e.return;while(e&&e.tag!==5&&e.tag!==27);return e||null}function Xd(e,t,n,r,i){for(var a=t._reactName,o=[];n!==null&&n!==r;){var s=n,c=s.alternate,l=s.stateNode;if(s=s.tag,c!==null&&c===r)break;s!==5&&s!==26&&s!==27||l===null||(c=l,i?(l=_n(n,a),l!=null&&o.unshift(qd(n,l,c))):i||(l=_n(n,a),l!=null&&o.push(qd(n,l,c)))),n=n.return}o.length!==0&&e.push({event:t,listeners:o})}var Zd=/\r\n?/g,Qd=/\u0000|\uFFFD/g;function $d(e){return(typeof e==`string`?e:``+e).replace(Zd,`
`).replace(Qd,``)}function ef(e,t){return t=$d(t),$d(e)===t}function tf(e,t,n,r,a,o){switch(n){case`children`:typeof r==`string`?t===`body`||t===`textarea`&&r===``||en(e,r):(typeof r==`number`||typeof r==`bigint`)&&t!==`body`&&en(e,``+r);break;case`className`:Rt(e,`class`,r);break;case`tabIndex`:Rt(e,`tabindex`,r);break;case`dir`:case`role`:case`viewBox`:case`width`:case`height`:Rt(e,n,r);break;case`style`:rn(e,r,o);break;case`data`:if(t!==`object`){Rt(e,`data`,r);break}case`src`:case`href`:if(r===``&&(t!==`a`||n!==`href`)){e.removeAttribute(n);break}if(r==null||typeof r==`function`||typeof r==`symbol`||typeof r==`boolean`){e.removeAttribute(n);break}r=cn(``+r),e.setAttribute(n,r);break;case`action`:case`formAction`:if(typeof r==`function`){e.setAttribute(n,`javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')`);break}else typeof o==`function`&&(n===`formAction`?(t!==`input`&&tf(e,t,`name`,a.name,a,null),tf(e,t,`formEncType`,a.formEncType,a,null),tf(e,t,`formMethod`,a.formMethod,a,null),tf(e,t,`formTarget`,a.formTarget,a,null)):(tf(e,t,`encType`,a.encType,a,null),tf(e,t,`method`,a.method,a,null),tf(e,t,`target`,a.target,a,null)));if(r==null||typeof r==`symbol`||typeof r==`boolean`){e.removeAttribute(n);break}r=cn(``+r),e.setAttribute(n,r);break;case`onClick`:r!=null&&(e.onclick=ln);break;case`onScroll`:r!=null&&Vd(`scroll`,e);break;case`onScrollEnd`:r!=null&&Vd(`scrollend`,e);break;case`dangerouslySetInnerHTML`:if(r!=null){if(typeof r!=`object`||!(`__html`in r))throw Error(i(61));if(n=r.__html,n!=null){if(a.children!=null)throw Error(i(60));e.innerHTML=n}}break;case`multiple`:e.multiple=r&&typeof r!=`function`&&typeof r!=`symbol`;break;case`muted`:e.muted=r&&typeof r!=`function`&&typeof r!=`symbol`;break;case`suppressContentEditableWarning`:case`suppressHydrationWarning`:case`defaultValue`:case`defaultChecked`:case`innerHTML`:case`ref`:break;case`autoFocus`:break;case`xlinkHref`:if(r==null||typeof r==`function`||typeof r==`boolean`||typeof r==`symbol`){e.removeAttribute(`xlink:href`);break}n=cn(``+r),e.setAttributeNS(`http://www.w3.org/1999/xlink`,`xlink:href`,n);break;case`contentEditable`:case`spellCheck`:case`draggable`:case`value`:case`autoReverse`:case`externalResourcesRequired`:case`focusable`:case`preserveAlpha`:r!=null&&typeof r!=`function`&&typeof r!=`symbol`?e.setAttribute(n,``+r):e.removeAttribute(n);break;case`inert`:case`allowFullScreen`:case`async`:case`autoPlay`:case`controls`:case`default`:case`defer`:case`disabled`:case`disablePictureInPicture`:case`disableRemotePlayback`:case`formNoValidate`:case`hidden`:case`loop`:case`noModule`:case`noValidate`:case`open`:case`playsInline`:case`readOnly`:case`required`:case`reversed`:case`scoped`:case`seamless`:case`itemScope`:r&&typeof r!=`function`&&typeof r!=`symbol`?e.setAttribute(n,``):e.removeAttribute(n);break;case`capture`:case`download`:!0===r?e.setAttribute(n,``):!1!==r&&r!=null&&typeof r!=`function`&&typeof r!=`symbol`?e.setAttribute(n,r):e.removeAttribute(n);break;case`cols`:case`rows`:case`size`:case`span`:r!=null&&typeof r!=`function`&&typeof r!=`symbol`&&!isNaN(r)&&1<=r?e.setAttribute(n,r):e.removeAttribute(n);break;case`rowSpan`:case`start`:r==null||typeof r==`function`||typeof r==`symbol`||isNaN(r)?e.removeAttribute(n):e.setAttribute(n,r);break;case`popover`:Vd(`beforetoggle`,e),Vd(`toggle`,e),Lt(e,`popover`,r);break;case`xlinkActuate`:zt(e,`http://www.w3.org/1999/xlink`,`xlink:actuate`,r);break;case`xlinkArcrole`:zt(e,`http://www.w3.org/1999/xlink`,`xlink:arcrole`,r);break;case`xlinkRole`:zt(e,`http://www.w3.org/1999/xlink`,`xlink:role`,r);break;case`xlinkShow`:zt(e,`http://www.w3.org/1999/xlink`,`xlink:show`,r);break;case`xlinkTitle`:zt(e,`http://www.w3.org/1999/xlink`,`xlink:title`,r);break;case`xlinkType`:zt(e,`http://www.w3.org/1999/xlink`,`xlink:type`,r);break;case`xmlBase`:zt(e,`http://www.w3.org/XML/1998/namespace`,`xml:base`,r);break;case`xmlLang`:zt(e,`http://www.w3.org/XML/1998/namespace`,`xml:lang`,r);break;case`xmlSpace`:zt(e,`http://www.w3.org/XML/1998/namespace`,`xml:space`,r);break;case`is`:Lt(e,`is`,r);break;case`innerText`:case`textContent`:break;default:(!(2<n.length)||n[0]!==`o`&&n[0]!==`O`||n[1]!==`n`&&n[1]!==`N`)&&(n=on.get(n)||n,Lt(e,n,r))}}function nf(e,t,n,r,a,o){switch(n){case`style`:rn(e,r,o);break;case`dangerouslySetInnerHTML`:if(r!=null){if(typeof r!=`object`||!(`__html`in r))throw Error(i(61));if(n=r.__html,n!=null){if(a.children!=null)throw Error(i(60));e.innerHTML=n}}break;case`children`:typeof r==`string`?en(e,r):(typeof r==`number`||typeof r==`bigint`)&&en(e,``+r);break;case`onScroll`:r!=null&&Vd(`scroll`,e);break;case`onScrollEnd`:r!=null&&Vd(`scrollend`,e);break;case`onClick`:r!=null&&(e.onclick=ln);break;case`suppressContentEditableWarning`:case`suppressHydrationWarning`:case`innerHTML`:case`ref`:break;case`innerText`:case`textContent`:break;default:if(!At.hasOwnProperty(n))a:{if(n[0]===`o`&&n[1]===`n`&&(a=n.endsWith(`Capture`),t=n.slice(2,a?n.length-7:void 0),o=e[gt]||null,o=o==null?null:o[n],typeof o==`function`&&e.removeEventListener(t,o,a),typeof r==`function`)){typeof o!=`function`&&o!==null&&(n in e?e[n]=null:e.hasAttribute(n)&&e.removeAttribute(n)),e.addEventListener(t,r,a);break a}n in e?e[n]=r:!0===r?e.setAttribute(n,``):Lt(e,n,r)}}}function rf(e,t,n){switch(t){case`div`:case`span`:case`svg`:case`path`:case`a`:case`g`:case`p`:case`li`:break;case`img`:Vd(`error`,e),Vd(`load`,e);var r=!1,a=!1,o;for(o in n)if(n.hasOwnProperty(o)){var s=n[o];if(s!=null)switch(o){case`src`:r=!0;break;case`srcSet`:a=!0;break;case`children`:case`dangerouslySetInnerHTML`:throw Error(i(137,t));default:tf(e,t,o,s,n,null)}}a&&tf(e,t,`srcSet`,n.srcSet,n,null),r&&tf(e,t,`src`,n.src,n,null);return;case`input`:Vd(`invalid`,e);var c=o=s=a=null,l=null,u=null;for(r in n)if(n.hasOwnProperty(r)){var d=n[r];if(d!=null)switch(r){case`name`:a=d;break;case`type`:s=d;break;case`checked`:l=d;break;case`defaultChecked`:u=d;break;case`value`:o=d;break;case`defaultValue`:c=d;break;case`children`:case`dangerouslySetInnerHTML`:if(d!=null)throw Error(i(137,t));break;default:tf(e,t,r,d,n,null)}}Yt(e,o,c,l,u,s,a,!1);return;case`select`:for(a in Vd(`invalid`,e),r=s=o=null,n)if(n.hasOwnProperty(a)&&(c=n[a],c!=null))switch(a){case`value`:o=c;break;case`defaultValue`:s=c;break;case`multiple`:r=c;default:tf(e,t,a,c,n,null)}t=o,n=s,e.multiple=!!r,t==null?n!=null&&Zt(e,!!r,n,!0):Zt(e,!!r,t,!1);return;case`textarea`:for(s in Vd(`invalid`,e),o=a=r=null,n)if(n.hasOwnProperty(s)&&(c=n[s],c!=null))switch(s){case`value`:r=c;break;case`defaultValue`:a=c;break;case`children`:o=c;break;case`dangerouslySetInnerHTML`:if(c!=null)throw Error(i(91));break;default:tf(e,t,s,c,n,null)}$t(e,r,a,o);return;case`option`:for(l in n)if(n.hasOwnProperty(l)&&(r=n[l],r!=null))switch(l){case`selected`:e.selected=r&&typeof r!=`function`&&typeof r!=`symbol`;break;default:tf(e,t,l,r,n,null)}return;case`dialog`:Vd(`beforetoggle`,e),Vd(`toggle`,e),Vd(`cancel`,e),Vd(`close`,e);break;case`iframe`:case`object`:Vd(`load`,e);break;case`video`:case`audio`:for(r=0;r<Rd.length;r++)Vd(Rd[r],e);break;case`image`:Vd(`error`,e),Vd(`load`,e);break;case`details`:Vd(`toggle`,e);break;case`embed`:case`source`:case`link`:Vd(`error`,e),Vd(`load`,e);case`area`:case`base`:case`br`:case`col`:case`hr`:case`keygen`:case`meta`:case`param`:case`track`:case`wbr`:case`menuitem`:for(u in n)if(n.hasOwnProperty(u)&&(r=n[u],r!=null))switch(u){case`children`:case`dangerouslySetInnerHTML`:throw Error(i(137,t));default:tf(e,t,u,r,n,null)}return;default:if(an(t)){for(d in n)n.hasOwnProperty(d)&&(r=n[d],r!==void 0&&nf(e,t,d,r,n,void 0));return}}for(c in n)n.hasOwnProperty(c)&&(r=n[c],r!=null&&tf(e,t,c,r,n,null))}function af(e,t,n,r){switch(t){case`div`:case`span`:case`svg`:case`path`:case`a`:case`g`:case`p`:case`li`:break;case`input`:var a=null,o=null,s=null,c=null,l=null,u=null,d=null;for(m in n){var f=n[m];if(n.hasOwnProperty(m)&&f!=null)switch(m){case`checked`:break;case`value`:break;case`defaultValue`:l=f;default:r.hasOwnProperty(m)||tf(e,t,m,null,r,f)}}for(var p in r){var m=r[p];if(f=n[p],r.hasOwnProperty(p)&&(m!=null||f!=null))switch(p){case`type`:o=m;break;case`name`:a=m;break;case`checked`:u=m;break;case`defaultChecked`:d=m;break;case`value`:s=m;break;case`defaultValue`:c=m;break;case`children`:case`dangerouslySetInnerHTML`:if(m!=null)throw Error(i(137,t));break;default:m!==f&&tf(e,t,p,m,r,f)}}Jt(e,s,c,l,u,d,o,a);return;case`select`:for(o in m=s=c=p=null,n)if(l=n[o],n.hasOwnProperty(o)&&l!=null)switch(o){case`value`:break;case`multiple`:m=l;default:r.hasOwnProperty(o)||tf(e,t,o,null,r,l)}for(a in r)if(o=r[a],l=n[a],r.hasOwnProperty(a)&&(o!=null||l!=null))switch(a){case`value`:p=o;break;case`defaultValue`:c=o;break;case`multiple`:s=o;default:o!==l&&tf(e,t,a,o,r,l)}t=c,n=s,r=m,p==null?!!r!=!!n&&(t==null?Zt(e,!!n,n?[]:``,!1):Zt(e,!!n,t,!0)):Zt(e,!!n,p,!1);return;case`textarea`:for(c in m=p=null,n)if(a=n[c],n.hasOwnProperty(c)&&a!=null&&!r.hasOwnProperty(c))switch(c){case`value`:break;case`children`:break;default:tf(e,t,c,null,r,a)}for(s in r)if(a=r[s],o=n[s],r.hasOwnProperty(s)&&(a!=null||o!=null))switch(s){case`value`:p=a;break;case`defaultValue`:m=a;break;case`children`:break;case`dangerouslySetInnerHTML`:if(a!=null)throw Error(i(91));break;default:a!==o&&tf(e,t,s,a,r,o)}Qt(e,p,m);return;case`option`:for(var h in n)if(p=n[h],n.hasOwnProperty(h)&&p!=null&&!r.hasOwnProperty(h))switch(h){case`selected`:e.selected=!1;break;default:tf(e,t,h,null,r,p)}for(l in r)if(p=r[l],m=n[l],r.hasOwnProperty(l)&&p!==m&&(p!=null||m!=null))switch(l){case`selected`:e.selected=p&&typeof p!=`function`&&typeof p!=`symbol`;break;default:tf(e,t,l,p,r,m)}return;case`img`:case`link`:case`area`:case`base`:case`br`:case`col`:case`embed`:case`hr`:case`keygen`:case`meta`:case`param`:case`source`:case`track`:case`wbr`:case`menuitem`:for(var g in n)p=n[g],n.hasOwnProperty(g)&&p!=null&&!r.hasOwnProperty(g)&&tf(e,t,g,null,r,p);for(u in r)if(p=r[u],m=n[u],r.hasOwnProperty(u)&&p!==m&&(p!=null||m!=null))switch(u){case`children`:case`dangerouslySetInnerHTML`:if(p!=null)throw Error(i(137,t));break;default:tf(e,t,u,p,r,m)}return;default:if(an(t)){for(var _ in n)p=n[_],n.hasOwnProperty(_)&&p!==void 0&&!r.hasOwnProperty(_)&&nf(e,t,_,void 0,r,p);for(d in r)p=r[d],m=n[d],!r.hasOwnProperty(d)||p===m||p===void 0&&m===void 0||nf(e,t,d,p,r,m);return}}for(var v in n)p=n[v],n.hasOwnProperty(v)&&p!=null&&!r.hasOwnProperty(v)&&tf(e,t,v,null,r,p);for(f in r)p=r[f],m=n[f],!r.hasOwnProperty(f)||p===m||p==null&&m==null||tf(e,t,f,p,r,m)}function sf(e){switch(e){case`css`:case`script`:case`font`:case`img`:case`image`:case`input`:case`link`:return!0;default:return!1}}function cf(){if(typeof performance.getEntriesByType==`function`){for(var e=0,t=0,n=performance.getEntriesByType(`resource`),r=0;r<n.length;r++){var i=n[r],a=i.transferSize,o=i.initiatorType,s=i.duration;if(a&&s&&sf(o)){for(o=0,s=i.responseEnd,r+=1;r<n.length;r++){var c=n[r],l=c.startTime;if(l>s)break;var u=c.transferSize,d=c.initiatorType;u&&sf(d)&&(c=c.responseEnd,o+=u*(c<s?1:(s-l)/(c-l)))}if(--r,t+=8*(a+o)/(i.duration/1e3),e++,10<e)break}}if(0<e)return t/e/1e6}return navigator.connection&&(e=navigator.connection.downlink,typeof e==`number`)?e:5}var lf=null,uf=null;function df(e){return e.nodeType===9?e:e.ownerDocument}function ff(e){switch(e){case`http://www.w3.org/2000/svg`:return 1;case`http://www.w3.org/1998/Math/MathML`:return 2;default:return 0}}function pf(e,t){if(e===0)switch(t){case`svg`:return 1;case`math`:return 2;default:return 0}return e===1&&t===`foreignObject`?0:e}function mf(e,t){return e===`textarea`||e===`noscript`||typeof t.children==`string`||typeof t.children==`number`||typeof t.children==`bigint`||typeof t.dangerouslySetInnerHTML==`object`&&t.dangerouslySetInnerHTML!==null&&t.dangerouslySetInnerHTML.__html!=null}var hf=null;function gf(){var e=window.event;return e&&e.type===`popstate`?e===hf?!1:(hf=e,!0):(hf=null,!1)}var _f=typeof setTimeout==`function`?setTimeout:void 0,vf=typeof clearTimeout==`function`?clearTimeout:void 0,yf=typeof Promise==`function`?Promise:void 0,bf=typeof queueMicrotask==`function`?queueMicrotask:yf===void 0?_f:function(e){return yf.resolve(null).then(e).catch(xf)};function xf(e){setTimeout(function(){throw e})}function Sf(e){return e===`head`}function Cf(e,t){var n=t,r=0;do{var i=n.nextSibling;if(e.removeChild(n),i&&i.nodeType===8)if(n=i.data,n===`/$`||n===`/&`){if(r===0){e.removeChild(i),nm(t);return}r--}else if(n===`$`||n===`$?`||n===`$~`||n===`$!`||n===`&`)r++;else if(n===`html`)Lf(e.ownerDocument.documentElement);else if(n===`head`){n=e.ownerDocument.head,Lf(n);for(var a=n.firstChild;a;){var o=a.nextSibling,s=a.nodeName;a[St]||s===`SCRIPT`||s===`STYLE`||s===`LINK`&&a.rel.toLowerCase()===`stylesheet`||n.removeChild(a),a=o}}else n===`body`&&Lf(e.ownerDocument.body);n=i}while(n);nm(t)}function wf(e,t){var n=e;e=0;do{var r=n.nextSibling;if(n.nodeType===1?t?(n._stashedDisplay=n.style.display,n.style.display=`none`):(n.style.display=n._stashedDisplay||``,n.getAttribute(`style`)===``&&n.removeAttribute(`style`)):n.nodeType===3&&(t?(n._stashedText=n.nodeValue,n.nodeValue=``):n.nodeValue=n._stashedText||``),r&&r.nodeType===8)if(n=r.data,n===`/$`){if(e===0)break;e--}else n!==`$`&&n!==`$?`&&n!==`$~`&&n!==`$!`||e++;n=r}while(n)}function Tf(e){var t=e.firstChild;for(t&&t.nodeType===10&&(t=t.nextSibling);t;){var n=t;switch(t=t.nextSibling,n.nodeName){case`HTML`:case`HEAD`:case`BODY`:Tf(n),Ct(n);continue;case`SCRIPT`:case`STYLE`:continue;case`LINK`:if(n.rel.toLowerCase()===`stylesheet`)continue}e.removeChild(n)}}function Ef(e,t,n,r){for(;e.nodeType===1;){var i=n;if(e.nodeName.toLowerCase()!==t.toLowerCase()){if(!r&&(e.nodeName!==`INPUT`||e.type!==`hidden`))break}else if(r){if(!e[St])switch(t){case`meta`:if(!e.hasAttribute(`itemprop`))break;return e;case`link`:if(a=e.getAttribute(`rel`),a===`stylesheet`&&e.hasAttribute(`data-precedence`)||a!==i.rel||e.getAttribute(`href`)!==(i.href==null||i.href===``?null:i.href)||e.getAttribute(`crossorigin`)!==(i.crossOrigin==null?null:i.crossOrigin)||e.getAttribute(`title`)!==(i.title==null?null:i.title))break;return e;case`style`:if(e.hasAttribute(`data-precedence`))break;return e;case`script`:if(a=e.getAttribute(`src`),(a!==(i.src==null?null:i.src)||e.getAttribute(`type`)!==(i.type==null?null:i.type)||e.getAttribute(`crossorigin`)!==(i.crossOrigin==null?null:i.crossOrigin))&&a&&e.hasAttribute(`async`)&&!e.hasAttribute(`itemprop`))break;return e;default:return e}}else if(t===`input`&&e.type===`hidden`){var a=i.name==null?null:``+i.name;if(i.type===`hidden`&&e.getAttribute(`name`)===a)return e}else return e;if(e=Mf(e.nextSibling),e===null)break}return null}function Df(e,t,n){if(t===``)return null;for(;e.nodeType!==3;)if((e.nodeType!==1||e.nodeName!==`INPUT`||e.type!==`hidden`)&&!n||(e=Mf(e.nextSibling),e===null))return null;return e}function Of(e,t){for(;e.nodeType!==8;)if((e.nodeType!==1||e.nodeName!==`INPUT`||e.type!==`hidden`)&&!t||(e=Mf(e.nextSibling),e===null))return null;return e}function kf(e){return e.data===`$?`||e.data===`$~`}function Af(e){return e.data===`$!`||e.data===`$?`&&e.ownerDocument.readyState!==`loading`}function jf(e,t){var n=e.ownerDocument;if(e.data===`$~`)e._reactRetry=t;else if(e.data!==`$?`||n.readyState!==`loading`)t();else{var r=function(){t(),n.removeEventListener(`DOMContentLoaded`,r)};n.addEventListener(`DOMContentLoaded`,r),e._reactRetry=r}}function Mf(e){for(;e!=null;e=e.nextSibling){var t=e.nodeType;if(t===1||t===3)break;if(t===8){if(t=e.data,t===`$`||t===`$!`||t===`$?`||t===`$~`||t===`&`||t===`F!`||t===`F`)break;if(t===`/$`||t===`/&`)return null}}return e}var Nf=null;function Pf(e){e=e.nextSibling;for(var t=0;e;){if(e.nodeType===8){var n=e.data;if(n===`/$`||n===`/&`){if(t===0)return Mf(e.nextSibling);t--}else n!==`$`&&n!==`$!`&&n!==`$?`&&n!==`$~`&&n!==`&`||t++}e=e.nextSibling}return null}function Ff(e){e=e.previousSibling;for(var t=0;e;){if(e.nodeType===8){var n=e.data;if(n===`$`||n===`$!`||n===`$?`||n===`$~`||n===`&`){if(t===0)return e;t--}else n!==`/$`&&n!==`/&`||t++}e=e.previousSibling}return null}function If(e,t,n){switch(t=df(n),e){case`html`:if(e=t.documentElement,!e)throw Error(i(452));return e;case`head`:if(e=t.head,!e)throw Error(i(453));return e;case`body`:if(e=t.body,!e)throw Error(i(454));return e;default:throw Error(i(451))}}function Lf(e){for(var t=e.attributes;t.length;)e.removeAttributeNode(t[0]);Ct(e)}var Rf=new Map,zf=new Set;function Bf(e){return typeof e.getRootNode==`function`?e.getRootNode():e.nodeType===9?e:e.ownerDocument}var Vf=ue.d;ue.d={f:Hf,r:Uf,D:Kf,C:qf,L:Jf,m:Yf,X:Zf,S:Xf,M:Qf};function Hf(){var e=Vf.f(),t=Ru();return e||t}function Uf(e){var t=Tt(e);t!==null&&t.tag===5&&t.type===`form`?Hs(t):Vf.r(e)}var Wf=typeof document>`u`?null:document;function Gf(e,t,n){var r=Wf;if(r&&typeof t==`string`&&t){var i=qt(t);i=`link[rel="`+e+`"][href="`+i+`"]`,typeof n==`string`&&(i+=`[crossorigin="`+n+`"]`),zf.has(i)||(zf.add(i),e={rel:e,crossOrigin:n,href:t},r.querySelector(i)===null&&(t=r.createElement(`link`),rf(t,`link`,e),Ot(t),r.head.appendChild(t)))}}function Kf(e){Vf.D(e),Gf(`dns-prefetch`,e,null)}function qf(e,t){Vf.C(e,t),Gf(`preconnect`,e,t)}function Jf(e,t,n){Vf.L(e,t,n);var r=Wf;if(r&&e&&t){var i=`link[rel="preload"][as="`+qt(t)+`"]`;t===`image`&&n&&n.imageSrcSet?(i+=`[imagesrcset="`+qt(n.imageSrcSet)+`"]`,typeof n.imageSizes==`string`&&(i+=`[imagesizes="`+qt(n.imageSizes)+`"]`)):i+=`[href="`+qt(e)+`"]`;var a=i;switch(t){case`style`:a=ep(e);break;case`script`:a=ip(e)}Rf.has(a)||(e=f({rel:`preload`,href:t===`image`&&n&&n.imageSrcSet?void 0:e,as:t},n),Rf.set(a,e),r.querySelector(i)!==null||t===`style`&&r.querySelector(tp(a))||t===`script`&&r.querySelector(ap(a))||(t=r.createElement(`link`),rf(t,`link`,e),Ot(t),r.head.appendChild(t)))}}function Yf(e,t){Vf.m(e,t);var n=Wf;if(n&&e){var r=t&&typeof t.as==`string`?t.as:`script`,i=`link[rel="modulepreload"][as="`+qt(r)+`"][href="`+qt(e)+`"]`,a=i;switch(r){case`audioworklet`:case`paintworklet`:case`serviceworker`:case`sharedworker`:case`worker`:case`script`:a=ip(e)}if(!Rf.has(a)&&(e=f({rel:`modulepreload`,href:e},t),Rf.set(a,e),n.querySelector(i)===null)){switch(r){case`audioworklet`:case`paintworklet`:case`serviceworker`:case`sharedworker`:case`worker`:case`script`:if(n.querySelector(ap(a)))return}r=n.createElement(`link`),rf(r,`link`,e),Ot(r),n.head.appendChild(r)}}}function Xf(e,t,n){Vf.S(e,t,n);var r=Wf;if(r&&e){var i=Dt(r).hoistableStyles,a=ep(e);t||=`default`;var o=i.get(a);if(!o){var s={loading:0,preload:null};if(o=r.querySelector(tp(a)))s.loading=5;else{e=f({rel:`stylesheet`,href:e,"data-precedence":t},n),(n=Rf.get(a))&&sp(e,n);var c=o=r.createElement(`link`);Ot(c),rf(c,`link`,e),c._p=new Promise(function(e,t){c.onload=e,c.onerror=t}),c.addEventListener(`load`,function(){s.loading|=1}),c.addEventListener(`error`,function(){s.loading|=2}),s.loading|=4,op(o,t,r)}o={type:`stylesheet`,instance:o,count:1,state:s},i.set(a,o)}}}function Zf(e,t){Vf.X(e,t);var n=Wf;if(n&&e){var r=Dt(n).hoistableScripts,i=ip(e),a=r.get(i);a||(a=n.querySelector(ap(i)),a||(e=f({src:e,async:!0},t),(t=Rf.get(i))&&cp(e,t),a=n.createElement(`script`),Ot(a),rf(a,`link`,e),n.head.appendChild(a)),a={type:`script`,instance:a,count:1,state:null},r.set(i,a))}}function Qf(e,t){Vf.M(e,t);var n=Wf;if(n&&e){var r=Dt(n).hoistableScripts,i=ip(e),a=r.get(i);a||(a=n.querySelector(ap(i)),a||(e=f({src:e,async:!0,type:`module`},t),(t=Rf.get(i))&&cp(e,t),a=n.createElement(`script`),Ot(a),rf(a,`link`,e),n.head.appendChild(a)),a={type:`script`,instance:a,count:1,state:null},r.set(i,a))}}function $f(e,t,n,r){var a=(a=_e.current)?Bf(a):null;if(!a)throw Error(i(446));switch(e){case`meta`:case`title`:return null;case`style`:return typeof n.precedence==`string`&&typeof n.href==`string`?(t=ep(n.href),n=Dt(a).hoistableStyles,r=n.get(t),r||(r={type:`style`,instance:null,count:0,state:null},n.set(t,r)),r):{type:`void`,instance:null,count:0,state:null};case`link`:if(n.rel===`stylesheet`&&typeof n.href==`string`&&typeof n.precedence==`string`){e=ep(n.href);var o=Dt(a).hoistableStyles,s=o.get(e);if(s||(a=a.ownerDocument||a,s={type:`stylesheet`,instance:null,count:0,state:{loading:0,preload:null}},o.set(e,s),(o=a.querySelector(tp(e)))&&!o._p&&(s.instance=o,s.state.loading=5),Rf.has(e)||(n={rel:`preload`,as:`style`,href:n.href,crossOrigin:n.crossOrigin,integrity:n.integrity,media:n.media,hrefLang:n.hrefLang,referrerPolicy:n.referrerPolicy},Rf.set(e,n),o||rp(a,e,n,s.state))),t&&r===null)throw Error(i(528,``));return s}if(t&&r!==null)throw Error(i(529,``));return null;case`script`:return t=n.async,n=n.src,typeof n==`string`&&t&&typeof t!=`function`&&typeof t!=`symbol`?(t=ip(n),n=Dt(a).hoistableScripts,r=n.get(t),r||(r={type:`script`,instance:null,count:0,state:null},n.set(t,r)),r):{type:`void`,instance:null,count:0,state:null};default:throw Error(i(444,e))}}function ep(e){return`href="`+qt(e)+`"`}function tp(e){return`link[rel="stylesheet"][`+e+`]`}function np(e){return f({},e,{"data-precedence":e.precedence,precedence:null})}function rp(e,t,n,r){e.querySelector(`link[rel="preload"][as="style"][`+t+`]`)?r.loading=1:(t=e.createElement(`link`),r.preload=t,t.addEventListener(`load`,function(){return r.loading|=1}),t.addEventListener(`error`,function(){return r.loading|=2}),rf(t,`link`,n),Ot(t),e.head.appendChild(t))}function ip(e){return`[src="`+qt(e)+`"]`}function ap(e){return`script[async]`+e}function K(e,t,n){if(t.count++,t.instance===null)switch(t.type){case`style`:var r=e.querySelector(`style[data-href~="`+qt(n.href)+`"]`);if(r)return t.instance=r,Ot(r),r;var a=f({},n,{"data-href":n.href,"data-precedence":n.precedence,href:null,precedence:null});return r=(e.ownerDocument||e).createElement(`style`),Ot(r),rf(r,`style`,a),op(r,n.precedence,e),t.instance=r;case`stylesheet`:a=ep(n.href);var o=e.querySelector(tp(a));if(o)return t.state.loading|=4,t.instance=o,Ot(o),o;r=np(n),(a=Rf.get(a))&&sp(r,a),o=(e.ownerDocument||e).createElement(`link`),Ot(o);var s=o;return s._p=new Promise(function(e,t){s.onload=e,s.onerror=t}),rf(o,`link`,r),t.state.loading|=4,op(o,n.precedence,e),t.instance=o;case`script`:return o=ip(n.src),(a=e.querySelector(ap(o)))?(t.instance=a,Ot(a),a):(r=n,(a=Rf.get(o))&&(r=f({},n),cp(r,a)),e=e.ownerDocument||e,a=e.createElement(`script`),Ot(a),rf(a,`link`,r),e.head.appendChild(a),t.instance=a);case`void`:return null;default:throw Error(i(443,t.type))}else t.type===`stylesheet`&&!(t.state.loading&4)&&(r=t.instance,t.state.loading|=4,op(r,n.precedence,e));return t.instance}function op(e,t,n){for(var r=n.querySelectorAll(`link[rel="stylesheet"][data-precedence],style[data-precedence]`),i=r.length?r[r.length-1]:null,a=i,o=0;o<r.length;o++){var s=r[o];if(s.dataset.precedence===t)a=s;else if(a!==i)break}a?a.parentNode.insertBefore(e,a.nextSibling):(t=n.nodeType===9?n.head:n,t.insertBefore(e,t.firstChild))}function sp(e,t){e.crossOrigin??=t.crossOrigin,e.referrerPolicy??=t.referrerPolicy,e.title??=t.title}function cp(e,t){e.crossOrigin??=t.crossOrigin,e.referrerPolicy??=t.referrerPolicy,e.integrity??=t.integrity}var lp=null;function up(e,t,n){if(lp===null){var r=new Map,i=lp=new Map;i.set(n,r)}else i=lp,r=i.get(n),r||(r=new Map,i.set(n,r));if(r.has(e))return r;for(r.set(e,null),n=n.getElementsByTagName(e),i=0;i<n.length;i++){var a=n[i];if(!(a[St]||a[ht]||e===`link`&&a.getAttribute(`rel`)===`stylesheet`)&&a.namespaceURI!==`http://www.w3.org/2000/svg`){var o=a.getAttribute(t)||``;o=e+o;var s=r.get(o);s?s.push(a):r.set(o,[a])}}return r}function dp(e,t,n){e=e.ownerDocument||e,e.head.insertBefore(n,t===`title`?e.querySelector(`head > title`):null)}function fp(e,t,n){if(n===1||t.itemProp!=null)return!1;switch(e){case`meta`:case`title`:return!0;case`style`:if(typeof t.precedence!=`string`||typeof t.href!=`string`||t.href===``)break;return!0;case`link`:if(typeof t.rel!=`string`||typeof t.href!=`string`||t.href===``||t.onLoad||t.onError)break;switch(t.rel){case`stylesheet`:return e=t.disabled,typeof t.precedence==`string`&&e==null;default:return!0}case`script`:if(t.async&&typeof t.async!=`function`&&typeof t.async!=`symbol`&&!t.onLoad&&!t.onError&&t.src&&typeof t.src==`string`)return!0}return!1}function pp(e){return!(e.type===`stylesheet`&&!(e.state.loading&3))}function mp(e,t,n,r){if(n.type===`stylesheet`&&(typeof r.media!=`string`||!1!==matchMedia(r.media).matches)&&!(n.state.loading&4)){if(n.instance===null){var i=ep(r.href),a=t.querySelector(tp(i));if(a){t=a._p,typeof t==`object`&&t&&typeof t.then==`function`&&(e.count++,e=_p.bind(e),t.then(e,e)),n.state.loading|=4,n.instance=a,Ot(a);return}a=t.ownerDocument||t,r=np(r),(i=Rf.get(i))&&sp(r,i),a=a.createElement(`link`),Ot(a);var o=a;o._p=new Promise(function(e,t){o.onload=e,o.onerror=t}),rf(a,`link`,r),n.instance=a}e.stylesheets===null&&(e.stylesheets=new Map),e.stylesheets.set(n,t),(t=n.state.preload)&&!(n.state.loading&3)&&(e.count++,n=_p.bind(e),t.addEventListener(`load`,n),t.addEventListener(`error`,n))}}var hp=0;function gp(e,t){return e.stylesheets&&e.count===0&&yp(e,e.stylesheets),0<e.count||0<e.imgCount?function(n){var r=setTimeout(function(){if(e.stylesheets&&yp(e,e.stylesheets),e.unsuspend){var t=e.unsuspend;e.unsuspend=null,t()}},6e4+t);0<e.imgBytes&&hp===0&&(hp=62500*cf());var i=setTimeout(function(){if(e.waitingForImages=!1,e.count===0&&(e.stylesheets&&yp(e,e.stylesheets),e.unsuspend)){var t=e.unsuspend;e.unsuspend=null,t()}},(e.imgBytes>hp?50:800)+t);return e.unsuspend=n,function(){e.unsuspend=null,clearTimeout(r),clearTimeout(i)}}:null}function _p(){if(this.count--,this.count===0&&(this.imgCount===0||!this.waitingForImages)){if(this.stylesheets)yp(this,this.stylesheets);else if(this.unsuspend){var e=this.unsuspend;this.unsuspend=null,e()}}}var vp=null;function yp(e,t){e.stylesheets=null,e.unsuspend!==null&&(e.count++,vp=new Map,t.forEach(bp,e),vp=null,_p.call(e))}function bp(e,t){if(!(t.state.loading&4)){var n=vp.get(e);if(n)var r=n.get(null);else{n=new Map,vp.set(e,n);for(var i=e.querySelectorAll(`link[data-precedence],style[data-precedence]`),a=0;a<i.length;a++){var o=i[a];(o.nodeName===`LINK`||o.getAttribute(`media`)!==`not all`)&&(n.set(o.dataset.precedence,o),r=o)}r&&n.set(null,r)}i=t.instance,o=i.getAttribute(`data-precedence`),a=n.get(o)||r,a===r&&n.set(null,i),n.set(o,i),this.count++,r=_p.bind(this),i.addEventListener(`load`,r),i.addEventListener(`error`,r),a?a.parentNode.insertBefore(i,a.nextSibling):(e=e.nodeType===9?e.head:e,e.insertBefore(i,e.firstChild)),t.state.loading|=4}}var xp={$$typeof:C,Provider:null,Consumer:null,_currentValue:de,_currentValue2:de,_threadCount:0};function Sp(e,t,n,r,i,a,o,s,c){this.tag=1,this.containerInfo=e,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=it(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=it(0),this.hiddenUpdates=it(null),this.identifierPrefix=r,this.onUncaughtError=i,this.onCaughtError=a,this.onRecoverableError=o,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=c,this.incompleteTransitions=new Map}function Cp(e,t,n,r,i,a,o,s,c,l,u,d){return e=new Sp(e,t,n,o,c,l,u,d,s),t=1,!0===a&&(t|=24),a=Di(3,null,null,t),e.current=a,a.stateNode=e,t=N(),t.refCount++,e.pooledCache=t,t.refCount++,a.memoizedState={element:r,isDehydrated:n,cache:t},no(a),e}function wp(e){return e?(e=Ti,e):Ti}function Tp(e,t,n,r,i,a){i=wp(i),r.context===null?r.context=i:r.pendingContext=i,r=io(t),r.payload={element:n},a=a===void 0?null:a,a!==null&&(r.callback=a),n=ao(e,r,t),n!==null&&(Nu(n,e,t),oo(n,e,t))}function Ep(e,t){if(e=e.memoizedState,e!==null&&e.dehydrated!==null){var n=e.retryLane;e.retryLane=n!==0&&n<t?n:t}}function Dp(e,t){Ep(e,t),(e=e.alternate)&&Ep(e,t)}function Op(e){if(e.tag===13||e.tag===31){var t=Si(e,67108864);t!==null&&Nu(t,e,67108864),Dp(e,67108864)}}function kp(e){if(e.tag===13||e.tag===31){var t=ju();t=ut(t);var n=Si(e,t);n!==null&&Nu(n,e,t),Dp(e,t)}}var Ap=!0;function jp(e,t,n,r){var i=le.T;le.T=null;var a=ue.p;try{ue.p=2,Np(e,t,n,r)}finally{ue.p=a,le.T=i}}function Mp(e,t,n,r){var i=le.T;le.T=null;var a=ue.p;try{ue.p=8,Np(e,t,n,r)}finally{ue.p=a,le.T=i}}function Np(e,t,n,r){if(Ap){var i=Pp(r);if(i===null)Kd(e,t,r,Fp,n),Kp(e,r);else if(Jp(i,e,t,n,r))r.stopPropagation();else if(Kp(e,r),t&4&&-1<Gp.indexOf(e)){for(;i!==null;){var a=Tt(i);if(a!==null)switch(a.tag){case 3:if(a=a.stateNode,a.current.memoizedState.isDehydrated){var o=k(a.pendingLanes);if(o!==0){var s=a;for(s.pendingLanes|=2,s.entangledLanes|=2;o;){var c=1<<31-qe(o);s.entanglements[1]|=c,o&=~c}Sd(a),!(Ql&6)&&(yu=Fe()+500,Cd(0,!1))}}break;case 31:case 13:s=Si(a,2),s!==null&&Nu(s,a,2),Ru(),Dp(a,2)}if(a=Pp(r),a===null&&Kd(e,t,r,Fp,n),a===i)break;i=a}i!==null&&r.stopPropagation()}else Kd(e,t,r,null,n)}}function Pp(e){return e=dn(e),Ip(e)}var Fp=null;function Ip(e){if(Fp=null,e=wt(e),e!==null){var t=o(e);if(t===null)e=null;else{var n=t.tag;if(n===13){if(e=s(t),e!==null)return e;e=null}else if(n===31){if(e=c(t),e!==null)return e;e=null}else if(n===3){if(t.stateNode.current.memoizedState.isDehydrated)return t.tag===3?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null)}}return Fp=e,null}function Lp(e){switch(e){case`beforetoggle`:case`cancel`:case`click`:case`close`:case`contextmenu`:case`copy`:case`cut`:case`auxclick`:case`dblclick`:case`dragend`:case`dragstart`:case`drop`:case`focusin`:case`focusout`:case`input`:case`invalid`:case`keydown`:case`keypress`:case`keyup`:case`mousedown`:case`mouseup`:case`paste`:case`pause`:case`play`:case`pointercancel`:case`pointerdown`:case`pointerup`:case`ratechange`:case`reset`:case`resize`:case`seeked`:case`submit`:case`toggle`:case`touchcancel`:case`touchend`:case`touchstart`:case`volumechange`:case`change`:case`selectionchange`:case`textInput`:case`compositionstart`:case`compositionend`:case`compositionupdate`:case`beforeblur`:case`afterblur`:case`beforeinput`:case`blur`:case`fullscreenchange`:case`focus`:case`hashchange`:case`popstate`:case`select`:case`selectstart`:return 2;case`drag`:case`dragenter`:case`dragexit`:case`dragleave`:case`dragover`:case`mousemove`:case`mouseout`:case`mouseover`:case`pointermove`:case`pointerout`:case`pointerover`:case`scroll`:case`touchmove`:case`wheel`:case`mouseenter`:case`mouseleave`:case`pointerenter`:case`pointerleave`:return 8;case`message`:switch(Ie()){case Le:return 2;case Re:return 8;case ze:case Be:return 32;case Ve:return 268435456;default:return 32}default:return 32}}var Rp=!1,zp=null,Bp=null,Vp=null,Hp=new Map,Up=new Map,Wp=[],Gp=`mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset`.split(` `);function Kp(e,t){switch(e){case`focusin`:case`focusout`:zp=null;break;case`dragenter`:case`dragleave`:Bp=null;break;case`mouseover`:case`mouseout`:Vp=null;break;case`pointerover`:case`pointerout`:Hp.delete(t.pointerId);break;case`gotpointercapture`:case`lostpointercapture`:Up.delete(t.pointerId)}}function qp(e,t,n,r,i,a){return e===null||e.nativeEvent!==a?(e={blockedOn:t,domEventName:n,eventSystemFlags:r,nativeEvent:a,targetContainers:[i]},t!==null&&(t=Tt(t),t!==null&&Op(t)),e):(e.eventSystemFlags|=r,t=e.targetContainers,i!==null&&t.indexOf(i)===-1&&t.push(i),e)}function Jp(e,t,n,r,i){switch(t){case`focusin`:return zp=qp(zp,e,t,n,r,i),!0;case`dragenter`:return Bp=qp(Bp,e,t,n,r,i),!0;case`mouseover`:return Vp=qp(Vp,e,t,n,r,i),!0;case`pointerover`:var a=i.pointerId;return Hp.set(a,qp(Hp.get(a)||null,e,t,n,r,i)),!0;case`gotpointercapture`:return a=i.pointerId,Up.set(a,qp(Up.get(a)||null,e,t,n,r,i)),!0}return!1}function Yp(e){var t=wt(e.target);if(t!==null){var n=o(t);if(n!==null){if(t=n.tag,t===13){if(t=s(n),t!==null){e.blockedOn=t,pt(e.priority,function(){kp(n)});return}}else if(t===31){if(t=c(n),t!==null){e.blockedOn=t,pt(e.priority,function(){kp(n)});return}}else if(t===3&&n.stateNode.current.memoizedState.isDehydrated){e.blockedOn=n.tag===3?n.stateNode.containerInfo:null;return}}}e.blockedOn=null}function Xp(e){if(e.blockedOn!==null)return!1;for(var t=e.targetContainers;0<t.length;){var n=Pp(e.nativeEvent);if(n===null){n=e.nativeEvent;var r=new n.constructor(n.type,n);un=r,n.target.dispatchEvent(r),un=null}else return t=Tt(n),t!==null&&Op(t),e.blockedOn=n,!1;t.shift()}return!0}function Zp(e,t,n){Xp(e)&&n.delete(t)}function Qp(){Rp=!1,zp!==null&&Xp(zp)&&(zp=null),Bp!==null&&Xp(Bp)&&(Bp=null),Vp!==null&&Xp(Vp)&&(Vp=null),Hp.forEach(Zp),Up.forEach(Zp)}function $p(e,n){e.blockedOn===n&&(e.blockedOn=null,Rp||(Rp=!0,t.unstable_scheduleCallback(t.unstable_NormalPriority,Qp)))}var em=null;function tm(e){em!==e&&(em=e,t.unstable_scheduleCallback(t.unstable_NormalPriority,function(){em===e&&(em=null);for(var t=0;t<e.length;t+=3){var n=e[t],r=e[t+1],i=e[t+2];if(typeof r!=`function`){if(Ip(r||n)===null)continue;break}var a=Tt(n);a!==null&&(e.splice(t,3),t-=3,Bs(a,{pending:!0,data:i,method:n.method,action:r},r,i))}}))}function nm(e){function t(t){return $p(t,e)}zp!==null&&$p(zp,e),Bp!==null&&$p(Bp,e),Vp!==null&&$p(Vp,e),Hp.forEach(t),Up.forEach(t);for(var n=0;n<Wp.length;n++){var r=Wp[n];r.blockedOn===e&&(r.blockedOn=null)}for(;0<Wp.length&&(n=Wp[0],n.blockedOn===null);)Yp(n),n.blockedOn===null&&Wp.shift();if(n=(e.ownerDocument||e).$$reactFormReplay,n!=null)for(r=0;r<n.length;r+=3){var i=n[r],a=n[r+1],o=i[gt]||null;if(typeof a==`function`)o||tm(n);else if(o){var s=null;if(a&&a.hasAttribute(`formAction`)){if(i=a,o=a[gt]||null)s=o.formAction;else if(Ip(i)!==null)continue}else s=o.action;typeof s==`function`?n[r+1]=s:(n.splice(r,3),r-=3),tm(n)}}}function rm(){function e(e){e.canIntercept&&e.info===`react-transition`&&e.intercept({handler:function(){return new Promise(function(e){return i=e})},focusReset:`manual`,scroll:`manual`})}function t(){i!==null&&(i(),i=null),r||setTimeout(n,20)}function n(){if(!r&&!navigation.transition){var e=navigation.currentEntry;e&&e.url!=null&&navigation.navigate(e.url,{state:e.getState(),info:`react-transition`,history:`replace`})}}if(typeof navigation==`object`){var r=!1,i=null;return navigation.addEventListener(`navigate`,e),navigation.addEventListener(`navigatesuccess`,t),navigation.addEventListener(`navigateerror`,t),setTimeout(n,100),function(){r=!0,navigation.removeEventListener(`navigate`,e),navigation.removeEventListener(`navigatesuccess`,t),navigation.removeEventListener(`navigateerror`,t),i!==null&&(i(),i=null)}}}function im(e){this._internalRoot=e}am.prototype.render=im.prototype.render=function(e){var t=this._internalRoot;if(t===null)throw Error(i(409));var n=t.current,r=ju();Tp(n,r,e,t,null,null)},am.prototype.unmount=im.prototype.unmount=function(){var e=this._internalRoot;if(e!==null){this._internalRoot=null;var t=e.containerInfo;Tp(e.current,2,null,e,null,null),Ru(),t[_t]=null}};function am(e){this._internalRoot=e}am.prototype.unstable_scheduleHydration=function(e){if(e){var t=ft();e={blockedOn:null,target:e,priority:t};for(var n=0;n<Wp.length&&t!==0&&t<Wp[n].priority;n++);Wp.splice(n,0,e),n===0&&Yp(e)}};var om=n.version;if(om!==`19.2.0`)throw Error(i(527,om,`19.2.0`));ue.findDOMNode=function(e){var t=e._reactInternals;if(t===void 0)throw typeof e.render==`function`?Error(i(188)):(e=Object.keys(e).join(`,`),Error(i(268,e)));return e=u(t),e=e===null?null:d(e),e=e===null?null:e.stateNode,e};var sm={bundleType:0,version:`19.2.0`,rendererPackageName:`react-dom`,currentDispatcherRef:le,reconcilerVersion:`19.2.0`};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<`u`){var cm=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!cm.isDisabled&&cm.supportsFiber)try{We=cm.inject(sm),Ge=cm}catch{}}e.createRoot=function(e,t){if(!a(e))throw Error(i(299));var n=!1,r=``,o=lc,s=uc,c=dc;return t!=null&&(!0===t.unstable_strictMode&&(n=!0),t.identifierPrefix!==void 0&&(r=t.identifierPrefix),t.onUncaughtError!==void 0&&(o=t.onUncaughtError),t.onCaughtError!==void 0&&(s=t.onCaughtError),t.onRecoverableError!==void 0&&(c=t.onRecoverableError)),t=Cp(e,1,!1,null,null,n,r,null,o,s,c,rm),e[_t]=t.current,Wd(e),new im(t)}})),y=u(s(((e,t)=>{function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>`u`||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!=`function`))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}n(),t.exports=v()}))()),b=u(p()),x=s((e=>{var t=Symbol.for(`react.transitional.element`),n=Symbol.for(`react.fragment`);function r(e,n,r){var i=null;if(r!==void 0&&(i=``+r),n.key!==void 0&&(i=``+n.key),`key`in n)for(var a in r={},n)a!==`key`&&(r[a]=n[a]);else r=n;return n=r.ref,{$$typeof:t,type:e,key:i,ref:n===void 0?null:n,props:r}}e.Fragment=n,e.jsx=r,e.jsxs=r})),S=u(s(((e,t)=>{t.exports=x()}))()),C=(0,b.forwardRef)((e,t)=>{let[n,r]=(0,b.useState)(null),i=(0,b.useRef)(null);return(0,b.useEffect)(()=>((async()=>{r(null);try{let e=await navigator.mediaDevices.getUserMedia({video:!0});i.current=e,t.current&&(t.current.srcObject=e,t.current.onloadedmetadata=()=>{t.current.play()})}catch(e){console.error(`Erro ao acessar a cmera:`,e),r(`Acesso  cmera negado ou indisponvel.`)}})(),()=>{let e=i.current;e&&(e.getTracks().forEach(e=>{e.stop(),console.log(`Trilha de mdia ${e.kind} parada.`)}),i.current=null,console.log(`Cmera desligada (LED deve apagar).`))}),[t]),(0,S.jsx)(`div`,{className:`camera-container`,children:n?(0,S.jsx)(`div`,{className:`camera-error`,children:(0,S.jsxs)(`p`,{children:[` `,n]})}):(0,S.jsx)(`video`,{ref:t,autoPlay:!0,playsInline:!0,muted:!0,className:`video-element`})})}),w=({title:e,children:t})=>(0,S.jsxs)(`div`,{className:`card`,children:[(0,S.jsx)(`h3`,{className:`card-title`,children:e}),(0,S.jsx)(`div`,{className:`card-content`,children:t})]});function T(e){throw Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}var ee,E,te,ne,re=o((()=>{ee=1e-7,E=1e-4,te=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},ne=class{refCount(e){return T(`refCount`)}incRef(e){return T(`incRef`)}timerAvailable(){return!0}time(e){return T(`time`)}read(e){return T(`read`)}readSync(e){return T(`readSync`)}readToGPU(e,t){return T(`readToGPU`)}numDataIds(){return T(`numDataIds`)}disposeData(e,t){return T(`disposeData`)}write(e,t,n){return T(`write`)}move(e,t,n,r,i){return T(`move`)}createTensorFromGPUData(e,t,n){return T(`createTensorFromGPUData`)}memory(){return T(`memory`)}floatPrecision(){return T(`floatPrecision`)}epsilon(){return this.floatPrecision()===32?ee:E}dispose(){return T(`dispose`)}}}));
/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/
function ie(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,ce(e,t,n)}function ae(e,t){if(e.length!==t.length)throw Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,ce(e,n,r),ce(t,n,r)}function oe(e,t,n){return Math.max(e,Math.min(t,n))}function se(e){return e%2==0?e:e+1}function ce(e,t,n){let r=e[t];e[t]=e[n],e[n]=r}function le(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function ue(e,t){let n=Math.random();return t*n+(1-n)*e}function de(e,t){let n=0;for(let r=0;r<e.length;r++){let i=Number(e[r])-Number(t[r]);n+=i*i}return n}function D(e,t){if(!e)throw Error(typeof t==`string`?t:t())}function fe(e,t,n=``){D(ge(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function pe(e){D(e!=null,()=>`The input to the tensor constructor must be a non-null value.`)}function O(e){if(e.length===0)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function me(e){return e.length===0}function he(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==null&&t[n]!==null&&e[n]!==t[n])return!1;return!0}function ge(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function _e(e){return e%1==0}function ve(e){if(Math.tanh!=null)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function ye(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function be(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return ie(t),t}function xe(e,t){return t<=e.length?e:e+` `.repeat(t-e.length)}function Se(e,t=e=>0,n,r){return new Promise((i,a)=>{let o=0,s=()=>{if(e()){i();return}o++;let c=t(o);if(n!=null&&o>=n){a();return}r==null?setTimeout(s,c):r(s,c)};s()})}function Ce(e,t){let n=1,r=-1;for(let t=0;t<e.length;++t)if(e[t]>=0)n*=e[t];else if(e[t]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${t}`);r=t}else if(e[t]<0)throw Error(`Shapes can not be < 0. Found ${e[t]} at dim ${t}`);if(r===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(n===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let i=e.slice();return i[r]=t/n,i}function we(e,t){let n=t.length;return e=e==null?t.map((e,t)=>t):[].concat(e),D(e.every(e=>e>=-n&&e<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),D(e.every(e=>_e(e)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(e=>e<0?n+e:e)}function Te(e,t){let n=[],r=[],i=t!=null&&Array.isArray(t)&&t.length===0,a=t==null||i?null:we(t,e).sort(),o=0;for(let t=0;t<e.length;++t){if(a!=null){if(a[o]===t&&e[t]!==1)throw Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);(a[o]==null||a[o]>t)&&e[t]===1&&(n.push(e[t]),r.push(t)),a[o]<=t&&o++}e[t]!==1&&(n.push(e[t]),r.push(t))}return{newShape:n,keptDims:r}}function Ee(e,t){return De(e,t)}function De(e,t){let n=null;if(e==null||e===`float32`)n=new Float32Array(t);else if(e===`int32`)n=new Int32Array(t);else if(e===`bool`)n=new Uint8Array(t);else if(e===`string`)n=Array(t);else throw Error(`Unknown data type ${e}`);return n}function Oe(e,t){for(let n=0;n<e.length;n++){let r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function ke(e){return e===`bool`||e===`complex64`||e===`float32`||e===`int32`||e===`string`}function Ae(e,t){return!(t===`complex64`||t===`float32`&&e!==`complex64`||t===`int32`&&e!==`float32`&&e!==`complex64`||t===`bool`&&e===`bool`)}function je(e){if(e===`float32`||e===`int32`)return 4;if(e===`complex64`)return 8;if(e===`bool`)return 1;throw Error(`Unknown dtype ${e}`)}function Me(e){if(e==null)return 0;let t=0;return e.forEach(e=>t+=e.length),t}function Ne(e){return typeof e==`string`||e instanceof String}function Pe(e){return typeof e==`boolean`}function Fe(e){return typeof e==`number`}function Ie(e){return Array.isArray(e)?Ie(e[0]):e instanceof Float32Array?`float32`:e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?`int32`:Fe(e)?`float32`:Ne(e)?`string`:Pe(e)?`bool`:`float32`}function Le(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Re(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function ze(e){let t=e.length;if(t<2)return[];let n=Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function Be(e,t,n,r=!1){let i=[];if(t.length===1){let a=t[0]*(r?2:1);for(let t=0;t<a;t++)i[t]=n[e+t]}else{let a=t[0],o=t.slice(1),s=o.reduce((e,t)=>e*t)*(r?2:1);for(let t=0;t<a;t++)i[t]=Be(e+t*s,o,n,r)}return i}function Ve(e,t,n=!1){if(e.length===0)return t[0];let r=e.reduce((e,t)=>e*t)*(n?2:1);if(r===0)return[];if(r!==t.length)throw Error(`[${e}] does not match the input size ${t.length}${n?` for a complex tensor`:``}.`);return Be(0,e,t,n)}function He(e,t){if(Array.isArray(e))return e;if(t===`float32`)return e instanceof Float32Array?e:new Float32Array(e);if(t===`int32`)return e instanceof Int32Array?e:new Int32Array(e);if(t===`bool`||t===`string`)return Uint8Array.from(new Int32Array(e));throw Error(`Unknown dtype ${t}`)}function Ue(e,t){let n=We(e,t);for(let e=0;e<n.length;e++)n[e]=1;return n}function We(e,t){if(t==null||t===`float32`||t===`complex64`)return new Float32Array(e);if(t===`int32`)return new Int32Array(e);if(t===`bool`)return new Uint8Array(e);throw Error(`Unknown data type ${t}`)}function Ge(e,t){let n=e.reduce((e,t)=>e*t,1);if(t==null||t===`float32`)return Ve(e,new Float32Array(n));if(t===`int32`)return Ve(e,new Int32Array(n));if(t===`bool`)return Ve(e,new Uint8Array(n));throw Error(`Unknown data type ${t}`)}function Ke(e){e.forEach(t=>{D(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function qe(e,t,n){if(t===0)return 0;if(t===1)return e[0];let r=e[e.length-1];for(let t=0;t<e.length-1;++t)r+=n[t]*e[t];return r}function Je(e,t,n){if(t===0)return[];if(t===1)return[e];let r=Array(t);for(let t=0;t<r.length-1;++t)r[t]=Math.floor(e/n[t]),e-=r[t]*n[t];return r[r.length-1]=e,r}function Ye(e){return e&&e.then&&typeof e.then==`function`}var Xe=o((()=>{}));function Ze(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...n)=>(Qe(t,n[0],n[1]),n.join(`=`))),t}function Qe(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||``)}function $e(e,t){let n=t.toLowerCase();return n===`true`||n===`false`?n===`true`:`${+n}`===n?+n:t}function k(){return rt}function et(e){rt=e}var tt,nt,rt,it=o((()=>{Xe(),tt=`tfjsflags`,nt=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Ze,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(k().getBool(`IS_TEST`)||k().getBool(`PROD`)||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},this.urlFlags[e]!=null){let t=this.urlFlags[e];k().getBool(`IS_TEST`)||k().getBool(`PROD`)||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(Ye(t))throw Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(this.global===void 0||this.global.location===void 0||this.global.location.search===void 0)return;let e=this.getQueryParams(this.global.location.search);tt in e&&e[tt].split(`,`).forEach(e=>{let[t,n]=e.split(`:`);this.urlFlags[t]=$e(t,n)})}},rt=null}));function at(){if(ct==null){let e;if(typeof window<`u`)e=window;else if(typeof global<`u`)e=global;else if(typeof process<`u`)e=process;else if(typeof self<`u`)e=self;else throw Error(`Could not find a global object`);ct=e}return ct}function ot(){let e=at();return e._tfGlobals??=new Map,e._tfGlobals}function st(e,t){let n=ot();if(n.has(e))return n.get(e);{let r=t();return n.set(e,r),n.get(e)}}var ct,lt=o((()=>{})),ut,dt,ft,pt,mt,ht,gt,_t,vt,yt,bt,xt,St,Ct,wt,Tt,Et,Dt,Ot,kt,At,jt,Mt,Nt,Pt,Ft,It,Lt,Rt,zt,Bt,Vt,Ht,Ut,Wt,Gt,Kt,qt,Jt,Yt,Xt,Zt,Qt,$t,en,tn,nn,rn,an,on,sn,cn,ln,un,dn,fn,pn,mn,hn,gn,_n,vn,yn,bn,xn,Sn,Cn,wn,Tn,En,Dn,On,kn,An,jn,Mn,Nn,Pn,Fn,In,Ln,Rn,zn,Bn,Vn,Hn,Un,Wn,Gn,Kn,qn,Jn,Yn,Xn,Zn,Qn,$n,er,tr,nr,rr,ir,ar,or,sr,cr,lr,ur,dr,fr,pr,mr,hr,gr,_r,vr,yr,br,xr,Sr,Cr,wr,Tr,Er,Dr,Or,kr,Ar,jr,Mr,Nr,Pr,Fr,Ir,Lr,Rr,zr,Br,Vr,Hr,Ur,Wr,Gr,Kr,qr,Jr,Yr,Xr,Zr,Qr,$r,ei,ti,ni,ri,ii,ai,oi,si,ci,A=o((()=>{ut=`Acos`,dt=`Acosh`,ft=`AddN`,pt=`ArgMax`,mt=`ArgMin`,ht=`Asin`,gt=`Asinh`,_t=`Atan`,vt=`Atanh`,yt=`Atan2`,bt=`AvgPool`,xt=`AvgPoolGrad`,St=`AvgPool3D`,Ct=`AvgPool3DGrad`,wt=`BatchMatMul`,Tt=`BatchToSpaceND`,Et=`Bincount`,Dt=`BitwiseAnd`,Ot=`BroadcastTo`,kt=`BroadcastArgs`,At=`Cast`,jt=`Ceil`,Mt=`ClipByValue`,Nt=`Complex`,Pt=`ComplexAbs`,Ft=`Concat`,It=`Conv2D`,Lt=`Conv2DBackpropFilter`,Rt=`Conv2DBackpropInput`,zt=`Conv3D`,Bt=`Conv3DBackpropFilterV2`,Vt=`Conv3DBackpropInputV2`,Ht=`Cosh`,Ut=`Cumprod`,Wt=`Cumsum`,Gt=`CropAndResize`,Kt=`DenseBincount`,qt=`DepthToSpace`,Jt=`DepthwiseConv2dNative`,Yt=`DepthwiseConv2dNativeBackpropFilter`,Xt=`DepthwiseConv2dNativeBackpropInput`,Zt=`Diag`,Qt=`Dilation2D`,$t=`Dilation2DBackpropInput`,en=`Dilation2DBackpropFilter`,tn=`Draw`,nn=`RealDiv`,rn=`Einsum`,an=`EluGrad`,on=`Equal`,sn=`ExpandDims`,cn=`Expm1`,ln=`Fill`,un=`FlipLeftRight`,dn=`Floor`,fn=`FloorDiv`,pn=`FusedBatchNorm`,mn=`GatherV2`,hn=`GatherNd`,gn=`Greater`,_n=`GreaterEqual`,vn=`Identity`,yn=`IFFT`,bn=`Imag`,xn=`IsFinite`,Sn=`IsInf`,Cn=`IsNan`,wn=`LeakyRelu`,Tn=`Less`,En=`LessEqual`,Dn=`LinSpace`,On=`Log1p`,kn=`LogicalAnd`,An=`LogicalNot`,jn=`LogicalOr`,Mn=`LogicalXor`,Nn=`LogSoftmax`,Pn=`LowerBound`,Fn=`LRNGrad`,In=`MatrixBandPart`,Ln=`Maximum`,Rn=`MaxPool`,zn=`MaxPoolGrad`,Bn=`MaxPool3D`,Vn=`MaxPool3DGrad`,Hn=`MaxPoolWithArgmax`,Un=`Mean`,Wn=`Minimum`,Gn=`MirrorPad`,Kn=`Multinomial`,qn=`Multiply`,Jn=`NotEqual`,Yn=`NonMaxSuppressionV3`,Xn=`NonMaxSuppressionV4`,Zn=`NonMaxSuppressionV5`,Qn=`OnesLike`,$n=`OneHot`,er=`Pack`,tr=`PadV2`,nr=`Pool`,rr=`Prelu`,ir=`Prod`,ar=`RaggedGather`,or=`RaggedRange`,sr=`RaggedTensorToTensor`,cr=`Range`,lr=`Real`,ur=`Reciprocal`,dr=`Relu`,fr=`Reshape`,pr=`ResizeNearestNeighbor`,mr=`ResizeNearestNeighborGrad`,hr=`ResizeBilinear`,gr=`ResizeBilinearGrad`,_r=`Relu6`,vr=`Reverse`,yr=`Round`,br=`Rsqrt`,xr=`ScatterNd`,Sr=`TensorScatterUpdate`,Cr=`SearchSorted`,wr=`Select`,Tr=`Selu`,Er=`Slice`,Dr=`Sinh`,Or=`Sign`,kr=`Sigmoid`,Ar=`Softplus`,jr=`Sqrt`,Mr=`SpaceToBatchND`,Nr=`SplitV`,Pr=`Softmax`,Fr=`SparseFillEmptyRows`,Ir=`SparseReshape`,Lr=`SparseSegmentMean`,Rr=`SparseSegmentSum`,zr=`SparseToDense`,Br=`SquaredDifference`,Vr=`Square`,Hr=`StaticRegexReplace`,Ur=`StridedSlice`,Wr=`StringNGrams`,Gr=`StringSplit`,Kr=`StringToHashBucketFast`,qr=`Tanh`,Jr=`Tile`,Yr=`TopK`,Xr=`Transform`,Zr=`Transpose`,Qr=`Unique`,$r=`Unpack`,ei=`UnsortedSegmentSum`,ti=`UpperBound`,ni=`ZerosLike`,ri=`Step`,ii=`FromPixels`,ai=`RotateWithOffset`,oi=`_FusedMatMul`,si=`FusedConv2D`,ci=`FusedDepthwiseConv2D`}));function li(...e){k().getBool(`IS_TEST`)||k().getBool(`PROD`)||console.warn(...e)}function ui(...e){k().getBool(`IS_TEST`)||k().getBool(`PROD`)||console.log(...e)}var di=o((()=>{it()}));function fi(e,t){let n=bi(e,t);return xi.get(n)}function pi(e){return Si.get(e)}function mi(e){let t=xi.entries(),n=[];for(;;){let{done:r,value:i}=t.next();if(r)break;let[a,o]=i,[s]=a.split(`_`);s===e&&n.push(o)}return n}function hi(e){let{kernelName:t,backendName:n}=e,r=bi(t,n);xi.has(r)&&li(`The kernel '${t}' for backend '${n}' is already registered`),xi.set(r,e)}function gi(e){let{kernelName:t}=e;Si.has(t)&&k().getBool(`DEBUG`)&&li(`Overriding the gradient for '${t}'`),Si.set(t,e)}function _i(e,t){let n=bi(e,t);if(!xi.has(n))throw Error(`The kernel '${e}' for backend '${t}' is not registered`);xi.delete(n)}function vi(e){if(!Si.has(e))throw Error(`The gradient '${e}' for backend is not registered`);Si.delete(e)}function yi(e,t){mi(e).forEach(e=>{let n=Object.assign({},e,{backendName:t});hi(n)})}function bi(e,t){return`${t}_${e}`}var xi,Si,Ci=o((()=>{it(),lt(),di(),xi=st(`kernelRegistry`,()=>new Map),Si=st(`gradRegistry`,()=>new Map)}));
/**
* @license
* Copyright 2023 Google LLC.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/
function wi(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var Ti=o((()=>{})),Ei=s(((e,t)=>{t.exports=r;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function r(e,t,n){this.low=e|0,this.high=t|0,this.unsigned=!!n}r.prototype.__isLong__,Object.defineProperty(r.prototype,`__isLong__`,{value:!0});function i(e){return(e&&e.__isLong__)===!0}r.isLong=i;var a={},o={};function s(e,t){var n,r,i;return t?(e>>>=0,(i=0<=e&&e<256)&&(r=o[e],r)?r:(n=l(e,(e|0)<0?-1:0,!0),i&&(o[e]=n),n)):(e|=0,(i=-128<=e&&e<128)&&(r=a[e],r)?r:(n=l(e,e<0?-1:0,!1),i&&(a[e]=n),n))}r.fromInt=s;function c(e,t){if(isNaN(e))return t?b:y;if(t){if(e<0)return b;if(e>=g)return T}else{if(e<=-_)return ee;if(e+1>=_)return w}return e<0?c(-e,t).neg():l(e%h|0,e/h|0,t)}r.fromNumber=c;function l(e,t,n){return new r(e,t,n)}r.fromBits=l;var u=Math.pow;function d(e,t,n){if(e.length===0)throw Error(`empty string`);if(e===`NaN`||e===`Infinity`||e===`+Infinity`||e===`-Infinity`)return y;if(typeof t==`number`?(n=t,t=!1):t=!!t,n||=10,n<2||36<n)throw RangeError(`radix`);var r;if((r=e.indexOf(`-`))>0)throw Error(`interior hyphen`);if(r===0)return d(e.substring(1),t,n).neg();for(var i=c(u(n,8)),a=y,o=0;o<e.length;o+=8){var s=Math.min(8,e.length-o),l=parseInt(e.substring(o,o+s),n);if(s<8){var f=c(u(n,s));a=a.mul(f).add(c(l))}else a=a.mul(i),a=a.add(c(l))}return a.unsigned=t,a}r.fromString=d;function f(e,t){return typeof e==`number`?c(e,t):typeof e==`string`?d(e,t):l(e.low,e.high,typeof t==`boolean`?t:e.unsigned)}r.fromValue=f;var p=65536,m=1<<24,h=p*p,g=h*h,_=g/2,v=s(m),y=s(0);r.ZERO=y;var b=s(0,!0);r.UZERO=b;var x=s(1);r.ONE=x;var S=s(1,!0);r.UONE=S;var C=s(-1);r.NEG_ONE=C;var w=l(-1,2147483647,!1);r.MAX_VALUE=w;var T=l(-1,-1,!0);r.MAX_UNSIGNED_VALUE=T;var ee=l(0,-2147483648,!1);r.MIN_VALUE=ee;var E=r.prototype;E.toInt=function(){return this.unsigned?this.low>>>0:this.low},E.toNumber=function(){return this.unsigned?(this.high>>>0)*h+(this.low>>>0):this.high*h+(this.low>>>0)},E.toString=function(e){if(e||=10,e<2||36<e)throw RangeError(`radix`);if(this.isZero())return`0`;if(this.isNegative())if(this.eq(ee)){var t=c(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}else return`-`+this.neg().toString(e);for(var i=c(u(e,6),this.unsigned),a=this,o=``;;){var s=a.div(i),l=(a.sub(s.mul(i)).toInt()>>>0).toString(e);if(a=s,a.isZero())return l+o;for(;l.length<6;)l=`0`+l;o=``+l+o}},E.getHighBits=function(){return this.high},E.getHighBitsUnsigned=function(){return this.high>>>0},E.getLowBits=function(){return this.low},E.getLowBitsUnsigned=function(){return this.low>>>0},E.getNumBitsAbs=function(){if(this.isNegative())return this.eq(ee)?64:this.neg().getNumBitsAbs();for(var e=this.high==0?this.low:this.high,t=31;t>0&&!(e&1<<t);t--);return this.high==0?t+1:t+33},E.isZero=function(){return this.high===0&&this.low===0},E.eqz=E.isZero,E.isNegative=function(){return!this.unsigned&&this.high<0},E.isPositive=function(){return this.unsigned||this.high>=0},E.isOdd=function(){return(this.low&1)==1},E.isEven=function(){return(this.low&1)==0},E.equals=function(e){return i(e)||(e=f(e)),this.unsigned!==e.unsigned&&this.high>>>31==1&&e.high>>>31==1?!1:this.high===e.high&&this.low===e.low},E.eq=E.equals,E.notEquals=function(e){return!this.eq(e)},E.neq=E.notEquals,E.ne=E.notEquals,E.lessThan=function(e){return this.comp(e)<0},E.lt=E.lessThan,E.lessThanOrEqual=function(e){return this.comp(e)<=0},E.lte=E.lessThanOrEqual,E.le=E.lessThanOrEqual,E.greaterThan=function(e){return this.comp(e)>0},E.gt=E.greaterThan,E.greaterThanOrEqual=function(e){return this.comp(e)>=0},E.gte=E.greaterThanOrEqual,E.ge=E.greaterThanOrEqual,E.compare=function(e){if(i(e)||(e=f(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},E.comp=E.compare,E.negate=function(){return!this.unsigned&&this.eq(ee)?ee:this.not().add(x)},E.neg=E.negate,E.add=function(e){i(e)||(e=f(e));var t=this.high>>>16,n=this.high&65535,r=this.low>>>16,a=this.low&65535,o=e.high>>>16,s=e.high&65535,c=e.low>>>16,u=e.low&65535,d=0,p=0,m=0,h=0;return h+=a+u,m+=h>>>16,h&=65535,m+=r+c,p+=m>>>16,m&=65535,p+=n+s,d+=p>>>16,p&=65535,d+=t+o,d&=65535,l(m<<16|h,d<<16|p,this.unsigned)},E.subtract=function(e){return i(e)||(e=f(e)),this.add(e.neg())},E.sub=E.subtract,E.multiply=function(e){if(this.isZero())return y;if(i(e)||(e=f(e)),n){var t=n.mul(this.low,this.high,e.low,e.high);return l(t,n.get_high(),this.unsigned)}if(e.isZero())return y;if(this.eq(ee))return e.isOdd()?ee:y;if(e.eq(ee))return this.isOdd()?ee:y;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(v)&&e.lt(v))return c(this.toNumber()*e.toNumber(),this.unsigned);var r=this.high>>>16,a=this.high&65535,o=this.low>>>16,s=this.low&65535,u=e.high>>>16,d=e.high&65535,p=e.low>>>16,m=e.low&65535,h=0,g=0,_=0,b=0;return b+=s*m,_+=b>>>16,b&=65535,_+=o*m,g+=_>>>16,_&=65535,_+=s*p,g+=_>>>16,_&=65535,g+=a*m,h+=g>>>16,g&=65535,g+=o*p,h+=g>>>16,g&=65535,g+=s*d,h+=g>>>16,g&=65535,h+=r*m+a*p+o*d+s*u,h&=65535,l(_<<16|b,h<<16|g,this.unsigned)},E.mul=E.multiply,E.divide=function(e){if(i(e)||(e=f(e)),e.isZero())throw Error(`division by zero`);if(n){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var t=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,e.low,e.high);return l(t,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?b:y;var r,a,o;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return b;if(e.gt(this.shru(1)))return S;o=b}else{if(this.eq(ee))return e.eq(x)||e.eq(C)?ee:e.eq(ee)?x:(r=this.shr(1).div(e).shl(1),r.eq(y)?e.isNegative()?x:C:(a=this.sub(e.mul(r)),o=r.add(a.div(e)),o));if(e.eq(ee))return this.unsigned?b:y;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();o=y}for(a=this;a.gte(e);){r=Math.max(1,Math.floor(a.toNumber()/e.toNumber()));for(var s=Math.ceil(Math.log(r)/Math.LN2),d=s<=48?1:u(2,s-48),p=c(r),m=p.mul(e);m.isNegative()||m.gt(a);)r-=d,p=c(r,this.unsigned),m=p.mul(e);p.isZero()&&(p=x),o=o.add(p),a=a.sub(m)}return o},E.div=E.divide,E.modulo=function(e){if(i(e)||(e=f(e)),n){var t=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,e.low,e.high);return l(t,n.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))},E.mod=E.modulo,E.rem=E.modulo,E.not=function(){return l(~this.low,~this.high,this.unsigned)},E.and=function(e){return i(e)||(e=f(e)),l(this.low&e.low,this.high&e.high,this.unsigned)},E.or=function(e){return i(e)||(e=f(e)),l(this.low|e.low,this.high|e.high,this.unsigned)},E.xor=function(e){return i(e)||(e=f(e)),l(this.low^e.low,this.high^e.high,this.unsigned)},E.shiftLeft=function(e){return i(e)&&(e=e.toInt()),(e&=63)==0?this:e<32?l(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):l(0,this.low<<e-32,this.unsigned)},E.shl=E.shiftLeft,E.shiftRight=function(e){return i(e)&&(e=e.toInt()),(e&=63)==0?this:e<32?l(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):l(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},E.shr=E.shiftRight,E.shiftRightUnsigned=function(e){if(i(e)&&(e=e.toInt()),e&=63,e===0)return this;var t=this.high;if(e<32){var n=this.low;return l(n>>>e|t<<32-e,t>>>e,this.unsigned)}else if(e===32)return l(t,0,this.unsigned);else return l(t>>>e-32,0,this.unsigned)},E.shru=E.shiftRightUnsigned,E.shr_u=E.shiftRightUnsigned,E.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},E.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},E.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},E.toBytesLE=function(){var e=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]},E.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,t>>>24,t>>>16&255,t>>>8&255,t&255]},r.fromBytes=function(e,t,n){return n?r.fromBytesLE(e,t):r.fromBytesBE(e,t)},r.fromBytesLE=function(e,t){return new r(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},r.fromBytesBE=function(e,t){return new r(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}}));function Di(e){return Vi.fromString(e,!0,16)}function Oi(e){return e.xor(e.shru(47))}function ki(e,t,n){let r=e.slice(t,t+n);return Vi.fromBytes(Array.from(r),!0,!0)}function Ai(e,t){return ki(e,t,8)}function ji(e,t){return ki(e,t,4)}function Mi(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function Ni(e,t,n=Di(`9ddfea08eb382d69`)){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let i=t.xor(r).mul(n);return i=i.xor(i.shru(47)),i=i.mul(n),i}function Pi(e,t,n,r,i,a){i=i.add(e),a=Mi(a.add(i).add(r),21);let o=i;return i=i.add(t),i=i.add(n),a=a.add(Mi(i,44)),[i.add(r),a.add(o)]}function Fi(e,t,n,r){return Pi(Ai(e,t),Ai(e,t+8),Ai(e,t+16),Ai(e,t+24),n,r)}function Ii(e,t=e.length){if(t>=8){let n=Wi.add(t*2),r=Ai(e,0).add(Wi),i=Ai(e,t-8),a=Mi(i,37).mul(n).add(r),o=Mi(r,25).add(i).mul(n);return Ni(a,o,n)}if(t>=4){let n=Wi.add(t*2),r=ji(e,0);return Ni(r.shl(3).add(t),ji(e,t-4),n)}if(t>0){let n=e[0],r=e[t>>1],i=e[t-1],a=n+(r<<8),o=t+(i<<2);return Oi(Wi.mul(a).xor(Hi.mul(o))).mul(Wi)}return Wi}function Li(e,t=e.length){let n=Wi.add(t*2),r=Ai(e,0).mul(Ui),i=Ai(e,8),a=Ai(e,t-8).mul(n),o=Ai(e,t-16).mul(Wi);return Ni(Mi(r.add(i),43).add(Mi(a,30)).add(o),r.add(Mi(i.add(Wi),18)).add(a),n)}function Ri(e,t=e.length){let n=Wi.add(t*2),r=Ai(e,0).mul(Wi),i=Ai(e,8),a=Ai(e,t-8).mul(n),o=Ai(e,t-16).mul(Wi),s=Mi(r.add(i),43).add(Mi(a,30)).add(o),c=Ni(s,r.add(Mi(i.add(Wi),18)).add(a),n),l=Ai(e,16).mul(n),u=Ai(e,24),d=s.add(Ai(e,t-32)).mul(n),f=c.add(Ai(e,t-24)).mul(n);return Ni(Mi(l.add(u),43).add(Mi(d,30)).add(f),l.add(Mi(u.add(r),18)).add(d),n)}function zi(e,t=e.length){let n=Vi.fromNumber(81,!0);if(t<=32)return t<=16?Ii(e,t):Li(e,t);if(t<=64)return Ri(e,t);let r=n,i=n.mul(Ui).add(113),a=Oi(i.mul(Wi).add(113)).mul(Wi),o=[Vi.UZERO,Vi.UZERO],s=[Vi.UZERO,Vi.UZERO];r=r.mul(Wi).add(Ai(e,0));let c=0,l=(t-1>>6)*64,u=l+(t-1&63)-63;do r=Mi(r.add(i).add(o[0]).add(Ai(e,c+8)),37).mul(Ui),i=Mi(i.add(o[1]).add(Ai(e,c+48)),42).mul(Ui),r=r.xor(s[1]),i=i.add(o[0]).add(Ai(e,c+40)),a=Mi(a.add(s[0]),33).mul(Ui),o=Fi(e,c,o[1].mul(Ui),r.add(s[0])),s=Fi(e,c+32,a.add(s[1]),i.add(Ai(e,c+16))),[a,r]=[r,a],c+=64;while(c!==l);let d=Ui.add(a.and(255).shl(1));return c=u,s[0]=s[0].add(t-1&63),o[0]=o[0].add(s[0]),s[0]=s[0].add(o[0]),r=Mi(r.add(i).add(o[0]).add(Ai(e,c+8)),37).mul(d),i=Mi(i.add(o[1]).add(Ai(e,c+48)),42).mul(d),r=r.xor(s[1].mul(9)),i=i.add(o[0].mul(9).add(Ai(e,c+40))),a=Mi(a.add(s[0]),33).mul(d),o=Fi(e,c,o[1].mul(d),r.add(s[0])),s=Fi(e,c+32,a.add(s[1]),i.add(Ai(e,c+16))),[a,r]=[r,a],Ni(Ni(o[0],s[0],d).add(Oi(i).mul(Hi)).add(a),Ni(o[1],s[1],d).add(r),d)}var Bi,Vi,Hi,Ui,Wi,Gi=o((()=>{Bi=u(Ei()),Vi=Bi.default||Bi,Hi=Di(`c3a5c85c97cb3127`),Ui=Di(`b492b66fbe98f273`),Wi=Di(`9ae16a3b2f90404f`)})),Ki=c({arraysEqual:()=>ge,arraysEqualWithNull:()=>he,assert:()=>D,assertNonNegativeIntegerDimensions:()=>Ke,assertNonNull:()=>pe,assertShapesMatch:()=>fe,bytesFromStringArray:()=>Me,bytesPerElement:()=>je,checkConversionForErrors:()=>Oe,clamp:()=>oe,computeStrides:()=>ze,convertBackendValuesAndArrayBuffer:()=>He,createScalarValue:()=>qi,createShuffledIndices:()=>be,decodeString:()=>$i,distSquared:()=>de,encodeString:()=>Qi,fetch:()=>Zi,fingerPrint64:()=>zi,flatten:()=>ta,getArrayFromDType:()=>De,getTypedArrayFromDType:()=>Ee,hasEncodingLoss:()=>Ae,hexToLong:()=>Di,indexToLoc:()=>Je,inferDtype:()=>Ie,inferFromImplicitShape:()=>Ce,isBoolean:()=>Pe,isFunction:()=>Le,isInt:()=>_e,isNumber:()=>Fe,isPromise:()=>Ye,isScalarShape:()=>me,isString:()=>Ne,isTypedArray:()=>ea,isValidDtype:()=>ke,locToIndex:()=>qe,makeOnesTypedArray:()=>Ue,makeZerosNestedTypedArray:()=>Ge,makeZerosTypedArray:()=>We,nearestDivisor:()=>Re,nearestLargerEven:()=>se,now:()=>Xi,parseAxisParam:()=>we,randUniform:()=>ue,repeatedTry:()=>Se,rightPad:()=>xe,shuffle:()=>ie,shuffleCombo:()=>ae,sizeFromShape:()=>O,sizeToSquarishShape:()=>ye,squeezeShape:()=>Te,sum:()=>le,swap:()=>ce,tanh:()=>ve,toNestedArray:()=>Ve,toTypedArray:()=>Yi});function qi(e,t){return t===`string`?Qi(e):Yi([e],t)}function Ji(e,t){return e instanceof Float32Array&&t===`float32`||e instanceof Int32Array&&t===`int32`||e instanceof Uint8Array&&t===`bool`}function Yi(e,t){if(t===`string`)throw Error(`Cannot convert a string[] to a TypedArray`);if(Array.isArray(e)&&(e=ta(e)),k().getBool(`DEBUG`)&&Oe(e,t),Ji(e,t))return e;if(t==null||t===`float32`||t===`complex64`)return new Float32Array(e);if(t===`int32`)return new Int32Array(e);if(t===`bool`){let t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)Math.round(e[n])!==0&&(t[n]=1);return t}else throw Error(`Unknown data type ${t}`)}function Xi(){return k().platform.now()}function Zi(e,t){return k().platform.fetch(e,t)}function Qi(e,t=`utf-8`){return t||=`utf-8`,k().platform.encode(e,t)}function $i(e,t=`utf-8`){return t||=`utf-8`,k().platform.decode(e,t)}function ea(e){return k().platform.isTypedArray==null?wi(e):k().platform.isTypedArray(e)}function ta(e,t=[],n=!1){if(t??=[],typeof e==`boolean`||typeof e==`number`||typeof e==`string`||Ye(e)||e==null||ea(e)&&n)t.push(e);else if(Array.isArray(e)||ea(e))for(let r=0;r<e.length;++r)ta(e[r],t,n);else{let r=-1;for(let t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(r=Math.max(r,Number(t)));for(let i=0;i<=r;i++)ta(e[i],t,n)}return t}var j=o((()=>{it(),Ti(),Xe(),Xe(),Gi()}));function na(e,t,n){if(t!==`float32`)return!1;for(let t=0;t<e.length;t++){let r=e[t];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}var ra,ia,aa=o((()=>{it(),j(),ra=class{constructor(e,t){this.backendTimer=e,this.logger=t,t??(this.logger=new ia)}profileKernel(e,t,n){let r,i=()=>{r=n()},a,o=Xi();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(i);else{i();for(let e of r)e.dataSync();a=Promise.resolve({kernelMs:Xi()-o})}if(k().getBool(`CHECK_COMPUTATION_FOR_ERRORS`))for(let t=0;t<r.length;t++){let n=r[t];n.data().then(t=>{na(t,n.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then(e=>e.kernelMs),extraInfo:a.then(e=>e.getExtraProfileInfo==null?``:e.getExtraProfileInfo())}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:r,inputs:i,extraInfo:a}=e;n.forEach(e=>{Promise.all([e.data(),r,a]).then(n=>{this.logger.logKernelProfile(t,e,n[0],n[1],i,n[2])})})}},ia=class{logKernelProfile(e,t,n,r,i,a){let o=typeof r==`number`?xe(`${r}ms`,9):r.error,s=xe(e,25),c=t.rank,l=t.size,u=xe(t.shape.toString(),14),d=``;for(let e in i){let n=i[e];if(n!=null){let r=n.shape||t.shape,i=r.length;d+=`${e}: ${i}D ${i>0?r:``} `}}console.log(`%c${s}\t%c${o}\t%c${c}D ${u}\t%c${l}\t%c${d}\t%c${a}`,`font-weight:bold`,`color:red`,`color:blue`,`color: orange`,`color: green`,`color: steelblue`)}}}));function oa(e,t,n){let r={},i={};for(let e=0;e<t.length;e++)r[t[e].id]=!0;for(let n=0;n<e.length;n++){let a=e[n],o=a.inputs;for(let e in o){let n=o[e],s=!1;for(let e=0;e<t.length;e++)if(r[n.id]){a.outputs.forEach(e=>r[e.id]=!0),s=!0,i[a.id]=!0;break}if(s)break}}let a={};a[n.id]=!0;let o={};for(let t=e.length-1;t>=0;t--){let n=e[t],r=n.inputs;for(let e=0;e<n.outputs.length;e++)if(a[n.outputs[e].id]){for(let e in r)a[r[e].id]=!0,o[n.id]=!0;break}}let s=[];for(let t=0;t<e.length;t++){let n=e[t];if(i[n.id]&&o[n.id]){let e={};for(let t in n.inputs){let i=n.inputs[t];r[i.id]&&(e[t]=i)}let t=Object.assign({},n);t.inputs=e,t.outputs=n.outputs,s.push(t)}}return s}function sa(e,t,n,r){for(let i=t.length-1;i>=0;i--){let a=t[i],o=[];if(a.outputs.forEach(t=>{let n=e[t.id];n==null?o.push(null):o.push(n)}),a.gradient==null)throw Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);let s=a.gradient(o);for(let t in a.inputs){if(!(t in s))throw Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(s)}.`);let i=n(()=>s[t]());if(i.dtype!==`float32`)throw Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${i.dtype}'`);let o=a.inputs[t];if(!ge(i.shape,o.shape))throw Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${t}' has shape '${i.shape}', which does not match the shape of the input '${o.shape}'`);if(e[o.id]==null)e[o.id]=i;else{let t=e[o.id];e[o.id]=r(t,i),t.dispose()}}}}var ca=o((()=>{j()}));function la(e,t,n,r){let i=ze(t),a=ua(e,t,n,i),o=t.length,s=pa(e,t,n,i,a),c=[`Tensor`];return r&&(c.push(`  dtype: ${n}`),c.push(`  rank: ${o}`),c.push(`  shape: [${t}]`),c.push(`  values:`)),c.push(s.map(e=>`    `+e).join(`
`)),c.join(`
`)}function ua(e,t,n,r){let i=O(t),a=r[r.length-1],o=Array(a).fill(0),s=t.length,c=n===`complex64`?ma(e):e;if(s>1)for(let e=0;e<i/a;e++){let t=e*a;for(let e=0;e<a;e++)o[e]=Math.max(o[e],da(c[t+e],0,n).length)}return o}function da(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(_a))} + ${parseFloat(e[1].toFixed(_a))}j`:Ne(e)?`'${e}'`:n===`bool`?fa(e):parseFloat(e.toFixed(_a)).toString(),xe(r,t)}function fa(e){return e===0?`false`:`true`}function pa(e,t,n,r,i,a=!0){let o=n===`complex64`?2:1,s=t[0],c=t.length;if(c===0){if(n===`complex64`){let t=ma(e);return[da(t[0],0,n)]}return n===`bool`?[fa(e[0])]:[e[0].toString()]}if(c===1){if(s>ha){let t=ga*o,r=Array.from(e.slice(0,t)),a=Array.from(e.slice((s-ga)*o,s*o));return n===`complex64`&&(r=ma(r),a=ma(a)),[`[`+r.map((e,t)=>da(e,i[t],n)).join(`, `)+`, ..., `+a.map((e,t)=>da(e,i[s-ga+t],n)).join(`, `)+`]`]}return[`[`+(n===`complex64`?ma(e):Array.from(e)).map((e,t)=>da(e,i[t],n)).join(`, `)+`]`]}let l=t.slice(1),u=r.slice(1),d=r[0]*o,f=[];if(s>ha){for(let t=0;t<ga;t++){let r=t*d,a=r+d;f.push(...pa(e.slice(r,a),l,n,u,i,!1))}f.push(`...`);for(let t=s-ga;t<s;t++){let r=t*d,a=r+d;f.push(...pa(e.slice(r,a),l,n,u,i,t===s-1))}}else for(let t=0;t<s;t++){let r=t*d,a=r+d;f.push(...pa(e.slice(r,a),l,n,u,i,t===s-1))}let p=c===2?`,`:``;f[0]=`[`+(s>0?f[0]+p:``);for(let e=1;e<f.length-1;e++)f[e]=` `+f[e]+p;let m=`,
`;for(let e=2;e<c;e++)m+=`
`;return f[f.length-1]=` `+f[f.length-1]+`]`+(a?``:m),f}function ma(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var ha,ga,_a,va=o((()=>{j(),ha=20,ga=3,_a=7}));function ya(e){Sa=e}function ba(e){Ca=e}function M(){return st(`Tensor`,()=>wa)}var xa,Sa,Ca,wa,Ta,N=o((()=>{lt(),va(),j(),xa=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=O(e),n!=null){let e=n.length;D(e===this.size,()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`)}if(t===`complex64`)throw Error(`complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).`);this.values=n||De(t,this.size),this.strides=ze(e)}set(e,...t){t.length===0&&(t=[0]),D(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let n=this.locToIndex(t);this.values[n]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(let n of e){if(n<0||n>=this.shape[t]){let t=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw Error(t)}t++}let n=e[e.length-1];for(let t=0;t<e.length-1;++t)n+=this.strides[t]*e[t];return this.values[n]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];let t=Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Sa().makeTensor(this.values,this.shape,this.dtype)}},Sa=null,Ca=null,wa=class{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||`float32`,this.size=O(e),this.strides=ze(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():`higher`}get rank(){return this.shape.length}async buffer(){let e=await this.data();return Ca.buffer(this.shape,this.dtype,e)}bufferSync(){return Ca.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return Ve(this.shape,e,this.dtype===`complex64`)}arraySync(){return Ve(this.shape,this.dataSync(),this.dtype===`complex64`)}async data(){this.throwIfDisposed();let e=Sa().read(this.dataId);if(this.dtype===`string`){let t=await e;try{return t.map(e=>$i(e))}catch{throw Error(`Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().`)}}return e}dataToGPU(e){return this.throwIfDisposed(),Sa().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=Sa().readSync(this.dataId);if(this.dtype===`string`)try{return e.map(e=>$i(e))}catch{throw Error(`Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().`)}return e}async bytes(){this.throwIfDisposed();let e=await Sa().read(this.dataId);return this.dtype===`string`?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Sa().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw Error(`Tensor is disposed.`)}print(e=!1){return Ca.print(this,e)}clone(){return this.throwIfDisposed(),Ca.clone(this)}toString(e=!1){let t=this.dataSync();return la(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Ca.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),Sa().makeVariable(this,e,t,n)}},Object.defineProperty(wa,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null}),M(),Ta=class extends wa{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!ge(e.shape,this.shape))throw Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Sa().disposeTensor(this),this.dataId=e.dataId,Sa().incRef(this,null)}dispose(){Sa().disposeVariable(this),this.isDisposedInternal=!0}},Object.defineProperty(Ta,Symbol.hasInstance,{value:e=>e instanceof wa&&e.assign!=null&&e.assign instanceof Function})}));function Ea(e,t){if(e===`string`||t===`string`){if(e===`string`&&t===`string`)return`string`;throw Error(`Can not upcast ${e} with ${t}`)}return Fa[e][t]}function Da(e){return Ea(e,`int32`)}function Oa(e){return typeof e==`object`&&!!e&&`texture`in e&&e.texture instanceof WebGLTexture}function ka(e){return typeof GPUBuffer<`u`&&typeof e==`object`&&!!e&&`buffer`in e&&e.buffer instanceof GPUBuffer}var Aa,ja,Ma,Na,Pa,Fa,Ia=o((()=>{(function(e){e.R0=`R0`,e.R1=`R1`,e.R2=`R2`,e.R3=`R3`,e.R4=`R4`,e.R5=`R5`,e.R6=`R6`})(Aa||={}),(function(e){e.float32=`float32`,e.int32=`int32`,e.bool=`int32`,e.complex64=`complex64`})(ja||={}),(function(e){e.float32=`float32`,e.int32=`int32`,e.bool=`bool`,e.complex64=`complex64`})(Ma||={}),(function(e){e.float32=`float32`,e.int32=`float32`,e.bool=`float32`,e.complex64=`complex64`})(Na||={}),(function(e){e.float32=`complex64`,e.int32=`complex64`,e.bool=`complex64`,e.complex64=`complex64`})(Pa||={}),Fa={float32:Na,int32:ja,bool:Ma,complex64:Pa}})),La=c({assertTypesMatch:()=>za,getTensorsInContainer:()=>Va,isTensorInList:()=>Ba,makeTypesMatch:()=>Ra});function Ra(e,t){if(e.dtype===t.dtype)return[e,t];let n=Ea(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function za(e,t){D(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function Ba(e,t){return t.some(t=>t.id===e.id)}function Va(e){let t=[];return Ha(e,t,new Set),t}function Ha(e,t,n){if(e==null)return;if(e instanceof wa){t.push(e);return}if(!Ua(e))return;let r=e;for(let e in r){let i=r[e];n.has(i)||(n.add(i),Ha(i,t,n))}}function Ua(e){return Array.isArray(e)||typeof e==`object`}var Wa=o((()=>{N(),Ia(),j()}));function Ga(e){return e.kernelName!=null}function Ka(e){let t=Ue(O(e),`float32`);return P.makeTensor(t,e,`float32`)}function qa(){let e=at();if(e._tfengine==null){let t=new nt(e);e._tfengine=new Xa(t)}return et(e._tfengine.ENV),ya(()=>e._tfengine),e._tfengine}function Ja(e,t){let n={a:e,b:t};return P.runKernel(`Add`,n)}var Ya,Xa,P,F=o((()=>{re(),it(),lt(),A(),Ci(),di(),aa(),ca(),N(),Wa(),j(),Ya=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},Xa=class e{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Ya}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t];if(await this.initializeBackend(n).success){await this.setBackend(n);return}}throw Error(`Could not initialize any backends, all backend initializations failed.`)}get backend(){if(this.pendingBackendInit!=null)throw Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){let{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(li(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;let{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new ra(this.backendInstance),!0}setupRegisteredKernels(){mi(this.backendName).forEach(e=>{e.setupFunc!=null&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){mi(e).forEach(t=>{t.disposeFunc!=null&&t.disposeFunc(this.registry[e])})}initializeBackend(e){let t=this.registryFactory[e];if(t==null)throw Error(`Cannot initialize backend ${e}, no registration found.`);try{let n=t.factory();if(n&&!(n instanceof ne)&&typeof n.then==`function`){let t=++this.pendingBackendInitId,r=n.then(n=>t<this.pendingBackendInitId?!1:(this.registry[e]=n,this.pendingBackendInit=null,!0)).catch(n=>t<this.pendingBackendInitId?!1:(this.pendingBackendInit=null,li(`Initialization of backend ${e} failed`),li(n.stack||n.message),!1));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}else return this.registry[e]=n,{success:!0,asyncInit:!1}}catch(t){return li(`Initialization of backend ${e} failed`),li(t.stack||t.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw Error(`No backend found in registry.`);return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t],{success:r,asyncInit:i}=this.initializeBackend(n);if(i||r)return{name:n,asyncInit:i}}throw Error(`Could not initialize any backends, all backend initializations failed.`)}moveData(e,t){let n=this.state.tensorInfo.get(t),r=n.backend,i=this.readSync(t),a=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,i,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n=null;if(t==null){if(typeof e!=`function`)throw Error(`Please provide a function to tidy()`);t=e}else{if(typeof e!=`string`&&!(e instanceof String))throw Error(`When calling with two arguments, the first argument to tidy() must be a string`);if(typeof t!=`function`)throw Error(`When calling with two arguments, the 2nd argument to tidy() must be a function`);n=e}let r;return this.scopedRun(()=>this.startScope(n),()=>this.endScope(r),()=>(r=t(),r instanceof Promise&&console.error(`Cannot return a Promise inside of tidy.`),r))}scopedRun(e,t,n){e();try{let e=n();return t(),e}catch(e){throw t(),e}}nextTensorId(){return e.nextTensorId++}nextVariableId(){return e.nextVariableId++}clone(e){let t=P.runKernel(vn,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],e=>({x:()=>{let t={x:e};return P.runKernel(At,t,{dtype:`float32`})}}),[],{}),t}runKernel(e,t,n){if(this.backendName??this.backend,fi(e,this.backendName)==null)throw Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool(`IS_TEST`)}checkKernelForMemLeak(e,t,n){let r=this.backend.numDataIds(),i=0;n.forEach(e=>{i+=e.dtype===`complex64`?3:1});let a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=r-t-i-a;if(o>0)throw Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[],r=this.isTapeOn(),i=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName??this.backend;let s,c=Ga(e)?e.kernelName:this.state.activeScope==null?``:this.state.activeScope.name;if(Ga(e)){let{kernelName:t,inputs:i,attrs:a}=e;this.backendName??this.backend;let c=fi(t,this.backendName);D(c!=null,()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`),o=()=>{let e=this.backend.numDataIds();s=c.kernelFunc({inputs:i,attrs:a,backend:this.backend});let o=Array.isArray(s)?s:[s];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,o);let l=o.map(e=>e.rank==null?this.makeTensorFromTensorInfo(e):e);if(r){let e=this.getTensorsForGradient(t,i,l);n=this.saveTensorsForBackwardMode(e)}return l}}else{let{forwardFunc:t}=e,i=e=>{r&&(n=e.map(e=>this.keep(this.clone(e))))};o=()=>{let e=this.backend.numDataIds();s=this.tidy(()=>t(this.backend,i));let n=Array.isArray(s)?s:[s];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,e,n),n}}let{inputs:l,attrs:u}=e,d=Ga(e)?null:e.backwardsFunc,f;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool(`DEBUG`)&&!this.state.profiling?t=o():(f=this.profiler.profileKernel(c,l,()=>o()),this.ENV.getBool(`DEBUG`)&&this.profiler.logKernelProfile(f),t=f.outputs)}),r&&this.addTapeNode(c,l,t,d,n,u),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map(e=>l[e]==null?null:l[e].shape),outputShapes:t.map(e=>e.shape),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(s)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(e=>this.keep(this.clone(e)))}getTensorsForGradient(e,t,n){let r=pi(e);if(r!=null){let e=r.inputsToSave||[],i=r.outputsToSave||[],a;r.saveAllInputs?(D(Array.isArray(t),()=>`saveAllInputs is true, expected inputs to be an array.`),a=Object.keys(t).map(e=>t[e])):a=e.map(e=>t[e]);let o=n.filter((e,t)=>i[t]);return a.concat(o)}return[]}makeTensor(e,t,n,r){if(e==null)throw Error(`Values passed to engine.makeTensor() are null`);n||=`float32`,r||=this.backend;let i=e;n===`string`&&Ne(e[0])&&(i=e.map(e=>Qi(e)));let a=r.write(i,t,n),o=new wa(t,n,a,this.nextTensorId());if(this.trackTensor(o,r),n===`string`){let e=this.state.tensorInfo.get(a),t=Me(i);this.state.numBytes+=t-e.bytes,e.bytes=t}return o}makeTensorFromDataId(e,t,n,r){n||=`float32`;let i={dataId:e,shape:t,dtype:n};return this.makeTensorFromTensorInfo(i,r)}makeTensorFromTensorInfo(e,t){let{dataId:n,shape:r,dtype:i}=e,a=new wa(r,i,n,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e,t=!0,n,r){n||=this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));let i=new Ta(e,t,n,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,t){this.state.numTensors++,e.dtype===`string`&&this.state.numStringTensors++;let n=0;e.dtype!==`complex64`&&e.dtype!==`string`&&(n=e.size*je(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof Ta||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype===`string`&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!==`complex64`&&e.dtype!==`string`){let t=e.size*je(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons??=[],e.reasons.push(`Memory usage by string tensors is approximate (2 bytes per character)`)),e}async profile(e){this.state.profiling=!0;let t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(e=>e.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(let e of this.state.activeProfile.kernels)e.kernelTimeMs=await e.kernelTimeMs,e.extraInfo=await e.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,n,r,i,a){let o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:i},s=pi(e);s!=null&&(r=s.gradFunc),r!=null&&(o.gradient=e=>(e=e.map((e,t)=>{if(e==null){let e=n[t],r=We(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e}),r(e.length>1?e:e[0],i,a))),this.state.activeTape.push(o)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let t={track:[],name:`unnamed scope`,id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){let t=Va(e),n=new Set(t.map(e=>e.id));for(let e=0;e<this.state.activeScope.track.length;e++){let t=this.state.activeScope.track[e];!t.kept&&!n.has(t.id)&&t.dispose()}let r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(e=>{!e.kept&&e.scopeId===r.id&&this.track(e)})}gradients(e,t,n,r=!1){if(D(t.length>0,()=>`gradients() received an empty list of xs.`),n!=null&&n.dtype!==`float32`)throw Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);let i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy(`forward`,e));D(i instanceof wa,()=>`The result y returned by f() must be a tensor.`);let a=oa(this.state.activeTape,t,i);if(!r&&a.length===0&&t.length>0)throw Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.`);return this.tidy(`backward`,()=>{let e={};e[i.id]=n??Ka(i.shape),sa(e,a,e=>this.tidy(e),Ja);let r=t.map(t=>e[t.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(e=>{for(let t of e.saved)t.dispose()}),this.state.activeTape=null),{value:i,grads:r}})}customGrad(e){return D(Le(e),()=>`The f passed in customGrad(f) must be a function.`),(...t)=>{D(t.every(e=>e instanceof wa),()=>`The args passed in customGrad(f)(x1, x2,...) must all be tensors`);let n,r={};return t.forEach((e,t)=>{r[t]=e}),this.runKernelFunc({forwardFunc:(r,i)=>(n=e(...t,i),D(n.value instanceof wa,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),D(Le(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),backwardsFunc:(e,r)=>{let i=n.gradFunc(e,r),a=Array.isArray(i)?i:[i];D(a.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),D(a.every(e=>e instanceof wa),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let o={};return a.forEach((e,t)=>{o[t]=()=>e}),o},inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){let t=Xi(),n=await this.backend.time(e);return n.wallMs=Xi()-t,n}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){for(let e in this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Ya,this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}},Xa.nextTensorId=0,Xa.nextVariableId=0,P=qa()})),Za=c({isBrowser:()=>to,isMobile:()=>eo,mockIsMobile:()=>$a});
/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/
function Qa(){return typeof navigator<`u`&&navigator!=null}function $a(e){no=e}function eo(e){if(no!==void 0)return no;if(e||Qa()){if(e||=navigator,e.product===`ReactNative`)return!0;let t=e.userAgent||e.vendor||(typeof window<`u`?window.opera:``);if(!t){let t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function to(){return typeof window<`u`&&window.document!=null||typeof WorkerGlobalScope<`u`}var no,ro=o((()=>{})),io,ao=o((()=>{F(),ro(),it(),io=k(),io.registerFlag(`DEBUG`,()=>!1,e=>{e&&console.warn(`Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.`)}),io.registerFlag(`IS_BROWSER`,()=>to()),io.registerFlag(`IS_NODE`,()=>typeof process<`u`&&process.versions!==void 0&&process.versions.node!==void 0),io.registerFlag(`IS_CHROME`,()=>typeof navigator<`u`&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),io.registerFlag(`IS_SAFARI`,()=>typeof navigator<`u`&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),io.registerFlag(`PROD`,()=>!1),io.registerFlag(`TENSORLIKE_CHECK_SHAPE_CONSISTENCY`,()=>io.getBool(`DEBUG`)),io.registerFlag(`DEPRECATION_WARNINGS_ENABLED`,()=>!0),io.registerFlag(`IS_TEST`,()=>!1),io.registerFlag(`CHECK_COMPUTATION_FOR_ERRORS`,()=>io.getBool(`DEBUG`)),io.registerFlag(`WRAP_TO_IMAGEBITMAP`,()=>!1),io.registerFlag(`CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU`,()=>!1),io.registerFlag(`USE_SETTIMEOUTCUSTOM`,()=>!1)}));function oo(e,t){let n=e;if(ea(e))return t===`string`?[]:[e.length];if(Oa(e)){let t=e.channels||`RGBA`;return[e.height,e.width*t.length]}else if(ka(e))return[e.buffer.size/(t==null?4:je(t))];if(!Array.isArray(e))return[];let r=[];for(;Array.isArray(n)||ea(n)&&t!==`string`;)r.push(n.length),n=n[0];return Array.isArray(e)&&k().getBool(`TENSORLIKE_CHECK_SHAPE_CONSISTENCY`)&&so(e,r,[]),r}function so(e,t,n){if(n||=[],!Array.isArray(e)&&!ea(e)){D(t.length===0,()=>`Element arr[${n.join(`][`)}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}D(t.length>0,()=>`Element arr[${n.join(`][`)}] should be a primitive, but is an array of ${e.length} elements`),D(e.length===t[0],()=>`Element arr[${n.join(`][`)}] should have ${t[0]} elements, but has ${e.length} elements`);let r=t.slice(1);for(let t=0;t<e.length;++t)so(e[t],r,n.concat(t))}function co(e,t,n,r){if(e!==`string_or_numeric`){if(e==null)throw Error(`Expected dtype cannot be null.`);if(e!==`numeric`&&e!==t||e===`numeric`&&t===`string`)throw Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function I(e,t,n,r=`numeric`){if(e instanceof M())return co(r,e.dtype,t,n),e;let i=Ie(e);if(i!==`string`&&[`bool`,`int32`,`float32`].indexOf(r)>=0&&(i=r),co(r,i,t,n),e==null||!ea(e)&&!Array.isArray(e)&&typeof e!=`number`&&typeof e!=`boolean`&&typeof e!=`string`){let r=e==null?`null`:e.constructor.name;throw Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}let a=oo(e,i);!ea(e)&&!Array.isArray(e)&&(e=[e]);let o=i===`string`?ta(e,[],!0):Yi(e,i);return P.makeTensor(o,a,i)}function lo(e,t,n,r=`numeric`){if(!Array.isArray(e))throw Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((e,i)=>I(e,`${t}[${i}]`,n,r))}var L=o((()=>{F(),it(),N(),Ia(),j(),Xe()}));function R(e){let t=Object.keys(e);if(t.length!==1)throw Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],r=e[n];n.endsWith(`_`)&&(n=n.substring(0,n.length-1)),n+=uo;let i=(...e)=>{P.startScope(n);try{let t=r(...e);return Ye(t)&&console.error(`Cannot return a Promise inside of tidy.`),P.endScope(t),t}catch(e){throw P.endScope(null),e}};return Object.defineProperty(i,`name`,{value:n,configurable:!0}),i}var uo,z=o((()=>{F(),j(),uo=`__op`}));function fo(e,t){let n=I(e,`real`,`complex`),r=I(t,`imag`,`complex`);fe(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);let i={real:n,imag:r};return P.runKernel(Nt,i)}var po,mo=o((()=>{F(),A(),L(),j(),z(),po=R({complex_:fo})}));function ho(e,t,n,r){if(r==null)r=Ie(e);else if(r===`complex64`)throw Error(`Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).`);if(ka(e)||Oa(e)){if(r!==`float32`&&r!==`int32`)throw Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return P.backend.createTensorFromGPUData(e,t||n,r)}if(!ea(e)&&!Array.isArray(e)&&typeof e!=`number`&&typeof e!=`boolean`&&typeof e!=`string`)throw Error(`values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray`);if(t!=null){Ke(t);let e=O(t),r=O(n);D(e===r,()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`);for(let e=0;e<n.length;++e){let r=n[e],i=e===n.length-1?r!==O(t.slice(e)):!0;D(n[e]===t[e]||!i,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!ea(e)&&!Array.isArray(e)&&(e=[e]),t||=n,e=r===`string`?ta(e,[],!0):Yi(e,r),P.makeTensor(e,t,r)}var go=o((()=>{F(),Ia(),j()}));function _o(e,t,n){let r=oo(e,n);return ho(e,t,r,n)}var vo=o((()=>{L(),go()})),yo,bo=o((()=>{yo={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8}}));function xo(e,t){let n=0,r=e.length;for(;n<=r;){let i=Math.floor((r-n)/2)+n,a=t(e[i]);if(a===0)return i;a<0?r=i:n=i+1}return-1}var So,Co=o((()=>{j(),So=class e{static join(t){return new e(t).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(e=>ea(e)?e.buffer:e),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){let r=e[n];n!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let i=t+r.byteLength;this.shards.push({buffer:r,start:t,end:i}),t=i}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0||(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e))return new ArrayBuffer(0);let n=this.findShardForByte(e);if(n===-1)throw Error(`Could not find start shard for byte ${e}`);let r=t-e,i=new ArrayBuffer(r),a=new Uint8Array(i),o=0;for(let r=n;r<this.shards.length;r++){let n=this.shards[r],i=e+o-n.start,s=o,c=Math.min(t,n.end)-n.start,l=new Uint8Array(n.buffer,i,c-i);if(a.set(l,s),o+=l.length,t<n.end)break}return i}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;let n=xo(this.shards,t);return n===-1?-1:(this.previousShardIndex=n,this.previousShardIndex)}}}));function wo(){k().set(`PROD`,!0)}function To(){k().set(`DEBUG`,!0)}function Eo(){k().set(`DEPRECATION_WARNINGS_ENABLED`,!1),console.warn(`TensorFlow.js deprecation warnings have been disabled.`)}function Do(e){k().getBool(`DEPRECATION_WARNINGS_ENABLED`)&&console.warn(e+` You can disable deprecation warnings with tf.disableDeprecationWarnings().`)}function Oo(){P.disposeVariables()}function ko(){return P}function Ao(){return P.memory()}function jo(e){return P.profile(e)}function B(e,t){return P.tidy(e,t)}function Mo(e){Va(e).forEach(e=>e.dispose())}function No(e){return P.keep(e)}function Po(e){return P.time(e)}function Fo(e){return P.setBackend(e)}function Io(){return P.ready()}function Lo(){return P.backendName}function Ro(e){P.removeBackend(e)}function zo(e){return P.findBackend(e)}function Bo(e){return P.findBackendFactory(e)}function Vo(e,t,n=1){return P.registerBackend(e,t,n)}function Ho(){return P.backend}function Uo(e,t){k().setPlatform(e,t)}var Wo=o((()=>{F(),it(),N(),Wa()}));async function Go(e,t){let n=[],r=[],i=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);for(let a=0;a<i.length;++a){let o=i[a],s=Array.isArray(e)?e[a].tensor:e[o];if(s.dtype!==`float32`&&s.dtype!==`int32`&&s.dtype!==`bool`&&s.dtype!==`string`&&s.dtype!==`complex64`)throw Error(`Unsupported dtype in weight '${o}': ${s.dtype}`);let c={name:o,shape:s.shape,dtype:s.dtype};if(s.dtype===`string`){let e=new Promise(async e=>{let t=await s.bytes(),n=t.reduce((e,t)=>e+t.length,0)+hs*t.length,r=new Uint8Array(n),i=0;for(let e=0;e<t.length;e++){let n=t[e],a=new Uint8Array(new Uint32Array([n.length]).buffer);r.set(a,i),i+=hs,r.set(n,i),i+=n.length}e(r)});r.push(e)}else r.push(s.data());t!=null&&(c.group=t),n.push(c)}let a=await Promise.all(r);return{data:Qo(a),specs:n}}function Ko(e,t){let n=new So(e),r={},i=0;for(let e of t){let t=qo(e,(e,t)=>n.slice(i+e,i+t));r[e.name]=Yo(e,n.slice(i,i+t)),i+=t}return r}function qo(e,t){let n=O(e.shape),r;if(`quantization`in e){let t=e.quantization;r=yo[t.dtype]}else if(e.dtype===`string`){let e=0;for(let r=0;r<n;r++)e+=hs+new Uint32Array(t(e,e+hs))[0];return e}else r=yo[e.dtype];return n*r}async function Jo(e,t){let n=O(e.shape),r;if(`quantization`in e){let t=e.quantization;r=yo[t.dtype]}else if(e.dtype===`string`){let e=0;for(let r=0;r<n;r++)e+=hs+new Uint32Array(await t(e,e+hs))[0];return e}else r=yo[e.dtype];return n*r}function Yo(e,t){let n=e.name,r=e.dtype,i=e.shape,a=O(i),o,s=0;if(`quantization`in e){let i=e.quantization;if(i.dtype===`uint8`||i.dtype===`uint16`){if(!(`min`in i&&`scale`in i))throw Error(`Weight ${e.name} with quantization ${i.dtype} doesn't have corresponding metadata min and scale.`)}else if(i.dtype===`float16`){if(r!==`float32`)throw Error(`Weight ${e.name} is quantized with ${i.dtype} which only supports weights of type float32 not ${r}.`)}else throw Error(`Weight ${e.name} has unknown quantization dtype ${i.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let c=yo[i.dtype],l=i.dtype===`uint8`?new Uint8Array(t):new Uint16Array(t);if(r===`float32`)if(i.dtype===`uint8`||i.dtype===`uint16`){o=new Float32Array(l.length);for(let e=0;e<l.length;e++)o[e]=l[e]*i.scale+i.min}else if(i.dtype===`float16`)o=ms()(l);else throw Error(`Unsupported quantization type ${i.dtype} for weight type float32.`);else if(r===`int32`){if(i.dtype!==`uint8`&&i.dtype!==`uint16`)throw Error(`Unsupported quantization type ${i.dtype} for weight type int32.`);o=new Int32Array(l.length);for(let e=0;e<l.length;e++){let t=l[e];o[e]=Math.round(t*i.scale+i.min)}}else throw Error(`Unsupported dtype in weight '${n}': ${r}`);s+=a*c}else if(r===`string`){let n=O(e.shape);o=[];for(let e=0;e<n;e++){let e=new Uint32Array(t.slice(s,s+hs))[0];s+=hs;let n=new Uint8Array(t.slice(s,s+e));o.push(n),s+=e}}else{let e=yo[r];if(r===`float32`)o=new Float32Array(t);else if(r===`int32`)o=new Int32Array(t);else if(r===`bool`)o=new Uint8Array(t);else if(r===`complex64`){o=new Float32Array(t);let e=new Float32Array(o.length/2),n=new Float32Array(o.length/2);for(let t=0;t<e.length;t++)e[t]=o[t*2],n[t]=o[t*2+1];let r=_o(e,i,`float32`),a=_o(n,i,`float32`),s=po(r,a);return r.dispose(),a.dispose(),s}else throw Error(`Unsupported dtype in weight '${n}': ${r}`);s+=a*e}return _o(o,i,r)}async function Xo(e,t,n){let r=new Uint8Array(t);for(;r.byteLength<n;){let{done:t,value:i}=await e.read();if(t&&i==null){let e=n-r.byteLength;throw Error(`Reader is done but ${e} bytes are still expected`)}let a=new Uint8Array(r.length+i.byteLength);a.set(r,0),a.set(new Uint8Array(i),r.length),r=a}return r.buffer}async function Zo(e,t){let n={},r=e.getReader(),i=new ArrayBuffer(0);for(let e of t){let t=await Jo(e,async(e,t)=>(i=await Xo(r,i,t),i.slice(e,t)));i=await Xo(r,i,t);let a=i.slice(0,t);i=i.slice(t);let o=Yo(e,a);if(n[e.name]=o,Lo()===`webgpu`){let e=Ho();`uploadToGPU`in e&&O(o.shape)>=k().get(`WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD`)&&e.uploadToGPU(o.dataId)}}return n}function Qo(e){if(e===null)throw Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach(e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)});let r=new Uint8Array(t),i=0;return n.forEach(e=>{r.set(new Uint8Array(e.buffer),i),i+=e.byteLength}),r.buffer}function $o(e){return gs?Buffer.byteLength(e,`utf8`):new Blob([e]).size}function es(e){if(gs)return Buffer.from(e).toString(`base64`);let t=new Uint8Array(e),n=``;for(let e=0,r=t.length;e<r;e++)n+=String.fromCharCode(t[e]);return btoa(n)}function ts(e){if(gs){let t=Buffer.from(e,`base64`);return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let e=0;e<t.length;++e)n.set([t.charCodeAt(e)],e);return n.buffer}function ns(e){return So.join(e)}function rs(e){for(e=e.trim();e.endsWith(`/`);)e=e.slice(0,e.length-1);let t=e.split(`/`);return t[t.length-1]}function os(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(n.initializerSignature=e.initializerSignature),e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),n}function ss(e,t,n){let r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(r.trainingConfig=e.trainingConfig),e.weightsManifest!=null){if(!t)throw Error(`modelJSON has weightsManifest but weightSpecs is null`);if(!n)throw Error(`modelJSON has weightsManifest but weightData is null`);r.weightSpecs=t,r.weightData=n}return e.signature!=null&&(r.signature=e.signature),e.userDefinedMetadata!=null&&(r.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(r.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(r.initializerSignature=e.initializerSignature),r}async function cs(e,t){let n,r;return e.weightsManifest!=null&&([n,r]=await t(e.weightsManifest)),ss(e,n,r)}function ls(e){if(e.modelTopology instanceof ArrayBuffer)throw Error(`Expected JSON model topology, received ArrayBuffer.`);return{dateSaved:new Date,modelTopologyType:`JSON`,modelTopologyBytes:e.modelTopology==null?0:$o(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:$o(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:new So(e.weightData).byteLength}}function us(e){let t=[];for(let n of e)t.push(...n.weights);return t}function ds(){let e=e=>{let t=e<<13,n=0;for(;!(t&8388608);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}function fs(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function ps(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function ms(){let e=ds(),t=fs(),n=ps();return r=>{let i=new ArrayBuffer(4*r.length),a=new Uint32Array(i);for(let i=0;i<r.length;i++){let o=r[i];a[i]=e[n[o>>10]+(o&1023)]+t[o>>10]}return new Float32Array(i)}}var hs,gs,_s=o((()=>{mo(),vo(),j(),bo(),Co(),Wo(),it(),hs=4,gs=typeof Buffer<`u`&&(typeof Blob>`u`||typeof atob>`u`||typeof btoa>`u`)})),vs,ys,bs,xs,Ss,Cs=o((()=>{vs=class e{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return e.instance??=new e,e.instance}static registerSaveRouter(t){e.getInstance().saveRouters.push(t)}static registerLoadRouter(t){e.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return e.getHandlers(t,`save`)}static getLoadHandlers(t,n){return e.getHandlers(t,`load`,n)}static getHandlers(t,n,r){let i=[];return(n===`load`?e.getInstance().loadRouters:e.getInstance().saveRouters).forEach(e=>{let n=e(t,r);n!==null&&i.push(n)}),i}},ys=e=>vs.registerSaveRouter(e),bs=e=>vs.registerLoadRouter(e),xs=e=>vs.getSaveHandlers(e),Ss=(e,t)=>vs.getLoadHandlers(e,t)}));function ws(){if(!k().getBool(`IS_BROWSER`))throw Error(`Failed to obtain IndexedDB factory because the current environmentis not a web browser.`);let e=typeof window>`u`?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw Error(`The current browser does not appear to support IndexedDB.`);return t}function Ts(e){let t=e.result;t.createObjectStore(As,{keyPath:`modelPath`}),t.createObjectStore(js,{keyPath:`modelPath`})}function Es(e){return new Ms(e)}function Ds(e){return e.startsWith(Ms.URL_SCHEME)?e.slice(Ms.URL_SCHEME.length):e}var Os,ks,As,js,Ms,Ns,Ps,Fs=o((()=>{ao(),it(),_s(),Cs(),Co(),Os=`tensorflowjs`,ks=1,As=`models_store`,js=`model_info_store`,Ms=class{constructor(e){if(this.indexedDB=ws(),e==null||!e)throw Error(`For IndexedDB, modelPath must not be null, undefined or empty.`);this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw Error(`BrowserLocalStorage.save() does not support saving model topology in binary formats yet.`);return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((e,n)=>{let r=this.indexedDB.open(Os,ks);r.onupgradeneeded=()=>Ts(r),r.onsuccess=()=>{let i=r.result;if(t==null){let t=i.transaction(As,`readonly`),r=t.objectStore(As).get(this.modelPath);r.onsuccess=()=>{if(r.result==null)return i.close(),n(Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(i.close(),n(r.error)),t.oncomplete=()=>i.close()}else{t.weightData=So.join(t.weightData);let r=ls(t),a=i.transaction(js,`readwrite`),o=a.objectStore(js),s;try{s=o.put({modelPath:this.modelPath,modelArtifactsInfo:r})}catch(e){return n(e)}let c;s.onsuccess=()=>{c=i.transaction(As,`readwrite`);let s=c.objectStore(As),l;try{l=s.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r})}catch(e){return n(e)}l.onsuccess=()=>e({modelArtifactsInfo:r}),l.onerror=e=>{o=a.objectStore(js);let t=o.delete(this.modelPath);t.onsuccess=()=>(i.close(),n(l.error)),t.onerror=e=>(i.close(),n(l.error))}},s.onerror=e=>(i.close(),n(s.error)),a.oncomplete=()=>{c==null?i.close():c.oncomplete=()=>i.close()}}},r.onerror=e=>n(r.error)})}},Ms.URL_SCHEME=`indexeddb://`,Ns=e=>k().getBool(`IS_BROWSER`)&&!Array.isArray(e)&&e.startsWith(Ms.URL_SCHEME)?Es(e.slice(Ms.URL_SCHEME.length)):null,vs.registerSaveRouter(Ns),vs.registerLoadRouter(Ns),Ps=class{constructor(){this.indexedDB=ws()}async listModels(){return new Promise((e,t)=>{let n=this.indexedDB.open(Os,ks);n.onupgradeneeded=()=>Ts(n),n.onsuccess=()=>{let r=n.result,i=r.transaction(js,`readonly`),a=i.objectStore(js).getAll();a.onsuccess=()=>{let t={};for(let e of a.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},a.onerror=e=>(r.close(),t(a.error)),i.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)})}async removeModel(e){return e=Ds(e),new Promise((t,n)=>{let r=this.indexedDB.open(Os,ks);r.onupgradeneeded=()=>Ts(r),r.onsuccess=()=>{let i=r.result,a=i.transaction(js,`readwrite`),o=a.objectStore(js),s=o.get(e),c;s.onsuccess=()=>{if(s.result==null)return i.close(),n(Error(`Cannot find model with path '${e}' in IndexedDB.`));{let r=o.delete(e),a=()=>{c=i.transaction(As,`readwrite`);let r=c.objectStore(As).delete(e);r.onsuccess=()=>t(s.result.modelArtifactsInfo),r.onerror=e=>n(s.error)};r.onsuccess=a,r.onerror=e=>(a(),i.close(),n(s.error))}},s.onerror=e=>(i.close(),n(s.error)),a.oncomplete=()=>{c==null?i.close():c.oncomplete=()=>i.close()}},r.onerror=e=>n(r.error)})}}}));function Is(e){return{info:[Hs,e,Us].join(Vs),topology:[Hs,e,Ws].join(Vs),weightSpecs:[Hs,e,Gs].join(Vs),weightData:[Hs,e,Ks].join(Vs),modelMetadata:[Hs,e,qs].join(Vs)}}function Ls(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function Rs(e){let t=e.split(Vs);if(t.length<3)throw Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(Vs)}function zs(e){return e.startsWith(Js.URL_SCHEME)?e.slice(Js.URL_SCHEME.length):e}function Bs(e){return new Js(e)}var Vs,Hs,Us,Ws,Gs,Ks,qs,Js,Ys,Xs,Zs=o((()=>{ao(),it(),j(),_s(),Co(),Cs(),Vs=`/`,Hs=`tensorflowjs_models`,Us=`info`,Ws=`model_topology`,Gs=`weight_specs`,Ks=`weight_data`,qs=`model_metadata`,Js=class{constructor(e){if(!k().getBool(`IS_BROWSER`)||typeof window>`u`||window.localStorage===void 0)throw Error(`The current environment does not support local storage.`);if(this.LS=window.localStorage,e==null||!e)throw Error(`For local storage, modelPath must not be null, undefined or empty.`);this.modelPath=e,this.keys=Is(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw Error(`BrowserLocalStorage.save() does not support saving model topology in binary formats yet.`);{let t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=ls(e),i=So.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,es(i));let a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature==null?void 0:e.signature,userDefinedMetadata:e.userDefinedMetadata==null?void 0:e.userDefinedMetadata,modelInitializer:e.modelInitializer==null?void 0:e.modelInitializer,initializerSignature:e.initializerSignature==null?void 0:e.initializerSignature,trainingConfig:e.trainingConfig==null?void 0:e.trainingConfig};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:r}}catch{throw Ls(this.keys),Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!==`JSON`)throw Error(`BrowserLocalStorage does not support loading non-JSON model topology yet.`);let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;let i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){let e=JSON.parse(i);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,e.signature!=null&&(t.signature=e.signature),e.userDefinedMetadata!=null&&(t.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(t.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(t.initializerSignature=e.initializerSignature),e.trainingConfig!=null&&(t.trainingConfig=e.trainingConfig)}let a=this.LS.getItem(this.keys.weightData);if(a==null)throw Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=ts(a),t}},Js.URL_SCHEME=`localstorage://`,Ys=e=>k().getBool(`IS_BROWSER`)&&!Array.isArray(e)&&e.startsWith(Js.URL_SCHEME)?Bs(e.slice(Js.URL_SCHEME.length)):null,vs.registerSaveRouter(Ys),vs.registerLoadRouter(Ys),Xs=class{constructor(){D(k().getBool(`IS_BROWSER`),()=>`Current environment is not a web browser`),D(typeof window>`u`||window.localStorage!==void 0,()=>`Current browser does not appear to support localStorage`),this.LS=window.localStorage}async listModels(){let e={},t=Hs+Vs,n=Vs+Us;for(let r=0;r<this.LS.length;++r){let i=this.LS.key(r);if(i.startsWith(t)&&i.endsWith(n)){let t=Rs(i);e[t]=JSON.parse(this.LS.getItem(i))}}return e}async removeModel(e){e=zs(e);let t=Is(e);if(this.LS.getItem(t.info)==null)throw Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return Ls(t),n}}}));function Qs(e){if(e.indexOf(ic)===-1)throw Error(`The url string provided does not contain a scheme. Supported schemes are: ${ac.getSchemes().join(`,`)}`);return{scheme:e.split(ic)[0],path:e.split(ic)[1]}}async function $s(e,t,n=!1){D(e!==t,()=>`Old path and new path are the same: '${e}'`);let r=vs.getLoadHandlers(e);D(r.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),D(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`);let i=r[0],a=vs.getSaveHandlers(t);D(a.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),D(a.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);let o=a[0],s=Qs(e).scheme,c=Qs(e).path,l=s===Qs(e).scheme,u=await i.load();n&&l&&await ac.getManager(s).removeModel(c);let d=await o.save(u);return n&&!l&&await ac.getManager(s).removeModel(c),d.modelArtifactsInfo}async function ec(){let e=ac.getSchemes(),t={};for(let n of e){let e=await ac.getManager(n).listModels();for(let r in e){let i=n+ic+r;t[i]=e[r]}}return t}async function tc(e){let t=Qs(e);return ac.getManager(t.scheme).removeModel(t.path)}async function nc(e,t){return $s(e,t,!1)}async function rc(e,t){return $s(e,t,!0)}var ic,ac,oc=o((()=>{j(),Cs(),ic=`://`,ac=class e{constructor(){this.managers={}}static getInstance(){return e.instance??=new e,e.instance}static registerManager(t,n){D(t!=null,()=>`scheme must not be undefined or null.`),t.endsWith(ic)&&(t=t.slice(0,t.indexOf(ic))),D(t.length>0,()=>`scheme must not be an empty string.`);let r=e.getInstance();D(r.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),r.managers[t]=n}static getManager(t){let n=e.getInstance().managers[t];if(n==null)throw Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(e.getInstance().managers)}}})),sc,cc=o((()=>{if(ao(),it(),Fs(),Zs(),oc(),Ti(),sc=class{constructor(){this.messageName=`setTimeoutCustom`,this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!==`utf-8`&&t!==`utf8`)throw Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder??=new TextEncoder,this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>`u`||!k().getBool(`USE_SETTIMEOUTCUSTOM`)){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},`*`)},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener(`message`,e=>{if(e.source===window&&e.data.name===this.messageName){e.stopPropagation();let t=this.functionRefs[e.data.index];t(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return wi(e)}},k().get(`IS_BROWSER`)){k().setPlatform(`browser`,new sc);try{ac.registerManager(Js.URL_SCHEME,new Xs)}catch{}try{ac.registerManager(Ms.URL_SCHEME,new Ps)}catch{}}})),lc=s(((e,t)=>{t.exports={}})),uc,dc,fc,pc=o((()=>{it(),uc={importFetch:()=>lc()},fc=class{constructor(){this.util=lc(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return k().global.fetch==null?(dc??=uc.importFetch(),dc(e,t)):k().global.fetch(e,t)}now(){let e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!==`utf-8`&&t!==`utf8`)throw Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?``:new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}},k().get(`IS_NODE`)&&!k().get(`IS_BROWSER`)&&k().setPlatform(`node`,new fc)}));function mc(e,t=`float32`,n){return t||=`float32`,Ke(e),new xa(e,t,n)}var hc=o((()=>{N(),j()}));function gc(e,t){let n=I(e,`x`,`cast`);if(!ke(t))throw Error(`Failed to cast to unknown dtype ${t}`);if(t===`string`&&n.dtype!==`string`||t!==`string`&&n.dtype===`string`)throw Error(`Only strings can be casted to strings`);let r={x:n},i={dtype:t};return P.runKernel(At,r,i)}var V,_c=o((()=>{F(),A(),L(),j(),z(),V=R({cast_:gc})}));function vc(e){let t={x:I(e,`x`,`clone`,`string_or_numeric`)};return P.runKernel(vn,t)}var yc,bc=o((()=>{F(),A(),L(),z(),yc=R({clone_:vc})}));
/**
* @license
* Copyright 2020 Google Inc. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/
function xc(e,t=!1){console.log(e.toString(t))}var Sc=o((()=>{})),Cc=o((()=>{F(),ao(),cc(),pc(),hc(),_c(),bc(),Sc(),N(),qa(),ba({buffer:mc,cast:V,clone:yc,print:xc})}));function wc(e,t){let n=I(e,`a`,`add`),r=I(t,`b`,`add`);[n,r]=Ra(n,r);let i={a:n,b:r};return P.runKernel(`Add`,i)}var H,Tc=o((()=>{F(),A(),Wa(),L(),z(),H=R({add_:wc})}));function Ec(e,t){let n=I(e,`a`,`floorDiv`),r=I(t,`b`,`floorDiv`);[n,r]=Ra(n,r);let i={a:n,b:r};return P.runKernel(fn,i)}var Dc,Oc=o((()=>{F(),A(),Wa(),L(),z(),Dc=R({floorDiv_:Ec})}));function kc(e,t){let n=I(e,`a`,`div`),r=I(t,`b`,`div`);if([n,r]=Ra(n,r),n.dtype===`int32`&&r.dtype===`int32`)return Dc(n,r);let i={a:n,b:r};return P.runKernel(nn,i,{})}var Ac,jc=o((()=>{F(),A(),Wa(),L(),Oc(),z(),Ac=R({div_:kc})}));function Mc(e,t){let n=I(e,`a`,`mul`),r=I(t,`b`,`mul`);[n,r]=Ra(n,r);let i={a:n,b:r};return P.runKernel(qn,i)}var U,Nc=o((()=>{F(),A(),Wa(),L(),z(),U=R({mul_:Mc})}));function Pc(e){let t=I(e,`x`,`abs`);if(t.dtype===`complex64`){let e={x:t};return P.runKernel(Pt,e)}else{let e={x:t};return P.runKernel(`Abs`,e)}}var Fc,Ic=o((()=>{F(),A(),L(),z(),Fc=R({abs_:Pc})}));function Lc(e){let t={x:I(e,`x`,`acos`)};return P.runKernel(ut,t)}var Rc,zc=o((()=>{F(),A(),L(),z(),Rc=R({acos_:Lc})}));function Bc(e){let t={x:I(e,`x`,`acosh`)};return P.runKernel(dt,t)}var Vc,Hc=o((()=>{F(),A(),L(),z(),Vc=R({acosh_:Bc})}));function Uc(e){D(Array.isArray(e),()=>`The argument passed to tf.addN() must be a list of tensors`),D(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);let t=e.map((e,t)=>I(e,`tensors${t}`,`addN`)),n=t[0];t.forEach(e=>{if(e.dtype!==n.dtype)throw Error(`All tensors passed to tf.addN() must have the same dtype`)}),t.forEach(e=>{if(!ge(e.shape,n.shape))throw Error(`All tensors passed to tf.addN() must have the same shape`)});let r=t;return P.runKernel(ft,r)}var Wc,Gc=o((()=>{F(),A(),L(),j(),z(),Wc=R({addN_:Uc})}));function Kc(e,t=null,n=!1){let r={x:I(e,`x`,`all`,`bool`)},i={axis:t,keepDims:n};return P.runKernel(`All`,r,i)}var qc,Jc=o((()=>{F(),A(),L(),z(),qc=R({all_:Kc})}));function Yc(e,t=null,n=!1){let r={x:I(e,`x`,`any`,`bool`)},i={axis:t,keepDims:n};return P.runKernel(`Any`,r,i)}var Xc,Zc=o((()=>{F(),A(),L(),z(),Xc=R({any_:Yc})}));function Qc(e,t=0){let n={x:I(e,`x`,`argMax`)},r={axis:t};return P.runKernel(pt,n,r)}var $c,el=o((()=>{F(),A(),L(),z(),$c=R({argMax_:Qc})}));function tl(e,t=0){let n={x:I(e,`x`,`argMin`)},r={axis:t};return P.runKernel(mt,n,r)}var nl,rl=o((()=>{F(),A(),L(),z(),nl=R({argMin_:tl})}));function il(e){let t={x:I(e,`x`,`asin`)};return P.runKernel(ht,t)}var al,ol=o((()=>{F(),A(),L(),z(),al=R({asin_:il})}));function sl(e){let t={x:I(e,`x`,`asinh`)};return P.runKernel(gt,t)}var cl,ll=o((()=>{F(),A(),L(),z(),cl=R({asinh_:sl})}));function ul(e){let t={x:I(e,`x`,`atan`)};return P.runKernel(_t,t)}var dl,fl=o((()=>{F(),A(),L(),z(),dl=R({atan_:ul})}));function pl(e,t){let n=I(e,`a`,`atan2`),r=I(t,`b`,`atan2`);[n,r]=Ra(n,r);let i={a:n,b:r};return P.runKernel(yt,i)}var ml,hl=o((()=>{F(),A(),Wa(),L(),z(),ml=R({atan2_:pl})}));function gl(e){let t={x:I(e,`x`,`atanh`)};return P.runKernel(vt,t)}var _l,vl=o((()=>{F(),A(),L(),z(),_l=R({atanh_:gl})}));function yl(e,t,n,r,i=`NHWC`,a){let o=e[3],s=[...t,o],c=Il(i);return Sl(e,s,n,a,r,null,null,c)}function bl(e,t,n,r,i,a,o=`channelsLast`){let[s,c]=Dl(t),l;if(o===`channelsLast`)l=[s,c,e[3],e[3]];else if(o===`channelsFirst`)l=[s,c,e[1],e[1]];else throw Error(`Unknown dataFormat ${o}`);return Sl(e,l,n,r,i,a,!1,o)}function xl(e,t,n,r,i,a,o=`NDHWC`){let[s,c,l]=Ol(t),u,d;if(o===`NDHWC`)d=`channelsLast`,u=[s,c,l,e[4],e[4]];else if(o===`NCDHW`)d=`channelsFirst`,u=[s,c,l,e[1],e[1]];else throw Error(`Unknown dataFormat ${o}`);return Cl(e,u,n,r,i,!1,d,a)}function Sl(e,t,n,r,i,a,o=!1,s=`channelsLast`){let[c,l,u,d]=[-1,-1,-1,-1];if(s===`channelsLast`)[c,l,u,d]=e;else if(s===`channelsFirst`)[c,d,l,u]=e;else throw Error(`Unknown dataFormat ${s}`);let[f,p,,m]=t,[h,g]=Dl(n),[_,v]=Dl(r),y=kl(f,_),b=kl(p,v),{padInfo:x,outHeight:S,outWidth:C}=Al(i,l,u,h,g,y,b,a,s),w=o?m*d:m,T;return s===`channelsFirst`?T=[c,w,S,C]:s===`channelsLast`&&(T=[c,S,C,w]),{batchSize:c,dataFormat:s,inHeight:l,inWidth:u,inChannels:d,outHeight:S,outWidth:C,outChannels:w,padInfo:x,strideHeight:h,strideWidth:g,filterHeight:f,filterWidth:p,effectiveFilterHeight:y,effectiveFilterWidth:b,dilationHeight:_,dilationWidth:v,inShape:e,outShape:T,filterShape:t}}function Cl(e,t,n,r,i,a=!1,o=`channelsLast`,s){let[c,l,u,d,f]=[-1,-1,-1,-1,-1];if(o===`channelsLast`)[c,l,u,d,f]=e;else if(o===`channelsFirst`)[c,f,l,u,d]=e;else throw Error(`Unknown dataFormat ${o}`);let[p,m,h,,g]=t,[_,v,y]=Ol(n),[b,x,S]=Ol(r),C=kl(p,b),w=kl(m,x),T=kl(h,S),{padInfo:ee,outDepth:E,outHeight:te,outWidth:ne}=jl(i,l,u,d,_,v,y,C,w,T,s),re=a?g*f:g,ie;return o===`channelsFirst`?ie=[c,re,E,te,ne]:o===`channelsLast`&&(ie=[c,E,te,ne,re]),{batchSize:c,dataFormat:o,inDepth:l,inHeight:u,inWidth:d,inChannels:f,outDepth:E,outHeight:te,outWidth:ne,outChannels:re,padInfo:ee,strideDepth:_,strideHeight:v,strideWidth:y,filterDepth:p,filterHeight:m,filterWidth:h,effectiveFilterDepth:C,effectiveFilterHeight:w,effectiveFilterWidth:T,dilationDepth:b,dilationHeight:x,dilationWidth:S,inShape:e,outShape:ie,filterShape:t}}function wl(e,t,n,r,i){r??=El(e,t,n);let a=e[0],o=e[1],s=Ml((a-t+2*r)/n+1,i),c=Ml((o-t+2*r)/n+1,i);return[s,c]}function Tl(e,t,n,r,i,a){i??=El(e,t[0],r[0]);let o=[0,0,0,n];for(let n=0;n<3;n++)e[n]+2*i>=t[n]&&(o[n]=Ml((e[n]-t[n]+2*i)/r[n]+1,a));return o}function El(e,t,n,r=1){let i=kl(t,r);return Math.floor((e[0]*(n-1)-n+i)/2)}function Dl(e){return typeof e==`number`?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function Ol(e){return typeof e==`number`?[e,e,e]:e}function kl(e,t){return t<=1?e:e+(e-1)*(t-1)}function Al(e,t,n,r,i,a,o,s,c){let l,u,d;if(typeof e==`number`){l={top:e,bottom:e,left:e,right:e,type:e===0?`VALID`:`NUMBER`};let i=wl([t,n],a,r,e,s);u=i[0],d=i[1]}else if(e===`same`){u=Math.ceil(t/r),d=Math.ceil(n/i);let e=Math.max(0,(u-1)*r+a-t),s=Math.max(0,(d-1)*i+o-n),c=Math.floor(e/2),f=e-c,p=Math.floor(s/2),m=s-p;l={top:c,bottom:f,left:p,right:m,type:`SAME`}}else if(e===`valid`)l={top:0,bottom:0,left:0,right:0,type:`VALID`},u=Math.ceil((t-a+1)/r),d=Math.ceil((n-o+1)/i);else if(typeof e==`object`){let f=c===`channelsLast`?e[1][0]:e[2][0],p=c===`channelsLast`?e[1][1]:e[2][1],m=c===`channelsLast`?e[2][0]:e[3][0],h=c===`channelsLast`?e[2][1]:e[3][1];l={top:f,bottom:p,left:m,right:h,type:f===0&&p===0&&m===0&&h===0?`VALID`:`EXPLICIT`},u=Ml((t-a+f+p)/r+1,s),d=Ml((n-o+m+h)/i+1,s)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:l,outHeight:u,outWidth:d}}function jl(e,t,n,r,i,a,o,s,c,l,u){let d,f,p,m;if(e===`valid`&&(e=0),typeof e==`number`){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?`VALID`:`NUMBER`};let h=Tl([t,n,r,1],[s,c,l],1,[i,a,o],e,u);f=h[0],p=h[1],m=h[2]}else if(e===`same`){f=Math.ceil(t/i),p=Math.ceil(n/a),m=Math.ceil(r/o);let e=(f-1)*i+s-t,u=(p-1)*a+c-n,h=(m-1)*o+l-r,g=Math.floor(e/2),_=e-g,v=Math.floor(u/2),y=u-v,b=Math.floor(h/2),x=h-b;d={top:v,bottom:y,left:b,right:x,front:g,back:_,type:`SAME`}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:d,outDepth:f,outHeight:p,outWidth:m}}function Ml(e,t){if(!t)return Math.trunc(e);switch(t){case`round`:return Math.round(e);case`ceil`:return Math.ceil(e);case`floor`:return Math.floor(e);default:throw Error(`Unknown roundingMode ${t}`)}}function Nl(e){let[t,n,r]=Dl(e);return t===1&&n===1&&r===1}function Pl(e,t){return Nl(e)||Nl(t)}function Fl(e){return Dl(e).every(e=>e>0)}function Il(e){if(e===`NHWC`)return`channelsLast`;if(e===`NCHW`)return`channelsFirst`;throw Error(`Unknown dataFormat ${e}`)}function Ll(e,t,n){if(n!=null){if(typeof t==`string`)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if(typeof t==`number`)D(_e(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if(typeof t==`object`)t.forEach(t=>{t.forEach(t=>{D(_e(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}var Rl=o((()=>{j()}));function zl(e,t){let n={x:I(e,`x`,`reshape`,`string_or_numeric`)},r={shape:t};return P.runKernel(fr,n,r)}var W,G=o((()=>{F(),A(),L(),z(),W=R({reshape_:zl})}));function Bl(e,t,n,r,i){let a=I(e,`x`,`avgPool`,`float32`);D(Pl(n,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`);let o=a,s=!1;a.rank===3&&(s=!0,o=W(a,[1,a.shape[0],a.shape[1],a.shape[2]])),D(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),Ll(`avgPool`,r,i);let c={x:o},l={filterSize:t,strides:n,pad:r,dimRoundingMode:i},u=P.runKernel(bt,c,l);return u=V(u,a.dtype),s?W(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var Vl,Hl=o((()=>{F(),A(),L(),j(),_c(),Rl(),z(),G(),Vl=R({avgPool_:Bl})}));function Ul(e,t,n,r,i,a=`NDHWC`){let o=I(e,`x`,`avgPool3d`,`float32`),s=o,c=!1;o.rank===4&&(c=!0,s=W(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),D(s.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${s.rank}.`),D(a===`NDHWC`,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),D(typeof n==`number`&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),Ll(`avgPool3d`,r,i);let l={x:s},u={filterSize:t,strides:n,pad:r,dimRoundingMode:i,dataFormat:a},d=P.runKernel(St,l,u);return d=V(d,s.dtype),c?W(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var Wl,Gl=o((()=>{F(),A(),L(),j(),_c(),Rl(),z(),G(),Wl=R({avgPool3d_:Ul})}));function Kl(e,t=0){D(e.length>=1,()=>`Pass at least one tensor to concat`);let n=lo(e,`tensors`,`concat`,`string_or_numeric`);if(n[0].dtype===`complex64`&&n.forEach(e=>{if(e.dtype!==`complex64`)throw Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${e.dtype}. `)}),n.length===1)return yc(n[0]);let r=n,i={axis:t};return P.runKernel(Ft,r,i)}var ql,Jl=o((()=>{F(),A(),L(),j(),bc(),z(),ql=R({concat_:Kl})}));function Yl(e,t,n=!1,r=!1){let i=I(e,`a`,`matMul`),a=I(t,`b`,`matMul`);[i,a]=Ra(i,a);let o={a:i,b:a},s={transposeA:n,transposeB:r};return P.runKernel(wt,o,s)}var Xl,Zl=o((()=>{F(),A(),Wa(),L(),z(),Xl=R({matMul_:Yl})}));function Ql(e){let t={x:I(e,`x`,`sigmoid`,`float32`)};return P.runKernel(kr,t)}var $l,eu=o((()=>{F(),A(),L(),z(),$l=R({sigmoid_:Ql})}));function tu(e,t,n){let r=I(e,`x`,`slice`,`string_or_numeric`);if(r.rank===0)throw Error(`Slicing scalar is not possible`);let i={x:r},a={begin:t,size:n};return P.runKernel(Er,i,a)}var nu,ru=o((()=>{F(),A(),L(),z(),nu=R({slice_:tu})}));function iu(e){let t={x:I(e,`x`,`tanh`,`float32`)};return P.runKernel(qr,t)}var au,ou=o((()=>{F(),A(),L(),z(),au=R({tanh_:iu})}));function su(e,t,n,r,i,a){let o=I(e,`forgetBias`,`basicLSTMCell`),s=I(t,`lstmKernel`,`basicLSTMCell`),c=I(n,`lstmBias`,`basicLSTMCell`),l=I(r,`data`,`basicLSTMCell`),u=I(i,`c`,`basicLSTMCell`),d=I(a,`h`,`basicLSTMCell`),f=ql([l,d],1),p=Xl(f,s),m=H(p,c),h=m.shape[0],g=m.shape[1]/4,_=[h,g],v=nu(m,[0,0],_),y=nu(m,[0,g],_),b=nu(m,[0,g*2],_),x=nu(m,[0,g*3],_),S=H(U($l(v),au(y)),U(u,$l(H(o,b)))),C=U(au(S),$l(x));return[S,C]}var cu,lu=o((()=>{L(),Tc(),Jl(),Zl(),Nc(),z(),eu(),ru(),ou(),cu=R({basicLSTMCell_:su})}));function uu(e,t,n){let r=I(e,`x`,`batchToSpaceND`),i=t.reduce((e,t)=>e*t);D(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),D(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),D(r.shape[0]%i===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(` * `)} === ${i}`);let a={x:r},o={blockShape:t,crops:n};return P.runKernel(Tt,a,o)}var du,fu=o((()=>{F(),A(),L(),j(),z(),du=R({batchToSpaceND_:uu})}));function pu(e){let t;return t=e.rank===0||e.rank===1?W(e,[1,1,1,e.size]):e.rank===2?W(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?W(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}var mu=o((()=>{G()}));function hu(e,t,n,r,i,a){a??=.001;let o=I(e,`x`,`batchNorm`),s=I(t,`mean`,`batchNorm`),c=I(n,`variance`,`batchNorm`),l;i!=null&&(l=I(i,`scale`,`batchNorm`));let u;r!=null&&(u=I(r,`offset`,`batchNorm`)),D(s.rank===c.rank,()=>`Batch normalization gradient requires mean and variance to have equal ranks.`),D(u==null||s.rank===u.rank,()=>`Batch normalization gradient requires mean and offset to have equal ranks.`),D(l==null||s.rank===l.rank,()=>`Batch normalization gradient requires mean and scale to have equal ranks.`);let d={x:pu(o),scale:l,offset:u,mean:s,variance:c},f={varianceEpsilon:a},p=P.runKernel(pn,d,f);return W(p,o.shape)}var gu,_u=o((()=>{F(),A(),L(),j(),mu(),z(),G(),gu=R({batchNorm_:hu})}));function vu(e,t,n,r,i,a){let o=I(e,`x`,`batchNorm`),s=I(t,`mean`,`batchNorm`),c=I(n,`variance`,`batchNorm`),l;i!=null&&(l=I(i,`scale`,`batchNorm`));let u;return r!=null&&(u=I(r,`offset`,`batchNorm`)),D(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),D(s.rank===2||s.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${s.rank}.`),D(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${c.rank}.`),l!=null&&D(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&D(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`),gu(o,s,c,u,l,a)}var yu,bu=o((()=>{L(),j(),_u(),z(),yu=R({batchNorm2d_:vu})}));function xu(e,t,n,r,i,a){let o=I(e,`x`,`batchNorm`),s=I(t,`mean`,`batchNorm`),c=I(n,`variance`,`batchNorm`),l;i!=null&&(l=I(i,`scale`,`batchNorm`));let u;return r!=null&&(u=I(r,`offset`,`batchNorm`)),D(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),D(s.rank===3||s.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${s.rank}.`),D(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${c.rank}.`),l!=null&&D(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&D(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`),gu(o,s,c,u,l,a)}var Su,Cu=o((()=>{L(),j(),_u(),z(),Su=R({batchNorm3d_:xu})}));function wu(e,t,n,r,i,a){let o=I(e,`x`,`batchNorm`),s=I(t,`mean`,`batchNorm`),c=I(n,`variance`,`batchNorm`),l;i!=null&&(l=I(i,`scale`,`batchNorm`));let u;return r!=null&&(u=I(r,`offset`,`batchNorm`)),D(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),D(s.rank===4||s.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${s.rank}.`),D(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${c.rank}.`),l!=null&&D(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&D(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`),gu(o,s,c,u,l,a)}var Tu,Eu=o((()=>{L(),j(),_u(),z(),Tu=R({batchNorm4d_:wu})}));function Du(e,t,n){let r=I(e,`x`,`bincount`),i=I(t,`weights`,`bincount`);D(r.dtype===`int32`,()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),D(n>=0,()=>`size must be non-negative, but got ${n}.`),D(i.size===r.size||i.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${i.shape}.`);let a={x:r,weights:i},o={size:n};return P.runKernel(Et,a,o)}var Ou,ku=o((()=>{F(),A(),L(),j(),z(),Ou=R({bincount_:Du})}));function Au(e,t){let n=I(e,`x`,`bitwiseAnd`),r=I(t,`y`,`bitwiseAnd`);if(!ge(n.shape,r.shape))throw Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if(n.dtype!==`int32`||r.dtype!==`int32`)throw Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);let i={a:n,b:r};return P.runKernel(Dt,i)}var ju,Mu=o((()=>{F(),A(),L(),Xe(),z(),ju=R({bitwiseAnd_:Au})}));function Nu(e,t){let n=I(e,`s0`,`broadcastArgs`,`int32`),r=I(t,`s1`,`broadcastArgs`,`int32`);if(n.rank!==1)throw Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(r.rank!==1)throw Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);let i={s0:n,s1:r};return P.runKernel(kt,i)}var Pu,Fu=o((()=>{F(),A(),L(),z(),Pu=R({broadcastArgs_:Nu})}));function Iu(e,t){let n=I(e,`broadcastTo`,`x`),r=n.shape;if(Ke(t),t.length<n.rank)throw Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=W(n,e)}let i=n.shape,a=Array.from(t);for(let e=t.length-1;e>=0;e--)if(i[e]===t[e])a[e]=1;else if(n.shape[e]!==1)throw Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(a.map((e,t)=>e>1?t:-1).filter(e=>e>=0).length===0)return yc(n);let o={x:n},s={reps:a};return P.runKernel(Jr,o,s)}var Lu,Ru=o((()=>{F(),A(),L(),Xe(),bc(),z(),G(),Lu=R({broadcastTo_:Iu})}));function zu(e){let t={x:I(e,`x`,`ceil`,`float32`)};return P.runKernel(jt,t)}var Bu,Vu=o((()=>{F(),A(),L(),z(),Bu=R({ceil_:zu})}));function Hu(e,t,n){Ke(e),n||=Ie(t);let r={shape:e,value:t,dtype:n};return P.runKernel(ln,{},r)}var Uu=o((()=>{F(),A(),j(),Xe()}));function Wu(e,t,n){let r=I(e,`x`,`clipByValue`);if(D(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)return Hu(r.shape,t,r.dtype);let i={x:r},a={clipValueMin:t,clipValueMax:n};return P.runKernel(Mt,i,a)}var Gu,Ku=o((()=>{F(),A(),L(),j(),Uu(),z(),Gu=R({clipByValue_:Wu})}));function qu(e){return ql(e,0)}var Ju,Yu=o((()=>{Jl(),z(),Ju=R({concat1d_:qu})}));function Xu(e,t){return ql(e,t)}var Zu,Qu=o((()=>{Jl(),z(),Zu=R({concat2d_:Xu})}));function $u(e,t){return ql(e,t)}var ed,td=o((()=>{Jl(),z(),ed=R({concat3d_:$u})}));function nd(e,t){return ql(e,t)}var rd,id=o((()=>{Jl(),z(),rd=R({concat4d_:nd})}));function ad(e,t,n,r,i=`NHWC`,a=[1,1],o){let s=I(e,`x`,`conv2d`,`float32`),c=I(t,`filter`,`conv2d`,`float32`),l=s,u=!1;s.rank===3&&(u=!0,l=W(s,[1,s.shape[0],s.shape[1],s.shape[2]])),D(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),D(c.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${c.rank}.`),Ll(`conv2d`,r,o);let d=i===`NHWC`?l.shape[3]:l.shape[1];D(d===c.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${c.shape[2]}.`),D(Pl(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),D(Fl(a),()=>`Error in conv2D: Dilated rates should be larger than 0.`),D(Fl(n),()=>`Error in conv2D: Strides should be larger than 0.`);let f={x:l,filter:c},p={strides:n,pad:r,dataFormat:i,dilations:a,dimRoundingMode:o},m=P.runKernel(It,f,p);return u?W(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var od,sd=o((()=>{F(),A(),L(),j(),Rl(),z(),G(),od=R({conv2d_:ad})}));function cd(e,t,n,r,i=`NWC`,a=1,o){let s=I(e,`x`,`conv1d`),c=I(t,`filter`,`conv1d`),l=s,u=!1;s.rank===2&&(u=!0,l=W(s,[1,s.shape[0],s.shape[1]])),D(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),D(c.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${c.rank}.`),Ll(`conv1d`,r,o),D(l.shape[2]===c.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${c.shape[1]}.`),D(Pl(n,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`),D(Fl(a),()=>`Error in conv1D: Dilated rates should be larger than 0.`),D(Fl(n),()=>`Error in conv1D: Stride should be larger than 0.`),D(i===`NWC`,()=>`Error in conv1d: got dataFormat of ${i} but only NWC is currently supported.`);let d=W(c,[1,c.shape[0],c.shape[1],c.shape[2]]),f=W(l,[l.shape[0],1,l.shape[1],l.shape[2]]),p=od(f,d,[1,n],r,`NHWC`,[1,a],o);return u?W(p,[p.shape[2],p.shape[3]]):W(p,[p.shape[0],p.shape[2],p.shape[3]])}var ld,ud=o((()=>{L(),j(),sd(),Rl(),z(),G(),ld=R({conv1d_:cd})}));function dd(e,t,n,r,i,a=`NHWC`,o){D(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let s=e,c=t,l=!1;t.rank===3&&(l=!0,c=W(t,[1,t.shape[0],t.shape[1],t.shape[2]]),s=[1,e[0],e[1],e[2]]),D(s.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${s.length}.`),D(c.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${c.rank}`),D(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);let u=a===`NHWC`?s[3]:s[1],d=a===`NHWC`?c.shape[3]:c.shape[1];D(u===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[2]}.`),D(d===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`),Ll(`conv2dDerInput`,i,o);let f={dy:c,filter:n},p={strides:r,pad:i,dataFormat:a,dimRoundingMode:o,inputShape:s},m=P.runKernel(Rt,f,p);return l?W(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var fd,pd=o((()=>{F(),A(),j(),Rl(),z(),G(),fd=R({conv2DBackpropInput_:dd})}));function md(e,t,n,r,i,a){let o=I(e,`x`,`conv2dTranspose`),s=I(t,`filter`,`conv2dTranspose`);return fd(n,o,s,r,i,`NHWC`,a)}var hd,gd=o((()=>{L(),pd(),z(),hd=R({conv2dTranspose_:md})}));function _d(e,t,n,r,i=`NDHWC`,a=[1,1,1]){let o=I(e,`x`,`conv3d`),s=I(t,`filter`,`conv3d`),c=o,l=!1;o.rank===4&&(l=!0,c=W(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),D(c.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${c.rank}.`),D(s.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${s.rank}.`),D(c.shape[4]===s.shape[3],()=>`Error in conv3d: depth of input (${c.shape[4]}) must match input depth for filter ${s.shape[3]}.`),D(Pl(n,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),D(i===`NDHWC`,()=>`Error in conv3d: got dataFormat of ${i} but only NDHWC is currently supported.`),D(Fl(a),()=>`Error in conv3D: Dilated rates should be larger than 0.`),D(Fl(n),()=>`Error in conv3D: Strides should be larger than 0.`);let u={x:c,filter:s},d={strides:n,pad:r,dataFormat:i,dilations:a},f=P.runKernel(zt,u,d);return l?W(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}var vd,yd=o((()=>{F(),A(),L(),j(),Rl(),z(),G(),vd=R({conv3d_:_d})}));function bd(e,t,n,r,i){D(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let a=e,o=t,s=!1;t.rank===4&&(s=!0,o=W(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),a=[1,e[0],e[1],e[2],e[3]]);let c=a[4],l=o.shape[4];D(a.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),D(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),D(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),D(c===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[3]}.`),D(l===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${n.shape[4]}.`);let u={dy:o,filter:n},d={pad:i,strides:r,inputShape:a},f=P.runKernel(Vt,u,d);return s?W(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}var xd,Sd=o((()=>{F(),A(),j(),z(),G(),xd=R({conv3DBackpropInput_:bd})}));function Cd(e,t,n,r,i){let a=I(e,`x`,`conv3dTranspose`),o=I(t,`filter`,`conv3dTranspose`);return xd(n,a,o,r,i)}var wd,Td=o((()=>{L(),Sd(),z(),wd=R({conv3dTranspose_:Cd})}));function Ed(e){let t={x:I(e,`x`,`cos`,`float32`)};return P.runKernel(`Cos`,t)}var Dd,Od=o((()=>{F(),A(),L(),z(),Dd=R({cos_:Ed})}));function kd(e){let t={x:I(e,`x`,`cosh`,`float32`)};return P.runKernel(Ht,t)}var Ad,jd=o((()=>{F(),A(),L(),z(),Ad=R({cosh_:kd})}));function Md(e,t=0,n=!1,r=!1){let i={x:I(e,`x`,`cumprod`)},a={axis:t,exclusive:n,reverse:r};return P.runKernel(Ut,i,a)}var Nd,Pd=o((()=>{F(),A(),L(),z(),Nd=R({cumprod_:Md})}));function Fd(e,t=0,n=!1,r=!1){let i={x:I(e,`x`,`cumsum`)},a={axis:t,exclusive:n,reverse:r};return P.runKernel(Wt,i,a)}var Id,Ld=o((()=>{F(),A(),L(),z(),Id=R({cumsum_:Fd})}));function Rd(e,t,n,r=!1){let i=I(e,`x`,`denseBincount`),a=I(t,`weights`,`denseBincount`);D(i.dtype===`int32`,()=>`Error in denseBincount: input dtype must be int32, but got ${i.dtype}`),D(i.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${i.rank}.`),D(n>=0,()=>`size must be non-negative, but got ${n}.`),D(a.size===i.size||a.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${i.shape}, weights shape: ${a.shape}.`);let o={x:i,weights:a},s={size:n,binaryOutput:r};return P.runKernel(Kt,o,s)}var zd,Bd=o((()=>{F(),A(),L(),j(),z(),zd=R({denseBincount_:Rd})}));function Vd(e,t,n=`NHWC`){let r=I(e,`x`,`depthToSpace`,`float32`),i=n===`NHWC`?r.shape[1]:r.shape[2],a=n===`NHWC`?r.shape[2]:r.shape[3],o=n===`NHWC`?r.shape[3]:r.shape[1];D(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),D(i*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${t}  for depthToSpace with input shape
    ${r.shape}`),D(a*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${t} for depthToSpace with input shape
        ${r.shape}`),D(o%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${o} for depthToSpace with input shape ${r.shape}`);let s={x:r},c={blockSize:t,dataFormat:n};return P.runKernel(qt,s,c)}var Hd,Ud=o((()=>{F(),A(),L(),j(),z(),Hd=R({depthToSpace_:Vd})}));function Wd(e,t,n,r,i=`NHWC`,a=[1,1],o){let s=I(e,`x`,`depthwiseConv2d`,`float32`),c=I(t,`filter`,`depthwiseConv2d`,`float32`),l=s,u=!1;s.rank===3&&(u=!0,l=W(s,[1,s.shape[0],s.shape[1],s.shape[2]])),D(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),D(c.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${c.rank}.`);let d=i===`NHWC`?l.shape[3]:l.shape[1];D(d===c.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${c.shape[2]}.`),Ll(`depthwiseConv2d`,r,o);let f={x:l,filter:c},p={strides:n,pad:r,dataFormat:i,dilations:a,dimRoundingMode:o},m=P.runKernel(Jt,f,p);return u?W(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var Gd,Kd=o((()=>{F(),A(),L(),j(),Rl(),z(),G(),Gd=R({depthwiseConv2d_:Wd})}));function qd(e){let t={x:I(e,`x`,`diag`)};return P.runKernel(Zt,t)}var Jd,Yd=o((()=>{F(),A(),L(),z(),Jd=R({diag_:qd})}));function Xd(e,t,n,r,i=[1,1],a=`NHWC`){let o=I(e,`x`,`dilation2d`),s=I(t,`filter`,`dilation2d`);D(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),D(s.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${s.rank}.`),D(a===`NHWC`,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let c=o,l=!1;o.rank===3&&(c=W(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=!0),D(c.shape[3]===s.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${c.shape[3]} vs ${s.shape[2]}`);let u={x:c,filter:s},d={strides:n,pad:r,dilations:i},f=P.runKernel(Qt,u,d);return l?W(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Zd,Qd=o((()=>{F(),A(),L(),j(),z(),G(),Zd=R({dilation2d_:Xd})})),$d=c({assertAndGetBroadcastShape:()=>nf,getBroadcastDims:()=>ef,getReductionAxes:()=>tf});
/**
* @license
* Copyright 2017 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/
function ef(e,t){let n=e.length,r=[];for(let i=0;i<n;i++){let a=n-1-i,o=e[a]||1;(t[t.length-1-i]||1)>1&&o===1&&r.unshift(a)}return r}function tf(e,t){let n=[];for(let r=0;r<t.length;r++){let i=e[e.length-r-1],a=t.length-r-1,o=t[a];(i==null||i===1&&o>1)&&n.unshift(a)}return n}function nf(e,t){let n=Math.max(e.length,t.length),r=Array(n);for(let i=0;i<n;i++){let a=e[e.length-i-1];a??=1;let o=t[t.length-i-1];if(o??=1,a===1)r[n-i-1]=o;else if(o===1)r[n-i-1]=a;else if(a!==o){let n=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(n)}else r[n-i-1]=a}return r}var rf=o((()=>{}));function af(e,t){let n=I(e,`a`,`equal`,`string_or_numeric`),r=I(t,`b`,`equal`,`string_or_numeric`);[n,r]=Ra(n,r),nf(n.shape,r.shape);let i={a:n,b:r};return P.runKernel(on,i)}var sf,cf=o((()=>{F(),A(),Wa(),L(),rf(),z(),sf=R({equal_:af})}));function lf(e,t,n){let r=I(t,`a`,`where`),i=I(n,`b`,`where`),a=I(e,`condition`,`where`,`bool`),o=nf(nf(a.shape,r.shape),i.shape),s=Lu(a,o),c=Lu(r,o),l=Lu(i,o),u={condition:s,t:c,e:l};return P.runKernel(wr,u)}var uf,df=o((()=>{F(),A(),L(),Ru(),rf(),z(),uf=R({where_:lf})}));function ff(e){let t={x:I(e,`x`,`zerosLike`)};return P.runKernel(ni,t)}var pf,mf=o((()=>{F(),A(),L(),z(),pf=R({zerosLike_:ff})}));function hf(e,t){let n=I(e,`a`,`div`),r=I(t,`b`,`div`);[n,r]=Ra(n,r);let i=Ac(n,r),a=pf(i),o=sf(r,a);return uf(o,a,i)}var gf,_f=o((()=>{Wa(),L(),jc(),cf(),z(),df(),mf(),gf=R({divNoNan_:hf})}));function vf(e,t){let n=I(e,`t1`,`dot`),r=I(t,`t2`,`dot`);D((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);let i=n.rank===1?n.size:n.shape[1],a=r.rank===1?r.size:r.shape[0];if(D(i===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${i} and ${a}.`),n.rank===1&&r.rank===1){let e=W(n,[1,-1]),t=W(r,[-1,1]),i=Xl(e,t);return W(i,[])}else if(n.rank===1&&r.rank===2){let e=W(n,[1,-1]),t=W(r,[r.shape[0],r.shape[1]]),i=Xl(e,t);return W(i,[i.size])}else if(n.rank===2&&r.rank===1){let e=W(r,[-1,1]),t=Xl(n,e);return W(t,[t.size])}else{let e=W(r,[r.shape[0],r.shape[1]]);return Xl(n,e)}}var yf,bf=o((()=>{L(),j(),Zl(),z(),G(),yf=R({dot_:vf})}));function xf(e,...t){let n=t.map((e,t)=>I(e,`tensors${t}`,`einsum`)),r={equation:e};return P.runKernel(rn,n,r)}var Sf,Cf=o((()=>{F(),A(),L(),z(),Sf=R({einsum_:xf})}));function wf(e){let t={x:I(e,`x`,`elu`,`float32`)};return P.runKernel(`Elu`,t)}var Tf,Ef=o((()=>{F(),A(),L(),z(),Tf=R({elu_:wf})}));function Df(e,t){let n=I(e,`x`,`ensureShape`,`string_or_numeric`);if(!he(n.shape,t))throw Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}var Of,kf=o((()=>{L(),Xe(),z(),Of=R({ensureShape_:Df})}));function Af(e){let t=I(e,`x`,`erf`);D(t.dtype===`int32`||t.dtype===`float32`,()=>"Input dtype must be `int32` or `float32`."),t.dtype===`int32`&&(t=V(t,`float32`));let n={x:t};return P.runKernel(`Erf`,n)}var jf,Mf=o((()=>{F(),A(),L(),j(),_c(),z(),jf=R({erf_:Af})}));function Nf(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function Pf(e,t,n){let r=e.length+t.length,i=[],a=0,o=0;for(let s=0;s<r;s++)n.indexOf(s)===-1?i.push(e[a++]):i.push(t[o++]);return i}function Ff(e,t){let n=[],r=e.length;for(let i=0;i<r;i++)t.indexOf(i)===-1&&n.push(e[i]);let i=t.map(t=>e[t]);return[n,i]}function If(e,t){let n=t.map(e=>1);return Pf(e,n,t)}function Lf(e,t,n){D(Nf(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function Rf(e,t){if(Nf(e,t))return null;let n=[];for(let r=0;r<t;++r)e.indexOf(r)===-1&&n.push(r);return e.forEach(e=>n.push(e)),n}function zf(e){return e.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function Bf(e,t){let n=[];for(let r=t-e;r<t;++r)n.push(r);return n}var Vf=o((()=>{j()}));function Hf(e,t=null,n=!1){let r={x:I(e,`x`,`max`)},i={reductionIndices:t,keepDims:n};return P.runKernel(`Max`,r,i)}var Uf,Wf=o((()=>{F(),A(),L(),z(),Uf=R({max_:Hf})}));function Gf(e,t=null,n=!1){let r={x:I(e,`x`,`min`)},i={axis:t,keepDims:n};return P.runKernel(`Min`,r,i)}var Kf,qf=o((()=>{F(),A(),L(),z(),Kf=R({min_:Gf})}));function Jf(e,t){let n=I(e,`base`,`pow`),r=I(t,`exp`,`pow`);[n,r]=Ra(n,r);let i={a:n,b:r};return P.runKernel(`Pow`,i)}var Yf,Xf=o((()=>{F(),A(),Wa(),L(),z(),Yf=R({pow_:Jf})}));function Zf(e,t){if((ea(e)&&t!==`string`||Array.isArray(e))&&t!==`complex64`)throw Error(`Error creating a new Scalar: value must be a primitive (number|boolean|string)`);if(t===`string`&&ea(e)&&!(e instanceof Uint8Array))throw Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return ho(e,[],[],t)}var Qf=o((()=>{j(),go()}));function $f(e){let t={x:I(e,`x`,`sqrt`,`float32`)};return P.runKernel(jr,t)}var ep,tp=o((()=>{F(),A(),L(),z(),ep=R({sqrt_:$f})}));function np(e){let t=I(e,`x`,`square`);return P.runKernel(`Square`,{x:t},{})}var rp,ip=o((()=>{F(),L(),z(),rp=R({square_:np})}));function ap(e,t=null,n=!1){let r=I(e,`x`,`sum`);r.dtype===`bool`&&(r=V(r,`int32`));let i={x:r},a={axis:t,keepDims:n};return P.runKernel(`Sum`,i,a)}var K,op=o((()=>{F(),A(),L(),_c(),z(),K=R({sum_:ap})}));function sp(e,t=`euclidean`,n=null,r=!1){e=I(e,`x`,`norm`);let i=cp(e,t,n),a=i.shape;if(r){let t=we(n,e.shape);a=If(i.shape,t)}return W(i,a)}function cp(e,t,n=null){if(e.rank===0)return Fc(e);if(e.rank!==1&&n===null)return cp(W(e,[-1]),t,n);if(e.rank===1||typeof n==`number`||Array.isArray(n)&&n.length===1){if(t===1)return K(Fc(e),n);if(t===1/0)return Uf(Fc(e),n);if(t===-1/0)return Kf(Fc(e),n);if(t===`euclidean`||t===2)return ep(K(Yf(Fc(e),Zf(2,`int32`)),n));throw Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1)return Uf(K(Fc(e),n[0]),n[1]-1);if(t===1/0)return Uf(K(Fc(e),n[1]),n[0]);if(t===-1/0)return Kf(K(Fc(e),n[1]),n[0]);if(t===`fro`||t===`euclidean`)return ep(K(rp(e),n));throw Error(`Error in norm: invalid ord value: ${t}`)}throw Error(`Error in norm: invalid axis: ${n}`)}var lp,up=o((()=>{L(),j(),Ic(),Vf(),Wf(),qf(),z(),Xf(),G(),Qf(),tp(),ip(),op(),lp=R({norm_:sp})}));function dp(e,t=null,n=!1){return lp(e,`euclidean`,t,n)}var fp,pp=o((()=>{up(),z(),fp=R({euclideanNorm_:dp})}));function mp(e){let t={x:I(e,`x`,`exp`)};return P.runKernel(`Exp`,t)}var hp,gp=o((()=>{F(),A(),L(),z(),hp=R({exp_:mp})}));function _p(e,t=0){let n=I(e,`x`,`expandDims`,`string_or_numeric`);D(t<=n.rank,()=>`Axis must be <= rank of the tensor`);let r={input:n},i={dim:t};return P.runKernel(sn,r,i)}var vp,yp=o((()=>{F(),A(),L(),j(),z(),vp=R({expandDims_:_p})}));function bp(e){let t={x:I(e,`x`,`expm1`)};return P.runKernel(cn,t)}var xp,Sp=o((()=>{F(),A(),L(),z(),xp=R({expm1_:bp})}));function Cp(e,t){let n=I(e,`x`,`tile`,`string_or_numeric`);D(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);let r={x:n},i={reps:t};return P.runKernel(Jr,r,i)}var wp,Tp=o((()=>{F(),A(),L(),j(),z(),wp=R({tile_:Cp})}));function Ep(e,t,n,r=`float32`){t??=e;let i=mc([e,t],r),a=e<=t?e:t;for(let e=0;e<a;++e)i.set(1,e,e);let o=W(i.toTensor(),[e,t]);if(n==null)return o;if(n.length===1)return wp(vp(o,0),[n[0],1,1]);if(n.length===2)return wp(vp(vp(o,0),0),[n[0],n[1],1,1]);if(n.length===3)return wp(vp(vp(vp(o,0),0),0),[n[0],n[1],n[2],1,1]);throw Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}var Dp,Op=o((()=>{hc(),yp(),z(),G(),Tp(),Dp=R({eye_:Ep})}));function kp(e){let t={x:I(e,`x`,`floor`,`float32`)};return P.runKernel(dn,t)}var Ap,jp=o((()=>{F(),A(),L(),z(),Ap=R({floor_:kp})}));function Mp(e,t,n=0,r=0){let i=I(e,`x`,`gather`),a=I(t,`indices`,`gather`,`int32`),o={x:i,indices:a},s={axis:n,batchDims:r};return P.runKernel(mn,o,s)}var Np,Pp=o((()=>{F(),A(),L(),z(),Np=R({gather_:Mp})}));function Fp(e,t){let n=I(e,`a`,`greater`,`string_or_numeric`),r=I(t,`b`,`greater`,`string_or_numeric`);[n,r]=Ra(n,r),nf(n.shape,r.shape);let i={a:n,b:r};return P.runKernel(gn,i)}var Ip,Lp=o((()=>{F(),A(),Wa(),L(),rf(),z(),Ip=R({greater_:Fp})}));function Rp(e,t){let n=I(e,`a`,`greaterEqual`,`string_or_numeric`),r=I(t,`b`,`greaterEqual`,`string_or_numeric`);[n,r]=Ra(n,r),nf(n.shape,r.shape);let i={a:n,b:r};return P.runKernel(_n,i)}var zp,Bp=o((()=>{F(),A(),Wa(),L(),rf(),z(),zp=R({greaterEqual_:Rp})}));function Vp(e){let t={input:I(e,`input`,`imag`)};return P.runKernel(bn,t)}var Hp,Up=o((()=>{F(),A(),L(),z(),Hp=R({imag_:Vp})}));function Wp(e){let t={x:I(e,`x`,`isFinite`)};return P.runKernel(xn,t)}var Gp,Kp=o((()=>{F(),A(),L(),z(),Gp=R({isFinite_:Wp})}));function qp(e){let t={x:I(e,`x`,`isInf`)};return P.runKernel(Sn,t)}var Jp,Yp=o((()=>{F(),A(),L(),z(),Jp=R({isInf_:qp})}));function Xp(e){let t={x:I(e,`x`,`isNaN`)};return P.runKernel(Cn,t)}var Zp,Qp=o((()=>{F(),A(),L(),z(),Zp=R({isNaN_:Xp})}));function $p(e,t=.2){let n={x:I(e,`x`,`leakyRelu`)},r={alpha:t};return P.runKernel(wn,n,r)}var em,tm=o((()=>{F(),A(),L(),z(),em=R({leakyRelu_:$p})}));function nm(e,t){let n=I(e,`a`,`less`,`string_or_numeric`),r=I(t,`b`,`less`,`string_or_numeric`);[n,r]=Ra(n,r),nf(n.shape,r.shape);let i={a:n,b:r};return P.runKernel(Tn,i)}var rm,im=o((()=>{F(),A(),Wa(),L(),rf(),z(),rm=R({less_:nm})}));function am(e,t){let n=I(e,`a`,`lessEqual`,`string_or_numeric`),r=I(t,`b`,`lessEqual`,`string_or_numeric`);[n,r]=Ra(n,r),nf(n.shape,r.shape);let i={a:n,b:r};return P.runKernel(En,i)}var om,sm=o((()=>{F(),A(),Wa(),L(),rf(),z(),om=R({lessEqual_:am})}));function cm(e,t,n){if(n<=0)throw Error(`The number of values should be positive.`);let r={start:e,stop:t,num:n};return P.runKernel(Dn,{},r)}var eee=o((()=>{F(),A()}));function tee(e,t=5,n=1,r=1,i=.5){let a=I(e,`x`,`localResponseNormalization`);D(a.rank===4||a.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${a.rank}.`),D(_e(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let o=a,s=!1;a.rank===3&&(s=!0,o=W(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let c={x:o},l={depthRadius:t,bias:n,alpha:r,beta:i},u=P.runKernel(`LRN`,c,l);return s?W(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var lm,um=o((()=>{F(),A(),L(),j(),z(),G(),lm=R({localResponseNormalization_:tee})}));function nee(e){let t={x:I(e,`x`,`log`,`float32`)};return P.runKernel(`Log`,t)}var dm,fm=o((()=>{F(),A(),L(),z(),dm=R({log_:nee})}));function ree(e){let t={x:I(e,`x`,`log1p`)};return P.runKernel(On,t)}var pm,mm=o((()=>{F(),A(),L(),z(),pm=R({log1p_:ree})}));function iee(e){return D(Le(e),()=>`The f passed in grad(f) must be a function`),(t,n)=>{let r=I(t,`x`,`tf.grad`,`string_or_numeric`),i=n==null?null:I(n,`dy`,`tf.grad`);return P.tidy(()=>{let{value:t,grads:n}=P.gradients(()=>e(r),[r],i);return i!=null&&fe(t.shape,i.shape,`The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)`),_m(n),n[0]})}}function aee(e){return D(Le(e),()=>`The f passed in grads(f) must be a function`),(t,n)=>{D(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let r=lo(t,`args`,`tf.grads`,`string_or_numeric`),i=n==null?null:I(n,`dy`,`tf.grads`);return P.tidy(()=>{let{value:t,grads:n}=P.gradients(()=>e(...r),r,i);return i!=null&&fe(t.shape,i.shape,`The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])`),_m(n),n})}}function oee(e){return D(Le(e),()=>`The f passed in valueAndGrad(f) must be a function`),(t,n)=>{D(t instanceof wa,()=>`The x passed in valueAndGrad(f)(x) must be a tensor`),D(n==null||n instanceof wa,()=>`The dy passed in valueAndGrad(f)(x, dy) must be a tensor`);let{grads:r,value:i}=P.gradients(()=>e(t),[t],n);return _m(r),{grad:r[0],value:i}}}function see(e){return D(Le(e),()=>`The f passed in valueAndGrads(f) must be a function`),(t,n)=>{D(Array.isArray(t)&&t.every(e=>e instanceof wa),()=>`The args passed in valueAndGrads(f)(args) must be array of tensors`),D(n==null||n instanceof wa,()=>`The dy passed in valueAndGrads(f)(args, dy) must be a tensor`);let r=P.gradients(()=>e(...t),t,n);return n!=null&&fe(r.value.shape,n.shape,`The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])`),_m(r.grads),r}}function hm(e,t){D(Le(e),()=>`The f passed in variableGrads(f) must be a function`),D(t==null||Array.isArray(t)&&t.every(e=>e instanceof Ta),()=>`The varList passed in variableGrads(f, varList) must be an array of variables`);let n=t!=null;if(!n)for(let e in t=[],P.registeredVariables)t.push(P.registeredVariables[e]);let r=n?t.filter(e=>!e.trainable):null,i=t.length;t=t.filter(e=>e.trainable),D(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${i} variables is trainable.`);let{value:a,grads:o}=P.gradients(e,t,null,!0);D(o.some(e=>e!=null),()=>`Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().`),D(a.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);let s={};return t.forEach((e,t)=>{o[t]!=null&&(s[e.name]=o[t])}),r?.forEach(e=>s[e.name]=null),{value:a,grads:s}}function gm(e){return P.customGrad(e)}function _m(e){if(e.filter(e=>e==null).length>0)throw Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}var vm=o((()=>{F(),N(),L(),j()}));function ym(e){let t={x:I(e,`x`,`neg`)};return P.runKernel(`Neg`,t)}var bm,xm=o((()=>{F(),A(),L(),z(),bm=R({neg_:ym})}));function Sm(e){let t={x:I(e,`x`,`softplus`)};return P.runKernel(Ar,t)}var Cm,wm=o((()=>{F(),A(),L(),z(),Cm=R({softplus_:Sm})}));function Tm(e){let t=I(e,`x`,`logSigmoid`);return gm(e=>({value:bm(Cm(bm(e))),gradFunc:t=>U(t,$l(bm(e)))}))(t)}var Em,Dm=o((()=>{vm(),L(),Nc(),xm(),z(),eu(),wm(),Em=R({logSigmoid_:Tm})}));function Om(e,t){let n=I(e,`a`,`sub`),r=I(t,`b`,`sub`);[n,r]=Ra(n,r);let i={a:n,b:r};return P.runKernel(`Sub`,i)}var q,km=o((()=>{F(),A(),Wa(),L(),z(),q=R({sub_:Om})}));function Am(e,t=-1){let n=I(e,`logits`,`logSoftmax`);if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return gm((e,n)=>{let r=Uf(e,t,!0),i=q(e,r),a=q(V(i,`float32`),dm(K(hp(i),t,!0)));return n([a]),{value:a,gradFunc:(e,n)=>{let[r]=n,i=hp(r);return q(e,U(K(e,t,!0),i))}}})(n)}var jm,Mm=o((()=>{vm(),L(),_c(),gp(),fm(),Wf(),Nc(),z(),km(),op(),jm=R({logSoftmax_:Am})}));function Nm(e,t=null,n=!1){let r=I(e,`x`,`logSumExp`),i=we(t,r.shape),a=Uf(r,i,!0),o=q(r,a),s=hp(o),c=K(s,i),l=dm(c),u=H(W(a,l.shape),l);if(n){let e=If(u.shape,i);return W(u,e)}return u}var Pm,Fm=o((()=>{L(),j(),Tc(),Vf(),gp(),fm(),Wf(),z(),G(),km(),op(),Pm=R({logSumExp_:Nm})}));function Im(e,t){let n=I(e,`a`,`logicalAnd`,`bool`),r=I(t,`b`,`logicalAnd`,`bool`);nf(n.shape,r.shape);let i={a:n,b:r};return P.runKernel(kn,i)}var Lm,Rm=o((()=>{F(),A(),L(),rf(),z(),Lm=R({logicalAnd_:Im})}));function zm(e){let t={x:I(e,`x`,`logicalNot`,`bool`)};return P.runKernel(An,t)}var Bm,Vm=o((()=>{F(),A(),L(),z(),Bm=R({logicalNot_:zm})}));function Hm(e,t){let n=I(e,`a`,`logicalOr`,`bool`),r=I(t,`b`,`logicalOr`,`bool`);nf(n.shape,r.shape);let i={a:n,b:r};return P.runKernel(jn,i)}var Um,Wm=o((()=>{F(),A(),L(),rf(),z(),Um=R({logicalOr_:Hm})}));function cee(e,t){let n=I(e,`a`,`logicalXor`,`bool`),r=I(t,`b`,`logicalXor`,`bool`);return nf(n.shape,r.shape),Lm(Um(e,t),Bm(Lm(e,t)))}var Gm,Km=o((()=>{L(),rf(),Rm(),Vm(),Wm(),z(),Gm=R({logicalXor_:cee})}));function lee(e,t,n=`left`){let r=I(e,`sortedSequence`,`searchSorted`),i=I(t,`values`,`searchSorted`),a=r.shape[r.shape.length-1],o=i.shape[i.shape.length-1],s=W(r,[-1,a]),c=W(i,[-1,o]);if(s.rank<2)throw Error(`Sorted input argument must be at least 2-dimensional`);if(s.shape[0]!==c.shape[0])throw Error(`Leading dimension of 'sortedSequence' and 'values' must match.`);if(O(c.shape)>=qm)throw Error(`values tensor size must less than ${qm}`);if(s.shape[1]>=qm)throw Error(`trailing dim_size must less than ${qm} for int32 output type, was ${s.shape[1]}`);let l={sortedSequence:s,values:c},u={side:n};return P.runKernel(Cr,l,u)}var qm,Jm,Ym=o((()=>{F(),A(),L(),Xe(),z(),G(),qm=2147483648,Jm=R({searchSorted_:lee})}));function Xm(e,t){return Jm(e,t,`left`)}var uee=o((()=>{Ym()}));function dee(e,t,n,r,i){let a=I(e,`x`,`maxPool`),o=a,s=!1;a.rank===3&&(s=!0,o=W(a,[1,a.shape[0],a.shape[1],a.shape[2]])),D(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),D(Pl(n,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`),Ll(`maxPool`,r,i);let c={x:o},l={filterSize:t,strides:n,pad:r,dimRoundingMode:i},u=P.runKernel(Rn,c,l);return s?W(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var Zm,Qm=o((()=>{F(),A(),L(),j(),Rl(),z(),G(),Zm=R({maxPool_:dee})}));function fee(e,t=[1,1,1],n,r,i,a=`NDHWC`){let o=I(e,`x`,`maxPool3d`),s=o,c=!1;o.rank===4&&(c=!0,s=W(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),D(s.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${s.rank}.`),D(a===`NDHWC`,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),Ll(`maxPool3d`,r,i);let l={x:s},u={filterSize:t,strides:n,pad:r,dimRoundingMode:i,dataFormat:a},d=P.runKernel(Bn,l,u);return c?W(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var $m,pee=o((()=>{F(),A(),L(),j(),Rl(),z(),G(),$m=R({maxPool3d_:fee})}));function mee(e,t,n,r,i=!1){let a={x:I(e,`x`,`maxPoolWithArgmax`)},o={filterSize:t,strides:n,pad:r,includeBatchInIndex:i},s=P.runKernel(Hn,a,o);return{result:s[0],indexes:s[1]}}var eh,hee=o((()=>{F(),A(),L(),z(),eh=R({maxPoolWithArgmax_:mee})}));function gee(e,t){let n=I(e,`a`,`maximum`),r=I(t,`b`,`maximum`);[n,r]=Ra(n,r),n.dtype===`bool`&&(n=V(n,`int32`),r=V(r,`int32`)),nf(n.shape,r.shape);let i={a:n,b:r};return P.runKernel(Ln,i)}var th,nh=o((()=>{F(),A(),Wa(),L(),rf(),_c(),z(),th=R({maximum_:gee})}));function _ee(e,t=null,n=!1){let r={x:I(e,`x`,`mean`)},i={axis:t,keepDims:n};return P.runKernel(Un,r,i)}var rh,ih=o((()=>{F(),A(),L(),z(),rh=R({mean_:_ee})}));function ah(e,t=`float32`){if(Ke(e),t===`complex64`){let t=ah(e,`float32`),n=ah(e,`float32`);return po(t,n)}let n=We(O(e),t);return P.makeTensor(n,e,t)}var oh=o((()=>{F(),j(),mo()}));function sh(e,t=`float32`){if(Ke(e),t===`complex64`){let t=sh(e,`float32`),n=ah(e,`float32`);return po(t,n)}let n=Ue(O(e),t);return P.makeTensor(n,e,t)}var ch=o((()=>{F(),j(),Xe(),mo(),oh()}));function lh(e,t,{indexing:n=`xy`}={}){if(n!==`xy`&&n!==`ij`)throw TypeError(`${n} is not a valid third argument to meshgrid`);if(e===void 0)return[];let r=I(e,`x`,`meshgrid`,e instanceof wa?e.dtype:`float32`);if(t===void 0)return[r];let i=I(t,`y`,`meshgrid`,t instanceof wa?t.dtype:`float32`),a=O(r.shape),o=O(i.shape);return n===`xy`?(r=W(r,[1,-1]),i=W(i,[-1,1]),[Xl(sh([o,1],r.dtype),r),Xl(i,sh([1,a],i.dtype))]):(r=W(r,[-1,1]),i=W(i,[1,-1]),[Xl(r,sh([1,o],r.dtype)),Xl(sh([a,1],i.dtype),i)])}var vee=o((()=>{Zl(),ch(),G(),N(),L(),Xe()}));function yee(e,t){let n=I(e,`a`,`minimum`),r=I(t,`b`,`minimum`);[n,r]=Ra(n,r),n.dtype===`bool`&&(n=V(n,`int32`),r=V(r,`int32`)),nf(n.shape,r.shape);let i={a:n,b:r};return P.runKernel(Wn,i)}var uh,dh=o((()=>{F(),A(),Wa(),L(),rf(),_c(),z(),uh=R({minimum_:yee})}));function bee(e,t,n){D(n===`reflect`||n===`symmetric`,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);let r=I(e,`x`,`mirrorPad`);if(r.rank===0)throw Error(`mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad`);D(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);let i=n===`reflect`?1:0;for(let e=0;e<r.rank;e++)D(t[e].length===2,()=>`Invalid number of paddings. Must be length of 2 each.`),D(t[e][0]>=0&&t[e][0]<=r.shape[e]-i&&t[e][1]>=0&&t[e][1]<=r.shape[e]-i,()=>`Padding in dimension ${e} cannot be greater than or equal to ${r.shape[e]-i} or less than 0 for input of shape ${r.shape}`);let a={paddings:t,mode:n},o={x:r};return P.runKernel(Gn,o,a)}var fh,ph=o((()=>{F(),A(),L(),j(),z(),fh=R({mirrorPad_:bee})}));function xee(e,t){let n=I(e,`a`,`mod`),r=I(t,`b`,`mod`);[n,r]=Ra(n,r);let i={a:n,b:r};return P.runKernel(`Mod`,i)}var mh,hh=o((()=>{F(),A(),Wa(),L(),z(),mh=R({mod_:xee})}));function See(e,t=null,n=!1){e=I(e,`x`,`moments`);let r=we(t,e.shape),i=rh(e,r,n),a=i.shape;n||(a=If(i.shape,r));let o=rp(q(V(e,`float32`),W(i,a))),s=rh(o,r,n);return{mean:i,variance:s}}var gh,Cee=o((()=>{L(),j(),Vf(),_c(),ih(),z(),G(),ip(),km(),gh=R({moments_:See})}));function wee(e,t,n,r){let i=I(t,`data`,`multiRNNCell`),a=lo(n,`c`,`multiRNNCell`),o=lo(r,`h`,`multiRNNCell`),s=i,c=[];for(let t=0;t<e.length;t++){let n=e[t](s,a[t],o[t]);c.push(n[0]),c.push(n[1]),s=n[1]}let l=[],u=[];for(let e=0;e<c.length;e+=2)l.push(c[e]),u.push(c[e+1]);return[l,u]}var _h,Tee=o((()=>{L(),z(),_h=R({multiRNNCell_:wee})}));function Eee(e,t,n,r=!1){let i=I(e,`logits`,`multinomial`),a=i.size,o=i.rank;if(a<2)throw Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(o>2)throw Error(`Rank of probabilities must be 1 or 2, but is ${o}`);n||=Math.random();let s={logits:o===1?W(i,[1,-1]):i},c={numSamples:t,seed:n,normalized:r},l=P.runKernel(Kn,s,c);return o===1?W(l,[l.size]):l}var vh,Dee=o((()=>{F(),A(),L(),z(),G(),vh=R({multinomial_:Eee})}));function Oee(e,t){let n=I(e,`a`,`notEqual`,`string_or_numeric`),r=I(t,`b`,`notEqual`,`string_or_numeric`);[n,r]=Ra(n,r),nf(n.shape,r.shape);let i={a:n,b:r};return P.runKernel(Jn,i)}var yh,bh=o((()=>{F(),A(),Wa(),L(),rf(),z(),yh=R({notEqual_:Oee})}));function kee(e,t,n=1,r=0,i=`int32`){if(t<2)throw Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let a={indices:I(e,`indices`,`oneHot`,`int32`)},o={dtype:i,depth:t,onValue:n,offValue:r};return P.runKernel($n,a,o)}var xh,Sh=o((()=>{F(),A(),L(),z(),xh=R({oneHot_:kee})}));function Ch(e){let t={x:I(e,`x`,`onesLike`)};return P.runKernel(Qn,t)}var wh,Th=o((()=>{F(),A(),L(),z(),wh=R({onesLike_:Ch})}));function Eh(e,t){let n=I(e,`v1`,`outerProduct`),r=I(t,`v2`,`outerProduct`);D(n.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);let i=W(n,[-1,1]),a=W(r,[1,-1]);return Xl(i,a)}var Dh,Oh=o((()=>{L(),j(),Zl(),z(),G(),Dh=R({outerProduct_:Eh})}));function kh(e,t,n=0){let r=I(e,`x`,`pad`);if(r.rank===0)throw Error(`pad(scalar) is not defined. Pass non-scalar to pad`);let i={paddings:t,constantValue:n},a={x:r};return P.runKernel(tr,a,i)}var Ah,jh=o((()=>{F(),A(),L(),z(),Ah=R({pad_:kh})}));function Mh(e,t,n=0){return D(t.length===2,()=>`Invalid number of paddings. Must be length of 2.`),Ah(e,[t],n)}var Nh,Ph=o((()=>{j(),z(),jh(),Nh=R({pad1d_:Mh})}));function Fh(e,t,n=0){return D(t.length===2&&t[0].length===2&&t[1].length===2,()=>`Invalid number of paddings. Must be length of 2 each.`),Ah(e,t,n)}var Ih,Lh=o((()=>{j(),z(),jh(),Ih=R({pad2d_:Fh})}));function Rh(e,t,n=0){return D(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>`Invalid number of paddings. Must be length of 2 each.`),Ah(e,t,n)}var zh,Aee=o((()=>{j(),z(),jh(),zh=R({pad3d_:Rh})}));function jee(e,t,n=0){return D(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>`Invalid number of paddings. Must be length of 2 each.`),Ah(e,t,n)}var Bh,Mee=o((()=>{j(),z(),jh(),Bh=R({pad4d_:jee})}));function Nee(e,t,n){let r=I(e,`x`,`spaceToBatchND`);D(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),D(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),D(r.shape.reduce((e,r,i)=>i>0&&i<=t.length?e&&(r+n[i-1][0]+n[i-1][1])%t[i-1]===0:e,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);let i={x:r},a={blockShape:t,paddings:n};return P.runKernel(Mr,i,a)}var Vh,Hh=o((()=>{F(),A(),L(),j(),z(),Vh=R({spaceToBatchND_:Nee})}));function Pee(e,t,n,r,i,a,o){i??=[1,1],a??=1,r===0&&(r=`valid`);let s=I(e,`x`,`maxPool`),c=s,l=!1;s.rank===3&&(l=!0,c=W(s,[1,s.shape[0],s.shape[1],s.shape[2]])),D(Pl(a,i),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${i}'`);let u=bl(c.shape,t,a,i,r),d=[u.dilationHeight,u.dilationWidth],f;f=r===`same`?Iee([u.filterHeight,u.filterWidth],d):[[0,0],[0,0]];let p=d[0]===1&&d[1]===1,[m,h]=Fee([u.inHeight,u.inWidth],d,f),g=p?r:`valid`,_=p?c:Vh(c,d,m),v=(n===`avg`?()=>Vl(_,t,a,g,o):()=>Zm(_,t,a,g,o))(),y=p?v:du(v,d,h);return l?W(y,[y.shape[1],y.shape[2],y.shape[3]]):y}function Fee(e,t,n){let r=n.map(e=>e[0]),i=n.map(e=>e[1]),a=e.concat(r,i),o=t.map((e,t)=>(e-a[t]%e)%e),s=i.map((e,t)=>e+o[t]),c=t.map((e,t)=>[r[t],s[t]]),l=t.map((e,t)=>[0,o[t]]);return[c,l]}function Iee(e,t){let n=e.map((e,n)=>e+(e-1)*(t[n]-1)).map(e=>e-1),r=n.map(e=>Math.floor(e/2)),i=n.map((e,t)=>e-r[t]);return n.map((e,t)=>[r[t],i[t]])}var Uh,Wh=o((()=>{L(),j(),Hl(),fu(),Rl(),Qm(),z(),G(),Hh(),Uh=R({pool_:Pee})}));function Lee(e,t){let n=I(e,`x`,`prelu`),r=I(t,`alpha`,`prelu`),i={x:n,alpha:r};return P.runKernel(rr,i)}var Gh,Kh=o((()=>{F(),A(),L(),z(),Gh=R({prelu_:Lee})}));function Ree(e,t=null,n=!1){let r=I(e,`x`,`prod`);r.dtype===`bool`&&(r=V(r,`int32`));let i={x:r},a={axis:t,keepDims:n};return P.runKernel(ir,i,a)}var qh,Jh=o((()=>{F(),A(),L(),_c(),z(),qh=R({prod_:Ree})}));function zee(e,t,n,r){let i=e.map((e,t)=>I(e,`tensors${t}`,`raggedGather`,`int32`)),a=I(t,`paramsDenseValues`,`raggedGather`),o=I(n,`indices`,`raggedGather`,`int32`),s={paramsNestedSplits:i,paramsDenseValues:a,indices:o},c={outputRaggedRank:r},l=P.runKernel(ar,s,c);return{outputNestedSplits:l.slice(0,l.length-1),outputDenseValues:l[l.length-1]}}var Yh,Bee=o((()=>{F(),A(),L(),z(),Yh=R({raggedGather_:zee})}));function Vee(e,t,n){let r=I(e,`starts`,`raggedRange`),i=I(t,`limits`,`raggedRange`,r.dtype),a=I(n,`deltas`,`raggedRange`,r.dtype),o={starts:r,limits:i,deltas:a},s=P.runKernel(or,o);return{rtNestedSplits:s[0],rtDenseValues:s[1]}}var Xh,Hee=o((()=>{F(),A(),L(),z(),Xh=R({raggedRange_:Vee})}));function Uee(e,t,n,r,i){let a=I(e,`shape`,`raggedTensorToTensor`,`int32`),o=I(t,`values`,`raggedTensorToTensor`),s=I(n,`defaultValue`,`raggedTensorToTensor`,o.dtype),c=r.map((e,t)=>I(e,`tensors${t}`,`raggedTensorToTensor`,`int32`)),l={shape:a,values:o,defaultValue:s,rowPartitionTensors:c},u={rowPartitionTypes:i};return P.runKernel(sr,l,u)}var Zh,Wee=o((()=>{F(),A(),L(),z(),Zh=R({raggedTensorToTensor_:Uee})}));function Gee(e,t,n){Ke(e);let r=O(e),i=null;if(n==null||n===`float32`)i=new Float32Array(r);else if(n===`int32`)i=new Int32Array(r);else if(n===`bool`)i=new Uint8Array(r);else throw Error(`Unknown data type ${n}`);for(let e=0;e<r;e++)i[e]=t();return P.makeTensor(i,e,n)}var Qh,Kee=o((()=>{F(),j(),Xe(),z(),Qh=R({rand_:Gee})})),qee=s(((e,t)=>{(function(e,t,n){function r(e){var t=this,n=o();t.next=function(){var e=2091639*t.s0+t.c*23283064365386963e-26;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=e|0)},t.c=1,t.s0=n(` `),t.s1=n(` `),t.s2=n(` `),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function a(e,t){var n=new r(e),a=t&&t.state,o=n.next;return o.int32=function(){return n.next()*4294967296|0},o.double=function(){return o()+(o()*2097152|0)*11102230246251565e-32},o.quick=o,a&&(typeof a==`object`&&i(a,n),o.state=function(){return i(n,{})}),o}function o(){var e=4022871197;return function(t){t=String(t);for(var n=0;n<t.length;n++){e+=t.charCodeAt(n);var r=.02519603282416938*e;e=r>>>0,r-=e,r*=e,e=r>>>0,r-=e,e+=r*4294967296}return(e>>>0)*23283064365386963e-26}}t&&t.exports?t.exports=a:n&&n.amd?n(function(){return a}):this.alea=a})(e,typeof t==`object`&&t,typeof define==`function`&&define)})),Jee=s(((e,t)=>{(function(e,t,n){function r(e){var t=this,n=``;t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(e|0)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=n.charCodeAt(r)|0,t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function a(e,t){var n=new r(e),a=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21);while(r===0);return r},o.int32=n.next,o.quick=o,a&&(typeof a==`object`&&i(a,n),o.state=function(){return i(n,{})}),o}t&&t.exports?t.exports=a:n&&n.amd?n(function(){return a}):this.xor128=a})(e,typeof t==`object`&&t,typeof define==`function`&&define)})),Yee=s(((e,t)=>{(function(e,t,n){function r(e){var t=this,n=``;t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^(e^e<<1))|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(e|0)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=n.charCodeAt(r)|0,r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function a(e,t){var n=new r(e),a=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21);while(r===0);return r},o.int32=n.next,o.quick=o,a&&(typeof a==`object`&&i(a,n),o.state=function(){return i(n,{})}),o}t&&t.exports?t.exports=a:n&&n.amd?n(function(){return a}):this.xorwow=a})(e,typeof t==`object`&&t,typeof define==`function`&&define)})),Xee=s(((e,t)=>{(function(e,t,n){function r(e){var t=this;t.next=function(){var e=t.x,n=t.i,r=e[n],i;return r^=r>>>7,i=r^r<<24,r=e[n+1&7],i^=r^r>>>10,r=e[n+3&7],i^=r^r>>>3,r=e[n+4&7],i^=r^r<<7,r=e[n+7&7],r^=r<<13,i^=r^r<<9,e[n]=i,t.i=n+1&7,i};function n(e,t){var n,r=[];if(t===(t|0))r[0]=t;else for(t=``+t,n=0;n<t.length;++n)r[n&7]=r[n&7]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&r[n]===0;++n);for(n==8?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}n(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function a(e,t){e??=+new Date;var n=new r(e),a=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21);while(r===0);return r},o.int32=n.next,o.quick=o,a&&(a.x&&i(a,n),o.state=function(){return i(n,{})}),o}t&&t.exports?t.exports=a:n&&n.amd?n(function(){return a}):this.xorshift7=a})(e,typeof t==`object`&&t,typeof define==`function`&&define)})),Zee=s(((e,t)=>{(function(e,t,n){function r(e){var t=this;t.next=function(){var e=t.w,n=t.X,r=t.i,i,a;return t.w=e=e+1640531527|0,a=n[r+34&127],i=n[r=r+1&127],a^=a<<13,i^=i<<17,a^=a>>>15,i^=i>>>12,a=n[r]=a^i,t.i=r,a+(e^e>>>16)|0};function n(e,t){var n,r,i,a,o,s=[],c=128;for(t===(t|0)?(r=t,t=null):(t+=`\0`,r=0,c=Math.max(c,t.length)),i=0,a=-32;a<c;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),a===0&&(o=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(o=o+1640531527|0,n=s[a&127]^=r+o,i=n==0?i+1:0);for(i>=128&&(s[(t&&t.length||0)&127]=-1),i=127,a=512;a>0;--a)r=s[i+34&127],n=s[i=i+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[i]=r^n;e.w=o,e.X=s,e.i=i}n(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function a(e,t){e??=+new Date;var n=new r(e),a=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21);while(r===0);return r},o.int32=n.next,o.quick=o,a&&(a.X&&i(a,n),o.state=function(){return i(n,{})}),o}t&&t.exports?t.exports=a:n&&n.amd?n(function(){return a}):this.xor4096=a})(e,typeof t==`object`&&t,typeof define==`function`&&define)})),Qee=s(((e,t)=>{(function(e,t,n){function r(e){var t=this,n=``;t.next=function(){var e=t.b,n=t.c,r=t.d,i=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^i,i=i-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^i,t.a=i-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=e|0):n+=e;for(var r=0;r<n.length+20;r++)t.b^=n.charCodeAt(r)|0,t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function a(e,t){var n=new r(e),a=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21);while(r===0);return r},o.int32=n.next,o.quick=o,a&&(typeof a==`object`&&i(a,n),o.state=function(){return i(n,{})}),o}t&&t.exports?t.exports=a:n&&n.amd?n(function(){return a}):this.tychei=a})(e,typeof t==`object`&&t,typeof define==`function`&&define)})),$ee=s(((e,t)=>{(function(e,n,r){var i=256,a=6,o=52,s=`random`,c=r.pow(i,a),l=r.pow(2,o),u=l*2,d=i-1,f;function p(e,t,o){var d=[];t=t==1?{entropy:!0}:t||{};var f=_(g(t.entropy?[e,y(n)]:e??v(),3),d),p=new m(d),b=function(){for(var e=p.g(a),t=c,n=0;e<l;)e=(e+n)*i,t*=i,n=p.g(1);for(;e>=u;)e/=2,t/=2,n>>>=1;return(e+n)/t};return b.int32=function(){return p.g(4)|0},b.quick=function(){return p.g(4)/4294967296},b.double=b,_(y(p.S),n),(t.pass||o||function(e,t,n,i){return i&&(i.S&&h(i,p),e.state=function(){return h(p,{})}),n?(r[s]=e,t):e})(b,f,`global`in t?t.global:this==r,t.state)}function m(e){var t,n=e.length,r=this,a=0,o=r.i=r.j=0,s=r.S=[];for(n||(e=[n++]);a<i;)s[a]=a++;for(a=0;a<i;a++)s[a]=s[o=d&o+e[a%n]+(t=s[a])],s[o]=t;(r.g=function(e){for(var t,n=0,a=r.i,o=r.j,s=r.S;e--;)t=s[a=d&a+1],n=n*i+s[d&(s[a]=s[o=d&o+t])+(s[o]=t)];return r.i=a,r.j=o,n})(i)}function h(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n=[],r=typeof e,i;if(t&&r==`object`)for(i in e)try{n.push(g(e[i],t-1))}catch{}return n.length?n:r==`string`?e:e+`\0`}function _(e,t){for(var n=e+``,r,i=0;i<n.length;)t[d&i]=d&(r^=t[d&i]*19)+n.charCodeAt(i++);return y(t)}function v(){try{var t;return f&&(t=f.randomBytes)?t=t(i):(t=new Uint8Array(i),(e.crypto||e.msCrypto).getRandomValues(t)),y(t)}catch{var r=e.navigator,a=r&&r.plugins;return[+new Date,e,a,e.screen,y(n)]}}function y(e){return String.fromCharCode.apply(0,e)}if(_(r.random(),n),typeof t==`object`&&t.exports){t.exports=p;try{f=lc()}catch{}}else typeof define==`function`&&define.amd?define(function(){return p}):r[`seed`+s]=p})(typeof self<`u`?self:e,[],Math)})),ete=s(((e,t)=>{var n=qee(),r=Jee(),i=Yee(),a=Xee(),o=Zee(),s=Qee(),c=$ee();c.alea=n,c.xor128=r,c.xorwow=i,c.xorshift7=a,c.xor4096=o,c.tychei=s,t.exports=c})),tte=c({TEST_EPSILON_FLOAT16:()=>ig,createVideoElement:()=>cte,encodeStrings:()=>ng,expectArrayBuffersEqual:()=>ste,expectArraysClose:()=>nte,expectArraysEqual:()=>ite,expectNumbersClose:()=>ate,expectPromiseToFail:()=>rte,expectValuesInRange:()=>ote,play:()=>lte,testEpsilon:()=>$h});function nte(e,t,n){return n??=$h(),eg(e,t,(e,t)=>tg(e,t,n))}function $h(){return P.backend.floatPrecision()===32?rg:ig}function eg(e,t,n){let r=!0;if((ea(e)||ea(t))&&(r=!1),ea(e)&&ea(t)&&(r=!0),r){let n=e.constructor.name,r=t.constructor.name;if(n!==r)throw Error(`Arrays are of different type. Actual: ${n}. Expected: ${r}`)}if(Array.isArray(e)&&Array.isArray(t)){let n=oo(e),r=oo(t);if(!ge(n,r))throw Error(`Arrays have different shapes. Actual: [${n}]. Expected: [${r}]`)}let i=ea(e)?e:ta(e),a=ea(t)?t:ta(t);if(i.length!==a.length)throw Error(`Arrays have different lengths actual: ${i.length} vs expected: ${a.length}.\nActual:   ${i}.\nExpected: ${a}.`);for(let e=0;e<a.length;++e){let t=i[e],r=a[e];if(!n(t,r))throw Error(`Arrays differ: actual[${e}] = ${t}, expected[${e}] = ${r}.\nActual:   ${i}.\nExpected: ${a}.`)}typeof expect<`u`&&expect().nothing()}function rte(e,t){e().then(()=>t.fail(),()=>t()),typeof expect<`u`&&expect().nothing()}function ite(e,t){let n=typeof t==`string`||typeof t==`number`||typeof t==`boolean`?[t]:t;return Ne(e)||Ne(e[0])||Ne(t)||Ne(t[0])?eg(e,n,(e,t)=>e==t):eg(e,t,(e,t)=>tg(e,t,0))}function ate(e,t,n){if(n??=$h(),!tg(e,t,n))throw Error(`Numbers differ: actual === ${e}, expected === ${t}`);typeof expect<`u`&&expect().nothing()}function tg(e,t,n){return!isFinite(e)&&!isFinite(t)?!0:!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function ote(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function ste(e,t){let n=new Float32Array(e),r=new Float32Array(t);if(n.length!==r.length)throw Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let e=0;e<r.length;e++)if(n[e]!==r[e])throw Error(`Expected ArrayBuffer value at ${e} to be ${r[e]} but got ${n[e]} instead`)}function ng(e){for(let t=0;t<e.length;t++){let n=e[t];Array.isArray(n)?ng(n):e[t]=Qi(n)}return e}function cte(e){let t=document.createElement(`video`);return`playsInline`in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position=`fixed`,t.style.left=`0px`,t.style.top=`0px`,t.preload=`auto`,t.appendChild(e),new Promise(e=>{t.addEventListener(`loadeddata`,n=>e(t)),t.load()})}async function lte(e){await e.play(),`requestVideoFrameCallback`in e&&await new Promise(t=>{e.requestVideoFrameCallback(t)})}var rg,ig,ute=o((()=>{F(),L(),j(),rg=.001,ig=.1})),ag,og,sg,cg,lg=o((()=>{ag=u(ete()),og=class{constructor(e,t,n,r,i){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let a=i||Math.random();this.random=ag.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){let e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,i,a;do r=2*this.random()-1,i=2*this.random()-1,a=r*r+i*i;while(a>=1||a===0);let o=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*r*o,t=this.mean+this.stdDev*i*o,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype===`float32`?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},sg=class{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;let i=r||Math.random();this.randu=ag.alea(i.toString()),this.randn=new og(0,1,n,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,i,a;for(;;){do r=this.randn.nextValue(),a=1+this.c*r;while(a<=0);if(a*=a*a,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-a+Math.log(a)),i=this.randu(),i<t||Math.log(i)<n)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=this.randu()**(1/this.alpha)),this.convertValue(a)}convertValue(e){return this.dtype===`float32`?e:Math.round(e)}},cg=class{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype===`float32`,this.min=e,this.range=t-e,this.dtype=n,r??=Math.random(),typeof r==`number`&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=ag.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}}));function dte(e,t,n=1,r=`float32`,i){if(Ke(e),n??=1,r??=`float32`,r!==`float32`&&r!==`int32`)throw Error(`Unsupported data type ${r}`);let a=new sg(t,n,r,i),o=mc(e,r);for(let e=0;e<o.values.length;e++)o.values[e]=a.nextValue();return o.toTensor()}var ug,fte=o((()=>{Xe(),hc(),z(),lg(),ug=R({randomGamma_:dte})}));function pte(e,t=0,n=1,r,i){if(Ke(e),r!=null&&r===`bool`)throw Error(`Unsupported data type ${r}`);let a=new og(t,n,r,!1,i),o=mc(e,r);for(let e=0;e<o.values.length;e++)o.values[e]=a.nextValue();return o.toTensor()}var dg,fg=o((()=>{Xe(),hc(),z(),lg(),dg=R({randomNormal_:pte})}));function mte(e,t,n){if(t!=null&&t===`bool`)throw Error(`Unsupported data type ${t}`);return dg(e,0,1,t,n)}var pg,hte=o((()=>{z(),fg(),pg=R({randomStandardNormal_:mte})}));function gte(e,t=0,n=1,r=`float32`,i){Ke(e);let a=mc(e,r),o=new cg(t,n,null,i);for(let e=0;e<a.values.length;e++)a.values[e]=o.nextValue();return a.toTensor()}var mg,hg=o((()=>{Xe(),hc(),z(),lg(),mg=R({randomUniform_:gte})}));function _te(e,t,n,r){return mg(e,t,n,`int32`,r)}var gg,vte=o((()=>{z(),hg(),gg=R({randomUniformInt_:_te})}));function _g(e,t,n=1,r=`float32`){if(n===0)throw Error(`Cannot have a step of zero`);let i={start:e,stop:t,step:n,dtype:r};return P.runKernel(cr,{},i)}var vg=o((()=>{F(),A()}));function yg(e){let t={input:I(e,`input`,`real`)};return P.runKernel(lr,t)}var bg,xg=o((()=>{F(),A(),L(),z(),bg=R({real_:yg})}));function yte(e){let t={x:I(e,`x`,`reciprocal`)};return P.runKernel(ur,t)}var Sg,Cg=o((()=>{F(),A(),L(),z(),Sg=R({reciprocal_:yte})}));function wg(e){let t={x:I(e,`x`,`relu`)};return P.runKernel(dr,t)}var Tg,Eg=o((()=>{F(),A(),L(),z(),Tg=R({relu_:wg})}));function bte(e){let t={x:I(e,`x`,`relu6`)};return P.runKernel(_r,t)}var Dg,Og=o((()=>{F(),A(),L(),z(),Dg=R({relu6_:bte})}));function kg(e,t){let n={x:I(e,`x`,`reverse`)},r={dims:t};return P.runKernel(vr,n,r)}var Ag,jg=o((()=>{F(),A(),L(),z(),Ag=R({reverse_:kg})}));function Mg(e){let t=I(e,`x`,`reverse`);return D(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),Ag(t,0)}var Ng,xte=o((()=>{L(),j(),z(),jg(),Ng=R({reverse1d_:Mg})}));function Ste(e,t){let n=I(e,`x`,`reverse`);return D(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),Ag(n,t)}var Pg,Cte=o((()=>{L(),j(),z(),jg(),Pg=R({reverse2d_:Ste})}));function wte(e,t){let n=I(e,`x`,`reverse`);return D(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),Ag(n,t)}var Fg,Tte=o((()=>{L(),j(),z(),jg(),Fg=R({reverse3d_:wte})}));function Ete(e,t){let n=I(e,`x`,`reverse`);return D(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),Ag(n,t)}var Ig,Dte=o((()=>{L(),j(),z(),jg(),Ig=R({reverse4d_:Ete})}));function Ote(e){let t={x:I(e,`x`,`round`)};return P.runKernel(yr,t)}var Lg,Rg=o((()=>{F(),A(),L(),z(),Lg=R({round_:Ote})}));function kte(e){let t={x:I(e,`x`,`rsqrt`,`float32`)};return P.runKernel(br,t)}var zg,Bg=o((()=>{F(),A(),L(),z(),zg=R({rsqrt_:kte})}));function Vg(e){let t={x:I(e,`x`,`selu`)};return P.runKernel(Tr,t)}var Hg,Ug=o((()=>{F(),A(),L(),z(),Hg=R({selu_:Vg})}));function Wg(e,t,n,r,i,a=[1,1],o=`NHWC`){let s=I(e,`x`,`separableConv2d`),c=I(t,`depthwiseFilter`,`separableConv2d`),l=I(n,`pointwiseFilter`,`separableConv2d`),u=s,d=!1;if(s.rank===3&&(d=!0,u=W(s,[1,s.shape[0],s.shape[1],s.shape[2]])),o===`NCHW`)throw Error(`separableConv2d currently does not support dataFormat NCHW; only NHWC is supported`);D(u.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`),D(c.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${c.rank}.`),D(l.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${c.rank}.`),D(l.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),D(l.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);let f=c.shape[2],p=c.shape[3];D(l.shape[2]===f*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${f*p}, but got ${l.shape[2]}.`);let m=Gd(u,c,r,i,o,a),h=od(m,l,1,`valid`,o);return d?W(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var Gg,Kg=o((()=>{L(),j(),sd(),Kd(),z(),G(),Gg=R({separableConv2d_:Wg})}));async function qg(e,t){let n=I(e,`x`,`setdiff1d`),r=I(t,`y`,`setdiff1d`);D(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),D(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),D(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);let i=await n.data(),a=await r.data(),o=new Set(a),s=0;for(let e=0;e<i.length;e++)o.has(i[e])||s++;let c=new xa([s],n.dtype),l=new xa([s],`int32`);for(let e=0,t=0;e<i.length;e++)o.has(i[e])||(c.values[t]=i[e],l.values[t]=e,t++);return[c.toTensor(),l.toTensor()]}var Jg,Yg=o((()=>{N(),L(),j(),Jg=qg}));function Xg(e){let t={x:I(e,`x`,`sign`)};return P.runKernel(Or,t)}var Zg,Qg=o((()=>{F(),A(),L(),z(),Zg=R({sign_:Xg})}));function $g(e){let t={x:I(e,`x`,`sin`,`float32`)};return P.runKernel(`Sin`,t)}var e_,t_=o((()=>{F(),A(),L(),z(),e_=R({sin_:$g})}));function Ate(e){let t={x:I(e,`x`,`sinh`)};return P.runKernel(Dr,t)}var n_,r_=o((()=>{F(),A(),L(),z(),n_=R({sinh_:Ate})}));function jte(e,t,n){let r=I(e,`x`,`slice1d`);return D(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),nu(r,[t],[n])}var i_,Mte=o((()=>{L(),j(),z(),ru(),i_=R({slice1d_:jte})}));function Nte(e,t,n){let r=I(e,`x`,`slice2d`);return D(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),nu(r,t,n)}var a_,Pte=o((()=>{L(),j(),z(),ru(),a_=R({slice2d_:Nte})}));function Fte(e,t,n){let r=I(e,`x`,`slice3d`);return D(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),nu(r,t,n)}var o_,Ite=o((()=>{L(),j(),z(),ru(),o_=R({slice3d_:Fte})}));function Lte(e,t,n){let r=I(e,`x`,`slice4d`);return D(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),nu(r,t,n)}var s_,Rte=o((()=>{L(),j(),z(),ru(),s_=R({slice4d_:Lte})}));function zte(e,t=-1){let n=I(e,`logits`,`softmax`,`float32`);if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let r={logits:n},i={dim:t};return P.runKernel(Pr,r,i)}var c_,l_=o((()=>{F(),A(),L(),z(),c_=R({softmax_:zte})}));function Bte(e){D(e.dtype===`complex64`,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);let t={input:e};return P.runKernel(`FFT`,t)}var u_,d_=o((()=>{F(),A(),j(),z(),u_=R({fft_:Bte})}));function Vte(e){D(e.dtype===`complex64`,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);let t={input:e};return P.runKernel(yn,t)}var f_,p_=o((()=>{F(),A(),j(),z(),f_=R({ifft_:Vte})}));function Hte(e){let t=e.shape[e.shape.length-1],n=e.size/t,r;if(t<=2){let i=W(e,[n,t]);r=f_(i)}else{let i=[n,2*(t-1)],a=W(bg(e),[n,t]),o=W(Hp(e),[n,t]),s=Ag(nu(a,[0,1],[n,t-2]),1),c=U(Ag(nu(o,[0,1],[n,t-2]),1),Zf(-1)),l=ql([a,s],1),u=ql([o,c],1),d=W(po(l,u),[i[0],i[1]]);r=f_(d)}if(r=bg(r),e.rank===3&&e.shape[0]!==0){let t=r,n=e.shape[0];r=W(r,[n,r.shape[0]/n,r.shape[1]]),t.dispose()}return r}var m_,Ute=o((()=>{mo(),Jl(),Up(),Nc(),z(),xg(),G(),jg(),Qf(),ru(),p_(),m_=R({irfft_:Hte})}));function Wte(e,t,n=0){let r={x:I(e,`x`,`split`)},i={numOrSizeSplits:t,axis:n};return P.runKernel(Nr,r,i)}var h_,g_=o((()=>{F(),A(),L(),z(),h_=R({split_:Wte})}));function Gte(e,t){D(e.dtype===`float32`,()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1],r=e.size/n,i;if(t!=null&&t<n){let r=e.shape.map(e=>0),a=e.shape.map(e=>e);a[e.shape.length-1]=t,i=nu(e,r,a),n=t}else if(t!=null&&t>n){let r=e.shape.map(e=>e);r[e.shape.length-1]=t-n,i=ql([e,ah(r)],e.shape.length-1),n=t}else i=e;let a=pf(i),o=W(po(i,a),[r,n]),s=u_(o),c=Math.floor(n/2)+1,l=bg(s),u=Hp(s),d=h_(l,[c,n-c],l.shape.length-1),f=h_(u,[c,n-c],u.shape.length-1),p=i.shape.slice();return p[i.shape.length-1]=c,W(po(d[0],f[0]),p)}var __,v_=o((()=>{j(),mo(),Jl(),Up(),z(),xg(),G(),ru(),g_(),oh(),mf(),d_(),__=R({rfft_:Gte})}));function Kte(e,t){let n=I(e,`a`,`squaredDifference`),r=I(t,`b`,`squaredDifference`);[n,r]=Ra(n,r),nf(n.shape,r.shape);let i={a:n,b:r};return P.runKernel(Br,i,{})}var y_,b_=o((()=>{F(),A(),Wa(),L(),rf(),z(),y_=R({squaredDifference_:Kte})}));function qte(e,t){let n=I(e,`x`,`squeeze`,`string_or_numeric`);return W(n,Te(n.shape,t).newShape)}var x_,S_=o((()=>{L(),j(),z(),G(),x_=R({squeeze_:qte})}));function Jte(e,t=0){let n=lo(e,`tensors`,`stack`,`string_or_numeric`);D(n.length>=1,()=>`Pass at least one tensor to tf.stack`),n.length>0&&D(t<=n[0].rank,()=>`Axis must be <= rank of the tensor`);let r=n,i={axis:t};return P.runKernel(er,r,i)}var C_,w_=o((()=>{F(),A(),L(),j(),z(),C_=R({stack_:Jte})}));function T_(e,t=0){let n={x:I(e,`x`,`step`)},r={alpha:t};return P.runKernel(ri,n,r)}var E_,D_=o((()=>{F(),A(),L(),z(),E_=R({step_:T_})}));function O_(e,t,n,r,i=0,a=0,o=0,s=0,c=0){let l={x:I(e,`x`,`stridedSlice`,`string_or_numeric`)},u={begin:t,end:n,strides:r,beginMask:i,endMask:a,ellipsisMask:o,newAxisMask:s,shrinkAxisMask:c};return P.runKernel(Ur,l,u)}var k_,A_=o((()=>{F(),A(),L(),z(),k_=R({stridedSlice_:O_})}));function j_(e){let t={x:I(e,`x`,`tan`,`float32`)};return P.runKernel(`Tan`,t)}var M_,N_=o((()=>{F(),A(),L(),z(),M_=R({tan_:j_})}));function P_(e,t){pe(e);let n=oo(e,t);if(n.length!==1)throw Error(`tensor1d() requires values to be a flat/TypedArray`);return ho(e,null,n,t)}var F_=o((()=>{L(),j(),go()}));function I_(e,t,n){if(pe(e),t!=null&&t.length!==2)throw Error(`tensor2d() requires shape to have two numbers`);let r=oo(e,n);if(r.length!==2&&r.length!==1)throw Error(`tensor2d() requires values to be number[][] or flat/TypedArray`);if(r.length===1&&t==null)throw Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return ho(e,t,r,n)}var L_=o((()=>{L(),j(),go()}));function R_(e,t,n){if(pe(e),t!=null&&t.length!==3)throw Error(`tensor3d() requires shape to have three numbers`);let r=oo(e,n);if(r.length!==3&&r.length!==1)throw Error(`tensor3d() requires values to be number[][][] or flat/TypedArray`);if(r.length===1&&t==null)throw Error("tensor3d() requires shape to be provided when `values` are a flat array");return ho(e,t,r,n)}var z_=o((()=>{L(),j(),go()}));function B_(e,t,n){if(pe(e),t!=null&&t.length!==4)throw Error(`tensor4d() requires shape to have four numbers`);let r=oo(e,n);if(r.length!==4&&r.length!==1)throw Error(`tensor4d() requires values to be number[][][][] or flat/TypedArray`);if(r.length===1&&t==null)throw Error("tensor4d() requires shape to be provided when `values` are a flat array");return ho(e,t,r,n)}var V_=o((()=>{L(),j(),go()}));function H_(e,t,n){if(pe(e),t!=null&&t.length!==5)throw Error(`tensor5d() requires shape to have five numbers`);let r=oo(e,n);if(r.length!==5&&r.length!==1)throw Error(`tensor5d() requires values to be number[][][][][] or flat/TypedArray`);if(r.length===1&&t==null)throw Error("tensor5d() requires shape to be provided when `values` are a flat array");return ho(e,t,r,n)}var U_=o((()=>{L(),j(),go()}));function W_(e,t,n){if(pe(e),t!=null&&t.length!==6)throw Error(`tensor6d() requires shape to have six numbers`);let r=oo(e,n);if(r.length!==6&&r.length!==1)throw Error(`tensor6d() requires values to be number[][][][][][] or flat/TypedArray`);if(r.length===1&&t==null)throw Error("tensor6d() requires shape to be provided when `values` are a flat array");return t||=r,ho(e,t,r,n)}var G_=o((()=>{L(),j(),go()})),K_=c({calculateShapes:()=>Y_,validateInput:()=>J_,validateUpdateShape:()=>q_});function q_(e,t,n){let r=t.rank>1?t.shape[t.rank-1]:1,i=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${i}.`;if(n.rank<i)throw Error(a+` update.rank < ${i}. `);if(e.length<r+(n.rank-i))throw Error(a+` Output shape length < ${r+(n.rank-i)}`);if(n.rank!==i+e.length-r)throw Error(a+` update.rank != ${i+e.length-r}`);for(let e=0;e<i;++e)if(n.shape[e]!==t.shape[e])throw Error(a+` updates.shape[${e}] (${n.shape[e]}) != indices.shape[${e}] (${t.shape[e]}).`);for(let t=0;t<n.rank-i;++t)if(n.shape[t+i]!==e[t+r])throw Error(a+` updates.shape[${t+i}] (${n.shape[t+i]}) != shape[${t+i}] (${e[t+i]})`)}function J_(e,t,n){if(t.rank<1)throw Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!==`int32`)throw Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw Error(`Updates specified for empty output. updates shape: ${e.shape}`)}q_(n,t,e)}function Y_(e,t,n){let r=t.shape.length,i=r>1?t.shape[r-1]:1,a=n.length,o=1;for(let e=i;e<a;++e)o*=n[e];let s=i<1?1:i,c=O(t.shape)/s,l=[...ze(n.slice(0,i)),1],u=O(n);return{sliceRank:i,numUpdates:c,sliceSize:o,strides:l,outputSize:u}}var X_=o((()=>{j()}));function Z_(e,t,n){let r=I(e,`tensor`,`tensorScatterupdate`),i=I(t,`indices`,`tensorScatterupdate`,`int32`),a=I(n,`updates`,`tensorScatterupdate`);if(J_(a,i,r.shape),r.dtype!==a.dtype)throw Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${a.dtype}.`);let o={tensor:r,indices:i,updates:a};return P.runKernel(Sr,o,{})}var Q_,$_=o((()=>{F(),A(),L(),z(),X_(),Q_=R({tensorScatterUpdate_:Z_})}));function ev(e,t=1,n=!0){let r=I(e,`x`,`topk`);if(r.rank===0)throw Error(`topk() expects the input to be of rank 1 or higher`);let i=r.shape[r.shape.length-1];if(t<0)throw Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>i)throw Error(`'k' passed to topk() must be <= the last dimension (${i}) but got ${t}`);let a={x:r},o={k:t,sorted:n},[s,c]=P.runKernel(Yr,a,o);return{values:s,indices:c}}var tv,nv=o((()=>{F(),A(),L(),z(),tv=R({topk_:ev})}));function rv(e,t=0,n=1,r,i){if(Ke(e),r!=null&&r===`bool`)throw Error(`Unsupported data type $ { dtype }`);let a=new og(t,n,r,!0,i),o=mc(e,r);for(let e=0;e<o.values.length;e++)o.values[e]=a.nextValue();return o.toTensor()}var iv,av=o((()=>{Xe(),hc(),z(),lg(),iv=R({truncatedNormal_:rv})}));function ov(e,t=0){let n=I(e,`x`,`unique`,`string_or_numeric`);D(n.rank>0,()=>`The input tensor must be at least 1D`);let r={x:n},i={axis:t},[a,o]=P.runKernel(Qr,r,i);return{values:a,indices:o}}var sv,cv=o((()=>{F(),A(),L(),j(),z(),sv=R({unique_:ov})}));function Yte(e,t,n){let r=I(e,`x`,`unsortedSegmentSum`),i=I(t,`segmentIds`,`unsortedSegmentSum`,`int32`);D(_e(n),()=>`numSegments must be of dtype int`);let a={x:r,segmentIds:i},o={numSegments:n};return P.runKernel(ei,a,o)}var lv,uv=o((()=>{F(),A(),L(),j(),z(),lv=R({unsortedSegmentSum_:Yte})}));function Xte(e,t=0){let n=I(e,`x`,`unstack`,`string_or_numeric`);D(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);let r={value:n},i={axis:t};return P.runKernel($r,r,i)}var dv,fv=o((()=>{F(),A(),L(),j(),z(),dv=R({unstack_:Xte})}));function pv(e,t){return Jm(e,t,`right`)}var Zte=o((()=>{Ym()}));function mv(e,t=!0,n,r){return P.makeVariable(e,t,n,r)}var Qte=o((()=>{F()}));function hv(e,t){let n=[];for(let e=0;e<t.length;e++)t[e]&&n.push(e);let r=mc(e,`int32`),i=mc([n.length,e.length],`int32`);for(let t=0;t<n.length;t++){let a=r.indexToLoc(n[t]),o=t*e.length;i.values.set(a,o)}return i.toTensor()}var gv=o((()=>{hc()}));async function $te(e){let t=I(e,`condition`,`whereAsync`,`bool`),n=await t.data(),r=hv(t.shape,n);return e!==t&&t.dispose(),r}var _v,vv=o((()=>{gv(),L(),_v=$te}));async function ene(e,t,n){let r=I(e,`tensor`,`boolMask`),i=I(t,`mask`,`boolMask`,`bool`),a=n??0,o=i.rank,s=r.shape;D(o>0,()=>`mask cannot be scalar`),fe(s.slice(a,a+o),i.shape,`mask's shape must match the first K dimensions of tensor's shape,`);let c=1;for(let e=a;e<a+o;e++)c*=s[e];let l=s.slice(0,a).concat([c],s.slice(a+o)),u=W(r,l),d=W(i,[-1]),f=await _v(d),p=x_(f,[1]),m=Np(u,p,a);return e!==r&&r.dispose(),t!==i&&i.dispose(),p.dispose(),u.dispose(),d.dispose(),f.dispose(),m}var yv,tne=o((()=>{L(),j(),Pp(),G(),S_(),vv(),yv=ene}));function nne(e,t,n){let r=I(e,`x`,`transpose`);if(t??=r.shape.map((e,t)=>t).reverse(),D(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`),t.forEach(e=>{D(e>=0&&e<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`)}),r.rank<=1)return r.clone();let i={x:r},a={perm:t};return r.dtype===`complex64`?B(()=>{let e=bg(r),t=Hp(r);return e=P.runKernel(Zr,{x:e},a),t=P.runKernel(Zr,{x:t},a),n&&(t=bm(t)),po(e,t)}):P.runKernel(Zr,i,a)}var bv,xv=o((()=>{F(),Wo(),A(),L(),j(),mo(),Up(),xm(),z(),xg(),bv=R({transpose_:nne})}));function rne(e,t,n,r,i=!0){let a=I(e,`v`,`movingAverage`),o=I(t,`x`,`movingAverage`),s=I(n,`decay`,`movingAverage`);za(a,o),D(ge(a.shape,o.shape),()=>`Shape mismatch in v and x`);let c=Zf(1),l=q(c,s),u=U(q(o,a),l);if(i){D(r!=null,()=>`When using zeroDebias: true, step is required.`);let e=I(r,`step`,`movingAverage`);u=Ac(u,q(c,Yf(s,e)))}return H(a,u)}var Sv,ine=o((()=>{Wa(),L(),j(),Tc(),jc(),Nc(),z(),Xf(),Qf(),km(),Sv=R({movingAverage_:rne})}));function ane(e,t,n){Ke(n);let r=I(e,`indices`,`scatterND`,`int32`),i=I(t,`updates`,`scatterND`);J_(i,r,n);let a={indices:r,updates:i},o={shape:n};return P.runKernel(xr,a,o)}var Cv,one=o((()=>{F(),A(),L(),Xe(),z(),X_(),Cv=R({scatterND_:ane})}));function sne(e,t,n,r){if(e.dtype!==`int32`)throw Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let i=e.rank>0?e.shape[0]:1,a=e.rank>1?e.shape[1]:1;if(n.length!==a)throw Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);let o=t.size;if(!(t.rank===0||t.rank===1&&o===i))throw Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${i}]`);if(t.dtype!==r.dtype)throw Error(`sparseValues.dtype must match defaultValues.dtype`)}var cne=o((()=>{}));function lne(e,t,n,r=0){Ke(n);let i=I(e,`sparseIndices`,`sparseToDense`,`int32`),a=I(t,`sparseValues`,`sparseToDense`,`string_or_numeric`),o=I(r,`defaultValue`,`sparseToDense`,a.dtype);sne(i,a,n,o);let s={sparseIndices:i,sparseValues:a,defaultValue:o},c={outputShape:n};return P.runKernel(zr,s,c)}var wv,une=o((()=>{F(),A(),cne(),L(),Xe(),z(),wv=R({sparseToDense_:lne})}));function dne(e,t){let n=I(t,`indices`,`gatherND`,`int32`),r={params:I(e,`x`,`gatherND`,`string_or_numeric`),indices:n};return P.runKernel(hn,r)}var Tv,fne=o((()=>{F(),A(),L(),z(),Tv=R({gatherND_:dne})}));function pne(e,t){if(t==null)return e.shape.slice();if(ge(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let r=0;r<e.shape.length;r++)t[r]==null&&e.shape[r]!=null?n.push(e.shape[r]):n.push(t[r]);return n}return t}var mne=o((()=>{j()}));function hne(e,t,n,r){let i=I(e,`x`,`dropout`);if(D(i.dtype===`float32`,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${i.dtype} tensor instead.`),D(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return e instanceof wa?i.clone():i;let a=pne(i,n),o=1-t,s=Ac(Ap(H(mg(a,0,1,`float32`,r),o)),o);return U(i,s)}var Ev,gne=o((()=>{N(),L(),j(),Tc(),jc(),mne(),jp(),Nc(),z(),hg(),Ev=R({dropout_:hne})}));function Dv(e){return Math.floor(2**Math.ceil(Math.log(e)/Math.log(2)))}function Ov(e,t,n){let r=1-e%2,i=new Float32Array(e);for(let a=0;a<e;++a){let o=2*Math.PI*a/(e+r-1);i[a]=t-n*Math.cos(o)}return P_(i,`float32`)}var kv=o((()=>{F_()}));async function _ne(e,t,n=1){let r=I(e,`predictions`,`inTopK`),i=I(t,`targets`,`inTopK`);D(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),D(r.rank-1===i.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${i.rank}`),fe(r.shape.slice(0,r.shape.length-1),i.shape,`predictions's shape should be align with the targets' shape, except the last dimension.`);let a=r.shape[r.shape.length-1];D(n>0&&n<=a,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${n}`);let o=await r.data(),s=await i.data(),[c,l]=[o.length/a,a],u=Ee(`bool`,c);for(let e=0;e<c;e++){let t=e*l,r=o.subarray(t,t+l),i=[];for(let e=0;e<r.length;e++)i.push({value:r[e],index:e});i.sort((e,t)=>t.value-e.value),u[e]=0;for(let t=0;t<n;t++)if(i[t].index===s[e]){u[e]=1;break}}return e!==r&&r.dispose(),t!==i&&i.dispose(),_o(u,i.shape,`bool`)}var Av,vne=o((()=>{L(),j(),vo(),Av=_ne}));function jv(e,t,n,r,i,a=`NHWC`,o){let s=e;e.rank===3&&(s=W(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let c=t;c.rank===3&&(c=W(t,[1,t.shape[0],t.shape[1],t.shape[2]])),D(s.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${s.shape}.`),D(c.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${c.shape}.`),D(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);let l=a===`NHWC`?s.shape[3]:s.shape[1],u=a===`NHWC`?c.shape[3]:c.shape[1];D(l===n[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${n[2]}.`),D(u===n[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${n[3]}).`),Ll(`conv2dDerFilter`,i,o);let d={x:s,dy:c},f={strides:r,pad:i,dataFormat:a,dimRoundingMode:o,filterShape:n};return P.runKernel(Lt,d,f)}var Mv,Nv=o((()=>{F(),A(),j(),Rl(),z(),G(),Mv=R({conv2DBackpropFilter_:jv})}));function Pv(e,t,n){if(n==null||n===`linear`)return e;if(n===`relu`)return U(e,E_(t));throw Error(`Cannot compute gradient for fused activation ${n}.`)}function Fv(e,t){let n=t,r=tf(e.shape,t.shape);return r.length>0&&(n=K(n,r)),W(n,e.shape)}function Iv(e,t,n,r){if(t===`linear`)return e;if(t===`relu`)return Tg(e);if(t===`elu`)return Tf(e);if(t===`relu6`)return Dg(e);if(t===`prelu`)return Gh(e,n);if(t===`leakyrelu`)return em(e,r);if(t===`sigmoid`)return $l(e);throw Error(`Unknown fused activation ${t}.`)}var Lv,Rv=o((()=>{rf(),Ef(),tm(),Nc(),Kh(),Eg(),Og(),G(),eu(),D_(),op(),Lv=(e,t)=>!(e>0)||t===`linear`}));function yne({x:e,filter:t,strides:n,pad:r,dataFormat:i=`NHWC`,dilations:a=[1,1],dimRoundingMode:o,bias:s,activation:c=`linear`,preluActivationWeights:l,leakyreluAlpha:u}){if(c||=`linear`,Lv(P.state.gradientDepth,c)===!1){D(i===`NHWC`,()=>`Error in fused conv2d: got dataFormat of ${i} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let d=od(e,t,n,r,i,a,o);return s!=null&&(d=H(d,s)),Iv(d,c,l,u)}let d=I(e,`x`,`conv2d`,`float32`),f=I(t,`filter`,`conv2d`,`float32`),p=d,m=!1;d.rank===3&&(m=!0,p=W(d,[1,d.shape[0],d.shape[1],d.shape[2]])),D(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),D(f.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${f.rank}.`),Ll(`fused conv2d`,r,o);let h=i===`NHWC`?p.shape[3]:p.shape[1];D(f.shape[2]===h,()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${f.shape[2]}.`),D(Pl(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);let g=Sl(p.shape,f.shape,n,a,r,o),_;s!=null&&(_=I(s,`bias`,`fused conv2d`),[_]=Ra(_,d),i===`NHWC`?nf(g.outShape,_.shape):(D(_.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${_.shape.length}.`),D(_.shape.length===0||_.shape[0]===g.outChannels||_.shape[0]===1,()=>`Error in fused conv2d: bias shape (${_.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let v;if(l!=null){let e=l.shape;if(D(e.length<=1||e.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`),e.length===1)D(e[0]===1||e[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${g.outChannels}).`);else if(e.length===3)try{nf(e,g.outShape)}catch{let t=`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(t)}v=I(l,`prelu weights`,`fused conv2d`)}let y=(e,t)=>{D(i===`NHWC`,()=>`Error in gradient of fused conv2D: got dataFormat of ${i} but only NHWC is currently supported.`);let[o,s,l,u]=t,d=Pv(e,l,c);D(Nl(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);let f=fd(s.shape,d,o,n,r),p=Mv(s,d,o.shape,n,r),m=[f,p];if(u!=null){let e=Fv(u,d);m.push(e)}return m},b={x:p,filter:f,bias:_,preluActivationWeights:v},x={strides:n,pad:r,dataFormat:i,dilations:a,dimRoundingMode:o,activation:c,leakyreluAlpha:u};return s==null?gm((e,t,n)=>{let r=P.runKernel(si,b,x);return n([t,e,r]),m&&(r=W(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:y}})(p,f):gm((e,t,n,r)=>{let i=P.runKernel(si,b,x);return r([t,e,i,n]),m&&(i=W(i,[i.shape[1],i.shape[2],i.shape[3]])),{value:i,gradFunc:y}})(p,f,_)}var zv,bne=o((()=>{F(),vm(),A(),Wa(),L(),j(),Tc(),rf(),sd(),Nv(),pd(),Rl(),Rv(),z(),G(),zv=R({fusedConv2d_:yne})}));function xne(e,t,n,r,i,a=[1,1],o){let s=e;e.rank===3&&(s=W(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let c=t;c.rank===3&&(c=W(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l={x:s,dy:c},u={strides:r,pad:i,dimRoundingMode:o,dilations:a,filterShape:n};return P.runKernel(Yt,l,u)}var Bv,Vv=o((()=>{F(),A(),z(),G(),Bv=R({depthwiseConv2dNativeBackpropFilter_:xne})}));function Sne(e,t,n,r,i,a=[1,1],o){let s=t,c=!1;t.rank===3&&(c=!0,s=W(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l={dy:s,filter:n},u={strides:r,pad:i,dimRoundingMode:o,dilations:a,inputShape:e},d=P.runKernel(Xt,l,u);return c?W(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var Hv,Uv=o((()=>{F(),A(),z(),G(),Hv=R({depthwiseConv2dNativeBackpropInput_:Sne})}));function Cne({x:e,filter:t,strides:n,pad:r,dataFormat:i=`NHWC`,dilations:a=[1,1],dimRoundingMode:o,bias:s,activation:c=`linear`,preluActivationWeights:l,leakyreluAlpha:u}){if(Lv(P.state.gradientDepth,c)===!1){let d=Gd(e,t,n,r,i,a,o);return s!=null&&(d=H(d,s)),Iv(d,c,l,u)}let d=I(e,`x`,`depthwiseConv2d`,`float32`),f=I(t,`filter`,`depthwiseConv2d`,`float32`),p=d,m=!1;d.rank===3&&(m=!0,p=W(d,[1,d.shape[0],d.shape[1],d.shape[2]])),D(p.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),D(f.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${f.rank}.`),D(p.shape[3]===f.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${f.shape[2]}.`),a??=[1,1],D(Pl(n,a),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),Ll(`fused depthwiseConv2d`,r,o);let h=Sl(p.shape,f.shape,n,a,r,o,!0),g;s!=null&&(g=I(s,`bias`,`fused conv2d`),[g]=Ra(g,d),nf(h.outShape,g.shape));let _;l!=null&&(_=I(l,`prelu weights`,`fused depthwiseConv2d`));let v=(e,t)=>{D(Nl(a),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);let[i,s,l,u]=t,d=Pv(e,l,c),f=Hv(s.shape,d,i,n,r,a,o),p=Bv(s,d,i.shape,n,r,a,o);if(u!=null){let e=Fv(g,d);return[f,p,e]}return[f,p]},y={x:p,filter:f,bias:g,preluActivationWeights:_},b={strides:n,pad:r,dataFormat:i,dilations:a,dimRoundingMode:o,activation:c,leakyreluAlpha:u};return s==null?gm((e,t,n)=>{let r=P.runKernel(ci,y,b);return n([t,e,r]),m&&(r=W(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:v}})(p,f):gm((e,t,n,r)=>{let i=P.runKernel(ci,y,b);return r([t,e,i,n]),m&&(i=W(i,[i.shape[1],i.shape[2],i.shape[3]])),{value:i,gradFunc:v}})(p,f,g)}var Wv,wne=o((()=>{F(),vm(),A(),Wa(),L(),j(),Tc(),rf(),Rl(),Kd(),Vv(),Uv(),Rv(),z(),G(),Wv=R({fusedDepthwiseConv2d_:Cne})}));function Tne({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:i,activation:a=`linear`,preluActivationWeights:o,leakyreluAlpha:s=.2}){if(Lv(P.state.gradientDepth,a)===!1){let c=Xl(e,t,n,r);return i!=null&&(c=H(c,i)),Iv(c,a,o,s)}let c=I(e,`a`,`fused matMul`),l=I(t,`b`,`fused matMul`);[c,l]=Ra(c,l);let u=n?c.shape[c.rank-2]:c.shape[c.rank-1],d=r?l.shape[l.rank-1]:l.shape[l.rank-2],f=n?c.shape[c.rank-1]:c.shape[c.rank-2],p=r?l.shape[l.rank-2]:l.shape[l.rank-1],m=c.shape.slice(0,-2),h=l.shape.slice(0,-2),g=O(m),_=O(h);D(u===d,()=>`Error in fused matMul: inner shapes (${u}) and (${d}) of Tensors with shapes ${c.shape} and ${l.shape} and transposeA=${n} and transposeB=${r} must match.`);let v=nf(c.shape.slice(0,-2),l.shape.slice(0,-2)).concat([f,p]),y=n?W(c,[g,u,f]):W(c,[g,f,u]),b=r?W(l,[_,p,d]):W(l,[_,d,p]),x;i!=null&&(x=I(i,`bias`,`fused matMul`),[x]=Ra(x,c),nf(v,x.shape));let S;o!=null&&(S=I(o,`prelu weights`,`fused matMul`));let C=(e,t)=>{let[o,s,c,l]=t,u=Pv(W(e,c.shape),c,a),d,f;if(!n&&!r?(d=Xl(u,s,!1,!0),f=Xl(o,u,!0,!1)):!n&&r?(d=Xl(u,s,!1,!1),f=Xl(u,o,!0,!1)):n&&!r?(d=Xl(s,u,!1,!0),f=Xl(o,u,!1,!1)):(d=Xl(s,u,!0,!0),f=Xl(u,o,!0,!0)),i!=null){let e=Fv(l,u);return[d,f,e]}else return[d,f]},w={a:y,b,bias:x,preluActivationWeights:S},T={transposeA:n,transposeB:r,activation:a,leakyreluAlpha:s};return i==null?gm((e,t,n)=>{let r=P.runKernel(oi,w,T);return n([e,t,r]),{value:W(r,v),gradFunc:C}})(y,b):gm((e,t,n,r)=>{let i=P.runKernel(oi,w,T);return r([e,t,i,n]),{value:W(i,v),gradFunc:C}})(y,b,x)}var Gv,Ene=o((()=>{F(),vm(),A(),Wa(),L(),j(),Tc(),rf(),Rv(),Zl(),z(),G(),Gv=R({fusedMatMul_:Tne})})),Kv=c({conv2d:()=>zv,depthwiseConv2d:()=>Wv,matMul:()=>Gv}),Dne=o((()=>{bne(),wne(),Ene()}));function One(e){return Ov(e,.54,.46)}var qv,kne=o((()=>{z(),kv(),qv=R({hammingWindow_:One})}));function Ane(e){return Ov(e,.5,.5)}var Jv,Yv=o((()=>{z(),kv(),Jv=R({hannWindow_:Ane})}));function jne(e,t,n,r=!1,i=0){let a=0,o=[];for(;a+t<=e.size;)o.push(nu(e,a,t)),a+=n;if(r)for(;a<e.size;){let r=a+t-e.size,s=ql([nu(e,a,t-r),Hu([r],i)]);o.push(s),a+=n}return o.length===0?I_([],[0,t]):W(ql(o),[o.length,t])}var Xv,Zv=o((()=>{Jl(),Uu(),z(),G(),ru(),L_(),Xv=R({frame_:jne})}));function Mne(e,t,n,r,i=Jv){r??=Dv(t);let a=Xv(e,t,n),o=U(a,i(t));return __(o,r)}var Qv,Nne=o((()=>{Nc(),z(),kv(),v_(),Zv(),Yv(),Qv=R({stft_:Mne})}));function Pne(e,t,n,r,i=`bilinear`,a=0){let o=I(e,`image`,`cropAndResize`),s=I(t,`boxes`,`cropAndResize`,`float32`),c=I(n,`boxInd`,`cropAndResize`,`int32`),l=s.shape[0];D(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),D(s.rank===2&&s.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${s.shape}.`),D(c.rank===1&&c.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${s.shape}.`),D(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),D(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),D(i===`bilinear`||i===`nearest`,()=>`method must be bilinear or nearest, but was ${i}`);let u={image:o,boxes:s,boxInd:c},d={method:i,extrapolationValue:a,cropSize:r};return P.runKernel(Gt,u,d)}var $v,Fne=o((()=>{F(),A(),L(),j(),z(),$v=R({cropAndResize_:Pne})}));function Ine(e){let t=I(e,`image`,`flipLeftRight`,`float32`);D(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let n={image:t};return P.runKernel(un,n,{})}var ey,Lne=o((()=>{F(),A(),L(),j(),z(),ey=R({flipLeftRight_:Ine})}));function Rne(e){let t=I(e,`image`,`grayscaleToRGB`),n=t.rank-1,r=t.shape[n];D(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),D(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);let i=Array(t.rank);return i.fill(1,0,n),i[n]=3,wp(t,i)}var ty,zne=o((()=>{L(),j(),z(),Tp(),ty=R({grayscaleToRGB_:Rne})}));function Bne(e){let t=I(e,`image`,`RGBToGrayscale`),n=t.rank-1,r=t.shape[n];D(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),D(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);let i=t.dtype,a=V(t,`float32`),o=P_([.2989,.587,.114]),s;switch(t.rank){case 2:s=Sf(`ij,j->i`,a,o);break;case 3:s=Sf(`ijk,k->ij`,a,o);break;case 4:s=Sf(`ijkl,l->ijk`,a,o);break;case 5:s=Sf(`ijklm,m->ijkl`,a,o);break;case 6:s=Sf(`ijklmn,n->ijklm`,a,o);break;default:throw Error(`Not a valid tensor rank.`)}return s=vp(s,-1),V(s,i)}var ny,Vne=o((()=>{L(),j(),_c(),Cf(),yp(),z(),F_(),ny=R({rgbToGrayscale_:Bne})}));function Hne(e,t,n=0,r=.5){let i=I(e,`image`,`rotateWithOffset`,`float32`);D(i.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${i.rank}.`);let a={image:i},o={radians:t,fillValue:n,center:r};return P.runKernel(ai,a,o)}var ry,Une=o((()=>{F(),A(),L(),j(),z(),ry=R({rotateWithOffset_:Hne})}));function iy(e,t,n,r,i,a){r??=.5,i??=-1/0,a??=0;let o=e.shape[0];return n=Math.min(n,o),D(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),D(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),D(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),D(t.rank===1,()=>`scores must be a 1D tensor`),D(t.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`),D(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:i,softNmsSigma:a}}var ay=o((()=>{j()}));function Wne(e,t,n,r=.5,i=-1/0){let a=I(e,`boxes`,`nonMaxSuppression`,`float32`),o=I(t,`scores`,`nonMaxSuppression`,`float32`),s=iy(a,o,n,r,i);n=s.maxOutputSize,r=s.iouThreshold,i=s.scoreThreshold;let c={maxOutputSize:n,iouThreshold:r,scoreThreshold:i};return P.runKernel(Yn,{boxes:a,scores:o},c)}var oy,Gne=o((()=>{F(),A(),L(),ay(),z(),oy=R({nonMaxSuppression_:Wne})}));
/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/
function Kne(e,t,n){let r=qne(e,t,n),i=r<0?-(r+1):r;e.splice(i,0,t)}function qne(e,t,n){return Yne(e,t,n||Jne)}function Jne(e,t){return e>t?1:e<t?-1:0}function Yne(e,t,n){let r=0,i=e.length,a=0,o=!1;for(;r<i;){a=r+(i-r>>>1);let s=n(t,e[a]);s>0?r=a+1:(i=a,o=!s)}return o?r:-r-1}var Xne=o((()=>{}));function sy(e,t,n,r,i){return uy(e,t,n,r,i,0)}function cy(e,t,n,r,i,a){return uy(e,t,n,r,i,0,!1,a,!0)}function ly(e,t,n,r,i,a){return uy(e,t,n,r,i,a,!0)}function uy(e,t,n,r,i,a,o=!1,s=!1,c=!1){let l=[];for(let e=0;e<t.length;e++)t[e]>i&&l.push({score:t[e],boxIndex:e,suppressBeginIndex:0});l.sort(dy);let u=a>0?-.5/a:0,d=[],f=[];for(;d.length<n&&l.length>0;){let t=l.pop(),{score:n,boxIndex:a,suppressBeginIndex:o}=t;if(n<i)break;let s=!1;for(let n=d.length-1;n>=o;--n){let o=Zne(e,a,d[n]);if(o>=r){s=!0;break}if(t.score*=Qne(r,u,o),t.score<=i)break}t.suppressBeginIndex=d.length,s||(t.score===n?(d.push(a),f.push(t.score)):t.score>i&&Kne(l,t,dy))}let p=d.length,m=n-p;s&&m>0&&(d.push(...Array(m).fill(0)),f.push(...Array(m).fill(0)));let h={selectedIndices:d};return o&&(h.selectedScores=f),c&&(h.validOutputs=p),h}function Zne(e,t,n){let r=e.subarray(t*4,t*4+4),i=e.subarray(n*4,n*4+4),a=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),s=Math.max(r[0],r[2]),c=Math.max(r[1],r[3]),l=Math.min(i[0],i[2]),u=Math.min(i[1],i[3]),d=Math.max(i[0],i[2]),f=Math.max(i[1],i[3]),p=(s-a)*(c-o),m=(d-l)*(f-u);if(p<=0||m<=0)return 0;let h=Math.max(a,l),g=Math.max(o,u),_=Math.min(s,d),v=Math.min(c,f),y=Math.max(_-h,0)*Math.max(v-g,0);return y/(p+m-y)}function Qne(e,t,n){let r=Math.exp(t*n*n);return n<=e?r:0}function dy(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}var fy=o((()=>{Xne()}));async function $ne(e,t,n,r=.5,i=-1/0){let a=I(e,`boxes`,`nonMaxSuppressionAsync`),o=I(t,`scores`,`nonMaxSuppressionAsync`),s=iy(a,o,n,r,i);n=s.maxOutputSize,r=s.iouThreshold,i=s.scoreThreshold;let c=await Promise.all([a.data(),o.data()]),l=c[0],u=c[1],{selectedIndices:d}=sy(l,u,n,r,i);return a!==e&&a.dispose(),o!==t&&o.dispose(),P_(d,`int32`)}var py,ere=o((()=>{fy(),L(),ay(),F_(),py=$ne}));function tre(e,t,n,r=.5,i=-1/0,a=0){let o=I(e,`boxes`,`nonMaxSuppression`),s=I(t,`scores`,`nonMaxSuppression`),c=iy(o,s,n,r,i,a);n=c.maxOutputSize,r=c.iouThreshold,i=c.scoreThreshold,a=c.softNmsSigma;let l={boxes:o,scores:s},u={maxOutputSize:n,iouThreshold:r,scoreThreshold:i,softNmsSigma:a},d=P.runKernel(Zn,l,u);return{selectedIndices:d[0],selectedScores:d[1]}}var my,nre=o((()=>{F(),A(),L(),ay(),z(),my=R({nonMaxSuppressionWithScore_:tre})}));async function rre(e,t,n,r=.5,i=-1/0,a=0){let o=I(e,`boxes`,`nonMaxSuppressionAsync`),s=I(t,`scores`,`nonMaxSuppressionAsync`),c=iy(o,s,n,r,i,a);n=c.maxOutputSize,r=c.iouThreshold,i=c.scoreThreshold,a=c.softNmsSigma;let l=await Promise.all([o.data(),s.data()]),u=l[0],d=l[1],{selectedIndices:f,selectedScores:p}=ly(u,d,n,r,i,a);return o!==e&&o.dispose(),s!==t&&s.dispose(),{selectedIndices:P_(f,`int32`),selectedScores:P_(p)}}var hy,ire=o((()=>{fy(),L(),ay(),F_(),hy=rre}));function are(e,t,n,r=.5,i=-1/0,a=!1){let o=I(e,`boxes`,`nonMaxSuppression`),s=I(t,`scores`,`nonMaxSuppression`),c=iy(o,s,n,r,i,null),l=c.maxOutputSize,u=c.iouThreshold,d=c.scoreThreshold,f={boxes:o,scores:s},p={maxOutputSize:l,iouThreshold:u,scoreThreshold:d,padToMaxOutputSize:a},m=P.runKernel(Xn,f,p);return{selectedIndices:m[0],validOutputs:m[1]}}var gy,ore=o((()=>{F(),A(),L(),ay(),z(),gy=R({nonMaxSuppressionPadded_:are})}));async function sre(e,t,n,r=.5,i=-1/0,a=!1){let o=I(e,`boxes`,`nonMaxSuppressionAsync`),s=I(t,`scores`,`nonMaxSuppressionAsync`),c=iy(o,s,n,r,i,null),l=c.maxOutputSize,u=c.iouThreshold,d=c.scoreThreshold,[f,p]=await Promise.all([o.data(),s.data()]),{selectedIndices:m,validOutputs:h}=cy(f,p,l,u,d,a);return o!==e&&o.dispose(),s!==t&&s.dispose(),{selectedIndices:P_(m,`int32`),validOutputs:Zf(h,`int32`)}}var _y,cre=o((()=>{fy(),L(),ay(),Qf(),F_(),_y=sre}));function lre(e,t,n=!1,r=!1){let i=I(e,`images`,`resizeBilinear`);D(i.rank===3||i.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${i.rank}.`),D(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),D(r===!1||n===!1,()=>`Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.`);let a=i,o=!1;i.rank===3&&(o=!0,a=W(i,[1,i.shape[0],i.shape[1],i.shape[2]]));let[]=t,s={images:a},c={alignCorners:n,halfPixelCenters:r,size:t},l=P.runKernel(hr,s,c);return o?W(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var vy,yy=o((()=>{F(),A(),L(),j(),z(),G(),vy=R({resizeBilinear_:lre})}));function ure(e,t,n=!1,r=!1){let i=I(e,`images`,`resizeNearestNeighbor`);D(i.rank===3||i.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${i.rank}.`),D(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),D(i.dtype===`float32`||i.dtype===`int32`,()=>"`images` must have `int32` or `float32` as dtype"),D(r===!1||n===!1,()=>`Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.`);let a=i,o=!1;i.rank===3&&(o=!0,a=W(i,[1,i.shape[0],i.shape[1],i.shape[2]]));let[]=t,s={images:a},c={alignCorners:n,halfPixelCenters:r,size:t},l=P.runKernel(pr,s,c);return o?W(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var by,xy=o((()=>{F(),A(),L(),j(),z(),G(),by=R({resizeNearestNeighbor_:ure})}));function dre(e,t=`binary`,n=!1,r=.5){let i=I(e,`image`,`threshold`),a=i.shape[0]*i.shape[1],o=U(P_([r]),255),s,c,l,u;if(D(i.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${i.rank}.`),D(i.shape[2]===3||i.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${i.shape[2]}.`),D(i.dtype===`int32`||i.dtype===`float32`,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${i.dtype}.`),D(t===`otsu`||t===`binary`,()=>`Method must be binary or otsu, but was ${t}`),i.shape[2]===3){[s,c,l]=h_(i,[1,1,1],-1);let e=U(s,.2989),t=U(c,.587),n=U(l,.114);u=H(H(e,t),n)}else u=e;if(t===`otsu`){let e=Ou(V(Lg(u),`int32`),_o([]),256);o=fre(e,a)}let d=n?om(u,o):Ip(u,o);return V(U(d,255),`int32`)}function fre(e,t){let n=P_([-1]),r=P_([0]),i=P_([0]),a,o,s,c,l,u;for(let d=0;d<e.size-1;d++){a=nu(e,0,d+1),o=nu(e,d+1),l=Ac(K(a),t),u=Ac(K(o),t);let f=K(U(a,_g(0,a.size)));s=Ac(f,K(a));let p=Hu(o.shape,a.size),m=H(_g(0,o.size),p),h=U(o,m);c=Ac(K(h),K(o));let g=q(s,c),_=q(s,c),v=U(l,u);i=U(U(v,g),_);let y=Ip(i,r);r=uf(y,i,r),n=uf(y,P_([d]),n)}return n}var Sy,pre=o((()=>{F_(),z(),_c(),g_(),ku(),sm(),Lp(),op(),Tc(),Nc(),jc(),km(),Rg(),df(),Uu(),ru(),vg(),vo(),j(),L(),Sy=R({threshold_:dre})}));function mre(e,t,n=`nearest`,r=`constant`,i=0,a){let o=I(e,`image`,`transform`,`float32`),s=I(t,`transforms`,`transform`,`float32`);D(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),D(s.rank===2&&(s.shape[0]===o.shape[0]||s.shape[0]===1)&&s.shape[1]===8,()=>`Error in transform: Input transform should be batch x 8 or 1 x 8`),D(a==null||a.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`);let c={image:o,transforms:s},l={interpolation:n,fillMode:r,fillValue:i,outputShape:a};return P.runKernel(Xr,c,l)}var Cy,hre=o((()=>{F(),A(),L(),j(),z(),Cy=R({transform_:mre})}));function gre(e,t,n){let r=I(e,`a`,`bandPart`);D(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);let i=r.shape,[a,o]=r.shape.slice(-2),s,c;typeof t==`number`?(D(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),D(t<=a,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`),s=I(t<0?a:t,`numLower`,`bandPart`)):(D(t.dtype===`int32`,()=>`bandPart(): numLower's dtype must be an int32.`),s=uf(rm(t,0),a,uh(t,a))),typeof n==`number`?(D(n%1==0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),D(n<=o,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${o}).`),c=I(n<0?o:n,`numUpper`,`bandPart`)):(D(n.dtype===`int32`,()=>`bandPart(): numUpper's dtype must be an int32.`),c=uf(rm(n,0),o,uh(n,o)));let l=W(_g(0,a,1,`int32`),[-1,1]),u=_g(0,o,1,`int32`),d=q(l,u),f=Lm(om(d,s),zp(d,bm(c))),p=ah([a,o],r.dtype);return W(C_(dv(W(r,[-1,a,o])).map(e=>uf(f,e,p))),i)}var wy,_re=o((()=>{L(),j(),Bp(),im(),sm(),Rm(),dh(),xm(),z(),vg(),G(),w_(),km(),fv(),df(),oh(),wy=R({bandPart_:gre})}));function vre(e){let t;if(Array.isArray(e)){t=!1,D(e!=null&&e.length>0,()=>`Gram-Schmidt process: input must not be null, undefined, or empty`);let n=e[0].shape[0];for(let t=1;t<e.length;++t)D(e[t].shape[0]===n,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`)}else t=!0,e=h_(e,e.shape[0],0).map(e=>x_(e,[0]));D(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);let n=[],r=e;for(let t=0;t<e.length;++t)n.push(P.tidy(()=>{let e=r[t];if(t>0)for(let r=0;r<t;++r){let t=U(K(U(n[r],e)),n[r]);e=q(e,t)}return Ac(e,lp(e,`euclidean`))}));return t?C_(n,0):n}var Ty,yre=o((()=>{F(),j(),jc(),Nc(),up(),z(),g_(),S_(),w_(),km(),op(),Ty=R({gramSchmidt_:vre})}));function bre(e,t=!1){if(D(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return Ey(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce((e,t)=>e*t),r=dv(W(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),i=[],a=[];r.forEach(e=>{let[n,r]=Ey(e,t);i.push(n),a.push(r)});let o=W(C_(i,0),e.shape),s=W(C_(a,0),e.shape);return[o,s]}}function Ey(e,t=!1){return P.tidy(()=>{D(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);let n=e.shape[0],r=e.shape[1],i=Dp(n),a=yc(e),o=I_([[1]],[1,1]),s=yc(o),c=n>=r?r:n;for(let e=0;e<c;++e){let t=a,c=s,l=i;[s,a,i]=P.tidy(()=>{let t=nu(a,[e,e],[n-e,1]),c=lp(t),l=nu(a,[e,e],[1,1]),u=uf(Ip(l,0),I_([[-1]]),I_([[1]])),d=q(l,U(u,c)),f=Ac(t,d);s=f.shape[0]===1?yc(o):ql([o,nu(f,[1,0],[f.shape[0]-1,f.shape[1]])],0);let p=bm(Ac(Xl(u,d),c)),m=nu(a,[e,0],[n-e,r]),h=U(p,s),g=bv(s);if(e===0)a=q(m,Xl(h,Xl(g,m)));else{let t=q(m,Xl(h,Xl(g,m)));a=ql([nu(a,[0,0],[e,r]),t],0)}let _=bv(h),v=nu(i,[0,e],[n,i.shape[1]-e]);if(e===0)i=q(v,Xl(Xl(v,s),_));else{let t=q(v,Xl(Xl(v,s),_));i=ql([nu(i,[0,0],[n,e]),t],1)}return[s,a,i]}),Mo([t,c,l])}return!t&&n>r&&(i=nu(i,[0,0],[n,r]),a=nu(a,[0,0],[r,r])),[i,a]})}var Dy,xre=o((()=>{F(),Wo(),j(),bc(),Jl(),jc(),Op(),Lp(),Zl(),Nc(),xm(),up(),z(),G(),ru(),w_(),km(),L_(),xv(),fv(),df(),Dy=R({qr_:bre})})),Oy,ky=o((()=>{(function(e){e[e.NONE=0]=`NONE`,e[e.MEAN=1]=`MEAN`,e[e.SUM=2]=`SUM`,e[e.SUM_BY_NONZERO_WEIGHTS=3]=`SUM_BY_NONZERO_WEIGHTS`})(Oy||={})}));function Sre(e,t,n=Oy.SUM_BY_NONZERO_WEIGHTS){let r=I(e,`losses`,`computeWeightedLoss`),i=null;t!=null&&(i=I(t,`weights`,`computeWeightedLoss`));let a=i==null?r:U(r,i);if(n===Oy.NONE)return a;if(n===Oy.SUM)return K(a);if(n===Oy.MEAN){if(i==null)return rh(a);{let e=r.size/i.size,t=Ac(K(a),K(i));return e>1?Ac(t,Zf(e)):t}}if(n===Oy.SUM_BY_NONZERO_WEIGHTS){if(i==null)return Ac(K(a),Zf(r.size));{let e=U(i,sh(r.shape)),t=V(K(yh(e,Zf(0))),`float32`);return Ac(K(a),t)}}throw Error(`Unknown reduction: ${n}`)}var Ay,jy=o((()=>{L(),_c(),jc(),ky(),ih(),Nc(),bh(),ch(),z(),Qf(),op(),Ay=R({computeWeightedLoss_:Sre})}));function Cre(e,t,n,r=Oy.SUM_BY_NONZERO_WEIGHTS){let i=I(e,`labels`,`absoluteDifference`),a=I(t,`predictions`,`absoluteDifference`),o=null;n!=null&&(o=I(n,`weights`,`absoluteDifference`)),fe(i.shape,a.shape,`Error in absoluteDifference: `);let s=Fc(q(i,a));return Ay(s,o,r)}var My,wre=o((()=>{L(),j(),Ic(),ky(),z(),km(),jy(),My=R({absoluteDifference_:Cre})}));function Tre(e,t,n,r,i=Oy.SUM_BY_NONZERO_WEIGHTS){let a=I(e,`labels`,`cosineDistance`),o=I(t,`predictions`,`cosineDistance`),s=null;r!=null&&(s=I(r,`weights`,`cosineDistance`)),fe(a.shape,o.shape,`Error in cosineDistance: `);let c=Zf(1),l=q(c,K(U(a,o),n,!0));return Ay(l,s,i)}var Ny,Ere=o((()=>{L(),j(),ky(),Nc(),z(),Qf(),km(),op(),jy(),Ny=R({cosineDistance_:Tre})}));function Dre(e,t,n,r=Oy.SUM_BY_NONZERO_WEIGHTS){let i=I(e,`labels`,`hingeLoss`),a=I(t,`predictions`,`hingeLoss`),o=null;n!=null&&(o=I(n,`weights`,`hingeLoss`)),fe(i.shape,a.shape,`Error in hingeLoss: `);let s=Zf(1);i=q(U(Zf(2),i),s);let c=Tg(q(s,U(i,a)));return Ay(c,o,r)}var Py,Ore=o((()=>{L(),j(),ky(),Nc(),z(),Eg(),Qf(),km(),jy(),Py=R({hingeLoss_:Dre})}));function kre(e,t,n,r=1,i=Oy.SUM_BY_NONZERO_WEIGHTS){let a=I(e,`labels`,`huberLoss`),o=I(t,`predictions`,`huberLoss`),s=null;n!=null&&(s=I(n,`weights`,`huberLoss`)),fe(a.shape,o.shape,`Error in huberLoss: `);let c=Zf(r),l=Fc(q(o,a)),u=uh(l,c),d=q(l,u),f=H(U(Zf(.5),rp(u)),U(c,d));return Ay(f,s,i)}var Fy,Are=o((()=>{L(),j(),Ic(),Tc(),ky(),dh(),Nc(),z(),Qf(),ip(),km(),jy(),Fy=R({huberLoss_:kre})}));function jre(e,t,n,r=1e-7,i=Oy.SUM_BY_NONZERO_WEIGHTS){let a=I(e,`labels`,`logLoss`),o=I(t,`predictions`,`logLoss`),s=null;n!=null&&(s=I(n,`weights`,`logLoss`)),fe(a.shape,o.shape,`Error in logLoss: `);let c=Zf(1),l=Zf(r),u=bm(U(a,dm(H(o,l)))),d=U(q(c,a),dm(H(q(c,o),l))),f=q(u,d);return Ay(f,s,i)}var Iy,Mre=o((()=>{L(),j(),Tc(),fm(),ky(),Nc(),xm(),z(),Qf(),km(),jy(),Iy=R({logLoss_:jre})}));function Nre(e,t,n,r=Oy.SUM_BY_NONZERO_WEIGHTS){let i=I(e,`labels`,`meanSquaredError`),a=I(t,`predictions`,`meanSquaredError`),o=null;n!=null&&(o=I(n,`weights`,`meanSquaredError`)),fe(i.shape,a.shape,`Error in meanSquaredError: `);let s=y_(i,a);return Ay(s,o,r)}var Ly,Pre=o((()=>{L(),j(),ky(),z(),b_(),jy(),Ly=R({meanSquaredError_:Nre})}));function Fre(e,t){let n=I(e,`labels`,`sigmoidCrossEntropyWithLogits`),r=I(t,`logits`,`sigmoidCrossEntropyWithLogits`);fe(n.shape,r.shape,`Error in sigmoidCrossEntropyWithLogits: `);let i=Tg(r),a=U(r,n),o=pm(hp(bm(Fc(r))));return H(q(i,a),o)}function Ry(e,t,n,r=0,i=Oy.SUM_BY_NONZERO_WEIGHTS){let a=I(e,`multiClassLabels`,`sigmoidCrossEntropy`),o=I(t,`logits`,`sigmoidCrossEntropy`),s=null;if(n!=null&&(s=I(n,`weights`,`sigmoidCrossEntropy`)),fe(a.shape,o.shape,`Error in sigmoidCrossEntropy: `),r>0){let e=Zf(r),t=Zf(1),n=Zf(.5);a=H(U(a,q(t,e)),U(n,e))}let c=Fre(a,o);return Ay(c,s,i)}var zy,By=o((()=>{L(),j(),Ic(),Tc(),gp(),mm(),ky(),Nc(),xm(),z(),Eg(),Qf(),km(),jy(),zy=R({sigmoidCrossEntropy_:Ry})}));function Vy(e,t,n=-1){if(n===-1&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return gm((e,t,r)=>{let i=Pm(t,[n],!0),a=q(V(t,`float32`),i);r([e,a]);let o=bm(U(a,e));return{value:K(o,[n]),gradFunc:(e,t)=>{let[r,i]=t,a=If(e.shape,[n]);return[U(W(e,a),q(V(r,`float32`),hp(i))),U(W(e,a),q(hp(i),V(r,`float32`)))]}}})(e,t)}function Hy(e,t,n,r=0,i=Oy.SUM_BY_NONZERO_WEIGHTS){let a=I(e,`onehotLabels`,`softmaxCrossEntropy`),o=I(t,`logits`,`softmaxCrossEntropy`),s=null;if(n!=null&&(s=I(n,`weights`,`softmaxCrossEntropy`)),fe(a.shape,o.shape,`Error in softmaxCrossEntropy: `),r>0){let e=Zf(r),t=Zf(1),n=Zf(a.shape[1]);a=H(U(a,q(t,e)),Ac(e,n))}let c=Vy(a,o);return Ay(c,s,i)}var Uy,Wy=o((()=>{vm(),L(),j(),Tc(),Vf(),_c(),jc(),gp(),Fm(),ky(),Nc(),xm(),z(),G(),Qf(),km(),op(),jy(),Uy=R({softmaxCrossEntropy_:Hy})}));function Gy(e,t,n,r){let i=I(e,`indices`,`sparseFillEmptyRows`,`int32`),a=I(t,`values`,`sparseFillEmptyRows`),o=I(n,`denseShape`,`sparseFillEmptyRows`,`int32`),s=I(r,`defaultValue`,`sparseFillEmptyRows`,a.dtype);if(i.rank!==2)throw Error(`Indices should be Tensor2D but received shape
        ${i.shape}`);if(a.rank!==1)throw Error(`Values should be Tensor1D but received shape ${a.shape}`);if(o.rank!==1)throw Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(s.rank!==0)throw Error(`Default value should be a scalar but received shape ${s.shape}`);let c={indices:i,values:a,denseShape:o,defaultValue:s},l=P.runKernel(Fr,c);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}var Ky,qy=o((()=>{F(),A(),L(),z(),Ky=R({sparseFillEmptyRows_:Gy})}));function Jy(e,t,n){let r=I(e,`inputIndices`,`sparseReshape`,`int32`),i=I(t,`inputShape`,`sparseReshape`,`int32`),a=I(n,`newShape`,`sparseReshape`,`int32`);if(r.rank!==2)throw Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(i.rank!==1)throw Error(`Input shape should be Tensor1D but received shape ${i.shape}`);if(a.rank!==1)throw Error(`New shape should be Tensor1D but received shape ${a.shape}`);let o={inputIndices:r,inputShape:i,newShape:a},s=P.runKernel(Ir,o);return{outputIndices:s[0],outputShape:s[1]}}var Yy,Xy=o((()=>{F(),A(),L(),z(),Yy=R({sparseReshape_:Jy})}));function Zy(e,t,n){let r=I(e,`data`,`sparseSegmentMean`),i=I(t,`indices`,`sparseSegmentMean`,`int32`),a=I(n,`segmentIds`,`sparseSegmentMean`,`int32`);if(r.rank<1)throw Error(`Data should be at least 1 dimensional but received scalar`);if(i.rank!==1)throw Error(`Indices should be Tensor1D but received shape
          ${i.shape}`);if(a.rank!==1)throw Error(`Segment ids should be Tensor1D but received shape
          ${a.shape}`);let o={data:r,indices:i,segmentIds:a};return P.runKernel(Lr,o)}var Qy,$y=o((()=>{F(),A(),L(),z(),Qy=R({sparseSegmentMean_:Zy})}));function eb(e,t,n){let r=I(e,`data`,`sparseSegmentSum`),i=I(t,`indices`,`sparseSegmentSum`,`int32`),a=I(n,`segmentIds`,`sparseSegmentSum`,`int32`);if(r.rank<1)throw Error(`Data should be at least 1 dimensional but received scalar`);if(i.rank!==1)throw Error(`Indices should be Tensor1D but received shape
         ${i.shape}`);if(a.rank!==1)throw Error(`Segment ids should be Tensor1D but received shape
         ${a.shape}`);let o={data:r,indices:i,segmentIds:a};return P.runKernel(Rr,o)}var tb,nb=o((()=>{F(),A(),L(),z(),tb=R({sparseSegmentSum_:eb})}));function rb(e,t,n,r,i,a,o,s){let c=I(e,`data`,`stringNGrams`,`string`);if(c.dtype!==`string`)throw Error(`Data must be of datatype string`);if(c.shape.length!==1)throw Error(`Data must be a vector, saw: ${c.shape}`);let l=I(t,`dataSplits`,`stringNGrams`);if(l.dtype!==`int32`)throw Error(`Data splits must be of datatype int32`);let u={separator:n,nGramWidths:r,leftPad:i,rightPad:a,padWidth:o,preserveShortSequences:s},d={data:c,dataSplits:l},f=P.runKernel(Wr,d,u);return{nGrams:f[0],nGramsSplits:f[1]}}var ib,ab=o((()=>{F(),A(),L(),z(),ib=R({stringNGrams_:rb})}));function ob(e,t,n=!0){let r=I(e,`input`,`stringSplit`,`string`),i=I(t,`delimiter`,`stringSplit`,`string`);if(r.rank!==1)throw Error(`Input should be Tensor1D but received shape ${r.shape}`);if(i.rank!==0)throw Error(`Delimiter should be a scalar but received shape ${i.shape}`);let a={skipEmpty:n},o={input:r,delimiter:i},s=P.runKernel(Gr,o,a);return{indices:s[0],values:s[1],shape:s[2]}}var sb,cb=o((()=>{F(),A(),L(),z(),sb=R({stringSplit_:ob})}));function lb(e,t){let n=I(e,`input`,`stringToHashBucketFast`,`string`),r={numBuckets:t};if(t<=0)throw Error(`Number of buckets must be at least 1`);let i={input:n};return P.runKernel(Kr,i,r)}var ub,db=o((()=>{F(),A(),L(),z(),ub=R({stringToHashBucketFast_:lb})}));function fb(e,t,n,r=!0){let i=I(e,`input`,`staticRegexReplace`,`string`),a={pattern:t,rewrite:n,replaceGlobal:r};return P.runKernel(Hr,{x:i},a)}var pb,mb=o((()=>{F(),A(),L(),z(),pb=R({staticRegexReplace_:fb})})),hb,gb,_b,vb,yb,bb,xb,Sb=o((()=>{Ic(),zc(),Hc(),Tc(),Gc(),Jc(),Zc(),el(),rl(),ol(),ll(),fl(),hl(),vl(),Hl(),Gl(),lu(),fu(),_u(),bu(),Cu(),Eu(),ku(),Mu(),Fu(),Ru(),hc(),_c(),Vu(),Ku(),bc(),mo(),Jl(),Yu(),Qu(),td(),id(),ud(),sd(),gd(),yd(),Td(),Od(),jd(),Pd(),Ld(),Bd(),Ud(),Kd(),Yd(),Qd(),jc(),_f(),bf(),Cf(),Ef(),kf(),cf(),Mf(),pp(),gp(),yp(),Sp(),Op(),Uu(),jp(),Oc(),Pp(),Lp(),Bp(),Up(),Kp(),Yp(),Qp(),tm(),im(),sm(),eee(),um(),fm(),mm(),Dm(),Mm(),Fm(),Rm(),Vm(),Wm(),Km(),uee(),Zl(),Wf(),Qm(),pee(),hee(),nh(),ih(),vee(),qf(),dh(),ph(),hh(),Cee(),Nc(),Tee(),Dee(),xm(),bh(),Sh(),ch(),Th(),Oh(),jh(),Ph(),Lh(),Aee(),Mee(),Wh(),Xf(),Kh(),Sc(),Jh(),Bee(),Hee(),Wee(),Kee(),fte(),fg(),hte(),hg(),vte(),vg(),xg(),Cg(),Eg(),Og(),G(),jg(),xte(),Cte(),Tte(),Dte(),Rg(),Bg(),Qf(),Ug(),Kg(),Yg(),eu(),Qg(),t_(),r_(),ru(),Mte(),Pte(),Ite(),Rte(),l_(),wm(),Hh(),d_(),p_(),Ute(),v_(),g_(),tp(),ip(),b_(),S_(),w_(),D_(),A_(),km(),op(),N_(),ou(),vo(),F_(),L_(),z_(),V_(),U_(),G_(),$_(),Tp(),nv(),av(),cv(),uv(),fv(),Zte(),Qte(),df(),vv(),oh(),mf(),tne(),xv(),up(),ine(),one(),Ym(),une(),fne(),gne(),kv(),vne(),z(),Dne(),kne(),Yv(),Zv(),Nne(),Fne(),Lne(),zne(),Vne(),Une(),Gne(),ere(),nre(),ire(),ore(),cre(),yy(),xy(),pre(),hre(),_re(),yre(),xre(),wre(),jy(),Ere(),Ore(),Are(),Mre(),Pre(),By(),Wy(),qy(),Xy(),$y(),nb(),ab(),cb(),db(),mb(),hb={fft:u_,ifft:f_,rfft:__,irfft:m_},gb={hammingWindow:qv,hannWindow:Jv,frame:Xv,stft:Qv},_b={flipLeftRight:ey,grayscaleToRGB:ty,resizeNearestNeighbor:by,resizeBilinear:vy,rgbToGrayscale:ny,rotateWithOffset:ry,cropAndResize:$v,nonMaxSuppression:oy,nonMaxSuppressionAsync:py,nonMaxSuppressionWithScore:my,nonMaxSuppressionWithScoreAsync:hy,nonMaxSuppressionPadded:gy,nonMaxSuppressionPaddedAsync:_y,threshold:Sy,transform:Cy},vb={bandPart:wy,gramSchmidt:Ty,qr:Dy},yb={absoluteDifference:My,computeWeightedLoss:Ay,cosineDistance:Ny,hingeLoss:Py,huberLoss:Fy,logLoss:Iy,meanSquaredError:Ly,sigmoidCrossEntropy:zy,softmaxCrossEntropy:Uy},bb={sparseFillEmptyRows:Ky,sparseReshape:Yy,sparseSegmentMean:Qy,sparseSegmentSum:tb},xb={stringNGrams:ib,stringSplit:sb,stringToHashBucketFast:ub,staticRegexReplace:pb}})),Cb=c({Serializable:()=>Db,SerializationMap:()=>Ob,getRegisteredName:()=>wb,registerClass:()=>J});function J(e,t,n){D(e.className!=null,()=>`Class being registered does not have the static className property defined.`),D(typeof e.className==`string`,()=>`className is required to be a string, but got type `+typeof e.className),D(e.className.length>0,()=>`Class being registered has an empty-string as its className, which is disallowed.`),t===void 0&&(t=`Custom`),n===void 0&&(n=e.className);let r=n,i=t+`>`+r;return Ob.register(e),Tb.set(i,e),Eb.set(e,i),e}function wb(e){return Eb.has(e)?Eb.get(e):e.className}var Tb,Eb,Db,Ob,kb=o((()=>{j(),Tb=new Map,Eb=new Map,Db=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},Ob=class e{constructor(){this.classNameMap={}}static getMap(){return e.instance??=new e,e.instance}static register(t){e.getMap().classNameMap[t.className]=[t,t.fromConfig]}}})),Ab,jb=o((()=>{Wo(),vm(),Sb(),kb(),Ab=class extends Db{minimize(e,t=!1,n){let{value:r,grads:i}=this.computeGradients(e,n);if(n!=null){let e=n.map(e=>({name:e.name,tensor:i[e.name]}));this.applyGradients(e)}else this.applyGradients(i);return Mo(i),t?r:(r.dispose(),null)}get iterations(){return this.iterations_??=0,this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return hm(e,t)}dispose(){this.iterations_!=null&&Mo(this.iterations_)}async saveIterations(){return this.iterations_??=0,{name:`iter`,tensor:Zf(this.iterations_,`int32`)}}async getWeights(){throw Error(`getWeights() is not implemented for this optimizer yet.`)}async setWeights(e){throw Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}},Object.defineProperty(Ab,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null})})),Mb,Nb=o((()=>{F(),Wo(),Tc(),jc(),Nc(),Sb(),ip(),mf(),jb(),Mb=class extends Ab{static get className(){return`Adadelta`}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n??(this.epsilon=P.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{let r=P.registeredVariables[t];this.accumulatedGrads[n]??(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:B(()=>pf(r).variable(!1))}),this.accumulatedUpdates[n]??(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:B(()=>pf(r).variable(!1))});let i=Array.isArray(e)?e[n].tensor:e[t];if(i==null)return;let a=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;B(()=>{let e=H(U(a,this.rho),U(rp(i),1-this.rho)),t=U(Ac(ep(H(o,this.epsilon)),ep(H(a,this.epsilon))),i),n=H(U(o,this.rho),U(rp(t),1-this.rho));a.assign(e),o.assign(n);let s=H(U(t,-this.learningRate),r);r.assign(s)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Mo(this.accumulatedGrads.map(e=>e.variable)),Mo(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=e.length/2;this.accumulatedGrads=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.accumulatedUpdates=e.slice(t,t*2).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}})),Pb,Fb=o((()=>{F(),Wo(),Tc(),jc(),Uu(),Nc(),tp(),ip(),jb(),Pb=class extends Ab{static get className(){return`Adagrad`}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{let r=P.registeredVariables[t];this.accumulatedGrads[n]??(this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:B(()=>Hu(r.shape,this.initialAccumulatorValue).variable(!1))});let i=Array.isArray(e)?e[n].tensor:e[t];if(i==null)return;let a=this.accumulatedGrads[n].variable;B(()=>{let e=H(a,rp(i));a.assign(e);let t=H(U(Ac(i,ep(H(e,P.backend.epsilon()))),-this.learningRate),r);r.assign(t)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Mo(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),this.accumulatedGrads=e.map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}})),Ib,Lb=o((()=>{F(),Wo(),Tc(),jc(),Nc(),Xf(),Qf(),tp(),ip(),km(),mf(),jb(),Ib=class extends Ab{static get className(){return`Adam`}constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],B(()=>{this.accBeta1=Zf(t).variable(),this.accBeta2=Zf(n).variable()}),r??(this.epsilon=P.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);B(()=>{let n=q(1,this.accBeta1),r=q(1,this.accBeta2);t.forEach((t,i)=>{let a=P.registeredVariables[t];this.accumulatedFirstMoment[i]??(this.accumulatedFirstMoment[i]={originalName:`${t}/m`,variable:B(()=>pf(a).variable(!1))}),this.accumulatedSecondMoment[i]??(this.accumulatedSecondMoment[i]={originalName:`${t}/v`,variable:B(()=>pf(a).variable(!1))});let o=Array.isArray(e)?e[i].tensor:e[t];if(o==null)return;let s=this.accumulatedFirstMoment[i].variable,c=this.accumulatedSecondMoment[i].variable,l=H(U(s,this.beta1),U(o,1-this.beta1)),u=H(U(c,this.beta2),U(rp(o),1-this.beta2)),d=Ac(l,n),f=Ac(u,r);s.assign(l),c.assign(u);let p=H(U(Ac(d,H(ep(f),this.epsilon)),-this.learningRate),a);a.assign(p)}),this.accBeta1.assign(U(this.accBeta1,this.beta1)),this.accBeta2.assign(U(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Mo(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Mo(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),B(()=>{this.accBeta1.assign(Yf(this.beta1,this.iterations_+1)),this.accBeta2.assign(Yf(this.beta2,this.iterations_+1))});let t=e.length/2;this.accumulatedFirstMoment=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}})),Rb,zb=o((()=>{F(),Wo(),Ic(),Tc(),jc(),nh(),Nc(),Qf(),km(),mf(),jb(),Rb=class extends Ab{static get className(){return`Adamax`}constructor(e,t,n,r=null,i=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],B(()=>{this.iteration=Zf(0).variable(),this.accBeta1=Zf(t).variable()}),r??(this.epsilon=P.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);B(()=>{let n=q(1,this.accBeta1),r=Ac(-this.learningRate,H(U(this.iteration,this.decay),1));t.forEach((t,i)=>{let a=P.registeredVariables[t];this.accumulatedFirstMoment[i]??(this.accumulatedFirstMoment[i]={originalName:`${t}/m`,variable:pf(a).variable(!1)}),this.accumulatedWeightedInfNorm[i]??(this.accumulatedWeightedInfNorm[i]={originalName:`${t}/v`,variable:pf(a).variable(!1)});let o=Array.isArray(e)?e[i].tensor:e[t];if(o==null)return;let s=this.accumulatedFirstMoment[i].variable,c=this.accumulatedWeightedInfNorm[i].variable,l=H(U(s,this.beta1),U(o,1-this.beta1)),u=U(c,this.beta2),d=Fc(o),f=th(u,d);s.assign(l),c.assign(f);let p=H(U(Ac(r,n),Ac(l,H(f,this.epsilon))),a);a.assign(p)}),this.iteration.assign(H(this.iteration,1)),this.accBeta1.assign(U(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Mo(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Mo(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw Error(`getWeights() is not implemented for Adamax yet.`)}async setWeights(e){throw Error(`setWeights() is not implemented for Adamax yet.`)}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}})),Bb,Vb=o((()=>{F(),Wo(),Tc(),Nc(),Qf(),jb(),Bb=class extends Ab{static get className(){return`SGD`}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{let r=Array.isArray(e)?e[n].tensor:e[t];if(r==null)return;let i=P.registeredVariables[t];B(()=>{let e=H(U(this.c,r),i);i.assign(e)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=No(Zf(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw Error(`SGD optimizer does not have settable weights.`)}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}})),Hb,Ub=o((()=>{F(),Wo(),Tc(),Nc(),Qf(),mf(),Vb(),Hb=class extends Bb{static get className(){return`Momentum`}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=Zf(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{let r=P.registeredVariables[t];this.accumulations[n]??(this.accumulations[n]={originalName:`${t}/momentum`,variable:B(()=>pf(r).variable(!1))});let i=this.accumulations[n].variable,a=Array.isArray(e)?e[n].tensor:e[t];a!=null&&B(()=>{let e,t=H(U(this.m,i),a);e=this.useNesterov?H(U(this.c,H(a,U(t,this.m))),r):H(U(this.c,t),r),i.assign(t),r.assign(e)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Mo(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),this.accumulations=e.map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}})),Wb,Gb=o((()=>{F(),Wo(),Tc(),jc(),Nc(),tp(),ip(),km(),mf(),jb(),Wb=class extends Ab{static get className(){return`RMSProp`}constructor(e,t=.9,n=0,r=null,i=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,r??(this.epsilon=P.backend.epsilon()),e==null)throw Error(`learningRate for RMSPropOptimizer must be defined.`)}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{let r=P.registeredVariables[t];this.accumulatedMeanSquares[n]??(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:B(()=>pf(r).variable(!1))}),this.accumulatedMoments[n]??(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:B(()=>pf(r).variable(!1))}),this.accumulatedMeanGrads[n]==null&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:B(()=>pf(r).variable(!1))});let i=Array.isArray(e)?e[n].tensor:e[t];if(i==null)return;let a=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;B(()=>{let e=H(U(a,this.decay),U(rp(i),1-this.decay));if(this.centered){let t=this.accumulatedMeanGrads[n].variable,s=H(U(t,this.decay),U(i,1-this.decay)),c=Ac(U(i,this.learningRate),ep(q(e,H(rp(s),this.epsilon)))),l=H(U(o,this.momentum),c);a.assign(e),t.assign(s),o.assign(l);let u=q(r,l);r.assign(u)}else{let e=H(U(a,this.decay),U(rp(i),1-this.decay)),t=H(U(o,this.momentum),Ac(U(i,this.learningRate),ep(H(e,this.epsilon))));a.assign(e),o.assign(t);let n=q(r,t);r.assign(n)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Mo(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Mo(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Mo(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2;this.accumulatedMeanSquares=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.accumulatedMoments=e.slice(t,t*2).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}}));function Kb(){for(let e of qb)J(e)}var qb,Jb=o((()=>{Nb(),Fb(),Lb(),zb(),Ub(),Gb(),Vb(),kb(),qb=[Mb,Pb,Ib,Rb,Hb,Wb,Bb]}));function Yb(e){return new Promise(e=>setTimeout(e)).then(e)}function Xb(e=`model`){return new tx(e)}function Zb(e){return new nx(e)}var Qb,$b,ex,tx,nx,rx,ix=o((()=>{ao(),it(),_s(),Cs(),Co(),Qb=`model`,$b=`.json`,ex=`.weights.bin`,tx=class e{constructor(t){if(!k().getBool(`IS_BROWSER`))throw Error(`browserDownloads() cannot proceed because the current environment is not a browser.`);t.startsWith(e.URL_SCHEME)&&(t=t.slice(e.URL_SCHEME.length)),(t==null||t.length===0)&&(t=Qb),this.modelJsonFileName=t+$b,this.weightDataFileName=t+ex}async save(e){if(typeof document>`u`)throw Error("Browser downloads are not supported in this environment since `document` is not present");let t=So.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:`application/octet-stream`}));if(e.modelTopology instanceof ArrayBuffer)throw Error(`BrowserDownloads.save() does not support saving model topology in binary formats yet.`);{let t=[{paths:[`./`+this.weightDataFileName],weights:e.weightSpecs}],r=os(e,t),i=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:`application/json`})),a=this.modelJsonAnchor==null?document.createElement(`a`):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=i,await Yb(()=>a.dispatchEvent(new MouseEvent(`click`))),e.weightData!=null){let e=this.weightDataAnchor==null?document.createElement(`a`):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await Yb(()=>e.dispatchEvent(new MouseEvent(`click`)))}return{modelArtifactsInfo:ls(e)}}}},tx.URL_SCHEME=`downloads://`,nx=class{constructor(e){if(e==null||e.length<1)throw Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let n=new FileReader;n.onload=n=>{let r=JSON.parse(n.target.result),i=r.modelTopology;if(i==null){t(Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(r.weightsManifest==null){t(Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:i});return}let a=cs(r,e=>this.loadWeights(e));e(a)},n.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){let t=[],n=[];for(let r of e)t.push(...r.weights),n.push(...r.paths);let r=this.checkManifestAndWeightFiles(e),i=n.map(e=>this.loadWeightsFile(e,r[e]));return Promise.all(i).then(e=>[t,e])}loadWeightsFile(e,t){return new Promise((n,r)=>{let i=new FileReader;i.onload=e=>{let t=e.target.result;n(t)},i.onerror=t=>r(`Failed to weights data from file of path '${e}'.`),i.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map(e=>rs(e.name)),r={};for(let i of e)i.paths.forEach(e=>{let i=rs(e);if(t.indexOf(i)!==-1)throw Error(`Duplicate file basename found in weights manifest: '${i}'`);if(t.push(i),n.indexOf(i)===-1)throw Error(`Weight file with basename '${i}' is not provided.`);r[e]=this.weightsFiles[n.indexOf(i)]});if(t.length!==this.weightsFiles.length)throw Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}},rx=e=>k().getBool(`IS_BROWSER`)&&!Array.isArray(e)&&e.startsWith(tx.URL_SCHEME)?Xb(e.slice(tx.URL_SCHEME.length)):null,vs.registerSaveRouter(rx)}));function ax(e,t,n,r){o(e),n??=0,r??=1,s(n,r);let i=0,a=a=>(a.then(a=>{let o=n+ ++i/e.length*(r-n);return t(o),a}),a);function o(e){D(e!=null&&Array.isArray(e)&&e.length>0,()=>`promises must be a none empty array`)}function s(e,t){D(e>=0&&e<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`),D(t>=0&&t<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`),D(t>=e,()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`)}return Promise.all(e.map(a))}var ox=o((()=>{j()}));async function sx(e,t){t??={};let n=t.fetchFunc==null?k().platform.fetch:t.fetchFunc,r=e.map(e=>n(e,t.requestInit,{isBinary:!0})),i=(t.onProgress==null?await Promise.all(r):await ax(r,t.onProgress,0,.5)).map(e=>e.arrayBuffer());return t.onProgress==null?await Promise.all(i):await ax(i,t.onProgress,.5,1)}function cx(e,t){var n;let r=t.fetchFunc==null?k().platform.fetch:t.fetchFunc,i=0,a;return(n=t.onProgress)==null||n.call(t,0),new ReadableStream({pull:async n=>{for(var o;i<e.length;){a||=(await r(e[i],t.requestInit,{isBinary:!0})).body.getReader();let{done:s,value:c}=await a.read();if(s){i++,a=void 0,(o=t.onProgress)==null||o.call(t,i/e.length);continue}n.enqueue(c);return}n.close()}})}async function lx(e,t=``,n,r){return ux(e=>sx(e,{requestInit:r}))(e,t,n)}function ux(e){return async(t,n=``,r)=>{let i=t.map(()=>!1),a={},o=r==null?[]:r.map(()=>!1),s=[];if(t.forEach((e,t)=>{let n=0;e.weights.forEach(e=>{let c=`quantization`in e?e.quantization.dtype:e.dtype,l=yo[c]*O(e.shape),u=()=>{i[t]=!0,a[t]??(a[t]=[]),a[t].push({manifestEntry:e,groupOffset:n,sizeBytes:l})};r==null?u():r.forEach((t,n)=>{t===e.name&&(u(),o[n]=!0)}),s.push(e.name),n+=l})}),!o.every(e=>e)){let e=r.filter((e,t)=>!o[t]);throw Error(`Could not find weights in manifest with names: ${e.join(`, `)}. \nManifest JSON has weights with names: ${s.join(`, `)}.`)}let c=i.reduce((e,t,n)=>(t&&e.push(n),e),[]),l=[];c.forEach(e=>{t[e].paths.forEach(e=>{let t=n+(n.endsWith(`/`)?``:`/`)+e;l.push(t)})});let u=await e(l),d={},f=0;return c.forEach(e=>{let n=t[e].paths.length,r=new So(u.slice(f,f+n));a[e].forEach(e=>{let t=r.slice(e.groupOffset,e.groupOffset+e.sizeBytes),n=Ko(t,[e.manifestEntry]);for(let e in n)d[e]=n[e]}),f+=n}),d}}var dx=o((()=>{it(),j(),Co(),_s(),ox(),bo()}));function fx(e){let t=e.lastIndexOf(`/`),n=e.lastIndexOf(`?`),r=e.substring(0,t),i=n>t?e.substring(n):``;return[r+`/`,i]}function px(e){return e.match(vx.URL_SCHEME_REGEX)!=null}function mx(e,t){return new vx(e,t)}function hx(e,t){return mx(e,t)}var gx,_x,vx,yx,bx=o((()=>{it(),j(),_s(),Co(),Cs(),dx(),gx=`application/octet-stream`,_x=`application/json`,vx=class{constructor(e,t){if(this.DEFAULT_METHOD=`POST`,t??={},this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc==null?this.fetch=k().platform.fetch:(D(typeof t.fetchFunc==`function`,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc),D(e!=null&&e.length>0,()=>`URL path for http must not be null, undefined or empty.`),Array.isArray(e)&&D(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw Error(`requestInit is expected to have no pre-existing body, but has one.`);this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw Error(`BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.`);let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=[{paths:[`./model.weights.bin`],weights:e.weightSpecs}],r=os(e,n);if(t.body.append(`model.json`,new Blob([JSON.stringify(r)],{type:_x}),`model.json`),e.weightData!=null){let n=So.join(e.weightData);t.body.append(`model.weights.bin`,new Blob([n],{type:gx}),`model.weights.bin`)}let i=await this.fetch(this.path,t);if(i.ok)return{modelArtifactsInfo:ls(e),responses:[i]};throw Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async loadModelJSON(){let e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let e=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(`.pb`)?e+=` Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.`:e+=` Please make sure the server is serving valid JSON for this request.`,Error(e)}let n=t.modelTopology,r=t.weightsManifest;if(n==null&&r==null)throw Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();let e=await this.loadModelJSON();return cs(e,e=>this.loadWeights(e))}async loadStream(){let e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=us(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>cx(t,this.loadOptions)})}async getWeightUrls(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=fx(t),i=this.weightPathPrefix||n,a=[],o=[];for(let t of e)for(let e of t.paths)this.weightUrlConverter==null?a.push(i+e+r):o.push(this.weightUrlConverter(e));return this.weightUrlConverter&&a.push(...await Promise.all(o)),a}async loadWeights(e){let t=await this.getWeightUrls(e),n=us(e),r=await sx(t,this.loadOptions);return[n,r]}},vx.URL_SCHEME_REGEX=/^https?:\/\//,yx=(e,t)=>{if(typeof fetch>`u`&&(t==null||t.fetchFunc==null))return null;{let n=!0;if(n=Array.isArray(e)?e.every(e=>px(e)):px(e),n)return mx(e,t)}return null},vs.registerSaveRouter(yx),vs.registerLoadRouter(yx)}));function xx(e,t,n,r){let i=arguments;return new Dx(Sx(...i))}function Sx(e,t,n,r){return arguments.length===1?e.modelTopology!=null||e.weightSpecs!=null?new Tx(e):(console.warn(`Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.`),new Tx({modelTopology:e})):(console.warn(`Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.`),new Tx({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r}))}function Cx(e){return new Ex(e)}function wx(e){return new Ex(e)}var Tx,Ex,Dx,Ox=o((()=>{Tx=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},Ex=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},Dx=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}})),kx=c({CompositeArrayBuffer:()=>So,browserFiles:()=>Zb,browserHTTPRequest:()=>hx,concatenateArrayBuffers:()=>ns,copyModel:()=>nc,decodeWeights:()=>Ko,decodeWeightsStream:()=>Zo,encodeWeights:()=>Go,fromMemory:()=>xx,fromMemorySync:()=>Sx,getLoadHandlers:()=>Ss,getModelArtifactsForJSON:()=>cs,getModelArtifactsForJSONSync:()=>ss,getModelArtifactsInfoForJSON:()=>ls,getSaveHandlers:()=>xs,getWeightSpecs:()=>us,http:()=>mx,isHTTPScheme:()=>px,listModels:()=>ec,loadWeights:()=>lx,moveModel:()=>rc,registerLoadRouter:()=>bs,registerSaveRouter:()=>ys,removeModel:()=>tc,weightsLoaderFactory:()=>ux,withSaveHandler:()=>Cx,withSaveHandlerSync:()=>wx}),Ax=o((()=>{Fs(),Zs(),ix(),bx(),_s(),Ox(),Cs(),dx(),Co(),oc()}));function jx(e,t,n){let r=I(e,`labels`,`confusionMatrix`),i=I(t,`predictions`,`confusionMatrix`);D(n==null||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),D(r.rank===1,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),D(i.rank===1,()=>`Expected the rank of predictions to be 1, but got ${i.rank}`),D(r.shape[0]===i.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${i.shape[0]}. Labels and predictions should have the same number of elements.`),D(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);let a=xh(V(r,`int32`),n),o=xh(V(i,`int32`),n),s=bv(a),c=Xl(s,o);return V(c,`int32`)}var Mx,Nx=o((()=>{L(),j(),_c(),Zl(),Sh(),z(),xv(),Mx=R({confusionMatrix_:jx})})),Px=c({confusionMatrix:()=>Mx}),Fx=o((()=>{Nx()})),Ix=c({draw:()=>zre,fromPixels:()=>Gx,fromPixelsAsync:()=>Ire,toPixels:()=>Rre});function Lx(e,t=3){if(t>4)throw Error(`Cannot construct Tensor with more than 4 channels from pixels.`);if(e==null)throw Error(`pixels passed to tf.browser.fromPixels() can not be null`);let n=!1,r=!1,i=!1,a=!1,o=!1,s=!1;if(e.data instanceof Uint8Array)n=!0;else if(typeof ImageData<`u`&&e instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<`u`&&e instanceof HTMLVideoElement)i=!0;else if(typeof HTMLImageElement<`u`&&e instanceof HTMLImageElement)a=!0;else if(e.getContext!=null)o=!0;else if(typeof ImageBitmap<`u`&&e instanceof ImageBitmap)s=!0;else throw Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);if(fi(`FromPixels`,P.backendName)!=null){let n={pixels:e},r={numChannels:t};return P.runKernel(ii,n,r)}let[c,l]=i?[e.videoWidth,e.videoHeight]:[e.width,e.height],u;if(o)u=e.getContext(`2d`).getImageData(0,0,c,l).data;else if(r||n)u=e.data;else if(a||i||s){if(Ux==null)if(typeof document>`u`)if(typeof OffscreenCanvas<`u`&&typeof OffscreenCanvasRenderingContext2D<`u`)Ux=new OffscreenCanvas(1,1).getContext(`2d`);else throw Error(`Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.`);else Ux=document.createElement(`canvas`).getContext(`2d`,{willReadFrequently:!0});Ux.canvas.width=c,Ux.canvas.height=l,Ux.drawImage(e,0,0,c,l),u=Ux.getImageData(0,0,c,l).data}let d;if(t===4)d=new Int32Array(u);else{let e=c*l;d=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)d[n*t+e]=u[n*4+e]}return R_(d,[l,c,t],`int32`)}function Rx(e){return e!=null&&e.data instanceof Uint8Array}function zx(){return typeof window<`u`&&typeof ImageBitmap<`u`&&window.hasOwnProperty(`createImageBitmap`)}function Bx(e){return e!=null&&e.width!==0&&e.height!==0}function Vx(e){return zx()&&!(e instanceof ImageBitmap)&&Bx(e)&&!Rx(e)}async function Ire(e,t=3){let n=null;if(k().getBool(`WRAP_TO_IMAGEBITMAP`)&&Vx(e)){let t;try{t=await createImageBitmap(e,{premultiplyAlpha:`none`})}catch{t=null}n=t!=null&&t.width===e.width&&t.height===e.height?t:e}else n=e;return Lx(n,t)}function Hx(e){if(e.rank!==2&&e.rank!==3)throw Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let t=e.rank===2?1:e.shape[2];if(t>4||t===2)throw Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if(e.dtype!==`float32`&&e.dtype!==`int32`)throw Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}function Lre(e){let t=e?.alpha||1;if(t>1||t<0)throw Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}async function Rre(e,t){let n=I(e,`img`,`toPixels`);if(!(e instanceof wa)){let e=n;n=V(e,`int32`),e.dispose()}Hx(n);let[r,i]=n.shape.slice(0,2),a=n.rank===2?1:n.shape[2],o=await n.data(),s=n.dtype===`float32`?255:1,c=new Uint8ClampedArray(i*r*4);for(let e=0;e<r*i;++e){let t=[0,0,0,255];for(let r=0;r<a;r++){let i=o[e*a+r];if(n.dtype===`float32`){if(i<0||i>1)throw Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${i}.`)}else if(n.dtype===`int32`&&(i<0||i>255))throw Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${i}.`);a===1?(t[0]=i*s,t[1]=i*s,t[2]=i*s):t[r]=i*s}let r=e*4;c[r+0]=Math.round(t[0]),c[r+1]=Math.round(t[1]),c[r+2]=Math.round(t[2]),c[r+3]=Math.round(t[3])}if(t!=null){Wx||fi(`Draw`,P.backendName)!=null&&(console.warn(`tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead.`),Wx=!0),t.width=i,t.height=r;let e=t.getContext(`2d`),n=new ImageData(c,i,r);e.putImageData(n,0,0)}return n!==e&&n.dispose(),c}function zre(e,t,n){let r=I(e,`img`,`draw`);if(!(e instanceof wa)){let e=r;r=V(e,`int32`),e.dispose()}Hx(r),Lre(n?.imageOptions);let i={image:r},a={canvas:t,options:n};P.runKernel(tn,i,a)}var Ux,Wx,Gx,Bre=o((()=>{F(),it(),A(),Ci(),N(),L(),_c(),z(),z_(),Wx=!1,Gx=R({fromPixels_:Lx})})),Vre=c({prepareAndValidate:()=>Kx});function Kx(e,t){let n=e.shape.length,r=t.shape.length;if(n<1)throw Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(t.dtype!==`int32`)throw Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(O(e.shape)===0)throw Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let i=t.shape,a=i[i.length-1],o=1;for(let e=0;e<i.length-1;++e)o*=i[e];let s=e.shape,c=i.slice();c.pop();let l=1;for(let e=a;e<n;++e)l*=s[e],c.push(s[e]);let u=[...ze(e.shape).map(e=>e/l),1].slice(0,a);return[c,o,l,u]}var qx=o((()=>{j()})),Jx=c({assertParamsValid:()=>Yx,computeFlatOffset:()=>oS,computeOutShape:()=>Xx,getNormalizedAxes:()=>Ure,isSliceContinous:()=>aS,maskToAxes:()=>Hre,parseSliceParams:()=>sS,sliceInfo:()=>cS,startForAxis:()=>rS,startIndicesWithElidedDims:()=>eS,stopForAxis:()=>iS,stopIndicesWithElidedDims:()=>tS,stridesForAxis:()=>nS,stridesWithElidedDims:()=>Zx});function Yx(e,t,n){let r=e.shape.length;D(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),D(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let i=0;i<r;++i)D(t[i]+n[i]<=e.shape[i],()=>`Error in slice${r}D: begin[${i}] + size[${i}] (${t[i]+n[i]}) would overflow input.shape[${i}] (${e.shape[i]})`)}function Hre(e){let t=[],n=0;for(;e>0;)e&1&&t.push(n),e/=2,n++;return t}function Xx(e,t,n){let r=[];for(let i=0;i<e.length;i++)r[i]=Math.ceil((t[i]-e[i])/n[i]);return r}function Zx(e,t,n,r){let i=[...e];for(let e=i.length;e<r.length;e++)i.push(1);for(let e=0;e<n;e++)e===0?i[t]=1:(i.splice(t,0,1),i.pop());return i}function Qx(e,t,n){return n<=e?n:n-(t-1)}function $x(e,t){let n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function Ure(e,t,n,r,i,a,o,s,c){let l=e.length,u=Array(l),d=Array(l),f=Array(l);if(t.length&&n>0){let c=t[0],l=n+1;u=eS(o,c,l,r,e),d=tS(s,c,l,i,e),f=Zx(a,c,l,e)}else for(let t=0;t<l;t++)u[t]=rS(o,r,a,e,t,c),d[t]=iS(s,i,a,e,t,c),f[t]=nS(a,t,c);return{begin:u,end:d,strides:f}}function eS(e,t,n,r,i){let a=[...i],o=$x(n,t);for(let i=0;i<a.length;i++)if(o.indexOf(i)>-1)a[i]=0;else{let o=Qx(t,n,i),s=r[o];e&1<<o&&(s=0),a[i]=s}return a}function tS(e,t,n,r,i){let a=[...i],o=$x(n,t);for(let i=0;i<a.length;i++)if(o.indexOf(i)>-1)a[i]=2**53-1;else{let o=Qx(t,n,i),s=r[o];e&1<<o&&(s=2**53-1),a[i]=s}for(let e=0;e<a.length;e++){let t=i[e];a[e]<0&&(a[e]+=t),a[e]=oe(0,a[e],i[e])}return a}function nS(e,t,n){let r=e[t];return(n&1<<t||r==null)&&(r=1),r}function rS(e,t,n,r,i,a){let o=t[i],s=n[i]||1;(e&1<<i||a&1<<i||o==null)&&(o=s>0?-(2**53-1):2**53-1);let c=r[i];return o<0&&(o+=c),o=oe(0,o,c-1),o}function iS(e,t,n,r,i,a){let o=t[i],s=n[i]||1;(e&1<<i||a&1<<i||o==null)&&(o=s>0?2**53-1:-(2**53-1));let c=r[i];return o<0&&(o+=c),o=s>0?oe(0,o,c):oe(-1,o,c-1),o}function aS(e,t,n){let r=n.length;for(let e=0;e<n.length;e++)if(n[e]>1){r=e;break}for(let i=r+1;i<n.length;i++)if(t[i]>0||n[i]!==e[i])return!1;return!0}function oS(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function sS(e,t,n){let r,i=e.shape.length;r=typeof t==`number`?[t,...Array(i-1).fill(0)]:t.length<i?t.concat(Array(i-t.length).fill(0)):t.slice(),r.forEach(e=>{D(e!==-1,()=>`slice() does not support negative begin indexing.`)});let a;return a=n==null?Array(i).fill(-1):typeof n==`number`?[n,...Array(i-1).fill(-1)]:n.length<i?n.concat(Array(i-n.length).fill(-1)):n,a=a.map((t,n)=>t>=0?t:(D(t===-1,()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`),e.shape[n]-r[n])),[r,a]}function cS(e,t,n,r,i,a,o,s,c){let l;if(r==null?(l=Array(t.length),l.fill(1)):l=r,o!=null&&o&o-1)throw Error(`Multiple ellipses in slice is not allowed.`);let u=!1,d={dims:l.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:l.slice(),beginMask:i,endMask:a,ellipsisMask:o,newAxisMask:s,shrinkAxisMask:c};for(let e=0;e<d.dims;e++)u&&1<<e&s&&d.numAddAxisAfterEllipsis++,1<<e&o&&(u=!0);u||(d.ellipsisMask|=1<<d.dims,d.dims++);let f={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};Wre(d,f);let p=!0,m=!0,h=!0,g=[],_=[];for(let t=0;t<e.length;++t){if(f.strides[t]===0)throw Error(`strides[${t}] must be non-zero`);let n=!!(f.shrinkAxisMask&1<<t),r=e[t];if(r===-1){g.push(n?1:-1);continue}let i=[f.beginMask&1<<t,f.endMask&1<<t],a=[f.strides[t]>0?0:-1,f.strides[t]>0?r:r-1];if(n&&f.strides[t]<=0)throw Error(`only stride 1 allowed on non-range indexing.`);h&&=f.strides[t]===1;let o=!!(f.beginMask&1<<t&&f.endMask&1<<t);if(f.beginValid&&f.endValid){if(n){let e=f.begin[t]<0?r+f.begin[t]:f.begin[t];if(f.begin[t]=e,f.end[t]=f.begin[t]+1,e<0||e>=r)throw Error(`slice index ${f.begin[t]} of dimension ${t} out of bounds.`)}else f.begin[t]=lS(f.begin[t],0,f.strides[t],r,i,a),f.end[t]=lS(f.end[t],1,f.strides[t],r,i,a);let e=f.strides[t]===1&&f.begin[t]===0&&f.end[t]===r;p&&=e,m&&=t===0&&f.strides[t]===1||e}else p=p&&f.strides[t]===1&&o,m&&=t===0&&f.strides[t]===1||o;let s,c=!1;if(f.beginValid&&f.endValid?(s=f.end[t]-f.begin[t],c=!0):n?(s=1,c=!0):o&&r>=0&&(s=f.strides[t]<0?-r:r,c=!0),c){let e;e=s===0||s<0!=f.strides[t]<0?0:Math.trunc(s/f.strides[t])+(s%f.strides[t]===0?0:1),g.push(e)}else g.push(-1)}for(let e=0;e<f.finalShapeGatherIndices.length;++e){let t=f.finalShapeGatherIndices[e];t>=0?_.push(g[t]):t===uS&&_.push(1)}return{finalShapeSparse:_.filter((e,t)=>f.finalShapeGatherIndices[t]!==uS),finalShape:_,isIdentity:p,sliceDim0:m,isSimpleSlice:h,begin:f.begin,end:f.end,strides:f.strides}}function Wre(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=e.begin!=null,t.endValid=e.end!=null,t.begin=Array(t.dims),t.end=Array(t.dims),t.strides=Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){let i=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<i;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(uS),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);e.begin!=null&&(t.begin[n]=e.begin[r]),e.end!=null&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(dS),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}function lS(e,t,n,r,i,a){if(i[t])return n>0?a[t]:a[t+1&1];{let t=e<0?r+e:e;return t<a[0]?a[0]:t>a[1]?a[1]:t}}var uS,dS,fS=o((()=>{j(),uS=-2,dS=-1})),pS,Gre=o((()=>{pS=`4.22.0`})),mS,hS=o((()=>{Nb(),Fb(),Lb(),zb(),Ub(),Gb(),Vb(),mS=class{static sgd(e){return new Bb(e)}static momentum(e,t,n=!1){return new Hb(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,i=!1){return new Wb(e,t,n,r,i)}static adam(e=.001,t=.9,n=.999,r=null){return new Ib(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new Mb(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,i=0){return new Rb(e,t,n,r,i)}static adagrad(e,t=.1){return new Pb(e,t)}}})),gS,Kre=o((()=>{hS(),gS=mS}));function _S(){return new Promise(e=>vS(()=>e()))}var vS,qre=o((()=>{vS=(()=>typeof requestAnimationFrame<`u`?requestAnimationFrame:typeof setImmediate<`u`?setImmediate:e=>e())()}));function yS(e,t){let n=e[0].length;e.forEach((e,t)=>{D(e.length===n,()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`)}),D(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);let r=e[0];e.forEach((e,i)=>{for(let a=0;a<n;a++)D(a===t||e[a]===r[a],()=>`Error in concat${n}D: Shape of tensors[${i}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${i}.`)})}function bS(e,t){let n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var Jre=o((()=>{j()})),Yre=o((()=>{}));function xS(e,t,n){let r=[];if(n==null&&t==null)return r;if(t==null)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(n==null)return r;if(e+n.length!==r.length)throw Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let i=1;i<n.length;++i){let a=n[i],o=r[r.length-n.length+i],s=r[o];if(a>=0)if(s>=0){if(s!==a)throw Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${i+e}] = ${a} but shape[${i+e}] = ${s}`)}else r[o]=a}return r}function SS(e){let t={FIRST_DIM_SIZE:TS.FIRST_DIM_SIZE,VALUE_ROWIDS:TS.VALUE_ROWIDS,ROW_LENGTHS:TS.ROW_LENGTHS,ROW_SPLITS:TS.ROW_SPLITS,ROW_LIMITS:TS.ROW_LIMITS,ROW_STARTS:TS.ROW_STARTS},n=[];for(let r of e)if(r in t)n.push(t[r]);else break;return n}function CS(e){return e.length===0?0:e[0]===TS.FIRST_DIM_SIZE?e.length-1:e.length}function wS(e,t){if(e==null||t==null)return;let n=e.length,r=t.length;if(n>=r)throw Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let i=0;i<Math.min(n,r-1);++i){let n=e[i],r=t[i+1];if(n>=0&&r>=0&&n!==1&&n!==r)throw Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${i-e.length}] = ${n} but ragged tensor input.flatValues.shape[${i-e.length}] = ${r}`)}}var TS,Xre=o((()=>{(function(e){e[e.FIRST_DIM_SIZE=0]=`FIRST_DIM_SIZE`,e[e.VALUE_ROWIDS=1]=`VALUE_ROWIDS`,e[e.ROW_LENGTHS=2]=`ROW_LENGTHS`,e[e.ROW_SPLITS=3]=`ROW_SPLITS`,e[e.ROW_LIMITS=4]=`ROW_LIMITS`,e[e.ROW_STARTS=5]=`ROW_STARTS`})(TS||={})}));function ES(e){return e<=30?e:Re(e,Math.floor(Math.sqrt(e)))}var DS=o((()=>{j()}));
/**
* @license
* Copyright 2020 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/
function OS(e,t,n){let r=n*(typeof e==`number`?e:e[0]),i=t*(typeof e==`number`?e:e[1]);return[r,i]}var Zre=o((()=>{}));
/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/
function kS(e,t,n,r=!0){let i=[];if(r)i=i.concat(t.slice(0)),i.push(e[0]/n),i=i.concat(e.slice(1));else{i=i.concat(e[0]);let n=t.length;for(let r=0;r<n;++r)i=i.concat([e[r+1]/t[r],t[r]]);i=i.concat(e.slice(n+1))}return i}function AS(e,t,n=!0){let r=[];if(n){r.push(t);for(let n=t+1;n<e;++n)n<=2*t?(r.push(n),r.push(n-(t+1))):r.push(n)}else{let n=[],i=[];for(let r=1;r<e;++r)r>=t*2+1||r%2==1?i.push(r):n.push(r);r.push(...n),r.push(0),r.push(...i)}return r}function jS(e,t,n,r=!0){let i=[];r?i.push(e[0]/n):i.push(e[0]*n);for(let n=1;n<e.length;++n)n<=t.length?r?i.push(t[n-1]*e[n]):i.push(e[n]/t[n-1]):i.push(e[n]);return i}function MS(e,t){let n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function NS(e,t,n){let r=e.slice(0,1);for(let i=0;i<n;++i)r.push(e[i+1]-t[i][0]-t[i][1]);return r}var Qre=o((()=>{})),PS,FS,IS=o((()=>{PS=1.7580993408473768,FS=1.0507009873554805})),LS,RS,zS,BS,VS,HS,$re=o((()=>{LS=.3275911,RS=.254829592,zS=-.284496736,BS=1.421413741,VS=-1.453152027,HS=1.061405429}));
/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/
function US(e,t){if(e.length!==t.length)throw Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(e.length*2);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function WS(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function GS(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=0;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function KS(e){let t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=2;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function qS(e,t){let n=e[t*2],r=e[t*2+1];return{real:n,imag:r}}function JS(e,t,n,r){e[r*2]=t,e[r*2+1]=n}function YS(e,t){let n=new Float32Array(e/2),r=new Float32Array(e/2);for(let i=0;i<Math.ceil(e/2);i++){let a=(t?2:-2)*Math.PI*(i/e);n[i]=Math.cos(a),r[i]=Math.sin(a)}return{real:n,imag:r}}function XS(e,t,n){let r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}var eie=o((()=>{}));function ZS(e,t){e=e.replace(/\s/g,``);let n=(e.length-e.replace(rC,``).length)/2;if(n<1)throw Error(`Equations without an arrow are not supported.`);if(n>1)throw Error(`Equation must contain exactly one arrow ("${nC}").`);let[r,i]=e.split(nC);D(r.indexOf(aC)===-1,()=>`The ellipsis notation ("${aC}") is not supported yet.`);let a=r.split(iC),o=a.length;if(t!==o)throw Error(`Expected ${o} input tensors, received ${t}`);if(o>2)throw Error(`Support for more than 2 input tensors is not implemented yet.`);let s=[];for(let e=0;e<i.length;++e){let t=i[e];if(!a.some(e=>e.indexOf(t)!==-1))throw Error(`Output subscripts contain the label ${t} not present in the input subscripts.`);s.indexOf(t)===-1&&s.push(t)}for(let e=0;e<r.length;++e){let t=r[e];s.indexOf(t)===-1&&t!==iC&&s.push(t)}let c=Array(a.length);for(let e=0;e<o;++e){if(new Set(a[e].split(``)).size!==a[e].length)throw Error(`Found duplicate axes in input component ${a[e]}. Support for duplicate axes in input is not implemented yet.`);c[e]=[];for(let t=0;t<a[e].length;++t)c[e].push(s.indexOf(a[e][t]))}let l=s.length,u=i.length,d=[];for(let e=u;e<l;++e)d.push(e);return{allDims:s,summedDims:d,idDims:c}}function QS(e,t){let n=Array(e);n.fill(-1);for(let e=0;e<t.length;++e)n[t[e]]=e;let r=[];for(let t=0;t<e;++t)n[t]===-1&&r.push(t);return n=n.filter(e=>e!==-1),{permutationIndices:n,expandDims:r}}function $S(e,t,n){let r=Array(e);for(let e=0;e<n.length;++e){let i=n[e].shape;for(let n=0;n<t[e].length;++n)r[t[e][n]]===void 0?r[t[e][n]]=i[n]:D(r[t[e][n]]===i[n],()=>`Expected dimension ${r[t[e][n]]} at axis ${n} of input shaped ${JSON.stringify(i)}, but got dimension ${i[n]}`)}}function eC(e,t){let n=e,r=[],i=0;e.length===0&&n.push(-1),i=e.length+1;for(let e=0;e<i;++e)r.push([]);let a=[];for(let e=0;e<n.length;++e){let i=n[e],o=tie(t,i);for(let t of o)a.indexOf(t)===-1&&(r[e].push(t),a.push(t))}return{path:n,steps:r}}function tC(e){return e.every((e,t)=>e===t)}function tie(e,t){let n=[];for(let r=0;r<e.length;++r)(e[r].length===0||e[r].indexOf(t)!==-1||t===-1)&&n.push(r);return n}var nC,rC,iC,aC,nie=o((()=>{Xe(),nC=`->`,rC=/->/g,iC=`,`,aC=`...`}));function oC(e,t,n=0){let r=[];if(typeof t==`number`)D(e.shape[n]%t===0,()=>`Number of splits must evenly divide the axis.`),r=Array(t).fill(e.shape[n]/t);else{let i=t.reduce((e,t)=>(t===-1&&(e+=1),e),0);D(i<=1,()=>`There should be only one negative value in split array.`);let a=t.indexOf(-1);if(a!==-1){let r=t.reduce((e,t)=>t>0?e+t:e);t[a]=e.shape[n]-r}D(e.shape[n]===t.reduce((e,t)=>e+t),()=>`The sum of sizes must match the size of the axis dimension.`),r=t}return r}var rie=o((()=>{j()}));
/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/
function sC(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function cC(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function lC(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}var iie=o((()=>{}));function uC(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function dC(e,t){return`size ${e} must be non-negative, not ${t}`}function fC(){return`reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero`}function pC(e,t){let n=O(e),r=O(t);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${e} outputShape= ${t}`}function mC(e,t){let n=O(e),r=O(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${e} outputShape=${t}`}var aie=o((()=>{j()}));
/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/
function hC(){return`segment ids must be >= 0`}function gC(){return`segment ids are not increasing`}function _C(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function vC(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}var oie=o((()=>{})),sie=c({collectGatherOpShapeInfo:()=>xC,computeOutShape:()=>bC,segOpComputeOptimalWindowSize:()=>yC});function yC(e,t){let n=!1,r;for(e<=30?(r=e,n=!0):r=Re(e,Math.floor(Math.sqrt(e)));!n;)r>t||r===e?n=!0:r=Re(e,r+1);return r}function bC(e,t,n){let r=[],i=e.length;for(let a=0;a<i;a++)a===t?r.push(n):r.push(e[a]);return r}function xC(e,t,n,r){let i=t.shape.length,a=e.shape.length;if(r!==0&&(r<-i||r>i))throw Error(`Expect batchDims in the range of [-${i}, ${i}], but got ${r}`);if(r<0&&(r+=i),r>a)throw Error(`batchDims (${r}) must be less than rank(x) (
    ${a}).`);if(n<r)throw Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let n=0;n<r;++n)if(e.shape[n]!==t.shape[n])throw Error(`x.shape[${n}]: ${e.shape[n]} should be equal to indices.shape[${n}]: ${t.shape[n]}.`);let o=e.shape[n],s=[],c=1,l=1,u=1;for(let t=0;t<r;++t)s.push(e.shape[t]),c*=e.shape[t];for(let t=r;t<n;t++)s.push(e.shape[t]),l*=e.shape[t];for(let e=r;e<i;e++)s.push(t.shape[e]);for(let t=n+1;t<a;t++)s.push(e.shape[t]),u*=e.shape[t];return{batchSize:c,sliceSize:u,outerSize:l,dimSize:o,outputShape:s}}var cie=o((()=>{j(),DS()})),SC=c({ERF_A1:()=>RS,ERF_A2:()=>zS,ERF_A3:()=>BS,ERF_A4:()=>VS,ERF_A5:()=>HS,ERF_P:()=>LS,PARALLELIZE_THRESHOLD:()=>30,RowPartitionType:()=>TS,SELU_SCALE:()=>FS,SELU_SCALEALPHA:()=>PS,applyActivation:()=>Iv,assertAndGetBroadcastShape:()=>nf,assertAxesAreInnerMostDims:()=>Lf,assertParamsConsistent:()=>yS,assignToTypedArray:()=>JS,axesAreInnerMostDims:()=>Nf,calculateShapes:()=>Y_,checkEinsumDimSizes:()=>$S,checkPadOnDimRoundingMode:()=>Ll,combineLocations:()=>Pf,combineRaggedTensorToTensorShapes:()=>xS,complexWithEvenIndex:()=>GS,complexWithOddIndex:()=>KS,computeConv2DInfo:()=>Sl,computeConv3DInfo:()=>Cl,computeDefaultPad:()=>El,computeDilation2DInfo:()=>yl,computeOptimalWindowSize:()=>ES,computeOutAndReduceShapes:()=>Ff,computeOutShape:()=>bS,computePool2DInfo:()=>bl,computePool3DInfo:()=>xl,convertConv2DDataFormat:()=>Il,decodeEinsumEquation:()=>ZS,eitherStridesOrDilationsAreOne:()=>Pl,expandShapeToKeepDim:()=>If,exponent:()=>XS,exponents:()=>YS,fromStringArrayToUint8:()=>wC,fromUint8ToStringArray:()=>CC,getAxesPermutation:()=>Rf,getBroadcastDims:()=>ef,getComplexWithIndex:()=>qS,getEinsumComputePath:()=>eC,getEinsumPermutation:()=>QS,getFusedBiasGradient:()=>Fv,getFusedDyActivation:()=>Pv,getImageCenter:()=>OS,getInnerMostAxes:()=>Bf,getPermuted:()=>AS,getRaggedRank:()=>CS,getReductionAxes:()=>tf,getReshaped:()=>kS,getReshapedPermuted:()=>jS,getRowPartitionTypesHelper:()=>SS,getSliceBeginCoords:()=>MS,getSliceSize:()=>NS,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>sC,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>cC,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>lC,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>fC,getSparseReshapeInputOutputMismatchErrorMessage:()=>mC,getSparseReshapeInputOutputMultipleErrorMessage:()=>pC,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>uC,getSparseReshapeNegativeOutputDimErrorMessage:()=>dC,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>vC,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>hC,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>gC,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>_C,getUndoAxesPermutation:()=>zf,isIdentityPermutation:()=>tC,log:()=>ui,mergeRealAndImagArrays:()=>US,prepareAndValidate:()=>Kx,prepareSplitSize:()=>oC,segment_util:()=>sie,shouldFuse:()=>Lv,slice_util:()=>Jx,splitRealAndImagArrays:()=>WS,stridesOrDilationsArePositive:()=>Fl,tupleValuesAreOne:()=>Nl,upcastType:()=>Ea,validateDefaultValueShape:()=>wS,validateInput:()=>J_,validateUpdateShape:()=>q_,warn:()=>li});function CC(e){try{return e.map(e=>$i(e))}catch(e){throw Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function wC(e){return e.map(e=>Qi(e))}var TC=o((()=>{j(),Vf(),rf(),Jre(),Rl(),Rv(),Yre(),Xre(),DS(),fS(),Ia(),Zre(),Qre(),qx(),X_(),IS(),Rv(),$re(),di(),eie(),nie(),rie(),iie(),aie(),oie(),cie()})),EC=c({nonMaxSuppressionV3Impl:()=>sy,nonMaxSuppressionV4Impl:()=>cy,nonMaxSuppressionV5Impl:()=>ly,whereImpl:()=>hv}),DC=o((()=>{fy(),gv()})),OC=o((()=>{Ax(),Fx(),rf(),Bre(),qx(),X_(),fS(),kb(),Wa(),ute(),j(),Gre(),Nb(),Fb(),Lb(),zb(),Ub(),jb(),hS(),Gb(),Vb(),N(),Ia(),Sb(),ky(),Kre(),Wo(),Ci(),vm(),it(),qre(),TC(),ro(),DC(),re(),A()})),Y=o((()=>{Cc(),Jb(),OC(),Kb()})),kC,AC=o((()=>{A(),_c(),Nc(),D_(),kC={kernelName:`Abs`,inputsToSave:[`x`],gradFunc:(e,t)=>{let[n]=t;return{x:()=>U(e,E_(V(n,`float32`),-1))}}}})),jC,MC=o((()=>{A(),_c(),jc(),xm(),Qf(),tp(),ip(),km(),jC={kernelName:ut,inputsToSave:[`x`],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=rp(V(n,`float32`)),r=ep(q(Zf(1),t));return bm(Ac(e,r))}}}}})),NC,PC=o((()=>{A(),_c(),jc(),tp(),ip(),km(),NC={kernelName:dt,inputsToSave:[`x`],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=ep(q(rp(V(n,`float32`)),1));return Ac(e,t)}}}}})),FC,IC=o((()=>{A(),rf(),G(),op(),FC={kernelName:`Add`,inputsToSave:[`a`,`b`],gradFunc:(e,t)=>{let[n,r]=t,i=nf(n.shape,r.shape);return{a:()=>{let t=e,r=tf(n.shape,i);return r.length>0&&(t=K(t,r)),W(t,n.shape)},b:()=>{let t=e,n=tf(r.shape,i);return n.length>0&&(t=K(t,n)),W(t,r.shape)}}}}})),LC,RC=o((()=>{A(),LC={kernelName:ft,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach((t,r)=>{n[r]=()=>e.clone()}),n}}})),zC,BC=o((()=>{A(),mf(),zC={kernelName:pt,inputsToSave:[`x`],gradFunc:(e,t)=>{let[n]=t;return{x:()=>pf(n)}}}})),VC,HC=o((()=>{A(),mf(),VC={kernelName:mt,inputsToSave:[`x`],gradFunc:(e,t)=>{let[n]=t;return{x:()=>pf(n)}}}})),UC,WC=o((()=>{A(),_c(),jc(),Qf(),tp(),ip(),km(),UC={kernelName:ht,inputsToSave:[`x`],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ac(e,ep(q(Zf(1),rp(V(n,`float32`)))))}}}})),GC,KC=o((()=>{A(),Tc(),_c(),jc(),Qf(),tp(),ip(),GC={kernelName:gt,inputsToSave:[`x`],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=ep(H(Zf(1),rp(V(n,`float32`))));return Ac(e,t)}}}}})),qC,JC=o((()=>{A(),Tc(),rf(),jc(),Nc(),xm(),G(),ip(),op(),qC={kernelName:yt,inputsToSave:[`a`,`b`],gradFunc:(e,t)=>{let[n,r]=t,i=nf(n.shape,r.shape);return{a:()=>{let t=H(rp(n),rp(r)),a=U(e,Ac(r,t)),o=tf(n.shape,i);return o.length>0&&(a=K(a,o)),W(a,n.shape)},b:()=>{let t=H(rp(n),rp(r)),a=bm(U(e,Ac(n,t))),o=tf(r.shape,i);return o.length>0&&(a=K(a,o)),W(a,r.shape)}}}}})),YC,XC=o((()=>{A(),Tc(),_c(),jc(),ip(),YC={kernelName:_t,inputsToSave:[`x`],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ac(e,H(rp(V(n,`float32`)),1))}}}})),ZC,lie=o((()=>{A(),_c(),jc(),ip(),km(),Qf(),ZC={kernelName:vt,inputsToSave:[`x`],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ac(e,q(Zf(1),rp(V(n,`float32`))))}}}}));function uie(e,t,n,r,i,a){let o=I(e,`dy`,`avgPool3dGrad`),s=I(t,`input`,`avgPool3dGrad`),c=o,l=s,u=!1;s.rank===4&&(u=!0,c=W(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),l=W(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),D(c.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),D(l.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`),Ll(`avgPool3dGrad`,i,a);let d={dy:c,input:l},f={filterSize:n,strides:r,pad:i,dimRoundingMode:a},p=P.runKernel(Ct,d,f);return u?W(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var QC,die=o((()=>{F(),A(),L(),j(),Rl(),z(),G(),QC=R({avgPool3dGrad_:uie})})),$C,fie=o((()=>{A(),die(),$C={kernelName:St,inputsToSave:[`x`],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:i,strides:a,pad:o,dimRoundingMode:s}=n;return{x:()=>QC(e,r,i,a,o,s)}}}}));function pie(e,t,n,r,i){let a=I(e,`dy`,`avgPoolGrad`),o=I(t,`input`,`avgPoolGrad`);D(o.rank===a.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${a.rank})`);let s=o,c=a,l=!1;o.rank===3&&(l=!0,s=W(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=W(a,[1,a.shape[0],a.shape[1],a.shape[2]])),D(c.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${c.rank}.`),D(s.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${s.rank}.`);let u={dy:c,input:s},d={filterSize:n,strides:r,pad:i},f=P.runKernel(xt,u,d);return l?W(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var ew,mie=o((()=>{F(),A(),L(),j(),z(),G(),ew=R({avgPoolGrad_:pie})})),tw,hie=o((()=>{A(),mie(),tw={kernelName:bt,inputsToSave:[`x`],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:i,strides:a,pad:o}=n;return{x:()=>ew(e,r,i,a,o)}}}})),nw,gie=o((()=>{A(),Zl(),nw={kernelName:wt,inputsToSave:[`a`,`b`],gradFunc:(e,t,n)=>{let[r,i]=t,{transposeA:a,transposeB:o}=n;return!a&&!o?{a:()=>Xl(e,i,!1,!0),b:()=>Xl(r,e,!0,!1)}:!a&&o?{a:()=>Xl(e,i,!1,!1),b:()=>Xl(e,r,!0,!1)}:a&&!o?{a:()=>Xl(i,e,!1,!0),b:()=>Xl(r,e,!1,!1)}:{a:()=>Xl(i,e,!0,!0),b:()=>Xl(e,r,!0,!0)}}}})),rw,_ie=o((()=>{A(),Hh(),rw={kernelName:Tt,gradFunc:(e,t,n)=>{let{blockShape:r,crops:i}=n;return{x:()=>Vh(e,r,i)}}}})),iw,vie=o((()=>{A(),op(),iw={kernelName:Ot,gradFunc:(e,t,n)=>{let r=n,i=r.inputShape,a=r.shape,o=Array.from(a);for(let e=i.length-1;e>=0;e--)if(i[e]===a[e])o[e]=1;else if(i[e]!==1)throw Error(`broadcastTo(): [${i}] cannot be broadcast to [${a}].`);let s=[];for(let e=0;e<o.length;e++)o[e]>1&&s.push(e);return{x:()=>K(e,s,!0)}}}})),aw,yie=o((()=>{A(),aw={kernelName:At,gradFunc:e=>({x:()=>e.clone()})}})),ow,bie=o((()=>{A(),mf(),ow={kernelName:jt,gradFunc:e=>({x:()=>pf(e)})}})),sw,xie=o((()=>{A(),Bp(),sm(),Rm(),df(),mf(),sw={kernelName:Mt,inputsToSave:[`x`],gradFunc:(e,t,n)=>{let[r]=t,{clipValueMin:i,clipValueMax:a}=n;return{x:()=>uf(Lm(zp(r,i),om(r,a)),e,pf(e))}}}})),cw,Sie=o((()=>{A(),AC(),cw={kernelName:Pt,inputsToSave:[`x`],gradFunc:kC.gradFunc}})),lw,Cie=o((()=>{A(),g_(),j(),lw={kernelName:Ft,saveAllInputs:!0,gradFunc:(e,t,n)=>{let r=t.map(e=>e.shape),{axis:i}=n,a=we(i,t[0].shape)[0],o=r.map(e=>e[a]);return h_(e,o,a).map(e=>()=>e)}}})),uw,wie=o((()=>{A(),Nv(),pd(),Rl(),j(),uw={kernelName:It,inputsToSave:[`x`,`filter`],gradFunc:(e,t,n)=>{let[r,i]=t,{dilations:a,strides:o,pad:s,dataFormat:c}=n;return D(Nl(a),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`),{x:()=>fd(r.shape,e,i,o,s,c),filter:()=>Mv(r,e,i.shape,o,s,c)}}}})),dw,Tie=o((()=>{A(),sd(),Nv(),dw={kernelName:Rt,inputsToSave:[`dy`,`filter`],gradFunc:(e,t,n)=>{let[r,i]=t,{strides:a,pad:o,dataFormat:s,dimRoundingMode:c}=n;return{dy:()=>od(e,i,a,o,s,1,c),filter:()=>Mv(e,r,i.shape,a,o,s,c)}}}}));function Eie(e,t,n,r,i){let a=e;e.rank===4&&(a=W(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let o=t;o.rank===4&&(o=W(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),D(a.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`),D(o.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),D(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),D(a.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`),D(o.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${n[4]}).`);let s={x:a,dy:o},c={strides:r,pad:i,filterShape:n};return P.runKernel(Bt,s,c)}var fw,Die=o((()=>{F(),A(),j(),z(),G(),fw=R({conv3DBackpropFilter_:Eie})})),pw,Oie=o((()=>{A(),Die(),Sd(),Rl(),j(),pw={kernelName:zt,inputsToSave:[`x`,`filter`],gradFunc:(e,t,n)=>{let{dilations:r,strides:i,pad:a}=n;D(Nl(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);let[o,s]=t;return{x:()=>xd(o.shape,e,s,i,a),filter:()=>fw(o,e,s.shape,i,a)}}}})),mw,kie=o((()=>{A(),_c(),Nc(),xm(),t_(),mw={kernelName:`Cos`,inputsToSave:[`x`],gradFunc:(e,t)=>{let[n]=t;return{x:()=>U(bm(e_(V(n,`float32`))),e)}}}})),hw,Aie=o((()=>{A(),_c(),Nc(),r_(),hw={kernelName:Ht,inputsToSave:[`x`],gradFunc:(e,t)=>{let[n]=t;return{x:()=>U(n_(V(n,`float32`)),e)}}}})),gw,jie=o((()=>{A(),Vf(),Ld(),xv(),gw={kernelName:Wt,inputsToSave:[`x`],gradFunc:(e,t,n)=>{let[r]=t,{axis:i,exclusive:a,reverse:o}=n;return{x:()=>{let t=Rf([i],r.rank),n=Id(e,i,a,!o);return t!=null&&(n=bv(n,t)),n}}}}})),_w,Mie=o((()=>{A(),Rl(),Vv(),Uv(),j(),_w={kernelName:Jt,inputsToSave:[`x`,`filter`],gradFunc:(e,t,n)=>{let{dilations:r,strides:i,pad:a,dimRoundingMode:o}=n,s=r??[1,1];D(Nl(s),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[c,l]=t;return D(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${c.rank}.`),D(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`),D(c.shape[3]===l.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${c.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),D(Pl(i,s),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${i} and dilations '${s}'.`),Ll(`depthwiseConv2d`,a,o),{x:()=>Hv(c.shape,e,l,i,a,s,o),filter:()=>Bv(c,e,l.shape,i,a,s,o)}}}})),vw,Nie=o((()=>{F(),A(),vw={kernelName:Qt,inputsToSave:[`x`,`filter`],gradFunc:(e,t,n)=>{let[r,i]=t,a={x:r,filter:i,dy:e},o={x:r,filter:i,dy:e};return{x:()=>P.runKernel($t,a,n),filter:()=>P.runKernel(en,o,n)}}}})),yw,Pie=o((()=>{F(),A(),yw={kernelName:`Elu`,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,r={dy:e,y:n};return{x:()=>P.runKernel(an,r)}}}})),bw,Fie=o((()=>{A(),gp(),Nc(),xm(),ip(),bw={kernelName:`Erf`,inputsToSave:[`x`],gradFunc:(e,t)=>{let[n]=t,r=U(hp(bm(rp(n))),2/Math.sqrt(Math.PI));return{x:()=>U(e,r)}}}})),xw,Iie=o((()=>{A(),Nc(),xw={kernelName:`Exp`,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>U(e,n)}}}})),Sw,Lie=o((()=>{A(),G(),Sw={kernelName:sn,inputsToSave:[`input`],gradFunc:(e,t)=>{let[n]=t;return{input:()=>W(e,n.shape)}}}})),Cw,Rie=o((()=>{A(),gp(),Nc(),Cw={kernelName:cn,inputsToSave:[`x`],gradFunc:(e,t)=>{let[n]=t;return{x:()=>U(e,hp(n))}}}})),ww,zie=o((()=>{A(),mf(),ww={kernelName:dn,gradFunc:e=>({x:()=>pf(e)})}})),Tw,Bie=o((()=>{A(),rf(),_c(),jc(),Nc(),xm(),G(),ip(),op(),Tw={kernelName:fn,inputsToSave:[`a`,`b`],gradFunc:(e,t)=>{let[n,r]=t,i=nf(n.shape,r.shape);return{a:()=>{let t=Ac(e,V(r,`float32`)),a=tf(n.shape,i);return a.length>0?W(K(t,a),n.shape):t},b:()=>{let t=U(e,V(n,`float32`)),a=tf(r.shape,i);a.length>0&&(t=W(K(t,a),r.shape));let o=rp(r);return bm(Ac(t,V(o,`float32`)))}}}}})),Ew,Vie=o((()=>{A(),Tc(),rf(),Nc(),G(),Bg(),Qf(),km(),op(),Tp(),Ew={kernelName:pn,inputsToSave:[`x`,`mean`,`variance`,`scale`],gradFunc:(e,t,n)=>{let{varianceEpsilon:r}=n,[i,a,o,s]=t,c=s??Zf(1),l=tf(a.shape,i.shape),u=[];if(a.rank===1){for(let e=0;e<i.shape.length-1;++e)u.push(i.shape[e]);u.push(1)}let d=q(i,a),f=U(e,c),p=zg(H(o,Zf(r))),m=U(U(U(p,p),p),Zf(-.5));return{x:()=>a.rank===1?W(U(U(e,wp(W(p,[1,1,1,a.shape[0]]),u)),c),i.shape):W(U(U(e,p),c),i.shape),mean:()=>{let e=U(U(p,Zf(-1)),f);return a.rank===1&&(e=K(e,l)),W(e,a.shape)},variance:()=>{let e=U(U(m,d),f);return a.rank===1&&(e=K(e,l)),W(e,a.shape)},scale:()=>{let t=U(d,p),n=U(e,t);return a.rank===1&&(n=K(n,l)),W(n,a.shape)},offset:()=>{let t=e;return a.rank===1&&(t=K(t,l)),W(t,a.shape)}}}}}));function Dw(e,t){let n=[];for(let r=e;r<t;++r)n.push(r);return n}function Ow(e){let t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}var kw,Hie=o((()=>{A(),Vf(),G(),w_(),xv(),uv(),j(),kw={kernelName:mn,inputsToSave:[`x`,`indices`],gradFunc:(e,t,n)=>{let[r,i]=t,{axis:a,batchDims:o}=n,s=we(a,r.shape)[0],c=(e,t,n)=>()=>{let r=e.shape,i=t.size,o=r.slice(0,s),c=o.length,l=r.slice(a,r.length).slice(1),u=l.length,d=Dw(0,c),f=Dw(c+1,c+1+u),p=Ow([o,[i],l]),m=W(n,p),h=W(t,[i]),g=Ow([[c],d,f]),_=bv(m,g),v=lv(_,h,e.shape[s]),y=zf(g);return v=bv(v,y),v};if(o===1){let t=r.shape[0],n=r.split(t,0);return{x:()=>C_(n.map((t,n)=>c(t,i.slice(n,1),e.slice(n,1))())).reshape(r.shape),indices:()=>i}}else return{x:c(r,i,e),indices:()=>i}}}})),Aw,Uie=o((()=>{A(),mf(),Aw={kernelName:_n,inputsToSave:[`a`,`b`],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>pf(n),b:()=>pf(r)}}}})),jw,Wie=o((()=>{A(),_c(),jw={kernelName:vn,gradFunc:e=>({x:()=>V(e,`float32`)})}})),Mw,Gie=o((()=>{A(),mf(),Mw={kernelName:xn,gradFunc:e=>({x:()=>pf(e)})}})),Nw,Kie=o((()=>{A(),mf(),Nw={kernelName:Sn,gradFunc:e=>({x:()=>pf(e)})}})),Pw,qie=o((()=>{A(),mf(),Pw={kernelName:Cn,gradFunc:e=>({x:()=>pf(e)})}})),Fw,Jie=o((()=>{A(),Lp(),Nc(),df(),Fw={kernelName:wn,inputsToSave:[`x`],gradFunc:(e,t,n)=>{let[r]=t,{alpha:i}=n,a=Ip(r,0);return{x:()=>uf(a,e,U(e,i))}}}})),Iw,Yie=o((()=>{A(),Tc(),jc(),Iw={kernelName:On,inputsToSave:[`x`],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ac(e,H(n,1))}}}})),Lw,Xie=o((()=>{A(),_c(),jc(),Lw={kernelName:`Log`,inputsToSave:[`x`],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ac(e,V(n,`float32`))}}}})),Rw,Zie=o((()=>{A(),gp(),Nc(),km(),op(),Rw={kernelName:Nn,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{axis:i}=n;return{logits:()=>{let t=hp(r);return q(e,U(K(e,i,!0),t))}}}}}));function Qie(e,t,n,r=5,i=1,a=1,o=.5){let s={x:e,y:t,dy:n},c={depthRadius:r,bias:i,alpha:a,beta:o};return P.runKernel(Fn,s,c)}var zw,$ie=o((()=>{F(),A(),z(),zw=R({localResponseNormalizationBackprop_:Qie})})),Bw,eae=o((()=>{A(),$ie(),Bw={kernelName:`LRN`,inputsToSave:[`x`],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,i]=t,{depthRadius:a,bias:o,alpha:s,beta:c}=n;return{x:()=>zw(r,i,e,a,o,s,c)}}}}));function Vw(e,t,n,r){return t.rank<n.rank&&(t=W(t,If(t.shape,r))),e.rank<n.rank&&(e=W(e,If(e.shape,r))),{x:()=>U(e,V(sf(n,t),e.dtype))}}var Hw=o((()=>{Vf(),_c(),cf(),Nc(),G()})),Uw,tae=o((()=>{A(),j(),Hw(),Uw={kernelName:`Max`,inputsToSave:[`x`],outputsToSave:[!0],gradFunc:(e,t,n)=>{let{reductionIndices:r}=n,i=t[0],a=t[1],o=we(r,i.shape),s=Vw(e,a,i,o);return{x:()=>s.x()}}}})),Ww,nae=o((()=>{A(),_c(),Bp(),im(),Nc(),Ww={kernelName:Ln,inputsToSave:[`a`,`b`],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>U(e,V(zp(n,r),`float32`)),b:()=>U(e,V(rm(n,r),`float32`))}}}}));function rae(e,t,n,r,i,a,o){let s=I(e,`dy`,`maxPool3dGrad`),c=I(t,`input`,`maxPool3dGrad`),l=I(n,`output`,`maxPool3dGrad`),u=s,d=c,f=l,p=!1;c.rank===4&&(p=!0,u=W(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]]),d=W(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]]),f=W(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),D(u.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),D(d.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),D(f.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${f.rank}.`),Ll(`maxPool3dGrad`,a,o);let m={dy:u,input:d,output:f},h={filterSize:r,strides:i,pad:a,dimRoundingMode:o},g=P.runKernel(Vn,m,h);return p?W(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var Gw,iae=o((()=>{F(),A(),L(),j(),Rl(),z(),G(),Gw=R({maxPool3dGrad_:rae})})),Kw,aae=o((()=>{A(),iae(),Kw={kernelName:Bn,inputsToSave:[`x`],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,i]=t,{filterSize:a,strides:o,pad:s,dimRoundingMode:c}=n;return{x:()=>Gw(e,r,i,a,o,s,c)}}}}));function oae(e,t,n,r,i,a,o){let s=I(e,`dy`,`maxPoolGrad`),c=I(t,`input`,`maxPoolGrad`),l=I(n,`output`,`maxPoolGrad`);D(c.rank===s.rank,()=>`Rank of input (${c.rank}) does not match rank of dy (${s.rank})`),D(s.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${s.rank}.`),D(c.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${c.rank}.`),Ll(`maxPoolGrad`,a,o);let u={dy:s,input:c,output:l},d={filterSize:r,strides:i,pad:a,dimRoundingMode:o};return P.runKernel(zn,u,d)}var qw,sae=o((()=>{F(),A(),L(),j(),Rl(),z(),qw=R({maxPoolGrad_:oae})})),Jw,cae=o((()=>{A(),sae(),Jw={kernelName:Rn,inputsToSave:[`x`],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,i]=t,{filterSize:a,strides:o,pad:s}=n;return{x:()=>qw(e,r,i,a,o,s)}}}})),Yw,lae=o((()=>{A(),Vf(),jc(),Nc(),ch(),G(),j(),Yw={kernelName:Un,inputsToSave:[`x`],gradFunc:(e,t,n)=>{let[r]=t,{axis:i}=n,a=we(i,r.shape),o=Ff(r.shape,a)[1],s=O(o);return{x:()=>{let t=r.shape.slice();a.forEach(e=>{t[e]=1});let n=W(e,t);return Ac(U(n,sh(r.shape,`float32`)),s)}}}}})),Xw,uae=o((()=>{A(),j(),Hw(),Xw={kernelName:`Min`,inputsToSave:[`x`],outputsToSave:[!0],gradFunc:(e,t,n)=>{let{axis:r}=n,[i,a]=t,o=we(r,i.shape),s=Vw(e,a,i,o);return{x:()=>s.x()}}}})),Zw,dae=o((()=>{A(),_c(),Lp(),sm(),Nc(),Zw={kernelName:Wn,inputsToSave:[`a`,`b`],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>U(e,V(om(n,r),`float32`)),b:()=>U(e,V(Ip(n,r),`float32`))}}}})),Qw,fae=o((()=>{A(),ru(),Qw={kernelName:Gn,inputsToSave:[`x`],gradFunc:(e,t,n)=>{let r=t[0],{paddings:i}=n,a=i.map(e=>e[0]);return{x:()=>nu(e,a,r.shape)}}}})),$w,pae=o((()=>{A(),rf(),jc(),jp(),Nc(),xm(),G(),op(),$w={kernelName:`Mod`,inputsToSave:[`a`,`b`],gradFunc:(e,t)=>{let[n,r]=t,i=nf(n.shape,r.shape);return{a:()=>{let t=tf(n.shape,i);return t.length>0?W(K(e,t),n.shape):e},b:()=>{let t=U(e,bm(Ap(Ac(n,r)))),a=tf(r.shape,i);return a.length>0?W(K(t,a),r.shape):t}}}}})),eT,mae=o((()=>{A(),rf(),_c(),Nc(),G(),op(),eT={kernelName:qn,inputsToSave:[`a`,`b`],gradFunc:(e,t)=>{let[n,r]=t,i=nf(n.shape,r.shape);return{a:()=>{let t=U(e,V(r,`float32`)),a=tf(n.shape,i);return a.length>0?W(K(t,a),n.shape):t},b:()=>{let t=U(e,V(n,`float32`)),a=tf(r.shape,i);return a.length>0?W(K(t,a),r.shape):t}}}}})),tT,hae=o((()=>{A(),xm(),tT={kernelName:`Neg`,gradFunc:e=>({x:()=>bm(e)})}})),nT,gae=o((()=>{A(),oh(),nT={kernelName:$n,inputsToSave:[`indices`],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>ah(n.shape,`float32`)}}}})),rT,_ae=o((()=>{A(),mf(),rT={kernelName:Qn,gradFunc:e=>({x:()=>pf(e)})}})),iT,vae=o((()=>{A(),fv(),iT={kernelName:er,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:r}=n;return dv(e,r).map(e=>()=>e)}}})),aT,yae=o((()=>{A(),ru(),aT={kernelName:tr,inputsToSave:[`x`],gradFunc:(e,t,n)=>{let r=t[0],{paddings:i}=n,a=i.map(e=>e[0]);return{x:()=>nu(e,a,r.shape)}}}})),oT,bae=o((()=>{A(),rf(),_c(),Lp(),fm(),Nc(),Xf(),G(),Qf(),km(),op(),df(),mf(),oT={kernelName:`Pow`,inputsToSave:[`a`,`b`],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,r,i]=t,a=n,o=r,s=nf(a.shape,o.shape);return{a:()=>{let t=V(o,`float32`),n=U(e,U(t,Yf(a,q(t,Zf(1))))),r=tf(a.shape,s);return r.length>0&&(n=K(n,r)),W(n,a.shape)},b:()=>{let t=Ip(a,0),n=uf(t,dm(a),pf(a)),r=U(e,U(i,n)),c=tf(o.shape,s);return c.length>0&&(r=K(r,c)),W(r,o.shape)}}}}})),sT,xae=o((()=>{A(),rf(),Lp(),Nc(),G(),op(),df(),mf(),sT={kernelName:rr,inputsToSave:[`x`,`alpha`],gradFunc:(e,t)=>{let[n,r]=t,i=Ip(n,0);return{x:()=>uf(i,e,U(e,r)),alpha:()=>{let t=uf(i,pf(e),U(e,n)),a=tf(r.shape,e.shape);return a.length>0&&(t=K(t,a)),W(t,r.shape)}}}}}));function Sae(e,t,n){let r=e.shape.slice();r[n]=1;let i=W(t,r),a=Nd(e,n,!0,!1),o=Nd(e,n,!0,!0),s=U(a,o);return U(i,s)}function Cae(e,t,n){let r=e.shape.length,i=r-n.length,a=Rf(n,r),o=e;a!=null&&(o=bv(e,a));let s=o.shape.slice(),c=s.splice(r-n.length,n.length).reduce((e,t)=>e*t,1);s.push(c);let l=o.reshape(s),u=Sae(l,t,i);if(u=u.reshape(o.shape),a!=null){let e=zf(a);u=bv(u,e)}return u}var cT,wae=o((()=>{OC(),A(),Pd(),Nc(),G(),xv(),cT={kernelName:ir,inputsToSave:[`x`],gradFunc:(e,t,n)=>{let[r]=t,{axis:i}=n,a=[];return a=i==null?r.shape.map((e,t)=>t):typeof i==`number`?[i]:i,{x:()=>Cae(r,e,a)}}}})),lT,Tae=o((()=>{A(),rf(),_c(),jc(),Nc(),xm(),G(),ip(),op(),lT={kernelName:nn,inputsToSave:[`a`,`b`],gradFunc:(e,t)=>{let[n,r]=t,i=nf(n.shape,r.shape);return{a:()=>{let t=Ac(e,V(r,`float32`)),a=tf(n.shape,i);return a.length>0?W(K(t,a),n.shape):t},b:()=>{let t=U(e,V(n,`float32`)),a=tf(r.shape,i);a.length>0&&(t=W(K(t,a),r.shape));let o=rp(r);return bm(Ac(t,V(o,`float32`)))}}}}})),uT,Eae=o((()=>{A(),jc(),xm(),ip(),uT={kernelName:ur,inputsToSave:[`x`],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ac(e,bm(rp(n)))}}}})),dT,Dae=o((()=>{A(),_c(),sm(),Nc(),D_(),dT={kernelName:_r,inputsToSave:[`x`],gradFunc:(e,t)=>{let[n]=t,r=U(om(n,6),E_(n));return{x:()=>U(e,V(r,`float32`))}}}})),fT,Oae=o((()=>{A(),_c(),Nc(),D_(),fT={kernelName:dr,inputsToSave:[`x`],gradFunc:(e,t)=>{let[n]=t;return{x:()=>U(e,V(E_(n),`float32`))}}}})),pT,kae=o((()=>{A(),G(),pT={kernelName:fr,inputsToSave:[`x`],gradFunc:(e,t)=>{let[n]=t;return{x:()=>W(e,n.shape)}}}})),mT,Aae=o((()=>{F(),A(),mT={kernelName:hr,inputsToSave:[`images`],gradFunc:(e,t,n)=>{let[r]=t,i={dy:e,images:r};return{images:()=>P.runKernel(gr,i,n)}}}})),hT,jae=o((()=>{F(),A(),hT={kernelName:pr,inputsToSave:[`images`],gradFunc:(e,t,n)=>{let[r]=t,i={dy:e,images:r};return{images:()=>P.runKernel(mr,i,n)}}}})),gT,Mae=o((()=>{A(),jg(),j(),gT={kernelName:vr,gradFunc:(e,t,n)=>{let{dims:r}=n,i=we(r,e.shape);return{x:()=>Ag(e,i)}}}})),_T,Nae=o((()=>{A(),mf(),_T={kernelName:yr,gradFunc:e=>({x:()=>pf(e)})}})),vT,Pae=o((()=>{A(),jc(),Nc(),xm(),Xf(),vT={kernelName:br,inputsToSave:[`x`],gradFunc:(e,t)=>{let[n]=t;return{x:()=>bm(Ac(e,U(Yf(n,1.5),2)))}}}})),yT,Fae=o((()=>{A(),_c(),Vm(),Nc(),mf(),yT={kernelName:wr,inputsToSave:[`condition`],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>V(pf(n),`float32`),t:()=>U(e,V(n,e.dtype)),e:()=>U(e,V(Bm(n),e.dtype))}}}})),bT,Iae=o((()=>{A(),_c(),gp(),Lp(),Nc(),Qf(),IS(),df(),bT={kernelName:Tr,inputsToSave:[`x`],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=Ip(n,Zf(0)),r=Zf(PS),i=Zf(FS),a=U(e,i),o=U(U(e,r),hp(V(n,`float32`)));return uf(t,a,o)}}}}})),xT,Lae=o((()=>{A(),Nc(),Qf(),km(),xT={kernelName:kr,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>U(e,U(n,q(Zf(1),n)))}}}})),ST,Rae=o((()=>{A(),mf(),ST={kernelName:Or,gradFunc:e=>({x:()=>pf(e)})}})),CT,zae=o((()=>{A(),_c(),Od(),Nc(),CT={kernelName:`Sin`,inputsToSave:[`x`],gradFunc:(e,t)=>{let[n]=t;return{x:()=>U(Dd(V(n,`float32`)),e)}}}})),wT,Bae=o((()=>{A(),_c(),jd(),Nc(),wT={kernelName:Dr,inputsToSave:[`x`],gradFunc:(e,t)=>{let[n]=t;return{x:()=>U(Ad(V(n,`float32`)),e)}}}})),TT,Vae=o((()=>{A(),jh(),fS(),TT={kernelName:Er,inputsToSave:[`x`],gradFunc:(e,t,n)=>{let[r]=t,{begin:i,size:a}=n,o=r.shape,[s,c]=sS(r,i,a),l=[];for(let t=0;t<e.rank;t++)l.push([s[t],o[t]-s[t]-c[t]]);return{x:()=>Ah(e,l)}}}})),ET,Hae=o((()=>{A(),Nc(),km(),op(),ET={kernelName:Pr,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{dim:i}=n,a=U(e,r);return{logits:()=>q(a,U(K(a,[i],!0),r))}}}})),DT,Uae=o((()=>{A(),Nc(),eu(),DT={kernelName:Ar,inputsToSave:[`x`],gradFunc:(e,t)=>{let[n]=t;return{x:()=>U(e,$l(n))}}}})),OT,Wae=o((()=>{A(),fu(),OT={kernelName:Mr,gradFunc:(e,t,n)=>{let{blockShape:r,paddings:i}=n;return{x:()=>du(e,r,i)}}}})),kT,Gae=o((()=>{A(),Jl(),kT={kernelName:Nr,gradFunc:(e,t,n)=>{let{axis:r}=n;return{x:()=>ql(e,r)}}}})),AT,Kae=o((()=>{A(),_c(),jc(),Nc(),tp(),AT={kernelName:jr,inputsToSave:[`x`],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ac(e,U(ep(V(n,`float32`)),2))}}}})),jT,qae=o((()=>{A(),_c(),Nc(),jT={kernelName:Vr,inputsToSave:[`x`],gradFunc:(e,t)=>{let[n]=t;return{x:()=>U(e,U(V(n,`float32`),2))}}}})),MT,Jae=o((()=>{A(),Nc(),Qf(),km(),MT={kernelName:Br,inputsToSave:[`a`,`b`],gradFunc:(e,t)=>{let[n,r]=t,i=Zf(2);return{a:()=>U(e,U(i,q(n,r))),b:()=>U(e,U(i,q(r,n)))}}}})),NT,Yae=o((()=>{A(),mf(),NT={kernelName:ri,gradFunc:e=>({x:()=>pf(e)})}})),PT,Xae=o((()=>{A(),rf(),xm(),G(),op(),PT={kernelName:`Sub`,inputsToSave:[`a`,`b`],gradFunc:(e,t)=>{let[n,r]=t,i=nf(n.shape,r.shape);return{a:()=>{let t=e,r=tf(n.shape,i);return r.length>0&&(t=K(t,r)),W(t,n.shape)},b:()=>{let t=e,n=tf(r.shape,i);return n.length>0&&(t=K(t,n)),W(bm(t),r.shape)}}}}})),FT,Zae=o((()=>{A(),Nc(),ch(),G(),j(),FT={kernelName:`Sum`,inputsToSave:[`x`],gradFunc:(e,t,n)=>{let[r]=t,i=r.shape.slice(),{axis:a}=n;we(a,r.shape).forEach(e=>{i[e]=1});let o=W(e,i),s=U(o,sh(r.shape,`float32`));return{x:()=>s}}}})),IT,Qae=o((()=>{A(),Od(),jc(),ip(),IT={kernelName:`Tan`,inputsToSave:[`x`],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ac(e,rp(Dd(n)))}}}})),LT,$ae=o((()=>{A(),Nc(),Qf(),ip(),km(),LT={kernelName:qr,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>U(q(Zf(1),rp(n)),e)}}}})),RT,eoe=o((()=>{A(),Tc(),ru(),mf(),RT={kernelName:Jr,inputsToSave:[`x`],gradFunc:(e,t,n)=>{let[r]=t,{reps:i}=n;return{x:()=>{let t=pf(r);if(r.rank===1)for(let n=0;n<i[0];++n)t=H(t,nu(e,[n*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let n=0;n<i[0];++n)for(let a=0;a<i[1];++a)t=H(t,nu(e,[n*r.shape[0],a*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let n=0;n<i[0];++n)for(let a=0;a<i[1];++a)for(let o=0;o<i[2];++o)t=H(t,nu(e,[n*r.shape[0],a*r.shape[1],o*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let n=0;n<i[0];++n)for(let a=0;a<i[1];++a)for(let o=0;o<i[2];++o)for(let s=0;s<i[3];++s)t=H(t,nu(e,[n*r.shape[0],a*r.shape[1],o*r.shape[2],s*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return t}}}}})),zT,toe=o((()=>{A(),Vf(),xv(),zT={kernelName:Zr,gradFunc:(e,t,n)=>{let{perm:r}=n,i=zf(r);return{x:()=>bv(e,i)}}}})),BT,noe=o((()=>{A(),w_(),BT={kernelName:$r,gradFunc:(e,t,n)=>{let{axis:r}=n;return{value:()=>C_(e,r)}}}}));function roe(e,t){let n=th(t,pf(t)),r=Np(e,n),i=zp(t,Zf(0,`int32`)),a=r.rank-i.rank;for(let e=0;e<a;++e)i=vp(i,e+1);i=Lm(i,sh(r.shape,`bool`));let o=pf(r);return uf(i,r,o)}var VT,ioe=o((()=>{A(),yp(),Pp(),Bp(),Rm(),nh(),ch(),Qf(),df(),mf(),VT={kernelName:ei,inputsToSave:[`segmentIds`],gradFunc:(e,t)=>{let[n]=t;return{x:()=>roe(e,n)}}}})),HT,aoe=o((()=>{A(),mf(),HT={kernelName:ni,gradFunc:e=>({x:()=>pf(e)})}})),UT,WT=o((()=>{AC(),MC(),PC(),IC(),RC(),BC(),HC(),WC(),KC(),JC(),XC(),lie(),fie(),hie(),gie(),_ie(),vie(),yie(),bie(),xie(),Sie(),Cie(),wie(),Tie(),Oie(),kie(),Aie(),jie(),Mie(),Nie(),Pie(),Fie(),Iie(),Lie(),Rie(),zie(),Bie(),Vie(),Hie(),Uie(),Wie(),Gie(),Kie(),qie(),Jie(),Yie(),Xie(),Zie(),eae(),tae(),nae(),aae(),cae(),lae(),uae(),dae(),fae(),pae(),mae(),hae(),gae(),_ae(),vae(),yae(),bae(),xae(),wae(),Tae(),Eae(),Dae(),Oae(),kae(),Aae(),jae(),Mae(),Nae(),Pae(),Fae(),Iae(),Lae(),Rae(),zae(),Bae(),Vae(),Hae(),Uae(),Wae(),Gae(),Kae(),qae(),Jae(),Yae(),Xae(),Zae(),Qae(),$ae(),eoe(),toe(),noe(),ioe(),aoe(),Ci(),UT=[kC,jC,NC,FC,LC,zC,VC,UC,GC,qC,YC,ZC,$C,tw,nw,rw,iw,aw,ow,sw,cw,lw,dw,uw,pw,mw,hw,gw,_w,vw,lT,yw,bw,xw,Sw,Cw,Tw,ww,Ew,kw,Aw,jw,Mw,Nw,Pw,Fw,Iw,Lw,Rw,Bw,Uw,Uw,Ww,Kw,Jw,Yw,Xw,Zw,Qw,$w,eT,tT,nT,rT,iT,aT,aT,oT,sT,cT,uT,dT,fT,pT,mT,hT,gT,_T,vT,yT,bT,xT,ST,CT,wT,TT,ET,DT,OT,OT,kT,kT,AT,MT,jT,NT,PT,FT,IT,LT,RT,zT,BT,VT,HT];for(let e of UT)gi(e)})),ooe=o((()=>{Sb(),N(),M().prototype.abs=function(){return this.throwIfDisposed(),Fc(this)}})),soe=o((()=>{Sb(),N(),M().prototype.acos=function(){return this.throwIfDisposed(),Rc(this)}})),coe=o((()=>{Sb(),N(),M().prototype.acosh=function(){return this.throwIfDisposed(),Vc(this)}})),loe=o((()=>{Tc(),N(),M().prototype.add=function(e){return this.throwIfDisposed(),H(this,e)}})),uoe=o((()=>{Jc(),N(),M().prototype.all=function(e,t){return this.throwIfDisposed(),qc(this,e,t)}})),doe=o((()=>{Zc(),N(),M().prototype.any=function(e,t){return this.throwIfDisposed(),Xc(this,e,t)}})),foe=o((()=>{el(),N(),M().prototype.argMax=function(e){return this.throwIfDisposed(),$c(this,e)}})),poe=o((()=>{rl(),N(),M().prototype.argMin=function(e){return this.throwIfDisposed(),nl(this,e)}})),moe=o((()=>{G(),N(),j(),M().prototype.asScalar=function(){return this.throwIfDisposed(),D(this.size===1,()=>`The array must have only 1 element.`),W(this,[])}})),hoe=o((()=>{Sb(),N(),M().prototype.asType=function(e){return this.throwIfDisposed(),V(this,e)}})),goe=o((()=>{G(),N(),M().prototype.as1D=function(){return this.throwIfDisposed(),W(this,[this.size])}})),_oe=o((()=>{G(),N(),M().prototype.as2D=function(e,t){return this.throwIfDisposed(),W(this,[e,t])}})),voe=o((()=>{G(),N(),M().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),W(this,[e,t,n])}})),yoe=o((()=>{G(),N(),M().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),W(this,[e,t,n,r])}})),boe=o((()=>{G(),N(),M().prototype.as5D=function(e,t,n,r,i){return this.throwIfDisposed(),W(this,[e,t,n,r,i])}})),xoe=o((()=>{Sb(),N(),M().prototype.asin=function(){return this.throwIfDisposed(),al(this)}})),Soe=o((()=>{Sb(),N(),M().prototype.asinh=function(){return this.throwIfDisposed(),cl(this)}})),Coe=o((()=>{Sb(),N(),M().prototype.atan=function(){return this.throwIfDisposed(),dl(this)}})),woe=o((()=>{hl(),N(),M().prototype.atan2=function(e){return this.throwIfDisposed(),ml(this,e)}})),Toe=o((()=>{Sb(),N(),M().prototype.atanh=function(){return this.throwIfDisposed(),_l(this)}})),Eoe=o((()=>{Hl(),N(),M().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),Vl(this,e,t,n,r)}})),Doe=o((()=>{fu(),N(),M().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),du(this,e,t)}})),Ooe=o((()=>{_u(),N(),M().prototype.batchNorm=function(e,t,n,r,i){return this.throwIfDisposed(),gu(this,e,t,n,r,i)}})),koe=o((()=>{Ru(),N(),M().prototype.broadcastTo=function(e){return this.throwIfDisposed(),Lu(this,e)}})),Aoe=o((()=>{Sb(),N(),M().prototype.cast=function(e){return this.throwIfDisposed(),V(this,e)}})),joe=o((()=>{Sb(),N(),M().prototype.ceil=function(){return this.throwIfDisposed(),Bu(this)}})),Moe=o((()=>{Sb(),N(),M().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),Gu(this,e,t)}})),Noe=o((()=>{Jl(),N(),M().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof wa&&(e=[e]),ql([this,...e],t)}})),Poe=o((()=>{ud(),N(),M().prototype.conv1d=function(e,t,n,r,i,a){return this.throwIfDisposed(),ld(this,e,t,n,r,i,a)}})),Foe=o((()=>{gd(),N(),M().prototype.conv2dTranspose=function(e,t,n,r,i){return this.throwIfDisposed(),hd(this,e,t,n,r,i)}})),Ioe=o((()=>{sd(),N(),M().prototype.conv2d=function(e,t,n,r,i,a){return this.throwIfDisposed(),od(this,e,t,n,r,i,a)}})),Loe=o((()=>{Sb(),N(),M().prototype.cos=function(){return this.throwIfDisposed(),Dd(this)}})),Roe=o((()=>{Sb(),N(),M().prototype.cosh=function(){return this.throwIfDisposed(),Ad(this)}})),zoe=o((()=>{Pd(),N(),M().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),Nd(this,e,t,n)}})),Boe=o((()=>{Ld(),N(),M().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),Id(this,e,t,n)}})),Voe=o((()=>{Ud(),N(),M().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),Hd(this,e,t)}})),Hoe=o((()=>{Kd(),N(),M().prototype.depthwiseConv2d=function(e,t,n,r,i,a){return this.throwIfDisposed(),Gd(this,e,t,n,r,i,a)}})),Uoe=o((()=>{Qd(),N(),M().prototype.dilation2d=function(e,t,n,r,i){return this.throwIfDisposed(),Zd(this,e,t,n,r,i)}})),Woe=o((()=>{_f(),N(),M().prototype.divNoNan=function(e){return this.throwIfDisposed(),gf(this,e)}})),Goe=o((()=>{jc(),N(),M().prototype.div=function(e){return this.throwIfDisposed(),Ac(this,e)}})),Koe=o((()=>{bf(),N(),M().prototype.dot=function(e){return this.throwIfDisposed(),yf(this,e)}})),qoe=o((()=>{Ef(),N(),M().prototype.elu=function(){return this.throwIfDisposed(),Tf(this)}})),Joe=o((()=>{cf(),N(),M().prototype.equal=function(e){return this.throwIfDisposed(),sf(this,e)}})),Yoe=o((()=>{Sb(),N(),M().prototype.erf=function(){return this.throwIfDisposed(),jf(this)}})),Xoe=o((()=>{pp(),N(),M().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),fp(this,e,t)}})),Zoe=o((()=>{Sb(),N(),M().prototype.exp=function(){return this.throwIfDisposed(),hp(this)}})),Qoe=o((()=>{yp(),N(),M().prototype.expandDims=function(e){return this.throwIfDisposed(),vp(this,e)}})),$oe=o((()=>{Sb(),N(),M().prototype.expm1=function(){return this.throwIfDisposed(),xp(this)}})),ese=o((()=>{Sb(),N(),M().prototype.fft=function(){return this.throwIfDisposed(),u_(this)}})),tse=o((()=>{G(),N(),M().prototype.flatten=function(){return this.throwIfDisposed(),W(this,[this.size])}})),nse=o((()=>{Sb(),N(),M().prototype.floor=function(){return this.throwIfDisposed(),Ap(this)}})),rse=o((()=>{Oc(),N(),M().prototype.floorDiv=function(e){return this.throwIfDisposed(),Dc(this,e)}})),ise=o((()=>{Pp(),N(),M().prototype.gather=function(e,t,n){return this.throwIfDisposed(),Np(this,e,t,n)}})),ase=o((()=>{Bp(),N(),M().prototype.greaterEqual=function(e){return this.throwIfDisposed(),zp(this,e)}})),ose=o((()=>{Lp(),N(),M().prototype.greater=function(e){return this.throwIfDisposed(),Ip(this,e)}})),sse=o((()=>{Sb(),N(),M().prototype.ifft=function(){return this.throwIfDisposed(),f_(this)}})),cse=o((()=>{Sb(),N(),M().prototype.irfft=function(){return this.throwIfDisposed(),m_(this)}})),lse=o((()=>{Sb(),N(),M().prototype.isFinite=function(){return this.throwIfDisposed(),Gp(this)}})),use=o((()=>{Sb(),N(),M().prototype.isInf=function(){return this.throwIfDisposed(),Jp(this)}})),dse=o((()=>{Sb(),N(),M().prototype.isNaN=function(){return this.throwIfDisposed(),Zp(this)}})),fse=o((()=>{tm(),N(),M().prototype.leakyRelu=function(e){return this.throwIfDisposed(),em(this,e)}})),pse=o((()=>{sm(),N(),M().prototype.lessEqual=function(e){return this.throwIfDisposed(),om(this,e)}})),mse=o((()=>{im(),N(),M().prototype.less=function(e){return this.throwIfDisposed(),rm(this,e)}})),hse=o((()=>{um(),N(),M().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),lm(this,e,t,n,r)}})),gse=o((()=>{Sb(),N(),M().prototype.logSigmoid=function(){return this.throwIfDisposed(),Em(this)}})),_se=o((()=>{Sb(),N(),M().prototype.logSoftmax=function(e){return this.throwIfDisposed(),jm(this,e)}})),vse=o((()=>{Fm(),N(),M().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),Pm(this,e,t)}})),GT=o((()=>{Sb(),N(),M().prototype.log=function(){return this.throwIfDisposed(),dm(this)}})),KT=o((()=>{Sb(),N(),M().prototype.log1p=function(){return this.throwIfDisposed(),pm(this)}})),qT=o((()=>{Rm(),N(),M().prototype.logicalAnd=function(e){return this.throwIfDisposed(),Lm(this,e)}})),JT=o((()=>{Vm(),N(),M().prototype.logicalNot=function(){return this.throwIfDisposed(),Bm(this)}})),YT=o((()=>{Wm(),N(),M().prototype.logicalOr=function(e){return this.throwIfDisposed(),Um(this,e)}})),XT=o((()=>{Km(),N(),M().prototype.logicalXor=function(e){return this.throwIfDisposed(),Gm(this,e)}})),ZT=o((()=>{Zl(),N(),M().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),Xl(this,e,t,n)}})),QT=o((()=>{Qm(),N(),M().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),Zm(this,e,t,n,r)}})),$T=o((()=>{Wf(),N(),M().prototype.max=function(e,t){return this.throwIfDisposed(),Uf(this,e,t)}})),eE=o((()=>{nh(),N(),M().prototype.maximum=function(e){return this.throwIfDisposed(),th(this,e)}})),tE=o((()=>{ih(),N(),M().prototype.mean=function(e,t){return this.throwIfDisposed(),rh(this,e,t)}})),nE=o((()=>{qf(),N(),M().prototype.min=function(e,t){return this.throwIfDisposed(),Kf(this,e,t)}})),rE=o((()=>{dh(),N(),M().prototype.minimum=function(e){return this.throwIfDisposed(),uh(this,e)}})),iE=o((()=>{ph(),N(),M().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),fh(this,e,t)}})),aE=o((()=>{hh(),N(),M().prototype.mod=function(e){return this.throwIfDisposed(),mh(this,e)}})),oE=o((()=>{Nc(),N(),M().prototype.mul=function(e){return this.throwIfDisposed(),U(this,e)}})),sE=o((()=>{Sb(),N(),M().prototype.neg=function(){return this.throwIfDisposed(),bm(this)}})),cE=o((()=>{Sb(),N(),M().prototype.norm=function(e,t,n){return this.throwIfDisposed(),lp(this,e,t,n)}})),lE=o((()=>{bh(),N(),M().prototype.notEqual=function(e){return this.throwIfDisposed(),yh(this,e)}})),uE=o((()=>{Sh(),N(),M().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),xh(this,e,t,n)}})),dE=o((()=>{Sb(),N(),M().prototype.onesLike=function(){return this.throwIfDisposed(),wh(this)}})),fE=o((()=>{jh(),N(),M().prototype.pad=function(e,t){return this.throwIfDisposed(),Ah(this,e,t)}})),pE=o((()=>{Wh(),N(),M().prototype.pool=function(e,t,n,r,i,a){return this.throwIfDisposed(),Uh(this,e,t,n,r,i,a)}})),mE=o((()=>{Xf(),N(),M().prototype.pow=function(e){return this.throwIfDisposed(),Yf(this,e)}})),hE=o((()=>{Kh(),N(),M().prototype.prelu=function(e){return this.throwIfDisposed(),Gh(this,e)}})),gE=o((()=>{Jh(),N(),M().prototype.prod=function(e,t){return this.throwIfDisposed(),qh(this,e,t)}})),_E=o((()=>{Sb(),N(),M().prototype.reciprocal=function(){return this.throwIfDisposed(),Sg(this)}})),vE=o((()=>{Eg(),N(),M().prototype.relu=function(){return this.throwIfDisposed(),Tg(this)}})),yE=o((()=>{Og(),N(),M().prototype.relu6=function(){return this.throwIfDisposed(),Dg(this)}})),bE=o((()=>{G(),N(),M().prototype.reshapeAs=function(e){return this.throwIfDisposed(),W(this,e.shape)}})),xE=o((()=>{G(),N(),M().prototype.reshape=function(e){return this.throwIfDisposed(),W(this,e)}})),SE=o((()=>{yy(),N(),M().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),vy(this,e,t,n)}})),CE=o((()=>{xy(),N(),M().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),by(this,e,t,n)}})),wE=o((()=>{jg(),N(),M().prototype.reverse=function(e){return this.throwIfDisposed(),Ag(this,e)}})),TE=o((()=>{Sb(),N(),M().prototype.rfft=function(){return this.throwIfDisposed(),__(this)}})),EE=o((()=>{Sb(),N(),M().prototype.round=function(){return this.throwIfDisposed(),Lg(this)}})),DE=o((()=>{Sb(),N(),M().prototype.rsqrt=function(){return this.throwIfDisposed(),zg(this)}})),OE=o((()=>{Ug(),N(),M().prototype.selu=function(){return this.throwIfDisposed(),Hg(this)}})),kE=o((()=>{Kg(),N(),M().prototype.separableConv2d=function(e,t,n,r,i,a){return this.throwIfDisposed(),Gg(this,e,t,n,r,i,a)}})),AE=o((()=>{Sb(),N(),M().prototype.sigmoid=function(){return this.throwIfDisposed(),$l(this)}})),jE=o((()=>{Sb(),N(),M().prototype.sign=function(){return this.throwIfDisposed(),Zg(this)}})),ME=o((()=>{Sb(),N(),M().prototype.sin=function(){return this.throwIfDisposed(),e_(this)}})),NE=o((()=>{Sb(),N(),M().prototype.sinh=function(){return this.throwIfDisposed(),n_(this)}})),PE=o((()=>{Sb(),N(),M().prototype.slice=function(e,t){return this.throwIfDisposed(),nu(this,e,t)}})),FE=o((()=>{Sb(),N(),M().prototype.softmax=function(e){return this.throwIfDisposed(),c_(this,e)}})),IE=o((()=>{Sb(),N(),M().prototype.softplus=function(){return this.throwIfDisposed(),Cm(this)}})),LE=o((()=>{Hh(),N(),M().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),Vh(this,e,t)}})),RE=o((()=>{g_(),N(),M().prototype.split=function(e,t){return this.throwIfDisposed(),h_(this,e,t)}})),zE=o((()=>{Sb(),N(),M().prototype.sqrt=function(){return this.throwIfDisposed(),ep(this)}})),BE=o((()=>{Sb(),N(),M().prototype.square=function(){return this.throwIfDisposed(),rp(this)}})),VE=o((()=>{b_(),N(),M().prototype.squaredDifference=function(e){return this.throwIfDisposed(),y_(this,e)}})),HE=o((()=>{S_(),N(),M().prototype.squeeze=function(e){return this.throwIfDisposed(),x_(this,e)}})),UE=o((()=>{w_(),N(),M().prototype.stack=function(e,t){this.throwIfDisposed();let n=e instanceof wa?[this,e]:[this,...e];return C_(n,t)}})),WE=o((()=>{Sb(),N(),M().prototype.step=function(e){return this.throwIfDisposed(),E_(this,e)}})),GE=o((()=>{Sb(),N(),M().prototype.stridedSlice=function(e,t,n,r,i,a,o,s){return this.throwIfDisposed(),k_(this,e,t,n,r,i,a,o,s)}})),KE=o((()=>{km(),N(),M().prototype.sub=function(e){return this.throwIfDisposed(),q(this,e)}})),qE=o((()=>{op(),N(),M().prototype.sum=function(e,t){return this.throwIfDisposed(),K(this,e,t)}})),yse=o((()=>{Sb(),N(),M().prototype.tan=function(){return this.throwIfDisposed(),M_(this)}})),bse=o((()=>{Sb(),N(),M().prototype.tanh=function(){return this.throwIfDisposed(),au(this)}})),xse=o((()=>{Tp(),N(),M().prototype.tile=function(e){return this.throwIfDisposed(),wp(this,e)}})),Sse=o((()=>{Sb(),N(),M().prototype.toBool=function(){return this.throwIfDisposed(),V(this,`bool`)}})),Cse=o((()=>{Sb(),N(),M().prototype.toFloat=function(){return this.throwIfDisposed(),V(this,`float32`)}})),wse=o((()=>{Sb(),N(),M().prototype.toInt=function(){return this.throwIfDisposed(),V(this,`int32`)}})),Tse=o((()=>{nv(),N(),M().prototype.topk=function(e,t){return this.throwIfDisposed(),tv(this,e,t)}})),Ese=o((()=>{xv(),N(),M().prototype.transpose=function(e){return this.throwIfDisposed(),bv(this,e)}})),Dse=o((()=>{cv(),N(),M().prototype.unique=function(e){return this.throwIfDisposed(),sv(this,e)}})),Ose=o((()=>{uv(),N(),M().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),lv(this,e,t)}})),kse=o((()=>{fv(),N(),M().prototype.unstack=function(e){return this.throwIfDisposed(),dv(this,e)}})),Ase=o((()=>{df(),N(),M().prototype.where=function(e,t){return this.throwIfDisposed(),uf(e,this,t)}})),jse=o((()=>{Sb(),N(),M().prototype.zerosLike=function(){return this.throwIfDisposed(),pf(this)}})),Mse=o((()=>{ooe(),soe(),coe(),loe(),uoe(),doe(),foe(),poe(),moe(),hoe(),goe(),_oe(),voe(),yoe(),boe(),xoe(),Soe(),Coe(),woe(),Toe(),Eoe(),Doe(),Ooe(),koe(),Aoe(),joe(),Moe(),Noe(),Poe(),Foe(),Ioe(),Loe(),Roe(),zoe(),Boe(),Voe(),Hoe(),Uoe(),Woe(),Goe(),Koe(),qoe(),Joe(),Yoe(),Xoe(),Zoe(),Qoe(),$oe(),ese(),tse(),nse(),rse(),ise(),ase(),ose(),sse(),cse(),lse(),use(),dse(),fse(),pse(),mse(),hse(),gse(),_se(),vse(),GT(),KT(),qT(),JT(),YT(),XT(),ZT(),QT(),$T(),eE(),tE(),nE(),rE(),iE(),aE(),oE(),sE(),cE(),lE(),uE(),dE(),fE(),pE(),mE(),hE(),gE(),_E(),vE(),yE(),bE(),xE(),SE(),CE(),wE(),TE(),EE(),DE(),OE(),kE(),AE(),jE(),ME(),NE(),PE(),FE(),IE(),LE(),RE(),zE(),BE(),VE(),HE(),UE(),WE(),GE(),KE(),qE(),yse(),bse(),xse(),Sse(),Cse(),wse(),Tse(),Ese(),Dse(),Ose(),kse(),Ase(),jse()})),JE,YE,X,XE,ZE,QE=o((()=>{JE=class e extends Error{constructor(t){super(t),Object.setPrototypeOf(this,e.prototype)}},YE=class e extends Error{constructor(t){super(t),Object.setPrototypeOf(this,e.prototype)}},X=class e extends Error{constructor(t){super(t),Object.setPrototypeOf(this,e.prototype)}},XE=class e extends Error{constructor(t){super(t),Object.setPrototypeOf(this,e.prototype)}},ZE=class e extends Error{constructor(t){super(t),Object.setPrototypeOf(this,e.prototype)}}})),$E,Nse=o((()=>{$E=class{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}}}));function eD(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}else{let n=Array(t);return n.fill(e),n}}function tD(e,t){if(!e)throw new ZE(t)}function nD(e,t){let n=0;for(let r of e)r===t&&n++;return n}function rD(e){return e.length===1?e[0]:e}function iD(e){return Array.isArray(e)?e:[e]}function aD(e){let t=e.replace(/(.)([A-Z][a-z0-9]+)/g,`$1_$2`).replace(/([a-z])([A-Z])/g,`$1_$2`).toLowerCase();return t[0]===`_`?`private`+t:t}function oD(e){return e.length<=1||e.indexOf(`_`)===-1?e:e.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}function sD(e){if(e==null)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function cD(e){if(!(typeof e!=`object`||!e))if(Array.isArray(e))e.forEach(e=>cD(e));else{let t=Object.keys(e);for(let n of t){let t=e[n];typeof t==`object`&&t&&(!Array.isArray(t)&&t.type===`ndarray`&&typeof t.value==`number`?e[n]=t.value:cD(t))}}}function lD(e,t={},n={},r=`object`,i=!1){if(typeof e==`string`){let i=e,a;if(i in n)a=n[i];else if(i in _D)a=_D[i];else if(a=t[i],a==null)throw new X(`Unknown ${r}: ${e}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}else{let a=e;if(a.className==null||a.config==null)throw new X(`${r}: Improper config format: ${JSON.stringify(a)}.\n'className' and 'config' must set.`);let o=a.className,s,c;if(o in n?[s,c]=n[o]:o in _D?[s,c]=_D.className:o in t&&([s,c]=t[o]),s==null)throw new X(`Unknown ${r}: ${o}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(c!=null){let e={};for(let t of Object.keys(_D))e[t]=_D[t];for(let t of Object.keys(n))e[t]=n[t];let t=a.config;t.customObjects=e;let r=Object.assign({},_D);for(let e of Object.keys(n))_D[e]=n[e];cD(a.config);let o=c(s,a.config,n,i);return _D=Object.assign({},r),o}else{let e=Object.assign({},_D);for(let e of Object.keys(n))_D[e]=n[e];let t=new s(a.config);return _D=Object.assign({},e),t}}}function Pse(e,t){return e<t?-1:e>t?1:0}function uD(e,t){return-1*Pse(e,t)}function dD(e){if(e==null)return e;let t=[];for(let n of e)t.indexOf(n)===-1&&t.push(n);return t}function Fse(e){if(e==null)throw new X(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function fD(e,t,n){if(n!=null&&e.indexOf(n)<0)throw new X(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function pD(e,t,n=0,r=1/0){return tD(n>=0),tD(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every(e=>typeof e===t)}function mD(e,t){Array.isArray(e)?(D(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((e,n)=>mD(e,`element ${n+1} of ${t}`))):D(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${hD(e)}.`)}function hD(e){return e===null?`null`:Array.isArray(e)?`[`+e.map(e=>hD(e)).join(`,`)+`]`:typeof e==`string`?`"${e}"`:`${e}`}function Ise(e,t,n){let r=n==null?Xi():n(),i;return(...a)=>{let o=n==null?Xi():n();return o-r<t?i:(r=o,i=e(...a),i)}}function gD(e){return e===`relu`?`relu`:e===`linear`?`linear`:e===`elu`?`elu`:null}var _D,vD=o((()=>{Y(),QE(),_D={}}));function yD(){return xD++}function bD(e=``){return e in SD||(SD[e]=0),SD[e]+=1,e+SD[e].toString()}var xD,SD,CD=o((()=>{xD=0,SD={}})),wD,TD,ED,DD,OD,kD=o((()=>{wD=[`channelsFirst`,`channelsLast`],TD=[`nearest`,`bilinear`],ED=[`valid`,`same`,`causal`],DD=[`max`,`avg`],OD=[`sum`,`mul`,`concat`,`ave`]}));function AD(e){fD(wD,`DataFormat`,e)}function Lse(e){fD(TD,`InterpolationFormat`,e)}function jD(e){fD(ED,`PaddingMode`,e)}function MD(e){fD(DD,`PoolMode`,e)}function ND(e,t){RD.push(e);try{let e=t();return RD.pop(),e}catch(e){throw RD.pop(),e}}function Rse(){return RD.length===0?``:RD.join(zD)+zD}function PD(e){if(!ID(e))throw Error(`Not a valid tensor name: '`+e+`'`);return Rse()+e}function FD(e){if(!ID(e))throw Error(`Not a valid tensor name: '`+e+`'`);LD.has(e)||LD.set(e,0);let t=LD.get(e);if(LD.set(e,LD.get(e)+1),t>0){let n=`${e}_${t}`;return LD.set(n,1),n}else return e}function ID(e){return!!e.match(BD)}var LD,RD,zD,BD,VD=o((()=>{kD(),vD(),LD=new Map,RD=[],zD=`/`,BD=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/)}));function zse(e){return e===parseInt(e.toString(),10)}function HD(e,t,n){t??=0,n??=e.length;let r=1;for(let i=t;i<n;++i)r*=e[i];return r}function UD(e){if(e.length===0)return NaN;let t=1/0;for(let n=0;n<e.length;n++){let r=e[n];r<t&&(t=r)}return t}function WD(e){if(e.length===0)return NaN;let t=-1/0;for(let n=0;n<e.length;n++){let r=e[n];r>t&&(t=r)}return t}function GD(e,t){if(t<e)throw new X(`end (${t}) < begin (${e}) is forbidden.`);let n=[];for(let r=e;r<t;++r)n.push(r);return n}var KD=o((()=>{QE()}));function qD(){return YD??=Ho().epsilon(),YD}function JD(){return`channelsLast`}var YD,XD=o((()=>{Y()}));function ZD(e,t){return V(e,t)}function QD(e,t=-1){let n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),W(e,n)}function Bse(e,t){return B(()=>{if(e.shape.length!==2)throw new X(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);let n=QD(e,1);return iO(n,[1,t,1])})}function Vse(e){let t=[HD(e.shape)];return W(e,t)}function Hse(e){if(e.rank<=1)throw new X(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],HD(e.shape,1)];return W(e,t)}function $D(e,t,n){return B(()=>{switch(e.rank){case 1:return i_(e,t,n);case 2:return a_(e,[t,0],[n,e.shape[1]]);case 3:return o_(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return s_(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return nu(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return nu(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new X(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function eO(e,t,n){return B(()=>{switch(e.rank){case 1:return i_(e,t,n);case 2:return a_(e,[0,t],[e.shape[0],n]);case 3:return o_(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return s_(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new X(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function tO(e,t,n,r){return B(()=>{switch(e.rank){case 1:return i_(e,t,n);case 2:switch(r){case 1:return $D(e,t,n);case 2:return eO(e,t,n);default:throw new X(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return $D(e,t,n);case 2:return o_(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return eO(e,t,n);default:throw new X(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return $D(e,t,n);case 2:return s_(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return s_(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return eO(e,t,n);default:throw new X(`The axis is not within the rank of the tensor ${r}`)}default:throw new X(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function nO(e,t=-1){let n;return t<0&&(n=e[0].rank,t=n===0?0:n),t===e[0].rank&&(t=-1),ql(e,t)}function rO(e,t){switch(e.rank){case 1:return Ju([e,t]);case 2:return Zu([e,t],0);case 3:return ed([e,t],0);case 4:return rd([e,t],0);default:throw new X(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function iO(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new X(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return wp(e,t)}function aO(e,t=0,n=1,r,i){return dg(e,t,n,r,i)}function oO(e,t,n,r){if(e.rank<2||t.rank<2)throw new XE(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){let n=e.shape.slice(-1)[0],r=t.shape.slice(-2)[0];if(n!==r)throw new XE(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(e.rank===2&&t.rank===2)return Gv({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?lO(e.rank,r,JD()):null,activation:n});{let i=e.shape.slice(),a=i.pop();e=W(e,[-1,a]);let o=t.shape.slice(),s=o.pop(),c=o.pop(),l=[...o,s],u=Array.from({length:t.rank},(e,n)=>n===0?t.rank-2:n<=t.rank-2?n-1:n);t=W(bv(t,u),[c,-1]);let d=[...i,...l];return W(Gv({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?lO(e.rank,r,JD()):null,activation:n}),d)}}function sO(e,t,n){return B(()=>(t=Array.isArray(t)?P_(t,`int32`):V(t,`int32`),Np(e,t,n)))}function cO(e){return U(e,e)}function lO(e,t,n){let r=t.shape;if(t.rank!==1&&t.rank!==e)throw new X(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(e===5){if(n===`channelsFirst`)return r.length===1?W(t,[1,r[0],1,1,1]):W(t,[1,r[3],r[0],r[1],r[2]]);if(n===`channelsLast`)return r.length===1?W(t,[1,1,1,1,r[0]]):W(t,[1].concat(r))}else if(e===4){if(n===`channelsFirst`)return r.length===1?W(t,[1,r[0],1,1]):W(t,[1,r[2],r[0],r[1]]);if(n===`channelsLast`)return r.length===1?W(t,[1,1,1,r[0]]):W(t,[1].concat(r))}else if(e===3){if(n===`channelsFirst`)return r.length===1?W(t,[1,r[0],1]):W(t,[1,r[1],r[0]]);if(n===`channelsLast`)return r.length===1?W(t,[1,1,r[0]]):W(t,[1].concat(r))}else if(e<3)return t;throw new X(`Unsupported input rank by biasAdd: ${t.rank}`)}function uO(e,t,n){return B(()=>(n??=JD(),AD(n),H(e,lO(e.rank,t,n))))}function Use(e,t=1){if(t!==1)throw new XE(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Tf(e)}function Wse(e){return B(()=>Ac(e,H(Fc(e),1)))}function dO(e,t,n,r){return B(()=>Ev(e,t,n,r))}function Gse(e){return B(()=>{let t=H(.5,U(.2,e));return Gu(t,0,1)})}function fO(e,t,n=!1){return n?e():t()}var pO=o((()=>{Y(),VD(),QE(),KD(),XD()})),mO,hO,Kse=o((()=>{mO=[`fanIn`,`fanOut`,`fanAvg`],hO=[`normal`,`uniform`,`truncatedNormal`]}));function qse(e){fD(mO,`FanMode`,e)}function Jse(e){fD(hO,`Distribution`,e)}function Yse(e,t=`channelsLast`){let n,r;if(AD(t),e.length===2)n=e[0],r=e[1];else if([3,4,5].indexOf(e.length)!==-1){if(t===`channelsFirst`){let t=HD(e,2);n=e[1]*t,r=e[0]*t}else if(t===`channelsLast`){let t=HD(e,0,e.length-2);n=e[e.length-2]*t,r=e[e.length-1]*t}}else{let t=HD(e);n=Math.sqrt(t),r=Math.sqrt(t)}return[n,r]}function gO(e,t={}){return lD(e,Ob.getMap().classNameMap,t,`initializer`)}function _O(e){return sD(e)}function vO(e){if(typeof e==`string`){let t=e in FO?FO[e]:e;if(t===`GlorotNormal`)return new kO;if(t===`GlorotUniform`)return new OO;if(t===`HeNormal`)return new AO;if(t===`HeUniform`)return new jO;if(t===`LeCunNormal`)return new MO;if(t===`LeCunUniform`)return new NO;{let e={};return e.className=t,e.config={},gO(e)}}else if(e instanceof yO)return e;else return gO(e)}var yO,bO,xO,SO,CO,wO,TO,EO,DO,OO,kO,AO,jO,MO,NO,PO,FO,IO=o((()=>{Y(),pO(),VD(),QE(),Kse(),vD(),KD(),yO=class extends Db{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},bO=class extends yO{apply(e,t){return ah(e,t)}},bO.className=`Zeros`,J(bO),xO=class extends yO{apply(e,t){return sh(e,t)}},xO.className=`Ones`,J(xO),SO=class extends yO{constructor(e){if(super(),typeof e!=`object`)throw new X(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new X(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return B(()=>U(Zf(this.value),sh(e,t)))}getConfig(){return{value:this.value}}},SO.className=`Constant`,J(SO),CO=class extends yO{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return mg(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}},CO.className=`RandomUniform`,J(CO),wO=class extends yO{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t||=`float32`,t!==`float32`&&t!==`int32`)throw new XE(`randomNormal does not support dType ${t}.`);return aO(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}},wO.className=`RandomNormal`,J(wO),TO=class extends yO{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t||=`float32`,t!==`float32`&&t!==`int32`)throw new XE(`truncatedNormal does not support dType ${t}.`);return iv(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}},TO.className=`TruncatedNormal`,J(TO),EO=class extends yO{constructor(e){super(),this.gain=e.gain==null?1:e.gain}apply(e,t){return B(()=>{if(e.length!==2||e[0]!==e[1])throw new X(`Identity matrix initializer can only be used for 2D square matrices.`);return U(this.gain,Dp(e[0]))})}getConfig(){return{gain:this.gain}}},EO.className=`Identity`,J(EO),DO=class extends yO{constructor(e){if(super(),e.scale<0)throw new X(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?`fanIn`:e.mode,qse(this.mode),this.distribution=e.distribution==null?`normal`:e.distribution,Jse(this.distribution),this.seed=e.seed}apply(e,t){let n=Yse(e),r=n[0],i=n[1],a=this.scale;if(this.mode===`fanIn`?a/=Math.max(1,r):this.mode===`fanOut`?a/=Math.max(1,i):a/=Math.max(1,(r+i)/2),this.distribution===`normal`){let n=Math.sqrt(a);if(t||=`float32`,t!==`float32`&&t!==`int32`)throw new XE(`${this.getClassName()} does not support dType ${t}.`);return iv(e,0,n,t,this.seed)}else{let n=Math.sqrt(3*a);return mg(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}},DO.className=`VarianceScaling`,J(DO),OO=class extends DO{constructor(e){super({scale:1,mode:`fanAvg`,distribution:`uniform`,seed:e==null?null:e.seed})}getClassName(){return DO.className}},OO.className=`GlorotUniform`,J(OO),kO=class extends DO{constructor(e){super({scale:1,mode:`fanAvg`,distribution:`normal`,seed:e==null?null:e.seed})}getClassName(){return DO.className}},kO.className=`GlorotNormal`,J(kO),AO=class extends DO{constructor(e){super({scale:2,mode:`fanIn`,distribution:`normal`,seed:e==null?null:e.seed})}getClassName(){return DO.className}},AO.className=`HeNormal`,J(AO),jO=class extends DO{constructor(e){super({scale:2,mode:`fanIn`,distribution:`uniform`,seed:e==null?null:e.seed})}getClassName(){return DO.className}},jO.className=`HeUniform`,J(jO),MO=class extends DO{constructor(e){super({scale:1,mode:`fanIn`,distribution:`normal`,seed:e==null?null:e.seed})}getClassName(){return DO.className}},MO.className=`LeCunNormal`,J(MO),NO=class extends DO{constructor(e){super({scale:1,mode:`fanIn`,distribution:`uniform`,seed:e==null?null:e.seed})}getClassName(){return DO.className}},NO.className=`LeCunUniform`,J(NO),PO=class extends yO{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return B(()=>{if(e.length<2)throw new XE(`Shape must be at least 2D.`);if(t!==`int32`&&t!==`float32`&&t!==void 0)throw TypeError(`Unsupported data type ${t}.`);t=t;let n=O(e.slice(0,-1)),r=e[e.length-1],i=n*r;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);let a=aO([Math.max(r,n),Math.min(r,n)],0,1,t,this.seed),o=vb.qr(a,!1),s=o[0],c=o[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return s=U(s,c.sign()),n<r&&(s=s.transpose()),U(Zf(this.gain),s.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}},PO.className=`Orthogonal`,J(PO),FO={constant:`Constant`,glorotNormal:`GlorotNormal`,glorotUniform:`GlorotUniform`,heNormal:`HeNormal`,heUniform:`HeUniform`,identity:`Identity`,leCunNormal:`LeCunNormal`,leCunUniform:`LeCunUniform`,ones:`Ones`,orthogonal:`Orthogonal`,randomNormal:`RandomNormal`,randomUniform:`RandomUniform`,truncatedNormal:`TruncatedNormal`,varianceScaling:`VarianceScaling`,zeros:`Zeros`}}));function LO(e){return Array.isArray(e)&&Array.isArray(e[0])}function RO(e){return e.length===0?[]:Array.isArray(e[0])?e:[e]}function zO(e){let t;if(Array.isArray(e)){if(e.length!==1)throw new X(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function BO(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(e.length===1)return e=e,e[0];throw new X(`Expected exactly 1 Shape; got ${e.length}`)}else return e}var VO=o((()=>{QE()}));
/**
* @license
* Copyright 2018 Google LLC
*
* Use of this source code is governed by an MIT-style
* license that can be found in the LICENSE file or at
* https://opensource.org/licenses/MIT.
* =============================================================================
*/
function HO(e){let t=0;for(let n of e)n.shape.length===0?t+=1:t+=n.shape.reduce((e,t)=>e*t);return t}var UO=o((()=>{}));function Xse(e,t){if(e.shape.toString()!==t.shape.toString())throw Error(`Shape mismatch: `+JSON.stringify(e.shape)+` vs. `+JSON.stringify(t.shape))}function WO(e){return e.map(e=>e.read())}function GO(e){e.forEach(e=>{e[0].write(e[1])})}var KO,qO,JO=o((()=>{Y(),CD(),VD(),KO=`Variable`,qO=class{constructor(e,t=`float32`,n=KO,r=!0,i=null){this.dtype=t??`float32`,this.shape=e.shape,this.id=yD(),n??=KO,this.originalName=PD(n),this.name=FD(this.originalName),this.trainable_=r,this.constraint=i,this.val=mv(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),Xse(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}}));function Zse(e){e=iD(e);let t=[];for(let n of e)t.push(n.shape);return rD(t)}function Qse(e){return`float32`}function YO(e,t,n){if((t==null||n!=null&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),t.inboundNodes.length===0)return[e];{let e=t.inboundNodes[n];if(e.inboundLayers.length===0)return e.inputTensors;{let t=[];for(let n=0;n<e.inboundLayers.length;n++){let r=e.inputTensors[n],i=e.inboundLayers[n],a=e.nodeIndices[n],o=YO(r,i,a);for(let e of o)t.indexOf(e)===-1&&t.push(e)}return t}}}function $se(e){let t=!0;for(let n of iD(e))if(!(n instanceof ZO)){t=!1;break}return t}function ece(e){let t=!0;for(let n of iD(e))if(n instanceof ZO){t=!1;break}return t}var XO,ZO,QO,$O,ek,tk,nk=o((()=>{Y(),CD(),VD(),QE(),IO(),vD(),VO(),UO(),JO(),XO=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape==null?this.ndim=e.ndim:this.ndim=e.shape.length,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},ZO=class{constructor(e,t,n,r,i,a,o){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=i,this.outputTensorIndex=o,this.id=yD(),a!=null&&(this.originalName=PD(a),this.name=FD(this.originalName)),this.rank=t.length}},QO=0,$O=class{constructor(e,t){this.callArgs=t,this.id=QO++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let t of e.inboundLayers)t?.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)t==null?e.push(null):e.push(t.name);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},ek=0,tk=class extends Db{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=ek++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let e=this.getClassName();t=aD(e)+`_`+bD(e)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let t;if(e.batchInputShape!=null)t=e.batchInputShape;else if(e.inputShape!=null){let n=null;e.batchSize!=null&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;n??=e.inputDType,n??=`float32`,this.dtype=n}e.weights==null?this.initialWeights=null:this.initialWeights=e.weights,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+`_ib-`+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new YE(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new X(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return rD(this.getNodeAtIndex(e,`input`).inputTensors)}getOutputAt(e){return rD(this.getNodeAtIndex(e,`output`).outputTensors)}get input(){if(this.inboundNodes.length>1)throw new JE(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new JE(`Layer ${this.name} is not connected, no input to return.`);return rD(this.getNodeAtIndex(0,`input`).inputTensors)}get output(){if(this.inboundNodes.length===0)throw new JE(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new JE(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return rD(this.getNodeAtIndex(0,`output`).outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw Error(`Cannot call the resetStates() method of a non-stateful Layer object.`)}assertInputCompatibility(e){let t=iD(e);if(this.inputSpec==null||this.inputSpec.length===0)return;let n=iD(this.inputSpec);if(t.length!==n.length)throw new X(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let e=0;e<t.length;e++){let r=t[e],i=n[e];if(i==null)continue;let a=r.rank;if(i.ndim!=null&&a!==i.ndim)throw new X(`Input ${e} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${a}`);if(i.maxNDim!=null&&a>i.maxNDim)throw new X(`Input ${e} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${a}`);if(i.minNDim!=null&&a<i.minNDim)throw new X(`Input ${e} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${a}.`);if(i.dtype!=null&&r.dtype!==i.dtype)throw new X(`Input ${e} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${r.dtype}.`);if(i.axes){let t=r.shape;for(let n in i.axes){let r=Number(n),a=i.axes[n],o=r>=0?t[r]:t[t.length+r];if(a!=null&&[a,null].indexOf(o)===-1)throw new X(`Input ${e} is incompatible with layer ${this.name}: expected axis ${r} of input shape to have value ${a} but got shape ${t}.`)}}if(i.shape!=null)for(let t=0;t<i.shape.length;++t){let n=i.shape[t],a=r.shape[t];if(n!=null&&a!=null&&n!==a)throw new X(`Input ${e} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t||={},this.assertNotDisposed();let n=iD(e),r=$se(e),i=ece(e);if(r===i)throw new X(`Arguments to apply() must be all SymbolicTensors or all Tensors`);return ND(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);let t=[];for(let n of iD(e))t.push(n.shape);this.build(rD(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&i&&(this._refCount=1)}if(this.assertInputCompatibility(e),i){let r=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,r);let i=iD(r),a=[];for(let e of i)n.indexOf(e)!==-1&&(e=e.clone()),a.push(e);if(r=rD(a),this.activityRegularizer!=null)throw new XE(`Layer invocation in the presence of activity regularizer(s) is not supported yet.`);return r}else{let n=Zse(e),r=this.computeOutputShape(n),i,a=Qse(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),i=r!=null&&r.length>0&&Array.isArray(r[0])?r.map((n,r)=>new ZO(a,n,this,iD(e),t,this.name,r)):new ZO(a,r,this,iD(e),t,this.name),this.addInboundNode(e,i,null,null,n,r,t),this._refCount++,this.activityRegularizer!=null)throw new XE(`Layer invocation in the presence of activity regularizer(s) is not supported yet.`);return i}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,r)=>{n!=null&&e[r]!=null&&e[r]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new JE(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);e.indexOf(n)===-1&&e.push(n)}if(e.length===1){let e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&e.length===1?e[0]:e}else throw new JE(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new YE(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return HO(this.weights)}build(e){this.built=!0}getWeights(e=!1){return WO(e?this.trainableWeights:this.weights)}setWeights(e){B(()=>{let t=this.weights;if(t.length!==e.length)throw new X(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;let n=[],r=WO(t);for(let i=0;i<r.length;++i){let a=r[i],o=t[i],s=e[i];if(!ge(a.shape,s.shape))throw new X(`Layer weight shape ${a.shape} not compatible with provided weight shape ${s.shape}`);n.push([o,s])}GO(n)})}addWeight(e,t,n,r,i,a,o,s){if(this._addedWeightNames.indexOf(e)!==-1)throw new X(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),n??=`float32`,this.fastWeightInitDuringBuild&&(r=s==null?vO(`zeros`):s());let c=r.apply(t,n),l=new qO(c,n,e,a,o);return c.dispose(),i!=null&&this.addLoss(()=>i.apply(l.read())),a??=!0,a?this._trainableWeights.push(l):this._nonTrainableWeights.push(l),l}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=iD(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(e=>{if(e!=null)throw TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;let r=this.computeMask(e,n),i=iD(t),a=iD(r);if(i.length!==a.length)throw Error(`${this.name} outputs ${i.length} tensors but ${i.length} masks for those tensors`);for(let e=0;e<i.length;e++)i[e].kerasMask=a[e]}addInboundNode(e,t,n,r,i,a,o=null){let s=iD(e);t=iD(t),n=iD(n),r=iD(r),i=RO(i),a=RO(a);let c=[],l=[],u=[];for(let e of s)c.push(e.sourceLayer),l.push(e.nodeIndex),u.push(e.tensorIndex);new $O({outboundLayer:this,inboundLayers:c,nodeIndices:l,tensorIndices:u,inputTensors:s,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:i,outputShapes:a},o);for(let e=0;e<t.length;e++)t[e].sourceLayer=this,t[e].nodeIndex=this.inboundNodes.length-1,t[e].tensorIndex=e}getConfig(){let e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}}));function rk(e){if(e.batchShape==null&&e.shape==null)throw Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(e.batchShape!=null&&e.shape!=null)throw new X("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;e.shape!=null&&t==null&&(t=[null].concat(e.shape));let n=e.dtype;return n??=`float32`,new ik({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}var ik,ak=o((()=>{Y(),CD(),QE(),nk(),ik=class extends tk{constructor(e){if(super({dtype:e.dtype,name:e.name==null?bD(`input`).toString():e.name}),e.batchSize??=null,e.sparse??=!1,this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new X(`Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.`);let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new X("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new X(`Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.`);let n=e.dtype||`float32`;this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let r=new ZO(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new $O({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new X(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}},ik.className=`InputLayer`,J(ik)}));function tce(e,t){if(e.dtype==null||e.dtype===t.dtype)return t;try{return V(t,e.dtype)}catch{throw new X(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}function nce(e){lk?.setMaxEntries(e),uk?.setMaxEntries(e)}function ok(e,t,n,r){let i=n==null?!1:n.training,a=Array.isArray(e),o=a?e:[e],s=o.map(e=>e.name),c=[],l=t.names();for(let e of s)l.indexOf(e)===-1?c.push(null):c.push(t.getValue(e));r!=null&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);let u=s.join(`,`)+`|`+t.names().sort().join(`,`),d=lk.get(u),f;if(d==null){let e=rce(o,t);d=e.sorted,f=e.recipientCounts,lk.put(u,d),uk.put(u,f)}f={},i||Object.assign(f,uk.get(u));let p=new ck(t);for(let e=0;e<d.length;++e){if(r!=null){let e=Ao().numTensors;e>r.maxNumTensors&&(r.maxNumTensors=e),e<r.minNumTensors&&(r.minNumTensors=e)}let a=d[e],o=a.sourceLayer;if(o instanceof ik)continue;let l=[],u=[],m=[],h=!1;for(let e of a.inputs){let n=p.getValue(e),r=p.getMask(e);l.push(n),u.push(r),r!=null&&(h=!0),i||(f[e.name]--,f[e.name]===0&&!t.hasKey(e)&&s.indexOf(e.name)===-1&&!n.isDisposed&&e.sourceLayer.stateful!==!0&&m.push(n))}h&&(n||={},n.mask=u[0]);let g=iD(o.apply(l,n)),_=null;o.supportsMasking&&(_=o.computeMask(l,u));let v=ace(a),y=Array.isArray(v)?v:[v];for(let e=0;e<y.length;++e){p.hasKey(y[e])||p.add(y[e],g[e],Array.isArray(_)?_[0]:_);let t=s.indexOf(y[e].name);t!==-1&&(c[t]=g[e])}i||Mo(m)}return p.disposeMasks(),a?c:c[0]}function rce(e,t){D(e!=null&&e.length>0,()=>`Expected at least one fetch, got none`);let n=[],r={};if(e.length===1){let i=sk(e[0],t);n=i.sorted,r=i.recipientMap}else{let i=new Set;for(let a of e){let{sorted:e,recipientMap:o}=sk(a,t);for(let t of e)i.has(t.name)||(n.push(t),i.add(t.name));for(let e in o)r[e]??(r[e]=new Set),o[e].forEach(t=>r[e].add(t))}}return{sorted:n,recipientCounts:ice(r)}}function ice(e){let t={};for(let n in e)t[n]=e[n].size;return t}function sk(e,t){let n=new Set,r=[],i={};for(let e of t.names())n.add(e);let a=[],o=[];for(a.push(e);a.length>0;){let e=a[a.length-1];if(n.has(e.name)){a.pop();continue}let t=o[o.length-1]===a.length-1;if(e.inputs.length===0||t)a.pop(),r.push(e),n.add(e.name),t&&o.pop();else{o.push(a.length-1);for(let t of e.inputs)i[t.name]??(i[t.name]=new Set),i[t.name].add(e.name),!n.has(t.name)&&a.push(t)}}return{sorted:r,recipientMap:i}}function ace(e){let t;if(e.sourceLayer.inboundNodes.length===1)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(let r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}var ck,lk,uk,dk=o((()=>{Y(),QE(),Nse(),vD(),ak(),nk(),ck=class e{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof e)for(let e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(t==null)return;for(let e of t)this.add(e.key,e.value)}}add(e,t,n){if(this.id2Value[e.id]==null)this.id2Value[e.id]=tce(e,t),this.name2Id[e.name]=e.id,n!=null&&(this.id2Mask[e.id]=n);else throw new X(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof ZO){if(this.id2Value[e.id]==null)throw new X(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{let t=this.name2Id[e];if(t==null)throw new X(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof ZO){if(this.id2Value[e.id]==null)throw new X(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{let t=this.name2Id[e];if(t==null)throw new X(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&Mo(this.id2Mask)}},lk=new $E,uk=new $E})),fk,oce=o((()=>{Y(),dk(),fk=k(),fk.registerFlag(`TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES`,()=>100,nce)}));function pk(e,t){return B(()=>ep(K(U(e,e),t,!0)))}function mk(e){return sD(e)}function hk(e,t={}){return lD(e,Ob.getMap().classNameMap,t,`constraint`)}function gk(e){if(e==null)return null;if(typeof e==`string`){let t={className:e in Sk?Sk[e]:e,config:{}};return hk(t)}else if(e instanceof _k)return e;else return hk(e)}var _k,vk,yk,bk,xk,Sk,Ck=o((()=>{Y(),XD(),vD(),_k=class extends Db{getConfig(){return{}}},vk=class extends _k{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue==null?this.defaultMaxValue:e.maxValue,this.axis=e.axis==null?this.defaultAxis:e.axis}apply(e){return B(()=>{let t=pk(e,this.axis),n=Gu(t,0,this.maxValue);return U(e,Ac(n,H(qD(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}},vk.className=`MaxNorm`,J(vk),yk=class extends _k{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis==null?this.defaultAxis:e.axis}apply(e){return B(()=>Ac(e,H(qD(),pk(e,this.axis))))}getConfig(){return{axis:this.axis}}},yk.className=`UnitNorm`,J(yk),bk=class extends _k{apply(e){return Tg(e)}},bk.className=`NonNeg`,J(bk),xk=class extends _k{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue==null?this.defaultMinValue:e.minValue,this.maxValue=e.maxValue==null?this.defaultMaxValue:e.maxValue,this.rate=e.rate==null?this.defaultRate:e.rate,this.axis=e.axis==null?this.defaultAxis:e.axis}apply(e){return B(()=>{let t=pk(e,this.axis),n=H(U(this.rate,Gu(t,this.minValue,this.maxValue)),U(1-this.rate,t));return U(e,Ac(n,H(qD(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}},xk.className=`MinMaxNorm`,J(xk),Sk={maxNorm:`MaxNorm`,minMaxNorm:`MinMaxNorm`,nonNeg:`NonNeg`,unitNorm:`UnitNorm`}})),sce=c({maxNorm:()=>cce,minMaxNorm:()=>dce,nonNeg:()=>uce,unitNorm:()=>lce});function cce(e){return new vk(e)}function lce(e){return new yk(e)}function uce(){return new bk}function dce(e){return new xk(e)}var fce=o((()=>{Ck()})),pce=c({constant:()=>gce,glorotNormal:()=>Cce,glorotUniform:()=>Sce,heNormal:()=>wce,heUniform:()=>Tce,identity:()=>bce,leCunNormal:()=>Ece,leCunUniform:()=>Dce,ones:()=>hce,orthogonal:()=>Oce,randomNormal:()=>vce,randomUniform:()=>_ce,truncatedNormal:()=>yce,varianceScaling:()=>xce,zeros:()=>mce});function mce(){return new bO}function hce(){return new xO}function gce(e){return new SO(e)}function _ce(e){return new CO(e)}function vce(e){return new wO(e)}function yce(e){return new TO(e)}function bce(e){return new EO(e)}function xce(e){return new DO(e)}function Sce(e){return new OO(e)}function Cce(e){return new kO(e)}function wce(e){return new AO(e)}function Tce(e){return new jO(e)}function Ece(e){return new MO(e)}function Dce(e){return new NO(e)}function Oce(e){return new PO(e)}var kce=o((()=>{IO()}));async function wk(e){if(e==null)return;let t=[],n=[],r=[];for(let i in e){let a=e[i];if(typeof a!=`number`){let e=a;t.push(e.data()),n.push(i),r.push(e)}}if(t.length>0){let i=await Promise.all(t);for(let t=0;t<i.length;++t)e[n[t]]=i[t][0];Mo(r)}}function Tk(e){if(e!=null)for(let t in e){let n=e[t];typeof n!=`number`&&n.dispose()}}var Ek=o((()=>{Y()}));function Dk(e,t){return e??={},e instanceof kk?[e]:Array.isArray(e)&&e[0]instanceof kk?e:iD(e).map(e=>new Nk(e,t))}function Ok(e,t,n,r,i,a,o,s,c){let l=new Mk,u=[new jk,...Pk.createCallbacks(t)];e!=null&&u.push(...e),u.push(l);let d=new Ak(u);return d.setParams({epochs:n,initialEpoch:r,samples:i,steps:a,batchSize:o,verbose:t,doValidation:s,metrics:c}),{callbackList:d,history:l}}var Ace,kk,Ak,jk,Mk,Nk,Pk,Fk=o((()=>{Y(),QE(),Ek(),vD(),(function(e){e[e.SILENT=0]=`SILENT`,e[e.VERBOSE=1]=`VERBOSE`})(Ace||={}),kk=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},Ak=class{constructor(e,t=10){e??=[],this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t??={};for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){t??={};for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){t??={};for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){t??={};for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){e??={};for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e??={};for(let t of this.callbacks)await t.onTrainEnd(e)}},jk=class extends kk{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t??={};let n=t.size==null?0:t.size;for(let e in this.seen+=n,t){let r=t[e];if(typeof r==`number`)this.totals.hasOwnProperty(e)||(this.totals[e]=0),this.totals[e]=this.totals[e]+r*n;else{let t;e in this.totals?t=this.totals[e]:this.totals[e]=0;let i=B(()=>H(this.totals[e],U(r,n)));this.totals[e]=i,t?.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(let e of this.params.metrics)this.totals[e]!=null&&(typeof this.totals[e]==`number`?t[e]=this.totals[e]/this.seen:B(()=>{t[e]=U(Ac(1,this.seen),this.totals[e]),this.totals[e].dispose(),No(t[e])}))}},Mk=class extends kk{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){for(let n in t??={},this.epoch.push(e),t)this.history[n]??(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let r in this.history){let i=this.history[r];for(let a=0;a<i.length;++a)if(typeof i[a]!=`number`){let o=i[a];e.push(o.data()),t.push(r),n.push(a)}}let r=await Promise.all(e);for(let e=0;e<r.length;++e)this.history[t[e]][n[e]].dispose(),this.history[t[e]][n[e]]=r[e][0]}},Nk=class extends kk{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||_S,this.yieldEvery=t||`auto`,this.yieldEvery===`auto`&&(this.yieldEvery=125),this.yieldEvery===`never`&&e.onYield!=null)throw Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Fe(this.yieldEvery)&&(this.maybeWait=Ise(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let r=[];this.yield!=null&&(await wk(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await wk(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];this.epochEnd!=null&&(await wk(t),n.push(this.epochEnd(e,t))),this.yieldEvery===`epoch`&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){this.batchBegin!=null&&(await wk(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];this.batchEnd!=null&&(await wk(t),n.push(this.batchEnd(e,t))),this.yieldEvery===`batch`?n.push(this.nextFrameFunc()):Fe(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){this.trainBegin!=null&&(await wk(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await wk(e),await this.trainEnd(e))}},Pk=class e{constructor(){}static registerCallbackConstructor(t,n){D(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),e.checkForDuplicate(n),e.constructors[t]??(e.constructors[t]=[]),e.constructors[t].push(n)}static checkForDuplicate(t){for(let n in e.constructors)e.constructors[+n].forEach(e=>{if(e===t)throw new X(`Duplicate callback constructor.`)})}static clear(){e.constructors={}}static createCallbacks(t){let n=[];for(let r in e.constructors){let i=+r;t>=i&&n.push(...e.constructors[i])}return n.map(e=>new e)}},Pk.constructors={}}));function Ik(e,t={},n=!1){return lD(e,Ob.getMap().classNameMap,t,`layer`,n)}var Lk=o((()=>{Y(),vD()}));function Rk(e,t){return B(()=>{e.dtype!==`float32`&&(e=V(e,`float32`));let n=K(cO(e),t,!0),r=Hu(n.shape,qD()),i=ep(th(n,r));return Ac(e,i)})}function zk(e,t){return B(()=>rh(cO(q(t,e)),-1))}function Bk(e,t){return B(()=>rh(Fc(q(t,e)),-1))}function Vk(e,t){return B(()=>{let n=q(e,t),r=Gu(Fc(e),qD(),Number.MAX_VALUE),i=Fc(Ac(n,r));return U(100,rh(i,-1))})}function jce(e,t){return B(()=>{let n=Gu(t,qD(),Number.MAX_VALUE),r=dm(H(1,n)),i=Gu(e,qD(),Number.MAX_VALUE),a=dm(H(1,i));return rh(cO(q(r,a)),-1)})}function Mce(e,t){return B(()=>{let n=th(0,q(1,U(e,t)));return rh(cO(n),-1)})}function Nce(e,t){return B(()=>{let n=th(0,q(1,U(e,t)));return rh(n,-1)})}function Pce(e,t){return B(()=>{let n=K(U(e,t),-1),r=Uf(U(q(1,e),t),-1);return th(0,H(1,q(r,n)))})}function Fce(e,t){return B(()=>{let n=Math.log(2),r=q(t,e),i=q(H(r,Cm(U(-2,r))),n);return rh(i,-1)})}function Hk(e,t,n=!1){return B(()=>{if(n)t=c_(t);else{let e=K(t,t.shape.length-1,!0);t=Ac(t,e)}return t=Gu(t,qD(),1-qD()),bm(K(U(V(e,`float32`),dm(t)),t.shape.length-1))})}function Uk(e,t,n=!1){return B(()=>{let r=V(Ap(Vse(e)),`int32`);t=Gu(t,qD(),1-qD());let i=t.shape,a=W(xh(r,i[i.length-1]),i);return Hk(a,t,n)})}function Ice(e,t){if(!ge(e.shape,t.shape))throw new X(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return B(()=>{let n=Tg(t),r=bm(Fc(t));return H(q(n,U(t,e)),pm(hp(r)))})}function Wk(e,t){return B(()=>{let n;return n=Gu(t,qD(),1-qD()),n=dm(Ac(n,q(1,n))),rh(Ice(e,n),-1)})}function Lce(e,t){return B(()=>{let n=Gu(e,qD(),1),r=Gu(t,qD(),1);return K(U(e,dm(Ac(n,r))),-1)})}function Rce(e,t){return B(()=>{let n=dm(H(qD(),t));return rh(q(t,U(e,n)),-1)})}function Gk(e,t){return B(()=>{let n=Rk(e,-1),r=Rk(t,-1),i=U(n,r);return bm(K(i,-1))})}function Kk(e){if(typeof e==`string`){if(e in qk)return qk[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes(`softmaxcrossentropy`)&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new X(t)}else return e}var qk,Jk=o((()=>{Y(),XD(),pO(),QE(),qk={meanSquaredError:zk,meanAbsoluteError:Bk,meanAbsolutePercentageError:Vk,meanSquaredLogarithmicError:jce,squaredHinge:Mce,hinge:Nce,categoricalHinge:Pce,logcosh:Fce,categoricalCrossentropy:Hk,sparseCategoricalCrossentropy:Uk,binaryCrossentropy:Wk,kullbackLeiblerDivergence:Lce,poisson:Rce,cosineProximity:Gk}}));function Yk(e,t){return B(()=>{let n=U(.5,wh(t)),r=ZD(Ip(t,n),e.dtype);return rh(sf(e,r),-1)})}function Xk(e,t){return B(()=>ZD(sf($c(e,-1),$c(t,-1)),`float32`))}function Zk(e,t){return B(()=>V(K(Lm(sf(e,1),sf(t,1))),`float32`))}function zce(e,t){return B(()=>V(K(Lm(sf(e,1),sf(t,0))),`float32`))}function Bce(e,t){return B(()=>V(K(Lm(sf(e,0),sf(t,1))),`float32`))}function Qk(e,t){return B(()=>{let n=Zk(e,t),r=Bce(e,t),i=H(n,r);return V(uf(Ip(i,0),Ac(n,i),0),`float32`)})}function Vce(e,t){return B(()=>{let n=Zk(e,t),r=zce(e,t),i=H(n,r);return V(uf(Ip(i,0),Ac(n,i),0),`float32`)})}function $k(e,t){return Wk(e,t)}function eA(e,t){return e.rank===t.rank&&(e=x_(e,[e.rank-1])),t=$c(t,-1),t.dtype!==e.dtype&&(t=V(t,e.dtype)),V(sf(e,t),`float32`)}function Hce(e,t){return B(()=>{let n=e.sub(t).square().sum(),r=e.sub(e.mean()).square().sum();return Zf(1).sub(n.div(r))})}function Uce(e){if(typeof e==`string`&&e in dA)return dA[e];if(typeof e!=`string`&&e!=null)return e;throw new X(`Unknown metric ${e}`)}function tA(e){if(tD(e!==null,`Unknown LossOrMetricFn ${e}`),typeof e==`string`)return e;{let t;for(let n of Object.keys(qk))if(qk[n]===e){t=n;break}if(t!==void 0)return t;for(let n of Object.keys(dA))if(dA[n]===e){t=n;break}return t===void 0?e.name:t}}var nA,rA,iA,aA,oA,sA,cA,lA,uA,dA,fA=o((()=>{Y(),pO(),QE(),Jk(),vD(),nA=zk,rA=zk,iA=Bk,aA=Bk,oA=Vk,sA=Vk,cA=Hk,lA=Gk,uA=Uk,dA={binaryAccuracy:Yk,categoricalAccuracy:Xk,precision:Qk,categoricalCrossentropy:cA,sparseCategoricalCrossentropy:uA,mse:nA,MSE:rA,mae:iA,MAE:aA,mape:oA,MAPE:sA,cosine:lA}}));function Wce(e){let t={Adagrad:()=>gS.adagrad(.01),Adadelta:()=>gS.adadelta(1,.95,qD()),Adam:()=>gS.adam(.001,.9,.999,qD()),Adamax:()=>gS.adamax(.002,.9,.999,qD(),0),RMSProp:()=>gS.rmsprop(.001,.9,0,qD()),SGD:()=>gS.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new X(`Unknown Optimizer ${e}`)}var Gce=o((()=>{Y(),XD(),QE()}));function pA(e,t,n=!1){if(typeof e!=`object`||!e||Object.getPrototypeOf(e)!==Object.prototype||!mA(e))throw Error(`User-defined metadata is expected to be a JSON object, but is not.`);if(n){let n=JSON.stringify(e);n.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${hA}.`)}}function mA(e){if(e===null)return!0;if(typeof e==`object`)if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let n of t)if(typeof n!=`string`||!mA(e[n]))return!1;return!0}else if(Array.isArray(e)){for(let t of e)if(!mA(t))return!1;return!0}else return!1;else{let t=typeof e;return t===`string`||t===`number`||t===`boolean`}}var hA,Kce=o((()=>{hA=1*1024*1024}));function qce(e,t,n,r=console.log){let i=Yce(e),a=[`Layer (type)`,`Input Shape`,`Output shape`,`Param #`];i?(t||=90,n||=[.32,.61,.89,1]):(t||=115,n||=[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(e=>Math.floor(t*e)));let o;if(!i)for(let t in a.push(`Receives inputs`),o=[],e.nodesByDepth)o.push(...e.nodesByDepth[t]);r(`_`.repeat(t)),gA(a,n,r),r(`=`.repeat(t));let s=e.layers;for(let e=0;e<s.length;++e)i?Xce(s[e],n,r):Zce(s[e],n,o,r),r((e===s.length-1?`=`:`_`).repeat(t));e.checkTrainableWeightsConsistency();let c=Jce(e),l=HO(e.nonTrainableWeights);r(`Total params: ${c+l}`),r(`Trainable params: ${c}`),r(`Non-trainable params: ${l}`),r(`_`.repeat(t))}function Jce(e){let t;return t=e.collectedTrainableWeights==null?HO(e.trainableWeights):HO(e.collectedTrainableWeights),t}function Yce(e){let t=!0,n=[],r=[];for(let t in e.nodesByDepth)n.push(e.nodesByDepth[t]);for(let e of n){if(e.length>1||e.length===1&&e[0].inboundLayers.length>1){t=!1;break}r.push(...e)}if(t)for(let n of e.layers){let e=!1;for(let i of n.inboundNodes)if(r.indexOf(i)!==-1)if(e){t=!1;break}else e=!0;if(!t)break}return t}function gA(e,t,n=console.log){let r=``;for(let n=0;n<e.length;++n)n>0&&(r=r.slice(0,r.length-1)+` `),r+=e[n],r=r.slice(0,t[n]),r+=` `.repeat(t[n]-r.length);n(r)}function Xce(e,t,n){let r,i;try{i=e.inboundNodes.map(e=>JSON.stringify(e.inputShapes)).join(`,`)}catch{i=`multiple`}try{r=JSON.stringify(e.outputShape)}catch{r=`multiple`}let a=e.name,o=e.getClassName(),s=[`${a} (${o})`,i,r,e.countParams().toString()];gA(s,t,n)}function Zce(e,t,n,r){let i,a;try{a=e.inboundNodes.map(e=>JSON.stringify(e.inputShapes)).join(`,`)}catch{a=`multiple`}try{i=JSON.stringify(e.outputShape)}catch{i=`multiple`}let o=[];for(let t of e.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(t)===-1))for(let e=0;e<t.inboundLayers.length;++e){let n=t.inboundLayers[e].name,r=t.nodeIndices[e],i=t.tensorIndices[e];o.push(`${n}[${r}][${i}]`)}let s=e.name,c=e.getClassName(),l=o.length===0?``:o[0],u=[`${s} (${c})`,a,i,e.countParams().toString(),l];gA(u,t,r);for(let e=1;e<o.length;++e)gA([``,``,``,``,o[e]],t,r)}var Qce=o((()=>{UO()}));function _A(e,t,n){return(e===`inboundNodes`||e===`outputLayers`||e===`inputLayers`)&&t===0&&typeof n==`string`}function vA(e,t){if(e===null)return null;if(typeof e==`string`)return oD(e);if(typeof e==`number`||typeof e==`boolean`)return e;if(e instanceof Array){let n=[],r=e.length;for(let i=0;i<r;++i){let r=e[i];_A(t,i,r)?n.push(r):n.push(vA(r,t))}return n}else{let t={};for(let n of Object.keys(e)){let r=e[n];if(n===`name`&&typeof r==`string`)t[n]=r;else{let e=oD(n);t[e]=vA(r,e)}}return t}}function yA(e,t){if(e==null)return null;if(typeof e==`string`)return aD(e);if(typeof e==`number`||typeof e==`boolean`)return e;if(e instanceof Array){let n=[],r=e.length;for(let i=0;i<r;++i){let r=e[i];_A(t,i,r)?n.push(r):n.push(yA(r,t))}return n}else{let t={};for(let n of Object.keys(e)){let r=e[n],i=aD(n);(n===`name`||n===`className`)&&typeof r==`string`?t[i]=r:t[i]=yA(r,n)}return t}}var bA=o((()=>{vD()})),xA,SA=o((()=>{xA=`4.22.0`})),CA,wA,$ce=o((()=>{Y(),CD(),QE(),Lk(),vD(),bA(),VO(),JO(),SA(),dk(),ak(),nk(),CA=e=>{let t=Object.keys(e);if(t.length===0)return!1;let n=t[0].split(`/`);return!isNaN(parseInt(n[n.length-1],10))},wA=class e extends tk{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){let e=this.getClassName().toLowerCase();this.name=bD(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],dD(this.inputs).length!==this.inputs.length)throw new X(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(e=>e.name)}`);dD(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(e=>e.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let e of this.outputs){let t=e.sourceLayer,n=e.nodeIndex,r=e.tensorIndex;this.outputLayers.push(t),this.outputLayersNodeIndices.push(n),this.outputLayersTensorIndices.push(r)}for(let e of this.inputs){let t=e.sourceLayer,n=e.nodeIndex,r=e.tensorIndex;tD(n===0,`input layer has >1 nodes`),tD(r===0,`input layer has >1 tensors`),this.inputLayers.push(t),this.inputLayersNodeIndices.push(n),this.inputLayersTensorIndices.push(r)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let e=0;e<this.inputLayers.length;e++){let n=this.inputLayers[e];if(!(n instanceof ik))throw TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${e} (0-based) originates from layer type ${n.getClassName()}.`);this.inputNames.push(n.name),this.feedInputShapes.push(n.batchInputShape),this.feedInputNames.push(n.name)}for(let e of this.outputLayers)this.outputNames.push(e.name);this.internalInputShapes=this.inputs.map(e=>e.shape),this.internalOutputShapes=this.outputs.map(e=>e.shape);let n={},r={},i={},a={},o={},s=[],c=(t,n,r,i,a,l)=>{(i==null||a==null||l==null)&&(i=t.sourceLayer,a=t.nodeIndex,l=t.tensorIndex);let u=i.inboundNodes[a];if(r.indexOf(u)!==-1)throw new YE(`The tensor ${t.name} at layer "${i.name}" is part of a cycle.`);if(n.indexOf(u)!==-1)return;this.containerNodes.add(e.nodeKey(i,a)),i.id in o||(o[i.id]=Object.keys(o).length),r.indexOf(u)===-1&&r.push(u);let d=u.inboundLayers.length;for(let e=0;e<d;e++){let t=u.inputTensors[e],i=u.inboundLayers[e],a=u.nodeIndices[e],o=u.tensorIndices[e];c(t,n,r,i,a,o)}for(n.push(u);r.indexOf(u)>=0;)r.splice(r.indexOf(u),1);s.push(u)},l=[],u=[];for(let e of this.outputs)c(e,l,u);let d=s.slice().reverse();for(let e of d){r[e.id]=e,e.id in n||(n[e.id]=0);let t=n[e.id],o=i[e.outboundLayer.id]==null?0:i[e.outboundLayer.id];t=Math.max(t,o),i[e.outboundLayer.id]=t,a[e.outboundLayer.id]=e.outboundLayer,n[e.id]=t;for(let i=0;i<e.inboundLayers.length;i++){let a=e.inboundLayers[i],o=e.nodeIndices[i],s=a.inboundNodes[o],c=n[s.id]==null?0:n[s.id];n[s.id]=Math.max(t+1,c),r[s.id]=s}}let f={};for(let e in n){let t=n[e];t in f||(f[t]=[]),f[t].push(r[e])}let p={};for(let e in i){let t=i[e];t in p||(p[t]=[]),p[t].push(a[e])}let m=Object.keys(p).map(e=>parseInt(e,10)).sort(uD);this.layers=[];for(let t of m){let n=p[t];n.sort((e,t)=>{let n=o[e.id],r=o[t.id];return n<r?-1:n>r?1:0});for(let t of n)t instanceof e&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=p,m=Object.keys(f).map(e=>parseInt(e,10)).sort(uD);let h=this.inputs.slice(),g=[];for(let e of m)for(let t of f[e]){let e=t.outboundLayer;if(e!=null){for(let n of t.inputTensors)if(h.indexOf(n)===-1)throw new YE(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${e.name}". The following previous layers were accessed without issue: ${g}`);for(let e of t.outputTensors)h.push(e);g.push(e.name)}}this.nodesByDepth=f;let _=this.layers.map(e=>e.name);for(let e of _){let t=_.filter(t=>t===e).length;if(t!==1)throw new YE(`The name "${e}" is used ${t} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(_))}this.outboundNodes=[],this.inboundNodes=[],new $O({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(e=>null),outputMasks:this.outputs.map(e=>null),inputShapes:this.inputs.map(e=>e.shape),outputShapes:this.outputs.map(e=>e.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(let t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(t=>t.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new X(`Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.`);if(!this.trainable)return[];let e=[];for(let t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){let n={},r=0,i=CA(e);i&&this.parseWeights(e);for(let e of this.layers)for(let[t,a]of e.weights.entries()){let e=i?`${a.name.split(`/`).slice(0,-1).join(`/`)+`/`}${t}`:a.originalName;if(n[e]!=null)throw new X(`Duplicate weight name: ${e}`);n[e]=a,r++}let a=[];for(let r in e){let i=r;if(n[r]==null){let e=r.split(`/`);i=e.slice(0,-2).concat([e[e.length-1]]).join(`/`)}if(n[i]!=null)a.push([n[i],e[r]]);else if(t)throw new X(`Provided weight data has no target variable: ${r}`);delete n[i]}if(t){let e=[];for(let t in n)e.push(t);if(e.length>0)throw new X(`${e.length} of ${r} weights are not set: ${e}`)}GO(a)}parseWeights(e){for(let t in Object.keys(e)){let n=t.split(`/`),r=[`vars`,`layer_checkpoint_dependencies`],i=n.map(e=>e.startsWith(`_`)?e.slice(1):e).filter(e=>!r.includes(e)).join(`/`);i!==t&&(e[i]=e[t],delete e[t])}}updatedConfig(){let e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${xA}`,t.backend=`TensorFlow.js`,t}toJSON(e,t=!0){let n=yA(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return B(()=>{e=iD(e);let n=new ck;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return ok(this.outputs,n,t)})}computeMask(e,t){return B(()=>{e=iD(e);let n;return n=t==null?eD(null,e.length):iD(t),this.runInternalGraph(e,n)[1]})}computeOutputShape(e){let t=RO(e);if(t.length!==this.inputLayers.length)throw new X(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);let n={};for(let e=0;e<t.length;e++){let r=this.inputLayers[e],i=t[e],a=r.name+`_0_0`;n[a]=i}let r=Object.keys(this.nodesByDepth).map(e=>parseInt(e,10)).sort(uD);if(r.length>1)for(let e of r){let t=this.nodesByDepth[e];for(let e of t){let t=e.outboundLayer;if(this.inputLayers.map(e=>e.id).indexOf(t.id)!==-1)continue;let r=[];for(let t=0;t<e.inboundLayers.length;t++){let i=e.inboundLayers[t],a=e.nodeIndices[t],o=e.tensorIndices[t],s=`${i.name}_${a}_${o}`,c=n[s];r.push(c)}let i=t.computeOutputShape(rD(r)),a=RO(i),o=t.inboundNodes.indexOf(e);for(let e=0;e<a.length;e++){let r=`${t.name}_${o}_${e}`;n[r]=a[e]}}}let i=[],a=[];for(let e=0;e<this.outputLayers.length;e++){let t=this.outputLayers[e],n=this.outputLayersNodeIndices[e],r=this.outputLayersTensorIndices[e],i=`${t.name}_${n}_${r}`;a.push(i)}for(let e=0;e<a.length;e++){let t=a[e];tD(t in n),i.push(n[t])}return rD(i)}runInternalGraph(e,t){t??=eD(null,e.length);let n={};for(let r=0;r<this.inputs.length;++r){let i=this.inputs[r],a=e[r],o=t[r];n[i.id]=[a,o]}let r=Object.keys(this.nodesByDepth).map(e=>parseInt(e,10)).sort(uD);for(let e of r){let t=this.nodesByDepth[e];for(let e of t){let t=e.outboundLayer,r=e.inputTensors,i=e.outputTensors,a=[];for(let e of r)e.id in n&&a.push(n[e.id]);if(a.length===r.length){let r={},o,s,c,l;if(e.callArgs!=null&&(r=e.callArgs),a.length===1){let[e,n]=a[0];r.mask??=n,c=iD(t.call(e,r)),l=iD(t.computeMask(e,n)),o=[e],s=[n]}else o=a.map(e=>e[0]),s=a.map(e=>e[1]),r.mask??=s,c=iD(t.call(o,r)),l=iD(t.computeMask(o,s));if(t.activityRegularizer)throw new XE(`LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.`);for(let e=0;e<i.length;++e){let t=i[e],r=c[e],a=l[e];n[t.id]=[r,a]}}}}let i=[],a=[],o=[];for(let e of this.outputs){tD(e.id in n,`Could not compute output ${e.name} : ${e.id}`);let[t,r]=n[e.id];o.push(t.shape),i.push(t),a.push(r)}return[i,a,o]}buildNodeConversionMap(t){let n={},r;for(let t of this.layers){r=t instanceof e?1:0;for(let i=0;i<t.inboundNodes.length;i++){let a=e.nodeKey(t,i);this.containerNodes.has(a)&&(n[a]=r,r+=1)}}return n}getLayer(e,t){if(t!=null)return this.findLayer(t);if(e==null)throw new X(`Provide either a layer name or layer index`);if(typeof e==`number`)return this.findLayer(e);for(let t of this.layers)if(t.name===e)return t;throw new X(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new X(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return B(()=>{let t=[];for(let n of this.layers)for(let r=0;r<n.inboundNodes.length;++r){let i=e.nodeKey(n,r);this.containerNodes.has(i)&&t.push(...n.calculateLosses())}return t})}getConfig(){let t={name:this.name},n=this.buildNodeConversionMap(this.layers),r=[];for(let t of this.layers){let i=t.getClassName(),a=t.getConfig(),o=[];for(let r=0;r<t.inboundNodes.length;r++){let i=t.inboundNodes[r],a=e.nodeKey(t,r),s={};if(this.containerNodes.has(a)){if(i.callArgs)try{JSON.stringify(i.callArgs),s=i.callArgs}catch{console.warn(`Layer ${t.name} was passed non-serializable keyword arguments: ${i.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),s={}}if(i.inboundLayers.length>0){let t=[];for(let r=0;r<i.inboundLayers.length;r++){let a=i.inboundLayers[r],o=i.nodeIndices[r],c=i.tensorIndices[r],l=e.nodeKey(a,o),u=n[l];u??=0,t.push([a.name,u,c,s])}o.push(t)}}}let s={};s.name=t.name,s.className=i,s.config=a,s.inboundNodes=o,r.push(s)}t.layers=r;let i=[];for(let t=0;t<this.inputLayers.length;t++){let r=this.inputLayers[t],a=this.inputLayersNodeIndices[t],o=e.nodeKey(r,a);if(!this.containerNodes.has(o))continue;let s=n[o];s??=0;let c=this.inputLayersTensorIndices[t];i.push([r.name,s,c])}t.inputLayers=i;let a=[];for(let t=0;t<this.outputLayers.length;t++){let r=this.outputLayers[t],i=this.outputLayersNodeIndices[t],o=e.nodeKey(r,i);if(!this.containerNodes.has(o))continue;let s=n[o];s??=0;let c=this.outputLayersTensorIndices[t];a.push([r.name,s,c])}return t.outputLayers=a,t}static fromConfig(e,t,n={},r=!1){let i={},a={};function o(e,t){e.name in a?a[e.name].push(t):a[e.name]=[t]}function s(e,t){let n=[],r;for(let a of t){let s=a[0],c=a[1],l=a[2];if(r=a[3]==null?{}:a[3],!(s in i)){o(e,t);return}let u=i[s];if(u.inboundNodes.length<=c){o(e,t);return}let d=u.inboundNodes[c];n.push(d.outputTensors[l])}n.length>0&&e.apply(rD(n),r)}function c(e){let n=e.name,a=Ik(e,t.customObjects==null?{}:t.customObjects);a.setFastWeightInitDuringBuild(r),i[n]=a,e.inboundNodes.forEach(e=>{if(!(e instanceof Array))throw new X(`Corrupted configuration, expected array for nodeData: ${e}`);o(a,e)})}let l=t.name,u=t.layers;for(let e of u)c(e);for(;!Fse(a);)for(let e of u){let t=i[e.name];if(t.name in a){let e=a[t.name];delete a[t.name];for(let n of e)s(t,n)}}let d=[],f=[],p=t.inputLayers;for(let e of p){let t=e[0],n=e[1],r=e[2];tD(t in i);let a=i[t].inboundNodes[n].outputTensors;d.push(a[r])}let m=t.outputLayers;for(let e of m){let t=e[0],n=e[1],r=e[2];tD(t in i);let a=i[t].inboundNodes[n].outputTensors;f.push(a[r])}return new e({inputs:d,outputs:f,name:l})}get stateful(){if(this._stateful)throw new X(`Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.`);for(let e of this.layers)if(e.stateful)return!0;return!1}resetStates(){B(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}}));function ele(e,t,n){let r=t.length;if(e==null||Array.isArray(e)&&e.length===0)return t.map(e=>null);if(r===1)return Array.isArray(e)&&e.length===1?e:typeof e==`object`&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}else if(typeof e==`object`&&Object.keys(e).length>0&&typeof e[Object.keys(e)[0]]==`object`){let n=[];return t.forEach(t=>{t in e?n.push(e[t]):n.push(null)}),n}else throw Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function TA(e,t){return ele(e,t,`classWeight`)}async function EA(e,t,n,r){if(t!=null||r!=null)throw Error(`Support sampleWeight is not implemented yet`);if(n!=null){let t=B(()=>{if(e.shape.length===1)return yc(e);if(e.shape.length===2){if(e.shape[1]>1)return $c(e,1);if(e.shape[1]===1)return W(e,[e.shape[0]]);throw Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),r=Array.from(await t.data());Mo(t);let i=[];return r.forEach(e=>{if(n[e]==null)throw Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);i.push(n[e])}),P_(i,`float32`)}else return null}function tle(e,t){return U(e,t)}var DA=o((()=>{Y()}));function OA(e,t){let n,r,i=t;n=i.xs,r=i.ys,D(n!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let a=kA(`input`,e.inputNames,n),o=kA(`output`,e.outputNames,r),s=a[0].shape[0];D(a.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),D(o.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let t=0;t<a.length;t++)D(a[t].shape[0]===s,()=>`Batch size mismatch: input ${e.inputNames[t]} has ${a[t].shape[0]}; expected  ${s} based on input ${e.inputNames[0]}.`);for(let t=0;t<o.length;t++)D(o[t].shape[0]===s,()=>`Batch size mismatch: output ${e.outputNames[t]} has ${o[t].shape[0]}; expected  ${s} based on input ${e.inputNames[0]}.`);return{xs:a,ys:o}}function kA(e,t,n){if(n instanceof wa)return[n];if(Array.isArray(n))return D(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{let r=[];for(let i of t){if(n[i]==null)throw new X(`The feature data generated by the dataset lacks the required ${e} key '${i}'.`);r.push(n[i])}return r}}function nle(e){if(e.length===3)throw new XE(`Validation with sample weights is not implemented yet.`);return{xs:e[0],ys:e[1]}}async function rle(e,t,n){let r=n.batchesPerEpoch!=null;if(D(e.optimizer!=null,()=>`You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).`),D(n!=null,()=>`For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.`),D(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),D(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),D(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw Error(`Cannot start training because another fit() call is ongoing.`);e.isTraining=!0;try{let i=n.validationData!=null,a,o;if(i)if(AA(n.validationData))D(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{let e=nle(n.validationData);a=e.xs,o=e.ys}let s=e.makeTrainFunction(),c=e.getDedupedMetricsNames(),l;l=i?c.slice().concat(c.map(e=>`val_`+e)):c.slice();let u=Dk(n.callbacks,n.yieldEvery),d=n.verbose==null?1:n.verbose,{callbackList:f,history:p}=Ok(u,d,n.epochs,null,null,ile(t,n),null,i,l);f.setModel(e),e.history=p,await f.onTrainBegin(),e.stopTraining_=!1;let m=n.initialEpoch==null?0:n.initialEpoch,h=await t.iterator();for(;m<n.epochs;){let l={};await f.onEpochBegin(m);let u=0,d=0;for(r||(h=await t.iterator());!r||u<n.batchesPerEpoch;){let t=await h.next();if(r&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${u} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(t.value!=null){let{xs:r,ys:i}=OA(e,t.value),a={};a.batch=d,a.size=r[0].shape[0],await f.onBatchBegin(d,a);let o=[];if(n.classWeight!=null){let t=TA(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)o.push(await EA(i[e],null,t[e]))}let l=r.concat(i).concat(o),p=s(l);Mo(l);for(let e=0;e<c.length;++e){let t=c[e],n=p[e];a[t]=n,No(n)}await f.onBatchEnd(d,a),Tk(a),d++,u++}if(r?u>=n.batchesPerEpoch:t.done){if(i){let t;t=AA(n.validationData)?iD(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):iD(e.evaluate(a,o,{batchSize:n.validationBatchSize==null?jA:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)l[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(await f.onEpochEnd(m,l),m++,e.stopTraining_)break}return await f.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function ile(e,t){let n=null;return t.batchesPerEpoch==null?Number.isFinite(e.size)&&(n=e.size):n=t.batchesPerEpoch,n}function AA(e){return typeof e.iterator==`function`}function ale(e){return typeof e.next==`function`}async function ole(e,t,n){n||={};let r=n.batches!=null,i=e.testFunction,a=[];if(n.verbose>0)throw new XE(`Verbose mode is not implemented yet.`);D(!r||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);let o=ale(t)?t:await t.iterator(),s=0,c=0;for(;!r||c<n.batches;){let t=await o.next();if(a=B(()=>{if(t.value){let{xs:n,ys:r}=OA(e,t.value),o=n.concat(r),l=B(()=>i(o));if(Mo(o),c===0)for(let e=0;e<l.length;++e)a.push(Zf(0));let u=o[0].shape[0];for(let e=0;e<l.length;++e){let t=l[e],n=a[e];a[e]=B(()=>H(a[e],U(u,t))),c>0&&Mo(n)}Mo(l),s+=u,++c}return a}),t.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let e=0;e<a.length;++e){let t=a[e];a[e]=Ac(a[e],s),Mo(t)}return rD(a)}var jA,sle=o((()=>{Y(),Fk(),QE(),Ek(),vD(),DA(),jA=32}));function MA(e){D(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function NA(e,t,n){return e==null?[null]:Array.isArray(e)?e.map(e=>$D(e,t,n-t)):$D(e,t,n-t)}function PA(e,t){return B(()=>e==null?null:Array.isArray(e)?e.map(e=>PA(e,t)):sO(e,t.dtype===`int32`?t:V(t,`int32`)))}function FA(e,t){let n=[],r=0,i=null;for(;r<e;)i=r+t,i>=e&&(i=e),n.push([r,i]),r=i;return n}function IA(e){let t=[];e instanceof wa&&(e=[e]);for(let n=0;n<e.length;++n){let r=e[n];if(r.rank===1)t.push(QD(r,1));else if(r.rank===0)throw Error(`Expected tensor to be at least 1D, but received a 0D tensor (scalar).`);else t.push(r)}return t}function LA(e,t){if(e==null)return;let n=[];if(t instanceof wa)n.push(t.id);else if(Array.isArray(t))t.forEach(e=>n.push(e.id));else if(t!=null)for(let e in t){let r=t[e];n.push(r.id)}let r=[];if(e instanceof wa)n.indexOf(e.id)===-1&&r.push(e);else if(Array.isArray(e))e.forEach(e=>{n.indexOf(e.id)===-1&&r.push(e)});else if(e!=null)for(let t in e){let i=e[t];n.indexOf(i.id)===-1&&r.push(i)}r.forEach(e=>{e.isDisposed||e.dispose()})}var cle=o((()=>{Y(),pO()}));function lle(e){return e instanceof wa}function RA(e){return Array.isArray(e)}function zA(e){return!lle(e)&&!RA(e)}function BA(e,t,n,r=!0,i=``){if(t==null||t.length===0){if(e!=null){let t=!1;if(RA(e)&&e.length>0)t=!0;else if(zA(e)){for(let n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new X(`Error when checking model ${i} expected no data, but got ${e}`)}return[]}if(e==null)return t.map(e=>null);let a;if(zA(e)){e=e,a=[];for(let n of t){if(e[n]==null)throw new X(`No data provided for "${n}". Need data for each key in: ${t}`);a.push(e[n])}}else if(RA(e)){if(e=e,e.length!==t.length)throw new X(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);a=e}else{if(e=e,t.length>1)throw new X(`The model ${i} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);a=[e]}if(a=IA(a),n!=null)for(let e=0;e<t.length;++e){if(n[e]==null)continue;let o=a[e];if(o.shape.length!==n[e].length)throw new X(`Error when checking ${i}: expected ${t[e]} to have ${n[e].length} dimension(s). but got array with shape ${o.shape}`);for(let t=0;t<n[e].length;++t){if(t===0&&!r)continue;let a=o.shape[t],s=n[e][t];if(s!=null&&s>=0&&a!==s)throw new X(`${i} expected a batch of elements where each example has shape [${n[e].slice(1,n[e].length)}] (i.e.,tensor shape [*,${n[e].slice(1,n[e].length)}]) but the ${i} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return a}function ule(e,t,n){let r=dD(e.map(e=>e.shape[0]));r.sort();let i=dD(t.map(e=>e.shape[0]));if(i.sort(),r.length>1)throw new X(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(e=>e.shape))}`);if(i.length>1)throw new X(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(e=>e.shape))}`);if(r.length>0&&i.length>0&&!ge(r,i))throw new X(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${i[0]} target sample(s).`)}function dle(e,t,n){let r=[zk,Wk,Hk];for(let i=0;i<e.length;++i){let a=e[i],o=t[i],s=n[i];if(o!=null){if(o===Hk&&a.shape[a.shape.length-1]===1)throw new X(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(o)!==-1){let e=a.shape.slice(1),t=s.slice(1);for(let n=0;n<e.length;++n){let r=e[n],i=t[n];if(i!=null&&r!==i)throw new X(`A target Tensor with shape ${a.shape} was passed for an output of shape ${s}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function VA(e,t,n,r=!0,i=``){let a;if(Array.isArray(e)){if(e.length!==t.length)throw new X(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);a=e}else{if(t.length>1)throw new X(`The model expects ${t.length} ${i} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);a=[e]}if(n!=null)for(let e=0;e<t.length;++e){if(n[e]==null)continue;let o=a[e];if(o.shape.length!==n[e].length)throw new X(`Error when checking ${i}: expected ${t[e]} to have ${n[e].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let a=0;a<n[e].length;++a){if(a===0&&!r)continue;let s=o.shape[a],c=n[e][a];if(c!=null&&c!==s)throw new X(`Error when checking ${i}: expected ${t[e]} to have shape ${JSON.stringify(n[e])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function fle(e,t){if(e==null||Array.isArray(e)&&e.length===0)return t.map(e=>[]);let n;if(typeof e==`string`||typeof e==`function`)n=[e];else if(Array.isArray(e)||typeof e==`object`)n=e;else throw TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);if(Array.isArray(n))return t.map(e=>n);{let e=[];for(let r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}var HA,UA,WA,GA=o((()=>{Y(),pO(),Fk(),VD(),QE(),Lk(),Ek(),Jk(),fA(),Gce(),Kce(),vD(),Qce(),KD(),bA(),SA(),$ce(),dk(),sle(),cle(),DA(),HA=`layers-model`,UA=class extends wA{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new X(`This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).`);qce(this,e,t,n)}compile(e){if(e.loss??=[],this.loss=e.loss,typeof e.optimizer==`string`)this.optimizer_=Wce(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Ab))throw new X(`User-defined optimizer must be an instance of tf.Optimizer.`);this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!=`string`&&typeof e.loss!=`function`){for(let t in e.loss=e.loss,e.loss)if(this.outputNames.indexOf(t)===-1)throw new X(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(let n of this.outputNames)e.loss[n]??console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(Kk(e.loss[n]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new X(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(e=>Kk(e))}else{let n=Kk(e.loss);this.outputs.forEach(e=>{t.push(n)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let e=0;e<this.outputs.length;++e){let t=this.internalOutputShapes[e],n=this.outputNames[e];this.feedOutputNames.push(n),this.feedOutputShapes.push(t),this.feedLossFns.push(this.lossFunctions[e])}let n=[];this.metrics=e.metrics,this.metricsNames=[`loss`],this.metricsTensors=[],ND(`loss`,()=>{for(let e=0;e<this.outputs.length;++e){if(n.indexOf(e)!==-1)continue;let t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+`_loss`))}});let r=fle(e.metrics,this.outputNames),i=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+`_`+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};ND(`metric`,()=>{for(let e=0;e<this.outputs.length;++e)n.indexOf(e)===-1&&(t=>{let n,r,a;for(let o of t){if(typeof o==`string`&&[`accuracy`,`acc`,`crossentropy`,`ce`].indexOf(o)!==-1){let t=this.internalOutputShapes[e];t[t.length-1]===1||this.lossFunctions[e]===Wk?[`accuracy`,`acc`].indexOf(o)===-1?[`crossentropy`,`ce`].indexOf(o)!==-1&&(r=$k):r=Yk:this.lossFunctions[e]===Uk?[`accuracy`,`acc`].indexOf(o)===-1?[`crossentropy`,`ce`].indexOf(o)!==-1&&(r=uA):r=eA:[`accuracy`,`acc`].indexOf(o)===-1?[`crossentropy`,`ce`].indexOf(o)!==-1&&(r=cA):r=Xk;let i;[`accuracy`,`acc`].indexOf(o)===-1?[`crossentropy`,`ce`].indexOf(o)!==-1&&(i=`ce`):i=`acc`,a=r,n=``+i}else a=Uce(o),n=``+tA(o);let t;ND(n,()=>{t=a}),i(e,n,t)}})(r[e])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){let r=n.batchSize==null?32:n.batchSize;MA(r);let i=this.standardizeUserDataXY(e,t,!0,r);try{let e=i[0].concat(i[1]);this.makeTestFunction();let t=this.testFunction,a=this.testLoop(t,e,r,n.verbose,n.steps);return rD(a)}finally{LA(i[0],e),LA(i[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),ole(this,e,t)}checkNumSamples(e,t,n,r=`steps`){let i;if(n!=null){if(i=null,t!=null)throw new X(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)i=Array.isArray(e)?e[0].shape[0]:e.shape[0];else throw new X(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return i}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new X("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),r=n?t:[t],i=this.retrieveSymbolicTensors(r),a=new ck;if(e instanceof wa&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new X(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)a.add(this.inputs[t],e[t])}else for(let t of this.inputs){let n=e[t.name];if(n==null)throw new X(`No value is provided for the model's input ${t.name}`);a.add(t,n)}let o=ok(i,a);return n?o:o[0]}retrieveSymbolicTensors(e){let t=eD(null,e.length),n=e.length;for(let r of this.layers){let i=Array.isArray(r.output)?r.output:[r.output],a=i.map(e=>e.name);for(let r=0;r<e.length;++r){let o=a.indexOf(e[r]);if(o!==-1&&(t[r]=i[o],n--),n===0)break}if(n===0)break}if(n>0){let n=[];throw t.forEach((t,r)=>{t??n.push(e[r])}),new X(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e,t=32,n=!1){return B(()=>{let r=this.checkNumSamples(e);if(n)throw new XE(`Verbose predictLoop() is not implemented yet.`);let i=FA(r,t),a=this.outputs.map(e=>[]);for(let t=0;t<i.length;++t)B(()=>{let n=i[t][0],r=i[t][1],a=NA(e,n,r),o=[];if(Array.isArray(a))for(let e=0;e<a.length;++e)o.push({key:this.inputs[e],value:a[e]});else o.push({key:this.inputs[0],value:a});let s=new ck(o);return ok(this.outputs,s)}).forEach((e,t)=>a[t].push(e));return rD(a.map(e=>ql(e,0)))})}predict(e,t={}){let n=IA(e);VA(n,this.inputNames,this.feedInputShapes,!1);try{let e=t.batchSize==null?32:t.batchSize;return MA(e),this.predictLoop(n,e)}finally{LA(n,e)}}predictOnBatch(e){VA(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(this.optimizer_==null)throw new YE(`You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).`);let i=[];for(let e=0;e<this.feedOutputShapes.length;++e){let t=this.feedOutputShapes[e];this.feedLossFns[e]===Uk?i.push(t.slice(0,t.length-1).concat([1])):i.push(t)}if(e=BA(e,this.feedInputNames,this.feedInputShapes,!1,`input`),t=BA(t,this.feedOutputNames,i,!1,`target`),ule(e,t,null),dle(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new X(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r,i=!0,a){let[o,s]=this.standardizeUserDataXY(e,t,i,a);if(n!=null)throw Error(`sample weight is not supported yet.`);let c=null;if(r!=null){let e=TA(r,this.outputNames);c=[];for(let t=0;t<e.length;++t)c.push(await EA(s[t],null,e[t]))}return[o,s,c]}testLoop(e,t,n,r=0,i){return B(()=>{let a=this.checkNumSamples(t,n,i,`steps`),o=[];if(r>0)throw new XE(`Verbose mode is not implemented yet.`);if(i!=null)throw new XE(`steps mode in testLoop() is not implemented yet`);{let r=FA(a,n),i=P_(GD(0,a));for(let n=0;n<r.length;++n){let a=r[n][0],s=r[n][1],c=$D(i,a,s-a),l=PA(t,c),u=e(l);if(n===0)for(let e=0;e<u.length;++e)o.push(Zf(0));for(let e=0;e<u.length;++e){let t=u[e];o[e]=H(o[e],U(s-a,t))}}for(let e=0;e<o.length;++e)o[e]=Ac(o[e],a)}return o})}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let r=e[n],i=r;if(nD(e,r)>1){let t=nD(e.slice(0,n),r);i+=`_${t}`}t.push(i)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),a=[],o=()=>{let e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});let o=new ck(e),s=ok(this.outputs,o,{training:!0}),c;for(let e=0;e<this.lossFunctions.length;++e){let n=this.lossFunctions[e],a=n(r[e],s[e]);i[e]!=null&&(a=tle(a,i[e]));let o=rh(a);t.push(o),c=e===0?a:H(c,a)}for(let e=0;e<this.metricsTensors.length;++e){let n;if(this.outputs.length>1&&e<this.outputs.length)n=t[e];else{let t=this.metricsTensors[e][0],i=this.metricsTensors[e][1];n=rh(t(r[i],s[i]))}No(n),a.push(n)}return c=rh(c),this.calculateLosses().forEach(e=>{c=H(c,e)}),c},s=this.collectedTrainableWeights.map(e=>e.read());return[this.optimizer_.minimize(o,!0,s)].concat(a)}}makeTestFunction(){this.testFunction=e=>B(()=>{let t=[],n,r=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let e=0;e<this.inputs.length;++e)a.push({key:this.inputs[e],value:r[e]});let o=new ck(a),s=ok(this.outputs,o);for(let e=0;e<this.lossFunctions.length;++e){let r=this.lossFunctions[e],a=rh(r(i[e],s[e]));n=e===0?a:H(n,a),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){let n=this.metricsTensors[e][0],r=this.metricsTensors[e][1],a=rh(n(i[r],s[r]));t.push(a)}return t})}async fit(e,t,n={}){if(this.isTraining)throw Error(`Cannot start training because another fit() call is ongoing.`);this.isTraining=!0;let r,i,a,o,s,c,l,u,d;try{let f=n.batchSize==null?32:n.batchSize;MA(f);let p=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,!1,f);r=p[0],i=p[1],d=p[2];let m=!1,h;if(n.validationData!=null&&n.validationData.length>0){if(m=!0,n.validationData.length===2)s=n.validationData[0],c=n.validationData[1];else if(n.validationData.length===3)throw new XE(`validationData including sample weights is not supported yet.`);else throw new X(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let e=await this.standardizeUserData(s,c,null,null,!0,f);l=e[0],u=e[1],h=l.concat(u)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){m=!0;let e=Math.floor(r[0].shape[0]*(1-n.validationSplit)),t=r[0].shape[0];l=NA(r,e,t),a=r,r=NA(r,0,e),u=NA(i,e,t),o=i,i=NA(i,0,e),h=l.concat(u)}else n.validationSteps!=null&&(m=!0);let g=r.concat(i).concat(d);this.checkTrainableWeightsConsistency();let _=this.makeTrainFunction(),v=this.getDedupedMetricsNames(),y,b;m?(this.makeTestFunction(),y=this.testFunction,b=v.slice().concat(v.map(e=>`val_`+e))):(y=null,h=[],b=v.slice());let x=Dk(n.callbacks,n.yieldEvery);return await this.fitLoop(_,g,v,f,n.epochs,n.verbose,x,y,h,n.shuffle,b,n.initialEpoch,null,null)}finally{this.isTraining=!1,LA(r,e),LA(i,t),LA(a,e),LA(o,t),LA(l,s),LA(u,c),d!=null&&Mo(d)}}async fitLoop(e,t,n,r,i,a,o,s,c,l,u,d,f,p){r??=32,i??=1,l??=!0,d??=0;let m=!1;if(s!=null&&c!=null&&(m=!0),p!=null&&(m=!0,f==null))throw new X("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let h=this.checkNumSamples(t,r,f,`steps_per_epoch`),g;h!=null&&(g=GD(0,h)),a??=1;let{callbackList:_,history:v}=Ok(o,a,i,d,h,f,r,m,u);_.setModel(this),this.history=v,await _.onTrainBegin(),this.stopTraining_=!1;for(let a=d;a<i;++a){await _.onEpochBegin(a);let i={};if(f!=null)throw new XE(`stepsPerEpoch mode is not implemented yet.`);{if(l===`batch`)throw new XE(`batch shuffling is not implemneted yet`);l&&ie(g);let a=P_(g),o=FA(h,r);for(let l=0;l<o.length;++l){let u={};if(await _.onBatchBegin(l,u),B(()=>{let d=o[l][0],f=o[l][1],p=$D(a,d,f-d);u.batch=l,u.size=f-d;let h=PA(t,p),g=e(h);for(let e=0;e<n.length;++e){let t=n[e],r=g[e];u[t]=r,No(r)}if(l===o.length-1&&m){let e=this.testLoop(s,c,r);for(let t=0;t<n.length;++t){let r=n[t],a=e[t];No(a),i[`val_`+r]=a}}}),await _.onBatchEnd(l,u),Tk(u),this.stopTraining_)break}a.dispose()}if(await _.onEpochEnd(a,i),this.stopTraining_)break}return await _.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return rle(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),r=n[0],i=n[1],a=this.makeTrainFunction()(r.concat(i)),o=[];for(let e of a){let t=await e.data();o.push(t[0])}return Mo(a),LA(n[0],e),LA(n[1],t),rD(o)}getNamedWeights(e){let t=[],n=e!=null&&e.trainableOnly,r=n?this.trainableWeights:this.weights,i=this.getWeights(n);for(let e=0;e<r.length;++e)n&&!r[e].trainable||t.push({name:r[e].originalName,tensor:i[e]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let t=Ao().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-Ao().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss==`string`)e=aD(this.loss);else if(Array.isArray(this.loss)){for(let e of this.loss)if(typeof e!=`string`)throw Error(`Serialization of non-string loss is not supported.`);e=this.loss.map(e=>aD(e))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let r of t)if(typeof n[r]==`string`)e[r]=aD(n[r]);else throw Error(`Serialization of non-string loss is not supported.`)}return e}getMetricIdentifiers(){if(typeof this.metrics==`string`||typeof this.metrics==`function`)return[aD(tA(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>aD(tA(e)));{let e={};for(let t in this.metrics)e[t]=aD(tA(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw Error(`Loading weight_metrics is not supported yet.`);if(e.loss_weights!=null)throw Error(`Loading loss_weights is not supported yet.`);if(e.sample_weight_mode!=null)throw Error(`Loading sample_weight_mode is not supported yet.`);let t=vA(e.optimizer_config),n=Ik(t),r;if(typeof e.loss==`string`)r=oD(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(e=>oD(e));else if(e.loss!=null)for(let t in r={},e.loss)r[t]=oD(e.loss[t]);let i;if(Array.isArray(e.metrics))i=e.metrics.map(e=>oD(e));else if(e.metrics!=null)for(let t in i={},e.metrics)i[t]=oD(e.metrics[t]);this.compile({loss:r,metrics:i,optimizer:n})}async save(e,t){if(typeof e==`string`){let t=xs(e);if(t.length===0)throw new X(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new X(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(e.save==null)throw new X("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await Go(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:HA,generatedBy:`TensorFlow.js tfjs-layers v${xA}`,convertedBy:null};if(t!=null&&t.includeOptimizer&&this.optimizer!=null){r.trainingConfig=this.getTrainingConfig();let{data:e,specs:t}=await Go(await this.optimizer.getWeights(),`optimizer`);n.specs.push(...t),n.data=ns([n.data,e])}return this.userDefinedMetadata!=null&&(pA(this.userDefinedMetadata,this.name,!0),r.userDefinedMetadata=this.userDefinedMetadata),r.weightData=n.data,r.weightSpecs=n.specs,e.save(r)}setUserDefinedMetadata(e){pA(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}},UA.className=`Model`,J(UA),WA=class extends UA{},WA.className=`Functional`,J(WA)}));async function KA(e,t){`modelTopology`in e||(e={modelTopology:e}),e=e;let n=e.modelTopology;n.model_config!=null&&(n=n.model_config);let r=vA(n),i=Ik(r,t);if(e.weightsManifest!=null){let t=await lx(e.weightsManifest,e.pathPrefix,i.weights.map(e=>e.originalName)),n={};for(let e of i.weights)n[e.originalName]=t[e.originalName];i.loadWeights(n),Mo(t)}return i}async function qA(e,t){if(t??={},typeof e==`string`){let n=Ss(e,t);if(n.length===0)n.push(hx(e,t));else if(n.length>1)throw new X(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return JA(e,void 0,t)}async function JA(e,t,n){if(n??={},e.load==null)throw new X("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let r=await e.load(),i=r.modelTopology;i.model_config!=null&&(i=i.model_config);let a=n.strict==null?!0:n.strict,o=r.weightData!=null&&r.weightSpecs!=null&&a,s=Ik(vA(i),t,o),c=r.trainingConfig;if(c!=null&&s.loadTrainingConfig(c),r.userDefinedMetadata!=null&&s.setUserDefinedMetadata(r.userDefinedMetadata),r.weightData!=null){if(r.weightSpecs==null)throw new X(`LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.`);let{modelWeights:e,optimizerWeights:t}=YA(r.weightData,r.weightSpecs);s.loadWeights(e,a),s.optimizer!=null&&t.length>0&&await s.optimizer.setWeights(t),Mo(e),Mo(t.map(e=>e.tensor))}return s}function YA(e,t){let n=Ko(e,t),r={},i=[];return t.forEach(e=>{e.group===`optimizer`?i.push({name:e.name,tensor:n[e.name]}):r[e.name]=n[e.name]}),{modelWeights:r,optimizerWeights:i}}var XA,ZA=o((()=>{Y(),CD(),ak(),nk(),GA(),QE(),Lk(),vD(),bA(),VO(),XA=class e extends UA{constructor(e){if(super({inputs:[],outputs:[]}),e||={},this.trainable=!0,this.built=!1,this.name=e.name==null?bD(`sequential_`):e.name,e.layers!=null)for(let t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(e=>e<0))throw new X(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(t){let n=t instanceof e||t instanceof UA,r;if(n){if(r=t,r.outputs.length!==1)throw new X(`All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.`);if(r.inputs.length!==1)throw new X(`All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.`)}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new X("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let e=rk({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+`_input`});t.apply(e)}if(n)this.outputs=r.outputs,this.inputs=r.inputs;else{if(t.inboundNodes.length!==1)throw new X(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new X(`All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.`);this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=YO(this.outputs[0])}this.inboundNodes=[],new $O({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:eD(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(e=>e.shape),outputShapes:this.outputs[0].shape})}else{let e=t.apply(this.outputs[0]);if(Array.isArray(e))throw TypeError(`All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.`);this.checkShape(t),this.outputs=[e],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw TypeError(`There are no layers in the model.`);if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model??this.build(),this.model.call(e,t)}build(e){if(BO(e),this.inputs.length===0||this.outputs.length===0)throw TypeError(`Sequential model cannot be built: model is empty. Add some layers first.`);this.model=new UA({inputs:this.inputs,outputs:this.outputs[0],name:this.name+`_model`}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){this.model??this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new YE(`The model needs to be compiled before being used.`);return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new YE(`The model needs to be compiled before being used.`);return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model??this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model??this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,n={}){if(!this.built)throw new YE(`The model needs to be compiled before being used.`);return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new YE(`The model needs to be compiled before being used.`);return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(t,n,r={},i=!1){let a,o={};if(n instanceof Array){if(n[0].className==null||n[0].className===`Merge`)throw new X(`Legacy serialization format not supported yet.`);a=n}else D(n.layers!=null,()=>`When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.`),a=n.layers,delete n.layers,o=n;let s=new t(o);if(!(s instanceof e))throw new XE(`Sequential.fromConfig called on non-Sequential input: ${s}`);for(let e of a){let t=Ik(e,void 0,i);i&&t.setFastWeightInitDuringBuild(!0),s.add(t)}return s}set stopTraining(e){if(this.model==null)throw new X(`Cannot set the stopTraining property of a sequential model before it is compiled.`);this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new X(`Cannot get the stopTraining property of a sequential model before it is compiled.`);return this.model.stopTraining}getConfig(){let e=[];for(let t of this.layers){let n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}},XA.className=`Sequential`,J(XA)}));function QA(e){return new UA(e)}function $A(e){return new XA(e)}function ej(e){return rk(e)}function tj(e,t){Pk.registerCallbackConstructor(e,t)}var nj=o((()=>{Fk(),ak(),GA(),ZA()}));function rj(e){return e.getClassName()}function ij(e,t={}){return lD(e,Ob.getMap().classNameMap,t,`activation`)}function aj(e){if(e==null){let e={};return e.className=`linear`,e.config={},ij(e)}if(typeof e==`string`){let t={};return t.className=e,t.config={},ij(t)}else if(e instanceof oj)return e;else return ij(e)}var oj,sj,cj,lj,uj,dj,fj,pj,mj,hj,gj,_j,vj,yj,bj,xj,Sj,Cj=o((()=>{Y(),pO(),vD(),oj=class extends Db{getConfig(){return{}}},sj=class extends oj{apply(e,t=1){return Use(e,t)}},sj.className=`elu`,J(sj),cj=class extends oj{apply(e){return Hg(e)}},cj.className=`selu`,J(cj),lj=class extends oj{apply(e){return Tg(e)}},lj.className=`relu`,J(lj),uj=class extends oj{apply(e){return B(()=>uh(6,Tg(e)))}},uj.className=`relu6`,J(uj),dj=class extends oj{apply(e){return e}},dj.className=`linear`,J(dj),fj=class extends oj{apply(e){return $l(e)}},fj.className=`sigmoid`,J(fj),pj=class extends oj{apply(e){return Gse(e)}},pj.className=`hardSigmoid`,J(pj),mj=class extends oj{apply(e){return Cm(e)}},mj.className=`softplus`,J(mj),hj=class extends oj{apply(e){return Wse(e)}},hj.className=`softsign`,J(hj),gj=class extends oj{apply(e){return au(e)}},gj.className=`tanh`,J(gj),_j=class extends oj{apply(e,t=-1){return c_(e,t)}},_j.className=`softmax`,J(_j),vj=class extends oj{apply(e,t=-1){return jm(e,t)}},vj.className=`logSoftmax`,J(vj),yj=class extends oj{apply(e){return B(()=>B(()=>{let t=U(.5,H(1,jf(Ac(e,Math.sqrt(2)))));return U(e,t)}))}},yj.className=`gelu`,J(yj),bj=class extends oj{apply(e){return B(()=>U(.5,U(e,H(1,au(U(ep(Ac(2,Math.PI)),H(e,U(.044715,Yf(e,3)))))))))}},bj.className=`gelu_new`,J(bj),xj=class extends oj{apply(e){return B(()=>U(e,au(Cm(e))))}},xj.className=`mish`,J(xj),Sj=class extends oj{apply(e,t=1){return B(()=>U($l(U(e,t)),e))}},Sj.className=`swish`,J(Sj)}));function wj(e){if(e!=null&&typeof e!=`object`)throw Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}function Tj(e){return wj(e),new jj({l1:e==null?null:e.l1,l2:0})}function Ej(e){return wj(e),new jj({l2:e==null?null:e.l2,l1:0})}function Dj(e){return sD(e)}function Oj(e,t={}){return lD(e,Ob.getMap().classNameMap,t,`regularizer`)}function kj(e){if(e==null)return null;if(typeof e==`string`){let t={className:e in Mj?Mj[e]:e,config:{}};return Oj(t)}else if(e instanceof Aj)return e;else return Oj(e)}var Aj,jj,Mj,Nj=o((()=>{Y(),pO(),vD(),Aj=class extends Db{},jj=class extends Aj{constructor(e){super(),wj(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return B(()=>{let t=ah([1]);return this.hasL1&&(t=H(t,K(U(this.l1,Fc(e))))),this.hasL2&&(t=H(t,K(U(this.l2,cO(e))))),W(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}},jj.className=`L1L2`,J(jj),Mj={l1l2:`L1L2`}})),Pj,Fj,Ij,Lj,Rj,zj,Bj=o((()=>{Y(),Cj(),Ck(),nk(),QE(),IO(),Nj(),VO(),Pj=class extends tk{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=zO(e);let n=Tg(e);return this.maxValue!=null&&(n=Gu(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}},Pj.className=`ReLU`,J(Pj),Fj=class extends tk{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e??={},this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=zO(e);return em(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}},Fj.className=`LeakyReLU`,J(Fj),Ij=class extends tk{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER=`zeros`,e??={},this.supportsMasking=!0,this.alphaInitializer=vO(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=kj(e.alphaRegularizer),this.alphaConstraint=gk(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes==`number`)this.sharedAxes=[e.sharedAxes];else throw new X(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=BO(e);let t=e.slice(1);if(this.sharedAxes!=null)for(let e of this.sharedAxes)t[e-1]=1;this.alpha=this.addWeight(`alpha`,t,`float32`,this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let t=1;t<e.length;++t)n[t]=e[t];this.inputSpec=[new XO({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=zO(e),Gh(e,this.alpha.read())}getConfig(){let e={alphaInitializer:_O(this.alphaInitializer),alphaRegularizer:Dj(this.alphaRegularizer),alphaConstraint:mk(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}},Ij.className=`PReLU`,J(Ij),Lj=class extends tk{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e??={},e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new XE(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=zO(e);return Tf(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}},Lj.className=`ELU`,J(Lj),Rj=class extends tk{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e??={},this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){let n=zO(e);return U(n,V(Ip(n,this.theta),`float32`))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}},Rj.className=`ThresholdedReLU`,J(Rj),zj=class extends tk{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e??={},this.softmax=new _j().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return B(()=>{let n=zO(e),r=t.mask;if(r!=null){let e=U(q(sh(n.shape),V(r,n.dtype)),Zf(-1e9));n=H(n,e)}return this.axis instanceof Array?this.axis.length>1?hp(q(n,Pm(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)})}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}},zj.className=`Softmax`,J(zj)}));function Vj(e,t,n){if(typeof e==`number`)return eD(e,t);if(e.length!==t)throw new X(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){let i=e[r];if(!zse(i))throw new X(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${i}`)}return e}function Hj(e,t,n,r,i=1){if(e==null)return e;let a=t+(t-1)*(i-1),o;return o=n===`same`?e:e-a+1,Math.floor((o+r-1)/r)}function Uj(e,t,n,r){if(e==null)return null;if(r===`valid`)e=e*t+WD([n-t,0]);else if(r===`same`)e*=t;else throw new X(`Unsupport padding mode: ${r}.`);return e}var Wj=o((()=>{QE(),vD(),KD()}));function Gj(e,t){return B(()=>(AD(t),t===`channelsFirst`?bv(e,[0,2,3,1]):e))}function Kj(e,t){return B(()=>(AD(t),t===`channelsFirst`?bv(e,[0,2,3,4,1]):e))}function qj(e,t,n,r=1,i=`valid`,a,o=1){return B(()=>{if(a??=JD(),AD(a),e.shape.length!==3)throw new X(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(t.shape.length!==3)throw new X(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new X(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if(a===`channelsFirst`&&(e=bv(e,[0,2,1])),i===`causal`)throw new XE(`The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.`);let s=ld(e,t,r,i===`same`?`same`:`valid`,`NWC`,o);return n!=null&&(s=uO(s,n)),s})}function Jj(e,t,n,r=[1,1],i=`valid`,a,o,s=null){return B(()=>{if(a??=JD(),AD(a),e.rank!==3&&e.rank!==4)throw new X(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(t.rank!==3&&t.rank!==4)throw new X(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let c=Gj(e,a);if(i===`causal`)throw new XE(`The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.`);return c=zv({x:c,filter:t,strides:r,pad:i===`same`?`same`:`valid`,dilations:o,dataFormat:`NHWC`,bias:n,activation:s}),a===`channelsFirst`&&(c=bv(c,[0,3,1,2])),c})}function Yj(e,t,n,r=[1,1,1],i=`valid`,a,o){return B(()=>{if(a??=JD(),AD(a),e.rank!==4&&e.rank!==5)throw new X(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(t.rank!==4&&t.rank!==5)throw new X(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let s=Kj(e,a);if(i===`causal`)throw new XE(`The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.`);return s=vd(s,t,r,i===`same`?`same`:`valid`,`NDHWC`,o),n!=null&&(s=uO(s,n)),a===`channelsFirst`&&(s=bv(s,[0,4,1,2,3])),s})}var Xj,Zj,Qj,$j,eM,tM,nM,rM,iM,aM,oM,sM=o((()=>{Y(),Cj(),XD(),pO(),VD(),Ck(),nk(),QE(),IO(),Nj(),Wj(),vD(),VO(),Xj=class e extends tk{constructor(t,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER=`glorotNormal`,this.DEFAULT_BIAS_INITIALIZER=`zeros`,e.verifyArgs(n),this.rank=t,mD(this.rank,`rank`),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new XE(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Vj(n.kernelSize,t,`kernelSize`),this.strides=Vj(n.strides==null?1:n.strides,t,`strides`),this.padding=n.padding==null?`valid`:n.padding,jD(this.padding),this.dataFormat=n.dataFormat==null?`channelsLast`:n.dataFormat,AD(this.dataFormat),this.activation=aj(n.activation),this.useBias=n.useBias==null?!0:n.useBias,this.biasInitializer=vO(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=gk(n.biasConstraint),this.biasRegularizer=kj(n.biasRegularizer),this.activityRegularizer=kj(n.activityRegularizer),this.dilationRate=Vj(n.dilationRate==null?1:n.dilationRate,t,`dilationRate`),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new X(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate==`number`)this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new X(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate==`number`)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new X(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(tD(`kernelSize`in e,`required key 'kernelSize' not in config`),typeof e.kernelSize!=`number`&&!pD(e.kernelSize,`number`,1,3))throw new X(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){let e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:rj(this.activation),useBias:this.useBias,biasInitializer:_O(this.biasInitializer),biasRegularizer:Dj(this.biasRegularizer),activityRegularizer:Dj(this.activityRegularizer),biasConstraint:mk(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}},Zj=class e extends Xj{constructor(t,n){super(t,n),this.kernel=null,e.verifyArgs(n),this.filters=n.filters,mD(this.filters,`filters`),this.kernelInitializer=vO(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=gk(n.kernelConstraint),this.kernelRegularizer=kj(n.kernelRegularizer)}build(e){e=BO(e);let t=this.dataFormat===`channelsFirst`?1:e.length-1;if(e[t]==null)throw new X(`The channel dimension of the input should be defined. Found ${e[t]}`);let n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight(`kernel`,r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight(`bias`,[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return B(()=>{e=zO(e);let t,n=this.bias==null?null:this.bias.read(),r=gD(this.activation.getClassName());if(r!=null&&this.rank===2)t=Jj(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(this.rank===1)t=qj(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)t=Jj(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)t=Yj(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new XE(`convolutions greater than 3D are not implemented yet.`);this.activation!=null&&(t=this.activation.apply(t))}return t})}computeOutputShape(e){e=BO(e);let t=[],n=this.dataFormat===`channelsLast`?e.slice(1,e.length-1):e.slice(2);for(let e=0;e<n.length;++e){let r=Hj(n[e],this.kernelSize[e],this.padding,this.strides[e],typeof this.dilationRate==`number`?this.dilationRate:this.dilationRate[e]);t.push(r)}let r=[e[0]];return this.dataFormat===`channelsLast`?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){let e={filters:this.filters,kernelInitializer:_O(this.kernelInitializer),kernelRegularizer:Dj(this.kernelRegularizer),kernelConstraint:mk(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!(`filters`in e)||typeof e.filters!=`number`||e.filters<1)throw new X(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}},Qj=class e extends Zj{constructor(t){super(2,t),e.verifyArgs(t)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!=`number`&&!pD(e.kernelSize,`number`,1,2))throw new X(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}},Qj.className=`Conv2D`,J(Qj),$j=class e extends Zj{constructor(t){super(3,t),e.verifyArgs(t)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!=`number`&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new X(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}},$j.className=`Conv3D`,J($j),eM=class extends Qj{constructor(e){if(super(e),this.inputSpec=[new XO({ndim:4})],this.padding!==`same`&&this.padding!==`valid`)throw new X(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=BO(e),e.length!==4)throw new X(`Input should have rank 4; Received input shape: `+JSON.stringify(e));let t=this.dataFormat===`channelsFirst`?1:e.length-1;if(e[t]==null)throw new X("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight(`kernel`,r,`float32`,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight(`bias`,[this.filters],`float32`,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new XO({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return B(()=>{let t=zO(e);if(t.shape.length!==4)throw new X(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);let n=t.shape,r=n[0],i,a;this.dataFormat===`channelsFirst`?(i=2,a=3):(i=1,a=2);let o=n[i],s=n[a],c=this.kernelSize[0],l=this.kernelSize[1],u=this.strides[0],d=this.strides[1],f=Uj(o,u,c,this.padding),p=Uj(s,d,l,this.padding),m=[r,f,p,this.filters];this.dataFormat!==`channelsLast`&&(t=bv(t,[0,2,3,1]));let h=hd(t,this.kernel.read(),m,this.strides,this.padding);return this.dataFormat!==`channelsLast`&&(h=bv(h,[0,3,1,2])),this.bias!=null&&(h=uO(h,this.bias.read(),this.dataFormat)),this.activation!=null&&(h=this.activation.apply(h)),h})}computeOutputShape(e){e=BO(e);let t=e.slice(),n,r,i;this.dataFormat===`channelsFirst`?(n=1,r=2,i=3):(n=3,r=1,i=2);let a=this.kernelSize[0],o=this.kernelSize[1],s=this.strides[0],c=this.strides[1];return t[n]=this.filters,t[r]=Uj(t[r],s,a,this.padding),t[i]=Uj(t[i],c,o,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}},eM.className=`Conv2DTranspose`,J(eM),tM=class extends $j{constructor(e){if(super(e),this.inputSpec=[new XO({ndim:5})],this.padding!==`same`&&this.padding!==`valid`)throw new X(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=BO(e),e.length!==5)throw new X(`Input should have rank 5; Received input shape: `+JSON.stringify(e));let t=this.dataFormat===`channelsFirst`?1:e.length-1;if(e[t]==null)throw new X("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight(`kernel`,r,`float32`,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight(`bias`,[this.filters],`float32`,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new XO({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return B(()=>{let t=zO(e);if(t.shape.length!==5)throw new X(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);let n=t.shape,r=n[0],i,a,o;this.dataFormat===`channelsFirst`?(o=2,i=3,a=4):(o=1,i=2,a=3);let s=n[o],c=n[i],l=n[a],u=this.kernelSize[0],d=this.kernelSize[1],f=this.kernelSize[2],p=this.strides[0],m=this.strides[1],h=this.strides[2],g=Uj(s,p,u,this.padding),_=Uj(c,m,d,this.padding),v=Uj(l,h,f,this.padding),y=[r,g,_,v,this.filters];this.dataFormat!==`channelsLast`&&(t=bv(t,[0,2,3,4,1]));let b=wd(t,this.kernel.read(),y,this.strides,this.padding);return this.dataFormat!==`channelsLast`&&(b=bv(b,[0,4,1,2,3])),this.bias!==null&&(b=uO(b,this.bias.read(),this.dataFormat)),this.activation!==null&&(b=this.activation.apply(b)),b})}computeOutputShape(e){e=BO(e);let t=e.slice(),n,r,i,a;this.dataFormat===`channelsFirst`?(n=1,r=2,i=3,a=4):(n=4,r=1,i=2,a=3);let o=this.kernelSize[0],s=this.kernelSize[1],c=this.kernelSize[2],l=this.strides[0],u=this.strides[1],d=this.strides[2];return t[n]=this.filters,t[r]=Uj(t[r],l,o,this.padding),t[i]=Uj(t[i],u,s,this.padding),t[a]=Uj(t[a],d,c,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}},tM.className=`Conv3DTranspose`,J(tM),nM=class extends Zj{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER=`glorotUniform`,this.DEFAULT_POINTWISE_INITIALIZER=`glorotUniform`,this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new X("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new X(`Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.`);if(t.padding!=null&&t.padding!==`same`&&t.padding!==`valid`)throw new X(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=vO(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=kj(t.depthwiseRegularizer),this.depthwiseConstraint=gk(t.depthwiseConstraint),this.pointwiseInitializer=vO(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=kj(t.pointwiseRegularizer),this.pointwiseConstraint=gk(t.pointwiseConstraint)}build(e){if(e=BO(e),e.length<this.rank+2)throw new X(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t=this.dataFormat===`channelsFirst`?1:e.length-1;if(e[t]==null||e[t]<0)throw new X(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),i=[];for(let e=0;e<this.rank;++e)i.push(1);i.push(n*this.depthMultiplier,this.filters),this.depthwiseKernel=this.addWeight(`depthwise_kernel`,r,`float32`,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight(`pointwise_kernel`,i,`float32`,this.pointwiseInitializer,this.pointwiseRegularizer,!0,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight(`bias`,[this.filters],`float32`,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.inputSpec=[new XO({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return B(()=>{e=zO(e);let t;if(this.rank===1)throw new XE(`1D separable convolution is not implemented yet.`);return this.rank===2&&(this.dataFormat===`channelsFirst`&&(e=bv(e,[0,2,3,1])),t=Gg(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,`NHWC`)),this.useBias&&(t=uO(t,this.bias.read(),this.dataFormat)),this.activation!=null&&(t=this.activation.apply(t)),this.dataFormat===`channelsFirst`&&(t=bv(t,[0,3,1,2])),t})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=_O(this.depthwiseInitializer),e.pointwiseInitializer=_O(this.pointwiseInitializer),e.depthwiseRegularizer=Dj(this.depthwiseRegularizer),e.pointwiseRegularizer=Dj(this.pointwiseRegularizer),e.depthwiseConstraint=mk(this.depthwiseConstraint),e.pointwiseConstraint=mk(this.pointwiseConstraint),e}},nM.className=`SeparableConv`,rM=class extends nM{constructor(e){super(2,e)}},rM.className=`SeparableConv2D`,J(rM),iM=class e extends Zj{constructor(t){super(1,t),e.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!=`number`&&!pD(e.kernelSize,`number`,1,1))throw new X(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}},iM.className=`Conv1D`,J(iM),aM=class extends tk{constructor(e){super(e),typeof e.cropping==`number`?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]==`number`?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?`channelsLast`:e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat===`channelsFirst`?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return B(()=>{if(e=zO(e),this.dataFormat===`channelsLast`){let t=tO(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return tO(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let t=tO(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return tO(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},aM.className=`Cropping2D`,J(aM),oM=class extends tk{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?`channelsLast`:e.dataFormat,AD(this.dataFormat),this.interpolation=e.interpolation==null?`nearest`:e.interpolation,Lse(this.interpolation)}computeOutputShape(e){if(this.dataFormat===`channelsFirst`){let t=e[2]==null?null:this.size[0]*e[2],n=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,n]}else{let t=e[1]==null?null:this.size[0]*e[1],n=e[2]==null?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return B(()=>{let t=zO(e),n=t.shape;if(this.dataFormat===`channelsFirst`){t=bv(t,[0,2,3,1]);let e=this.size[0]*n[2],r=this.size[1]*n[3],i=this.interpolation===`nearest`?_b.resizeNearestNeighbor(t,[e,r]):_b.resizeBilinear(t,[e,r]);return bv(i,[0,3,1,2])}else{let e=this.size[0]*n[1],r=this.size[1]*n[2];return this.interpolation===`nearest`?_b.resizeNearestNeighbor(t,[e,r]):_b.resizeBilinear(t,[e,r])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}},oM.className=`UpSampling2D`,J(oM)}));function cM(e,t,n=[1,1],r=`valid`,i,a){return B(()=>{i??=JD(),AD(i);let o=Gj(e,i);if(e.rank!==4)throw new X(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(t.rank!==4)throw new X(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return o=Gd(o,t,n,r===`same`?`same`:`valid`,`NHWC`,a),i===`channelsFirst`&&(o=bv(o,[0,3,1,2])),o})}var lM,uM=o((()=>{Y(),XD(),pO(),VD(),Ck(),QE(),IO(),Nj(),Wj(),VO(),sM(),lM=class extends Xj{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=vO(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=gk(e.depthwiseConstraint),this.depthwiseRegularizer=kj(e.depthwiseRegularizer)}build(e){if(e=BO(e),e.length<4)throw new X(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t=this.dataFormat===`channelsFirst`?1:3;if(e[t]==null||e[t]<0)throw new X(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight(`depthwise_kernel`,r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight(`bias`,[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return B(()=>{e=zO(e);let t=cM(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=uO(t,this.bias.read(),this.dataFormat)),this.activation!=null&&(t=this.activation.apply(t)),t})}computeOutputShape(e){e=BO(e);let t=this.dataFormat===`channelsFirst`?e[2]:e[1],n=this.dataFormat===`channelsFirst`?e[3]:e[2],r=this.dataFormat===`channelsFirst`?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=Hj(t,this.kernelSize[0],this.padding,this.strides[0]),a=Hj(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat===`channelsFirst`?[e[0],r,i,a]:[e[0],i,a,r]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=_O(this.depthwiseInitializer),e.depthwiseRegularizer=Dj(this.depthwiseRegularizer),e.depthwiseConstraint=mk(this.depthwiseRegularizer),e}},lM.className=`DepthwiseConv2D`,J(lM)}));function dM(e,t,n,r){if(Array.isArray(e)){if(t!=null||n!=null)throw new X(`When inputs is an array, neither initialState or constants should be provided`);r!=null&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function i(e){return e==null||Array.isArray(e)?e:[e]}return t=i(t),n=i(n),{inputs:e,initialState:t,constants:n}}function fM(e,t,n,r=!1,i,a,o=!1,s=!1){return B(()=>{let c=t.shape.length;if(c<3)throw new X(`Input should be at least 3D, but is ${c}D.`);let l=[1,0].concat(GD(2,c));if(t=bv(t,l),a!=null)throw new XE(`The rnn() functoin of the deeplearn.js backend does not support constants yet.`);o&&console.warn(`Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend.`),i!=null&&(i=V(V(i,`bool`),`float32`),i.rank===c-1&&(i=vp(i,-1)),i=bv(i,l)),r&&(t=Ag(t,0),i!=null&&(i=Ag(i,0)));let u=[],d,f=n,p=t.shape[0],m=dv(t),h;i!=null&&(h=dv(i));for(let t=0;t<p;++t){let n=m[t],r=B(()=>e(n,f));if(i==null)d=r[0],f=r[1];else{let e=B(()=>{let e=h[t],n=q(wh(e),e),i=H(U(r[0],e),U(f[0],n)),a=f.map((t,i)=>H(U(r[1][i],e),U(t,n)));return{output:i,newStates:a}});d=e.output,f=e.newStates}s&&u.push(d)}let g;return s&&(g=C_(u,1)),[d,g,f]})}function pM(e){let{ones:t,rate:n,training:r=!1,count:i=1,dropoutFunc:a}=e,o=()=>a==null?dO(t(),n):a(t(),n),s=()=>fO(o,t,r);return!i||i<=1?No(s().clone()):Array(i).fill(void 0).map(s).map(e=>No(e.clone()))}var mM,hM,gM,_M,vM,yM,bM,xM,SM,CM=o((()=>{Y(),Cj(),pO(),VD(),Ck(),nk(),QE(),IO(),Nj(),vD(),KD(),VO(),JO(),Lk(),mM=class e extends tk{constructor(e){super(e);let t;if(e.cell==null)throw new X(`cell property is missing for the constructor of RNN.`);if(t=Array.isArray(e.cell)?new SM({cells:e.cell}):e.cell,t.stateSize==null)throw new X("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new XO({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return GD(0,e).map(e=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){LO(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);let n=t[0],r;if(r=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){let n=[];for(let r of t)n.push([e[0],r]);return[r].concat(n)}else return r}computeMask(e,t){return B(()=>{Array.isArray(t)&&(t=t[0]);let e=this.returnSequences?t:null;if(this.returnState){let t=this.states.map(e=>null);return[e].concat(t)}else return e})}get states(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new XE(`Constants support is not implemented in RNN yet.`);LO(e)&&(e=e[0]),e=e;let t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new XO({shape:[t,null,...n]});let r=[e[0]].concat(e.slice(2));this.cell.build(r);let i;if(i=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],this.stateSpec!=null){if(!ge(this.stateSpec.map(e=>e.shape[e.shape.length-1]),i))throw new X(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(e=>new XO({shape:[null,e]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){B(()=>{if(!this.stateful)throw new JE(`Cannot call resetStates() on an RNN Layer that is not stateful.`);let n=this.inputSpec[0].shape[0];if(n==null)throw new X("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(e=>ah([n,e])):this.states_=[ah([n,this.cell.stateSize])];else if(e==null)Mo(this.states_),this.keptStates!=null&&(Mo(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(e=>ah([n,e])):this.states_[0]=ah([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new X(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):Mo(this.states_);for(let t=0;t<this.states_.length;++t){let r=e[t],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,a=[n,i];if(!ge(r.shape,a))throw new X(`State ${t} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${r.shape}`);this.states_[t]=r}}this.states_=this.states_.map(e=>No(e.clone()))})}apply(e,t){let n=t==null?null:t.initialState,r=t==null?null:t.constants;t??={};let i=dM(e,n,r,this.numConstants);e=i.inputs,n=i.initialState,r=i.constants;let a=[],o=[];if(n!=null){t.initialState=n,a=a.concat(n),this.stateSpec=[];for(let e of n)this.stateSpec.push(new XO({shape:e.shape}));o=o.concat(this.stateSpec)}if(r!=null&&(t.constants=r,a=a.concat(r),this.numConstants=r.length),a[0]instanceof ZO){let n=[e].concat(a),r=this.inputSpec.concat(o),i=this.inputSpec;this.inputSpec=r;let s=super.apply(n,t);return this.inputSpec=i,s}else return super.apply(e,t)}call(e,t){return B(()=>{let n=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;e=zO(e),i??=this.stateful?this.states_:this.getInitialState(e);let a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==a)throw new X(`RNN Layer has ${a} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn(`Ignoring unroll = true for RNN layer, due to imperative backend.`);let o={training:r},s=fM((e,t)=>{let n=this.cell.call([e].concat(t),o);return[n[0],n.slice(1)]},e,i,this.goBackwards,n,null,this.unroll,this.returnSequences),c=s[0],l=s[1],u=s[2];this.stateful&&this.resetStates(u,r);let d=this.returnSequences?l:c;return this.returnState?[d].concat(u):d})}getInitialState(e){return B(()=>{let t=ah(e.shape);return t=K(t,[1,2]),t=QD(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(e=>e>1?iO(t,[1,e]):t):this.cell.stateSize>1?[iO(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){let t=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);let r=this.cell.getConfig();return this.getClassName()===e.className&&(n.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),t),n)}static fromConfig(e,t,n={}){let r=t.cell,i=Ik(r,n);return new e(Object.assign(t,{cell:i}))}},mM.className=`RNN`,J(mM),hM=class extends tk{},gM=class extends hM{constructor(e){super(e),this.DEFAULT_ACTIVATION=`tanh`,this.DEFAULT_KERNEL_INITIALIZER=`glorotNormal`,this.DEFAULT_RECURRENT_INITIALIZER=`orthogonal`,this.DEFAULT_BIAS_INITIALIZER=`zeros`,this.units=e.units,mD(this.units,`units`),this.activation=aj(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=vO(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=vO(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=vO(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=kj(e.kernelRegularizer),this.recurrentRegularizer=kj(e.recurrentRegularizer),this.biasRegularizer=kj(e.biasRegularizer),this.kernelConstraint=gk(e.kernelConstraint),this.recurrentConstraint=gk(e.recurrentConstraint),this.biasConstraint=gk(e.biasConstraint),this.dropout=UD([1,WD([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=UD([1,WD([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=BO(e),this.kernel=this.addWeight(`kernel`,[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight(`recurrent_kernel`,[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight(`bias`,[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return B(()=>{if(e=e,e.length!==2)throw new X(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let r=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=pM({ones:()=>wh(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=pM({ones:()=>wh(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let i,a=this.dropoutMask,o=this.recurrentDropoutMask;i=oO(a==null?e:U(e,a),this.kernel.read()),this.bias!=null&&(i=uO(i,this.bias.read())),o!=null&&(n=U(n,o));let s=H(i,oO(n,this.recurrentKernel.read()));return this.activation!=null&&(s=this.activation.apply(s)),[s,s]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:rj(this.activation),useBias:this.useBias,kernelInitializer:_O(this.kernelInitializer),recurrentInitializer:_O(this.recurrentInitializer),biasInitializer:_O(this.biasInitializer),kernelRegularizer:Dj(this.kernelRegularizer),recurrentRegularizer:Dj(this.recurrentRegularizer),biasRegularizer:Dj(this.biasRegularizer),activityRegularizer:Dj(this.activityRegularizer),kernelConstraint:mk(this.kernelConstraint),recurrentConstraint:mk(this.recurrentConstraint),biasConstraint:mk(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}},gM.className=`SimpleRNNCell`,J(gM),_M=class extends mM{constructor(e){e.cell=new gM(e),super(e)}call(e,t){return B(()=>{this.cell.dropoutMask!=null&&(Mo(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Mo(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:i})})}static fromConfig(e,t){return new e(t)}},_M.className=`SimpleRNN`,J(_M),vM=class extends hM{constructor(e){if(super(e),this.DEFAULT_ACTIVATION=`tanh`,this.DEFAULT_RECURRENT_ACTIVATION=`hardSigmoid`,this.DEFAULT_KERNEL_INITIALIZER=`glorotNormal`,this.DEFAULT_RECURRENT_INITIALIZER=`orthogonal`,this.DEFAULT_BIAS_INITIALIZER=`zeros`,e.resetAfter)throw new X(`GRUCell does not support reset_after parameter set to true.`);this.units=e.units,mD(this.units,`units`),this.activation=aj(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=aj(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=vO(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=vO(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=vO(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=kj(e.kernelRegularizer),this.recurrentRegularizer=kj(e.recurrentRegularizer),this.biasRegularizer=kj(e.biasRegularizer),this.kernelConstraint=gk(e.kernelConstraint),this.recurrentConstraint=gk(e.recurrentConstraint),this.biasConstraint=gk(e.biasConstraint),this.dropout=UD([1,WD([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=UD([1,WD([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=BO(e);let t=e[e.length-1];this.kernel=this.addWeight(`kernel`,[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight(`recurrent_kernel`,[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight(`bias`,[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return B(()=>{if(e=e,e.length!==2)throw new X(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training==null?!1:t.training,r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=pM({ones:()=>wh(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=pM({ones:()=>wh(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let i=this.dropoutMask,a=this.recurrentDropoutMask,o,s,c;0<this.dropout&&this.dropout<1&&(e=U(e,i[0]));let l=oO(e,this.kernel.read());this.useBias&&(l=uO(l,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=U(r,a[0]));let u=this.recurrentKernel.read(),[d,f]=h_(u,[2*this.units,this.units],u.rank-1),p=oO(r,d),[m,h,g]=h_(l,3,l.rank-1),[_,v]=h_(p,2,p.rank-1);o=this.recurrentActivation.apply(H(m,_)),s=this.recurrentActivation.apply(H(h,v));let y=oO(U(s,r),f);c=this.activation.apply(H(g,y));let b=H(U(o,r),U(H(1,bm(o)),c));return[b,b]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:rj(this.activation),recurrentActivation:rj(this.recurrentActivation),useBias:this.useBias,kernelInitializer:_O(this.kernelInitializer),recurrentInitializer:_O(this.recurrentInitializer),biasInitializer:_O(this.biasInitializer),kernelRegularizer:Dj(this.kernelRegularizer),recurrentRegularizer:Dj(this.recurrentRegularizer),biasRegularizer:Dj(this.biasRegularizer),activityRegularizer:Dj(this.activityRegularizer),kernelConstraint:mk(this.kernelConstraint),recurrentConstraint:mk(this.recurrentConstraint),biasConstraint:mk(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}},vM.className=`GRUCell`,J(vM),yM=class extends mM{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new vM(e),super(e)}call(e,t){return B(()=>{this.cell.dropoutMask!=null&&(Mo(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Mo(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:i})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}},yM.className=`GRU`,J(yM),bM=class extends hM{constructor(e){super(e),this.DEFAULT_ACTIVATION=`tanh`,this.DEFAULT_RECURRENT_ACTIVATION=`hardSigmoid`,this.DEFAULT_KERNEL_INITIALIZER=`glorotNormal`,this.DEFAULT_RECURRENT_INITIALIZER=`orthogonal`,this.DEFAULT_BIAS_INITIALIZER=`zeros`,this.units=e.units,mD(this.units,`units`),this.activation=aj(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=aj(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=vO(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=vO(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=vO(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=kj(e.kernelRegularizer),this.recurrentRegularizer=kj(e.recurrentRegularizer),this.biasRegularizer=kj(e.biasRegularizer),this.kernelConstraint=gk(e.kernelConstraint),this.recurrentConstraint=gk(e.recurrentConstraint),this.biasConstraint=gk(e.biasConstraint),this.dropout=UD([1,WD([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=UD([1,WD([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=BO(e);let n=e[e.length-1];this.kernel=this.addWeight(`kernel`,[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight(`recurrent_kernel`,[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){let e=this.biasInitializer,n=this.units;r=new(t=class extends yO{apply(t,r){let i=e.apply([n]),a=new xO().apply([n]),o=e.apply([n*2]);return rO(rO(i,a),o)}},t.className=`CustomInit`,t)}else r=this.biasInitializer;this.bias=this.addWeight(`bias`,[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return B(()=>{let n=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new X(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1],i=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=pM({ones:()=>wh(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=pM({ones:()=>wh(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let a=this.dropoutMask,o=this.recurrentDropoutMask,s,c,l,u;0<this.dropout&&this.dropout<1&&(e=U(e,a[0]));let d=oO(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=U(r,o[0])),d=H(d,oO(r,this.recurrentKernel.read())),this.useBias&&(d=uO(d,this.bias.read()));let[f,p,m,h]=h_(d,4,d.rank-1);s=this.recurrentActivation.apply(f),c=this.recurrentActivation.apply(p),l=H(U(c,i),U(s,this.activation.apply(m))),u=this.recurrentActivation.apply(h);let g=U(u,this.activation.apply(l));return[g,g,l]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:rj(this.activation),recurrentActivation:rj(this.recurrentActivation),useBias:this.useBias,kernelInitializer:_O(this.kernelInitializer),recurrentInitializer:_O(this.recurrentInitializer),biasInitializer:_O(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Dj(this.kernelRegularizer),recurrentRegularizer:Dj(this.recurrentRegularizer),biasRegularizer:Dj(this.biasRegularizer),activityRegularizer:Dj(this.activityRegularizer),kernelConstraint:mk(this.kernelConstraint),recurrentConstraint:mk(this.recurrentConstraint),biasConstraint:mk(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}},bM.className=`LSTMCell`,J(bM),xM=class extends mM{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new bM(e),super(e)}call(e,t){return B(()=>{this.cell.dropoutMask!=null&&(Mo(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Mo(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:i})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}},xM.className=`LSTM`,J(xM),SM=class extends hM{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return B(()=>{e=e;let n=e.slice(1),r=[];for(let e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(n.splice(0,e.stateSize.length)):r.push(n.splice(0,1));r.reverse();let i=[],a;for(let o=0;o<this.cells.length;++o){let s=this.cells[o];n=r[o],a=o===0?[e[0]].concat(n):[a[0]].concat(n),a=s.call(a,t),i.push(a.slice(1))}n=[];for(let e of i.slice().reverse())n.push(...e);return[a[0]].concat(n)})}build(e){LO(e)&&(e=e[0]),e=e;let t;this.cells.forEach((n,r)=>{ND(`RNNCell_${r}`,()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){let e=super.getConfig(),t={cells:this.cells.map(e=>({className:e.getClassName(),config:e.getConfig()}))};return Object.assign(Object.assign({},e),t)}static fromConfig(e,t,n={}){let r=[];for(let e of t.cells)r.push(Ik(e,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return WO(e)}setWeights(e){let t=[];for(let n of this.cells){let r=n.weights.length,i=e.splice(r);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],i[e]])}GO(t)}},SM.className=`StackedRNNCells`,J(SM)})),wM,TM,EM,DM,OM=o((()=>{Y(),pO(),VD(),nk(),QE(),IO(),Wj(),vD(),VO(),CM(),wM=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(e!=null&&typeof Object.getOwnPropertySymbols==`function`)for(var i=0,r=Object.getOwnPropertySymbols(e);i<r.length;i++)t.indexOf(r[i])<0&&Object.prototype.propertyIsEnumerable.call(e,r[i])&&(n[r[i]]=e[r[i]]);return n},TM=class extends mM{constructor(e){if(e.unroll)throw new XE(`Unrolling is not possible with convolutional RNNs.`);if(Array.isArray(e.cell))throw new XE(`It is not possible at the moment to stack convolutional cells.`);super(e),this.inputSpec=[new XO({ndim:5})]}call(e,t){return B(()=>{if(this.cell.dropoutMask!=null&&(Mo(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Mo(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new X(`ConvRNN2D cell does not support constants`);let n=t==null?null:t.mask,r=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:i})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...[,,].fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return B(()=>{let{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),i=[r[0],...r.slice(2)],a=ah(i);return Array.isArray(t)?Array(t.length).fill(a):[a]})}resetStates(e,t=!1){B(()=>{if(!this.stateful)throw new JE(`Cannot call resetStates() on an RNN Layer that is not stateful.`);let n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),i=[r[0],...r.slice(2)];if(n[0]==null)throw new X("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ah(i)):this.states_=[ah(i)];else if(e==null)Mo(this.states_),this.keptStates!=null&&(Mo(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ah(i)):this.states_[0]=ah(i);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new X(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Mo(this.states_);for(let t=0;t<this.states_.length;++t){let n=e[t],r=i;if(!ge(n.shape,r))throw new X(`State ${t} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map(e=>No(e.clone()))})}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:r,padding:i,strides:a,dilationRate:o}=this.cell,s=t===`channelsFirst`,c=e[s?3:2],l=e[s?4:3],u=Hj(c,r[0],i,a[0],o[0]),d=Hj(l,r[1],i,a[1],o[1]);return[...e.slice(0,2),...s?[n,u,d]:[u,d,n]]}},TM.className=`ConvRNN2D`,EM=class extends bM{constructor(e){let{filters:t,kernelSize:n,strides:r,padding:i,dataFormat:a,dilationRate:o}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,mD(this.filters,`filters`),this.kernelSize=Vj(n,2,`kernelSize`),this.kernelSize.forEach(e=>mD(e,`kernelSize`)),this.strides=Vj(r||1,2,`strides`),this.strides.forEach(e=>mD(e,`strides`)),this.padding=i||`valid`,jD(this.padding),this.dataFormat=a||`channelsLast`,AD(this.dataFormat),this.dilationRate=Vj(o||1,2,`dilationRate`),this.dilationRate.forEach(e=>mD(e,`dilationRate`))}build(e){var t;e=BO(e);let n=this.dataFormat===`channelsFirst`?1:e.length-1;if(e[n]==null)throw new X(`The channel dimension of the input should be defined. Found ${e[n]}`);let r=e[n],i=this.kernelSize.concat([r,this.filters*4]);this.kernel=this.addWeight(`kernel`,i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let a=this.kernelSize.concat([this.filters,this.filters*4]);if(this.recurrentKernel=this.addWeight(`recurrent_kernel`,a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){let n=this.biasInitializer,r=this.filters;e=new(t=class extends yO{apply(e,t){let i=n.apply([r]),a=sh([r]),o=n.apply([r*2]);return nO([i,a,o])}},t.className=`CustomInit`,t)}else e=this.biasInitializer;this.bias=this.addWeight(`bias`,[this.filters*4],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return B(()=>{if(e.length!==3)throw new X(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,r=e[0],i=e[1],a=e[2];0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=pM({ones:()=>wh(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let o=this.dropoutMask,s=(e,t,n)=>!t||!t[n]?e:U(t[n],e),c=s(r,o,0),l=s(r,o,1),u=s(r,o,2),d=s(r,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=pM({ones:()=>wh(i),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let f=this.recurrentDropoutMask,p=s(i,f,0),m=s(i,f,1),h=s(i,f,2),g=s(i,f,3),[_,v,y,b]=h_(this.kernel.read(),4,3),[x,S,C,w]=this.useBias?h_(this.bias.read(),4):[null,null,null,null];c=this.inputConv(c,_,x,this.padding),l=this.inputConv(l,v,S,this.padding),u=this.inputConv(u,y,C,this.padding),d=this.inputConv(d,b,w,this.padding);let[T,ee,E,te]=h_(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,T),m=this.recurrentConv(m,ee),h=this.recurrentConv(h,E),g=this.recurrentConv(g,te);let ne=this.recurrentActivation.apply(H(c,p)),re=this.recurrentActivation.apply(H(l,m)),ie=H(U(re,a),U(ne,this.activation.apply(H(u,h)))),ae=U(this.recurrentActivation.apply(H(d,g)),this.activation.apply(ie));return[ae,ae,ie]})}getConfig(){let e=super.getConfig(),{units:t}=e,n=wM(e,[`units`]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(e,t,n,r){let i=od(e,t,this.strides,r||`valid`,this.dataFormat===`channelsFirst`?`NCHW`:`NHWC`,this.dilationRate);return n?uO(i,n,this.dataFormat):i}recurrentConv(e,t){return od(e,t,1,`same`,this.dataFormat===`channelsFirst`?`NCHW`:`NHWC`)}},EM.className=`ConvLSTM2DCell`,J(EM),DM=class extends TM{constructor(e){let t=new EM(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}},DM.className=`ConvLSTM2D`,J(DM)})),kM,AM,jM,MM,NM,PM,FM,IM,LM,RM=o((()=>{Y(),Cj(),pO(),Ck(),nk(),QE(),IO(),Nj(),vD(),KD(),VO(),kM=class extends tk{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;let t=e.shape,n=[];for(let e=0;e<this.noiseShape.length;++e)n.push(this.noiseShape[e]==null?t[e]:this.noiseShape[e]);return n}call(e,t){return B(()=>{this.invokeCallHook(e,t);let n=zO(e);if(0<this.rate&&this.rate<1){let e=t.training==null?!1:t.training,r=this.getNoiseShape(n);return fO(()=>dO(n,this.rate,r,this.seed),()=>n,e)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}},kM.className=`Dropout`,J(kM),AM=class extends kM{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}},AM.className=`SpatialDropout1D`,J(AM),jM=class extends tk{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER=`glorotNormal`,this.DEFAULT_BIAS_INITIALIZER=`zeros`,e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,mD(this.units,`units`),this.activation=aj(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=vO(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=vO(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=gk(e.kernelConstraint),this.biasConstraint=gk(e.biasConstraint),this.kernelRegularizer=kj(e.kernelRegularizer),this.biasRegularizer=kj(e.biasRegularizer),this.activityRegularizer=kj(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=BO(e);let t=e[e.length-1];this.kernel??(this.kernel=this.addWeight(`kernel`,[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight(`bias`,[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=BO(e);let t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return B(()=>{this.invokeCallHook(e,t);let n=zO(e),r=gD(this.activation.getClassName()),i;return r==null?(i=oO(n,this.kernel.read()),this.bias!=null&&(i=uO(i,this.bias.read())),this.activation!=null&&(i=this.activation.apply(i))):i=oO(n,this.kernel.read(),r,this.bias?this.bias.read():null),i})}getConfig(){let e={units:this.units,activation:rj(this.activation),useBias:this.useBias,kernelInitializer:_O(this.kernelInitializer),biasInitializer:_O(this.biasInitializer),kernelRegularizer:Dj(this.kernelRegularizer),biasRegularizer:Dj(this.biasRegularizer),activityRegularizer:Dj(this.activityRegularizer),kernelConstraint:mk(this.kernelConstraint),biasConstraint:mk(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}},jM.className=`Dense`,J(jM),MM=class extends tk{constructor(e){e||={},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=BO(e);for(let t of e.slice(1))if(t==null)throw new X(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],HD(e,1)]}call(e,t){return B(()=>{this.invokeCallHook(e,t);let n=zO(e);if(this.dataFormat===`channelsFirst`&&n.rank>1){let e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=bv(n,e)}return Hse(n)})}getConfig(){let e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}},MM.className=`Flatten`,J(MM),NM=class extends tk{constructor(e){super(e),this.supportsMasking=!0,this.activation=aj(e.activation)}call(e,t){return B(()=>{this.invokeCallHook(e,t);let n=zO(e);return this.activation.apply(n)})}getConfig(){let e={activation:rj(this.activation)},t=super.getConfig();return Object.assign(e,t),e}},NM.className=`Activation`,J(NM),PM=class extends tk{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return B(()=>(e=zO(e),Bse(e,this.n)))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}},PM.className=`RepeatVector`,J(PM),FM=class extends tk{constructor(e){super(e),this.targetShape=e.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){let n=`Total size of new array must be unchanged.`,r=t.slice(),i=1,a=null;for(let e=0;e<r.length;++e){let t=r[e];if(this.isUnknown(t))if(a===null)a=e;else throw new X(`Can only specifiy one unknown dimension.`);else i*=t}let o=HD(e);if(a!==null){if(i===0||o%i!==0)throw new X(n);r[a]=o/i}else if(o!==i)throw new X(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return B(()=>{this.invokeCallHook(e,t);let n=zO(e),r=n.shape,i=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return W(n,i)})}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}},FM.className=`Reshape`,J(FM),IM=class extends tk{constructor(e){if(super(e),e.dims==null)throw Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=GD(1,e.dims.length+1);if(!ge(e.dims.slice().sort(),t))throw Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new XO({ndim:this.dims.length+1})]}computeOutputShape(e){e=BO(e);let t=e.slice();return this.dims.forEach((n,r)=>{t[r+1]=e[n]}),t}call(e,t){return bv(zO(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}},IM.className=`Permute`,J(IM),LM=class extends tk{constructor(e){super(e??{}),this.supportsMasking=!0,e==null?this.maskValue=0:this.maskValue=e.maskValue==null?0:e.maskValue}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=zO(e);return Xc(yh(n,this.maskValue),-1)}call(e,t){return B(()=>{this.invokeCallHook(e,t);let n=zO(e),r=Xc(yh(n,this.maskValue),-1,!0);return U(n,V(r,n.dtype))})}},LM.className=`Masking`,J(LM)})),zM,BM=o((()=>{Y(),pO(),Ck(),nk(),QE(),IO(),Nj(),vD(),VO(),zM=class extends tk{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER=`randomUniform`,e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(iD(e.inputLength))}this.inputDim=e.inputDim,mD(this.inputDim,`inputDim`),this.outputDim=e.outputDim,mD(this.outputDim,`outputDim`),this.embeddingsInitializer=vO(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=kj(e.embeddingsRegularizer),this.activityRegularizer=kj(e.activityRegularizer),this.embeddingsConstraint=gk(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight(`embeddings`,[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return B(()=>this.maskZero?(e=zO(e),yh(e,pf(e))):null)}computeOutputShape(e){if(e=BO(e),this.inputLength==null)return[...e,this.outputDim];let t=iD(this.inputLength);if(t.length!==e.length-1)throw new X(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){let i=t[r],a=e[r+1];if(i!=null&&a!=null&&i!==a)throw new X(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);i??(t[n]=a),n++}}return[e[0],...t,this.outputDim]}call(e,t){return B(()=>{this.invokeCallHook(e,t);let n=zO(e);n.dtype!==`int32`&&(n=ZD(n,`int32`));let r=sO(this.embeddings.read(),W(n,[n.size]));return W(r,BO(this.computeOutputShape(n.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:_O(this.embeddingsInitializer),embeddingsRegularizer:Dj(this.embeddingsRegularizer),activityRegularizer:Dj(this.activityRegularizer),embeddingsConstraint:mk(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}},zM.className=`Embedding`,J(zM)}));function VM(e,t){for(;e<0;)e+=t;return e}function HM(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new XE(`batchDot is not implemented for tensors of 4D or higher rank yet`);if(D(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),D(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof n==`number`&&(n=[n,n]),e.dtype===`complex64`||t.dtype===`complex64`)throw new XE(`batchDot is not implemented for complex64-type Tensors yet.`);let r=e.shape.length,i=t.shape.length;n??=[r-1,i-2];let a=n;return B(()=>{let n;if(r>i){n=r-i;let e=[];for(let t=0;t<n;++t)e.push(1);t=W(t,t.shape.concat(e))}else if(i>r){n=i-r;let t=[];for(let e=0;e<n;++e)t.push(1);e=W(e,e.shape.concat(t))}else n=0;let o;if(e.shape.length===2&&t.shape.length===2)o=a[0]===a[1]?K(U(e,t),a[0]):K(U(bv(e,[1,0]),t),a[1]);else{let n=a[0]!==e.shape.length-1,r=a[1]===t.shape.length-1;o=Xl(e,t,n,r)}if(n>0){let e;e=r>i?r+i-3:r-1;let t=[];for(let r=e;r<e+n;++r)t.push(r);o=x_(o,t)}return o.shape.length===1&&(o=vp(o,1)),o})}var UM,WM,GM,KM,qM,JM,YM,XM,ZM=o((()=>{Y(),pO(),nk(),QE(),Jk(),vD(),KD(),VO(),UM=class extends tk{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new XE}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;let n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){let i=e[e.length-t.length+r],a=t[r];if(i==null||a==null||i<0||a<0)n.push(null);else if(i===1)n.push(a);else if(a===1)n.push(i);else{if(i!==a)throw new X(`Operands could not be broadcast together with shapes `+JSON.stringify(e)+` `+JSON.stringify(t));n.push(i)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[BO(e)]),e=e,e.length<2)throw new X(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let n of e)n!=null&&n[0]!==null&&t.push(n[0]);if(t=dD(t),t.length>1)throw new X(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=e[0]==null?null:e[0].slice(1);for(let t=1;t<e.length;++t){let r=e[t]==null?null:e[t].slice(1);n=this.computeElementwiseOpOutputShape(n,r)}let r=e.map(e=>e.length);e.indexOf(null)===-1&&dD(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return B(()=>{if(e=e,this.reshapeRequired){let t=[],n=e.map(e=>e.rank);if(n.indexOf(null)===-1){let r=WD(n);for(let n of e){let e=n.rank;for(let t=0;t<r-e;++t)n=QD(n,1);t.push(n)}return this.mergeFunction(t)}else{let n=!1;for(let r of e){let e=r.rank;if(e==null){let e=r.shape,i=e[0],a=e.slice(1).concat([i]),o=W(r,[i].concat(HD(e.slice(1))));o=bv(o,[1,0]),o=W(o,a),t.push(o),n=!0}else if(e>1){let i=GD(1,e).concat([0]);t.push(bv(r,i)),n=!0}else t.push(r)}let r=this.mergeFunction(t),i=r.rank;if(n){if(i==null){let e=r.shape,t=e.length,n=e[t-1],i=[n].concat(e.slice(0,e.length-1));r=W(bv(W(r,[-1,n]),[1,0]),i)}else if(i>1){let e=[i-1].concat(GD(0,i-1));r=bv(r,e)}}return r}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;t=e[0]==null?null:e[0].slice(1);for(let n=1;n<e.length;++n){let r=e[n]==null?null:e[n].slice(1);t=this.computeElementwiseOpOutputShape(t,r)}let n=[];for(let t of e)t!=null&&t[0]!==null&&n.push(t[0]);return n=dD(n),t=n.length===1?n.concat(t):[null].concat(t),t}computeMask(e,t){return B(()=>{if(t==null)return null;if(!Array.isArray(t))throw new X("`mask` should be an Array");if(!Array.isArray(e))throw new X("`inputs` should be an Array");if(t.length!==e.length)throw new X(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(e=>e==null))return null;t=t.map(e=>e==null?e:vp(e,0));let n=t[0];for(let e=1;e<t.length-1;++e)n=Lm(n,t[e]);return n})}},WM=class extends UM{constructor(e){super(e)}mergeFunction(e){return B(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=H(t,e[n]);return t})}},WM.className=`Add`,J(WM),GM=class extends UM{constructor(e){super(e)}mergeFunction(e){return B(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=U(t,e[n]);return t})}},GM.className=`Multiply`,J(GM),KM=class extends UM{constructor(e){super(e)}mergeFunction(e){return B(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=H(t,e[n]);return U(1/e.length,t)})}},KM.className=`Average`,J(KM),qM=class extends UM{constructor(e){super(e)}mergeFunction(e){return B(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=th(t,e[n]);return t})}},qM.className=`Maximum`,J(qM),JM=class extends UM{constructor(e){super(e)}mergeFunction(e){return B(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=uh(t,e[n]);return t})}},JM.className=`Minimum`,J(JM),YM=class extends UM{constructor(e){super(e),this.DEFAULT_AXIS=-1,e??={},this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new X("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(let n of e)if(n!=null){t=!1;break}if(t)return;let n=[];for(let t=0;t<e.length;++t){let r=e[t].slice();r.splice(this.axis,1);let i=!1;for(let e of n)if(ge(e,r)){i=!0;break}i||n.push(r)}if(n.length>1)throw new X("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return B(()=>nO(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new X("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(let e of t.slice(1)){if(n[r]==null||e[r]==null){n[r]=null;break}n[r]+=e[r]}return n}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new X("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new X("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new X(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return B(()=>{let n=!0;if(t.forEach(e=>{if(e!=null){n=!1;return}}),n)return null;let r=[];for(let n=0;n<e.length;++n)t[n]==null?r.push(V(wh(e[n]),`bool`)):t[n].rank<e[n].rank?r.push(vp(t[n],-1)):r.push(t[n]);let i=ql(r,this.axis);return qc(i,-1,!1)})}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}},YM.className=`Concatenate`,J(YM),XM=class extends UM{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){D(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new XE(`Dot layer does not support tensors of 4D or higher rank yet.`);let r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new X(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new X(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],n=e[1],r;return r=Array.isArray(this.axes)?this.axes.map((t,n)=>VM(t,e[n].shape.length)):[VM(this.axes,t.shape.length),VM(this.axes,n.shape.length)],this.normalize&&(t=Rk(t,r[0]),n=Rk(n,r[1])),HM(t,n,r)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[VM(this.axes,e.length),VM(this.axes,t.length)],n}computeOutputShape(e){D(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new XE(`Dot layer does not support tensors of 4D or higher rank yet.`);let r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);let i=t.concat(n);return i.length===1&&i.push(1),i}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}},XM.className=`Dot`,J(XM)})),QM,$M,eN,tN=o((()=>{Y(),pO(),nk(),VO(),QM=class extends tk{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return B(()=>{this.invokeCallHook(e,t);let n=zO(e);return fO(()=>H(aO(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}},QM.className=`GaussianNoise`,J(QM),$M=class extends tk{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return B(()=>{this.invokeCallHook(e,t);let n=zO(e);return this.rate>0&&this.rate<1?fO(()=>{let e=Math.sqrt(this.rate/(1-this.rate));return U(n,aO(n.shape,1,e))},()=>n,t.training||!1):n})}},$M.className=`GaussianDropout`,J($M),eN=class extends tk{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||zO(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return B(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return fO(()=>{let t=zO(e),r=-1.6732632423543772*1.0507009873554805,i=zp(mg(n),this.rate);i=ZD(i,`float32`);let a=((1-this.rate)*(1+this.rate*r**2))**-.5,o=-a*r*this.rate,s=H(U(t,i),U(H(i,-1),r));return H(U(s,a),o)},()=>zO(e),t.training||!1)}return e})}},eN.className=`AlphaDropout`,J(eN)}));function nN(e,t,n,r,i,a=.001){let o;if(e.rank===2)o=yu(e,t,n,r,i,a);else if(e.rank===3)o=Su(e,t,n,r,i,a);else if(e.rank===4)o=Tu(e,t,n,r,i,a);else throw new XE(`batchNormalization is not implemented for array of rank ${e.rank} yet`);return o}function rN(e,t,n,r,i=.001){return B(()=>{let a=gh(e,r),o=a.mean,s=a.variance;return[nN(e,o,s,n,t,i),o,s]})}function iN(e,t,n,r,i=.001){return B(()=>{let a=gh(e,r),o=a.mean,s=a.variance,c=[];for(let t of GD(0,e.rank))r.indexOf(t)===-1?c.push(e.shape[t]):c.push(1);let l=W(o,c),u=W(s,c),d=t==null?null:W(t,c),f=n==null?null:W(n,c);return[nN(e,l,u,f,d,i),o,s]})}function aN(e,t,n,r,i=.001){return ge(r.slice().sort(),GD(0,e.rank-1))?rN(e,t,n,r,i):iN(e,t,n,r,i)}var oN,sN,cN=o((()=>{Y(),Ck(),nk(),QE(),IO(),Nj(),vD(),KD(),VO(),oN=class extends tk{constructor(e){e??={},super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=vO(e.betaInitializer||`zeros`),this.gammaInitializer=vO(e.gammaInitializer||`ones`),this.movingMeanInitializer=vO(e.movingMeanInitializer||`zeros`),this.movingVarianceInitializer=vO(e.movingVarianceInitializer||`ones`),this.betaConstraint=gk(e.betaConstraint),this.gammaConstraint=gk(e.gammaConstraint),this.betaRegularizer=kj(e.betaRegularizer),this.gammaRegularizer=kj(e.gammaRegularizer)}build(e){e=BO(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(n==null)throw new X(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new XO({ndim:e.length,axes:{[t]:n}})];let r=[n];this.scale&&(this.gamma=this.addWeight(`gamma`,r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight(`beta`,r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight(`moving_mean`,r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight(`moving_variance`,r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return B(()=>{let n=t.training==null?!1:t.training,r=zO(e),i=r.shape,a=i.length,o=GD(0,a),s=this.axis>=0?this.axis:this.axis+a;o.splice(s,1);let c=eD(1,a);c[s]=i[s];let l=o.slice();l.sort();let u=!ge(l,GD(0,a).slice(0,a-1)),d=()=>{if(u){let e=W(this.movingMean.read(),c),t=W(this.movingVariance.read(),c),n=this.center?W(this.beta.read(),c):null,i=this.scale?W(this.gamma.read(),c):null;return nN(r,e,t,n,i,this.epsilon)}else return nN(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return d();let[f,p,m]=aN(r,this.gamma.read(),this.beta.read(),o,this.epsilon),h=(e,t,n)=>{B(()=>{let r=1-n,i=e.read(),a=U(q(i,t),r);e.write(q(i,a))})};return h(this.movingMean,p,this.momentum),h(this.movingVariance,m,this.momentum),f})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:_O(this.betaInitializer),gammaInitializer:_O(this.gammaInitializer),movingMeanInitializer:_O(this.movingMeanInitializer),movingVarianceInitializer:_O(this.movingVarianceInitializer),betaRegularizer:Dj(this.betaRegularizer),gammaRegularizer:Dj(this.gammaRegularizer),betaConstraint:mk(this.betaConstraint),gammaConstraint:mk(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}},oN.className=`BatchNormalization`,J(oN),sN=class extends tk{constructor(e){if(e??={},super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis==`number`){if(!Number.isInteger(this.axis))throw Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let e of this.axis)if(!Number.isInteger(e))throw Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=vO(e.betaInitializer||`zeros`),this.gammaInitializer=vO(e.gammaInitializer||`ones`),this.betaRegularizer=kj(e.betaRegularizer),this.gammaRegularizer=kj(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=BO(e);let t=e.length;typeof this.axis==`number`&&(this.axis=[this.axis]);for(let e=0;e<this.axis.length;++e)this.axis[e]<0&&(this.axis[e]+=t);for(let e of this.axis)if(e<0||e>=t)throw Error(`Invalid axis: ${e}`);if(this.axis.length!==dD(this.axis).length)throw Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(t=>e[t]);this.scale?this.gamma=this.addWeight(`gamma`,n,`float32`,this.gammaInitializer,this.gammaRegularizer,!0):this.gamma=null,this.center?this.beta=this.addWeight(`beta`,n,`float32`,this.betaInitializer,this.betaRegularizer,!0):this.beta=null,this.built=!0}call(e,t){let n=zO(e),r=n.shape,i=r.length;return B(()=>{let{mean:e,variance:t}=gh(n,this.axis,!0),a=eD(1,i);for(let e of this.axis)a[e]=r[e];let o=e=>e!=null&&e.shape.length!==i?W(e,a):e,s=this.scale?o(this.gamma.read()):null,c=this.center?o(this.beta.read()):null,l=[],u=[];for(let e=0;e<i;++e)this.axis.indexOf(e)===-1?(l.push(1),u.push(r[e])):(l.push(r[e]),u.push(1));return e=wp(e,l),t=wp(t,l),s!=null&&(s=wp(s,u)),c!=null&&(c=wp(c,u)),nN(n,e,t,c,s,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:_O(this.betaInitializer),gammaInitializer:_O(this.gammaInitializer),betaRegularizer:Dj(this.betaRegularizer),gammaRegularizer:Dj(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}},sN.className=`LayerNormalization`,J(sN)}));function lN(e,t,n){return B(()=>{if(e.rank!==4)throw new X(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(t??=[[1,1],[1,1]],t.length!==2||t[0].length!==2||t[1].length!==2)throw new X("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n??=JD(),n!==`channelsLast`&&n!==`channelsFirst`)throw new X(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r=n===`channelsFirst`?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],Ah(e,r)})}var uN,dN=o((()=>{Y(),XD(),nk(),QE(),VO(),uN=class extends tk{constructor(e){if(e??={},super(e),this.dataFormat=e.dataFormat==null?JD():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding==`number`)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new X(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if(typeof e.padding[0]==`number`)t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new X(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new X(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new XO({ndim:4})]}computeOutputShape(e){e=BO(e);let t,n;return this.dataFormat===`channelsFirst`?(t=e[2]!=null&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=e[3]!=null&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=e[1]!=null&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=e[2]!=null&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return B(()=>lN(zO(e),this.padding,this.dataFormat))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},uN.className=`ZeroPadding2D`,J(uN)}));function fN(e,t,n,r,i,a){return B(()=>{AD(i),MD(a),jD(r),n??=[1,1],r??=`valid`,i??=JD(),a??=`max`,e=Gj(e,i);let o,s=r===`same`?`same`:`valid`;return o=a===`max`?Zm(e,t,n,s):Vl(e,t,n,s),i===`channelsFirst`&&(o=bv(o,[0,3,1,2])),o})}function pN(e,t,n,r,i,a){return B(()=>{AD(i),MD(a),jD(r),n??=[1,1,1],r??=`valid`,i??=JD(),a??=`max`,e=Kj(e,i);let o,s=r===`same`?`same`:`valid`;return o=a===`max`?$m(e,t,n,s):Wl(e,t,n,s),i===`channelsFirst`&&(o=bv(o,[0,4,1,2,3])),o})}var mN,hN,gN,_N,vN,yN,bN,xN,SN,CN,wN,TN,EN,DN,ON,kN=o((()=>{Y(),XD(),pO(),VD(),nk(),QE(),Wj(),vD(),VO(),sM(),mN=class extends tk{constructor(e){if(e.poolSize??=2,super(e),typeof e.poolSize==`number`)this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]==`number`)this.poolSize=e.poolSize;else throw new X(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(mD(this.poolSize,`poolSize`),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides==`number`)this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]==`number`)this.strides=e.strides;else throw new X(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);mD(this.strides,`strides`),this.padding=e.padding==null?`valid`:e.padding,jD(this.padding),this.inputSpec=[new XO({ndim:3})]}computeOutputShape(e){e=BO(e);let t=Hj(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return B(()=>{this.invokeCallHook(e,t),e=QD(zO(e),2);let n=this.poolingFunction(zO(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,`channelsLast`);return x_(n,[2])})}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},hN=class extends mN{constructor(e){super(e)}poolingFunction(e,t,n,r,i){return AD(i),jD(r),fN(e,t,n,r,i,`max`)}},hN.className=`MaxPooling1D`,J(hN),gN=class extends mN{constructor(e){super(e)}poolingFunction(e,t,n,r,i){return AD(i),jD(r),fN(e,t,n,r,i,`avg`)}},gN.className=`AveragePooling1D`,J(gN),_N=class extends tk{constructor(e){if(e.poolSize??=[2,2],super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new X(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];mD(this.poolSize,`poolSize`),mD(this.strides,`strides`),this.padding=e.padding==null?`valid`:e.padding,this.dataFormat=e.dataFormat==null?`channelsLast`:e.dataFormat,AD(this.dataFormat),jD(this.padding),this.inputSpec=[new XO({ndim:4})]}computeOutputShape(e){e=BO(e);let t=this.dataFormat===`channelsFirst`?e[2]:e[1],n=this.dataFormat===`channelsFirst`?e[3]:e[2];return t=Hj(t,this.poolSize[0],this.padding,this.strides[0]),n=Hj(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat===`channelsFirst`?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return B(()=>(this.invokeCallHook(e,t),this.poolingFunction(zO(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},vN=class extends _N{constructor(e){super(e)}poolingFunction(e,t,n,r,i){return AD(i),jD(r),fN(e,t,n,r,i,`max`)}},vN.className=`MaxPooling2D`,J(vN),yN=class extends _N{constructor(e){super(e)}poolingFunction(e,t,n,r,i){return AD(i),jD(r),fN(e,t,n,r,i,`avg`)}},yN.className=`AveragePooling2D`,J(yN),bN=class extends tk{constructor(e){if(e.poolSize??=[2,2,2],super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new X(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];mD(this.poolSize,`poolSize`),mD(this.strides,`strides`),this.padding=e.padding==null?`valid`:e.padding,this.dataFormat=e.dataFormat==null?`channelsLast`:e.dataFormat,AD(this.dataFormat),jD(this.padding),this.inputSpec=[new XO({ndim:5})]}computeOutputShape(e){e=BO(e);let t=this.dataFormat===`channelsFirst`?e[2]:e[1],n=this.dataFormat===`channelsFirst`?e[3]:e[2],r=this.dataFormat===`channelsFirst`?e[4]:e[3];return t=Hj(t,this.poolSize[0],this.padding,this.strides[0]),n=Hj(n,this.poolSize[1],this.padding,this.strides[1]),r=Hj(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat===`channelsFirst`?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return B(()=>(this.invokeCallHook(e,t),this.poolingFunction(zO(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},xN=class extends bN{constructor(e){super(e)}poolingFunction(e,t,n,r,i){return AD(i),jD(r),pN(e,t,n,r,i,`max`)}},xN.className=`MaxPooling3D`,J(xN),SN=class extends bN{constructor(e){super(e)}poolingFunction(e,t,n,r,i){return AD(i),jD(r),pN(e,t,n,r,i,`avg`)}},SN.className=`AveragePooling3D`,J(SN),CN=class extends tk{constructor(e){super(e),this.inputSpec=[new XO({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new XE}},wN=class extends CN{constructor(e){super(e||{})}call(e,t){return B(()=>{let t=zO(e);return rh(t,1)})}},wN.className=`GlobalAveragePooling1D`,J(wN),TN=class extends CN{constructor(e){super(e||{})}call(e,t){return B(()=>{let t=zO(e);return Uf(t,1)})}},TN.className=`GlobalMaxPooling1D`,J(TN),EN=class extends tk{constructor(e){super(e),this.dataFormat=e.dataFormat==null?`channelsLast`:e.dataFormat,AD(this.dataFormat),this.inputSpec=[new XO({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat===`channelsLast`?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new XE}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},DN=class extends EN{call(e,t){return B(()=>{let t=zO(e);return this.dataFormat===`channelsLast`?rh(t,[1,2]):rh(t,[2,3])})}},DN.className=`GlobalAveragePooling2D`,J(DN),ON=class extends EN{call(e,t){return B(()=>{let t=zO(e);return this.dataFormat===`channelsLast`?Uf(t,[1,2]):Uf(t,[2,3])})}},ON.className=`GlobalMaxPooling2D`,J(ON)}));function AN(e){fD(OD,`BidirectionalMergeMode`,e)}var jN,MN,NN,PN,FN=o((()=>{Y(),pO(),VD(),nk(),QE(),kD(),vD(),VO(),CM(),Lk(),jN=class extends tk{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer==null?!1:this.layer.trainable}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){let r=t.layer,i=Ik(r,n);delete t.layer;let a={layer:i};return Object.assign(a,t),new e(a)}},MN=class extends jN{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=BO(e),e.length<3)throw new X(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=BO(e);let t=[e[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return B(()=>(e=zO(e),fM((e,n)=>[zO(this.layer.call(e,t)),[]],e,[],!1,null,null,!1,!0)[1]))}},MN.className=`TimeDistributed`,J(MN),NN=`concat`,PN=class extends jN{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=Ik(n),t.goBackwards=t.goBackwards!==!0;let r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=Ik(r),this.forwardLayer.name=`forward_`+this.forwardLayer.name,this.backwardLayer.name=`backward_`+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?NN:e.mergeMode,AN(this.mergeMode),e.weights)throw new XE(`weights support is not implemented for Bidirectional layer yet.`);this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let n,r,i;return this.returnState&&(i=t.slice(1)),n=t[0],n=n,this.mergeMode===`concat`?(n[n.length-1]*=2,r=[n]):r=this.mergeMode==null?[n,n.slice()]:[n],this.returnState?this.mergeMode==null?r.concat(i).concat(i.slice()):[n].concat(i,i.slice()):rD(r)}apply(e,t){let n=t==null?null:t.initialState,r=t==null?null:t.constants;t??={};let i=dM(e,n,r,this.numConstants);if(e=i.inputs,n=i.initialState,r=i.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(n==null||n.length===0)&&r==null)return super.apply(e,t);let a=[],o=[];if(n!=null){let e=n.length;if(e%2>0)throw new X("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,a.push(...n);let r=n.map(e=>new XO({shape:e.shape}));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),o.push(...r)}if(r!=null)throw new XE(`Support for constants in Bidirectional layers is not implemented yet.`);let s=a[0]instanceof ZO;for(let e of a)if(e instanceof ZO!==s)throw new X(`The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors`);if(s){let n=[e].concat(a),r=this.inputSpec.concat(o),i=this.inputSpec;this.inputSpec=r;let s=super.apply(n,t);return this.inputSpec=i,s}else return super.apply(e,t)}call(e,t){return B(()=>{let n=t.initialState,r,i;if(n==null)r=this.forwardLayer.call(e,t),i=this.backwardLayer.call(e,t);else{let a=n.slice(0,n.length/2),o=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:a})),i=this.backwardLayer.call(e,Object.assign(t,{initialState:o}))}let a;this.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(i.slice(1))),r=r[0],i=i[0]),this.returnSequences&&(i=Ag(i,1));let o;return this.mergeMode===`concat`?o=nO([r,i]):this.mergeMode===`sum`?o=H(r,i):this.mergeMode===`ave`?o=U(.5,H(r,i)):this.mergeMode===`mul`?o=U(r,i):this.mergeMode??(o=[r,i]),this.returnState?this.mergeMode==null?o.concat(a):[o].concat(a):o})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){ND(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),ND(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let n;if(n=this.returnSequences?this.mergeMode==null?[t,t]:t:this.mergeMode==null?[null,null]:null,this.returnState){let e=this.forwardLayer.states.map(e=>null);return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e,e)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=Ik(t.layer);if(delete t.layer,t.numConstants!=null)throw new XE(`Deserialization of a Bidirectional layer with numConstants present is not supported yet.`);let r=t;return r.layer=n,new e(r)}},PN.className=`Bidirectional`,J(PN)})),IN,LN=o((()=>{nk(),Y(),VO(),pO(),IN=class extends tk{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return B(()=>(e=zO(e),e.dtype!==`float32`&&(e=ZD(e,`float32`)),H(U(e,this.scale),this.offset)))}},IN.className=`Rescaling`,J(IN)})),RN,zN,BN,VN=o((()=>{Y(),VO(),nk(),pO(),{resizeBilinear:RN,cropAndResize:zN}=_b,BN=class extends tk{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,i,a,o,s){return B(()=>{let c,l=!1,u=t/a,d=n/o,f=(r+t)/a,p=(i+n)/o,m=[u,d,f,p],h=[];e.rank===3?(l=!0,c=C_([e])):c=e;for(let e=0;e<c.shape[0];e++)h.push(m);let g=_o(h,[h.length,4]),_=_g(0,h.length,1,`int32`),v=zN(c,g,_,[r,i],`nearest`);return ZD(l?zO(dv(v)):v,s)})}upsize(e,t,n,r){return B(()=>{let i=RN(e,[t,n]);return ZD(i,r)})}call(e,t){return B(()=>{let t=zO(e),n=t.dtype,r=t.shape,i=r[r.length-3],a=r[r.length-2],o=0;i!==this.height&&(o=Math.floor((i-this.height)/2));let s=0;return a!==this.width&&(s=Math.floor((a-this.width)/2),s===0&&(s=1)),o>=0&&s>=0?this.centerCrop(t,o,s,this.height,this.width,i,a,n):this.upsize(e,this.height,this.width,n)})}getConfig(){let e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=BO(e);let t=e.length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}},BN.className=`CenterCrop`,J(BN)}));function HN(e,t,n,r){let i=zO(e);if(i.dtype!==`int32`&&(i=ZD(i,`int32`)),t===`int`)return i;let a=i.shape;if(i.rank===0&&(i=vp(i,-1)),t===`oneHot`&&i.shape[i.shape.length-1]!==1&&(i=vp(i,-1)),i.rank>2)throw new X(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${a} which would result in output rank ${i.rank}.`);let o=[`multiHot`,`oneHot`].includes(t),s=i,c;if(c=r!==void 0&&t===`count`?zd(s,r,n,o):zd(s,[],n,o),t!==`tfIdf`)return c;if(r)return U(c,r);throw new X(`When outputMode is 'tfIdf', weights must be provided.`)}var UN=o((()=>{Y(),VO(),QE(),pO()})),WN,GN=o((()=>{nk(),Y(),VO(),QE(),pO(),UN(),WN=class extends tk{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode=`multiHot`}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=BO(e),e==null?[this.numTokens]:this.outputMode===`oneHot`&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return B(()=>{e=zO(e),e.dtype!==`int32`&&(e=ZD(e,`int32`));let n;if(t.countWeights!==void 0){if(this.outputMode!==`count`)throw new X(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);n=zO(t.countWeights)}let r=Uf(e),i=Kf(e),a=Ip(this.numTokens,r).bufferSync().get(0),o=zp(i,0).bufferSync().get(0);if(!(a&&o))throw new X(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return HN(e,this.outputMode,this.numTokens,n)})}},WN.className=`CategoryEncoding`,J(WN)})),KN,qN,JN=o((()=>{Y(),nk(),QE(),VO(),KN=new Set([`bilinear`,`nearest`]),qN=class extends tk{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(KN.has(e.interpolation))this.interpolation=e.interpolation;else throw new X(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation=`bilinear`;this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=BO(e);let t=e[2];return[this.height,this.width,t]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return B(()=>{let t=[this.height,this.width];if(this.interpolation===`bilinear`)return _b.resizeBilinear(e,t,!this.cropToAspectRatio);if(this.interpolation===`nearest`)return _b.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw Error(`Interpolation is ${this.interpolation} but only ${[...KN]} are supported`)})}},qN.className=`Resizing`,J(qN)})),YN,XN=o((()=>{YN=class{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}},YN.className=`RandomSeed`})),ZN,QN=o((()=>{nk(),XN(),ZN=class extends tk{constructor(e){super(e),this.randomGenerator=new YN(e.seed)}getConfig(){let e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}},ZN.className=`BaseRandomLayer`})),$N,eP,tP,nP=o((()=>{Y(),VO(),QE(),QN(),$N=[`bilinear`,`nearest`],eP=new Set($N),tP=class extends ZN{constructor(e){super(e);let{factor:t,interpolation:n=`bilinear`}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new X(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new X(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new X(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(n)if(eP.has(n))this.interpolation=n;else throw new X(`Invalid interpolation parameter: ${n} is not implemented`)}getConfig(){let e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=BO(e);let t=e[2];return[this.imgHeight,-1,t]}call(e,t){return B(()=>{let t=zO(e);this.imgHeight=t.shape[t.shape.length-3];let n=t.shape[t.shape.length-2];this.widthFactor=mg([1],1+this.widthLower,1+this.widthUpper,`float32`,this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*n;r=Math.round(r);let i=[this.imgHeight,r];switch(this.interpolation){case`bilinear`:return _b.resizeBilinear(e,i);case`nearest`:return _b.resizeNearestNeighbor(e,i);default:throw Error(`Interpolation is ${this.interpolation}
          but only ${[...eP]} are supported`)}})}},tP.className=`RandomWidth`,J(tP)})),rP=c({Layer:()=>tk,RNN:()=>mM,RNNCell:()=>hM,activation:()=>bP,add:()=>kP,alphaDropout:()=>Ole,average:()=>AP,averagePooling1d:()=>zP,averagePooling2d:()=>HP,averagePooling3d:()=>GP,avgPool1d:()=>BP,avgPool2d:()=>UP,avgPool3d:()=>KP,avgPooling1d:()=>VP,avgPooling2d:()=>WP,avgPooling3d:()=>qP,batchNormalization:()=>IP,bidirectional:()=>wle,categoryEncoding:()=>Nle,centerCrop:()=>jle,concatenate:()=>jP,conv1d:()=>dP,conv2d:()=>fP,conv2dTranspose:()=>pP,conv3d:()=>mP,conv3dTranspose:()=>hP,convLstm2d:()=>ble,convLstm2dCell:()=>xle,cropping2D:()=>_P,dense:()=>xP,depthwiseConv2d:()=>yP,dot:()=>FP,dropout:()=>SP,elu:()=>aP,embedding:()=>OP,flatten:()=>wP,gaussianDropout:()=>Dle,gaussianNoise:()=>Ele,globalAveragePooling1d:()=>JP,globalAveragePooling2d:()=>YP,globalMaxPool1d:()=>eF,globalMaxPool2d:()=>tF,globalMaxPooling1d:()=>XP,globalMaxPooling2d:()=>ZP,gru:()=>mle,gruCell:()=>hle,input:()=>ej,inputLayer:()=>iP,layerNormalization:()=>LP,leakyReLU:()=>sP,lstm:()=>gle,lstmCell:()=>_le,masking:()=>kle,maxPool1d:()=>nF,maxPool2d:()=>rF,maxPooling1d:()=>QP,maxPooling2d:()=>$P,maxPooling3d:()=>ple,maximum:()=>MP,minimum:()=>NP,multiply:()=>PP,permute:()=>DP,prelu:()=>cP,randomWidth:()=>Ple,reLU:()=>oP,repeatVector:()=>TP,rescaling:()=>Ale,reshape:()=>EP,resizing:()=>Mle,rnn:()=>Sle,separableConv2d:()=>gP,simpleRNN:()=>vle,simpleRNNCell:()=>yle,softmax:()=>lP,spatialDropout1d:()=>CP,stackedRNNCells:()=>Cle,thresholdedReLU:()=>uP,timeDistributed:()=>Tle,upSampling2d:()=>vP,zeroPadding2d:()=>RP});function iP(e){return new ik(e)}function aP(e){return new Lj(e)}function oP(e){return new Pj(e)}function sP(e){return new Fj(e)}function cP(e){return new Ij(e)}function lP(e){return new zj(e)}function uP(e){return new Rj(e)}function dP(e){return new iM(e)}function fP(e){return new Qj(e)}function pP(e){return new eM(e)}function mP(e){return new $j(e)}function hP(e){return new tM(e)}function gP(e){return new rM(e)}function _P(e){return new aM(e)}function vP(e){return new oM(e)}function yP(e){return new lM(e)}function bP(e){return new NM(e)}function xP(e){return new jM(e)}function SP(e){return new kM(e)}function CP(e){return new AM(e)}function wP(e){return new MM(e)}function TP(e){return new PM(e)}function EP(e){return new FM(e)}function DP(e){return new IM(e)}function OP(e){return new zM(e)}function kP(e){return new WM(e)}function AP(e){return new KM(e)}function jP(e){return new YM(e)}function MP(e){return new qM(e)}function NP(e){return new JM(e)}function PP(e){return new GM(e)}function FP(e){return new XM(e)}function IP(e){return new oN(e)}function LP(e){return new sN(e)}function RP(e){return new uN(e)}function zP(e){return new gN(e)}function BP(e){return zP(e)}function VP(e){return zP(e)}function HP(e){return new yN(e)}function UP(e){return HP(e)}function WP(e){return HP(e)}function GP(e){return new SN(e)}function KP(e){return GP(e)}function qP(e){return GP(e)}function JP(e){return new wN(e)}function YP(e){return new DN(e)}function XP(e){return new TN(e)}function ZP(e){return new ON(e)}function QP(e){return new hN(e)}function $P(e){return new vN(e)}function ple(e){return new xN(e)}function mle(e){return new yM(e)}function hle(e){return new vM(e)}function gle(e){return new xM(e)}function _le(e){return new bM(e)}function vle(e){return new _M(e)}function yle(e){return new gM(e)}function ble(e){return new DM(e)}function xle(e){return new EM(e)}function Sle(e){return new mM(e)}function Cle(e){return new SM(e)}function wle(e){return new PN(e)}function Tle(e){return new MN(e)}function Ele(e){return new QM(e)}function Dle(e){return new $M(e)}function Ole(e){return new eN(e)}function kle(e){return new LM(e)}function Ale(e){return new IN(e)}function jle(e){return new BN(e)}function Mle(e){return new qN(e)}function Nle(e){return new WN(e)}function Ple(e){return new tP(e)}var eF,tF,nF,rF,Fle=o((()=>{ak(),nk(),nj(),Bj(),sM(),uM(),OM(),RM(),BM(),ZM(),tN(),cN(),dN(),kN(),CM(),FN(),LN(),VN(),GN(),JN(),nP(),eF=XP,tF=ZP,nF=QP,rF=$P})),Ile=c({MAPE:()=>qle,MSE:()=>Xle,binaryAccuracy:()=>Lle,binaryCrossentropy:()=>Rle,categoricalAccuracy:()=>Ble,categoricalCrossentropy:()=>Vle,cosineProximity:()=>Wle,mape:()=>Jle,meanAbsoluteError:()=>Gle,meanAbsolutePercentageError:()=>Kle,meanSquaredError:()=>Yle,mse:()=>Zle,precision:()=>Hle,r2Score:()=>Qle,recall:()=>Ule,sparseCategoricalAccuracy:()=>zle});function Lle(e,t){return Yk(e,t)}function Rle(e,t){return $k(e,t)}function zle(e,t){return eA(e,t)}function Ble(e,t){return Xk(e,t)}function Vle(e,t){return cA(e,t)}function Hle(e,t){return Qk(e,t)}function Ule(e,t){return Vce(e,t)}function Wle(e,t){return Gk(e,t)}function Gle(e,t){return Bk(e,t)}function Kle(e,t){return Vk(e,t)}function qle(e,t){return Vk(e,t)}function Jle(e,t){return Vk(e,t)}function Yle(e,t){return zk(e,t)}function Xle(e,t){return zk(e,t)}function Zle(e,t){return zk(e,t)}function Qle(e,t){return Hce(e,t)}var $le=o((()=>{Jk(),fA()})),eue=c({modelFromJSON:()=>KA}),tue=o((()=>{ZA()})),nue=c({l1:()=>iue,l1l2:()=>rue,l2:()=>aue});function rue(e){return new jj(e)}function iue(e){return Tj(e)}function aue(e){return Ej(e)}var oue=o((()=>{Nj()}));function iF(e,t){return e<t}function aF(e,t){return e>t}function sue(e){return new sF(e)}var oF,sF,cF,cue=o((()=>{Fk(),GA(),QE(),Ek(),oF=class extends kk{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof UA))throw Error(`model must be a LayersModel, not some other Container`);this.model=e}},sF=class extends oF{constructor(e){if(super(),e??={},e.restoreBestWeights)throw new XE(`restoreBestWeights = True is not implemented in EarlyStopping yet.`);this.monitor=e.monitor||`val_loss`,this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||`auto`,this.baseline=e.baseline,[`auto`,`min`,`max`].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode=`auto`),this.mode===`min`?this.monitorFunc=iF:this.mode===`max`?this.monitorFunc=aF:this.monitor.indexOf(`acc`)===-1?this.monitorFunc=iF:this.monitorFunc=aF,this.monitorFunc===iF&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline==null?this.best=this.monitorFunc===iF?1/0:-1/0:this.best=this.baseline}async onEpochEnd(e,t){await wk(t);let n=this.getMonitorValue(t);n!=null&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e??={};let t=e[this.monitor];return t??console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}},cF={earlyStopping:sue}})),lF=o((()=>{oce(),Y(),WT(),fce(),kce(),Fle(),$le(),tue(),oue(),Fk(),cue(),nk(),GA(),nj(),CM(),ZA(),JO(),SA()})),lue=o((()=>{Y(),k().registerFlag(`KEEP_INTERMEDIATE_TENSORS`,()=>!1,e=>{e&&console.warn(`Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.`)})})),uF,uue,due=o((()=>{(function(e){e[e.DT_INVALID=0]=`DT_INVALID`,e[e.DT_FLOAT=1]=`DT_FLOAT`,e[e.DT_DOUBLE=2]=`DT_DOUBLE`,e[e.DT_INT32=3]=`DT_INT32`,e[e.DT_UINT8=4]=`DT_UINT8`,e[e.DT_INT16=5]=`DT_INT16`,e[e.DT_INT8=6]=`DT_INT8`,e[e.DT_STRING=7]=`DT_STRING`,e[e.DT_COMPLEX64=8]=`DT_COMPLEX64`,e[e.DT_INT64=9]=`DT_INT64`,e[e.DT_BOOL=10]=`DT_BOOL`,e[e.DT_QINT8=11]=`DT_QINT8`,e[e.DT_QUINT8=12]=`DT_QUINT8`,e[e.DT_QINT32=13]=`DT_QINT32`,e[e.DT_BFLOAT16=14]=`DT_BFLOAT16`,e[e.DT_QINT16=15]=`DT_QINT16`,e[e.DT_QUINT16=16]=`DT_QUINT16`,e[e.DT_UINT16=17]=`DT_UINT16`,e[e.DT_COMPLEX128=18]=`DT_COMPLEX128`,e[e.DT_HALF=19]=`DT_HALF`,e[e.DT_RESOURCE=20]=`DT_RESOURCE`,e[e.DT_VARIANT=21]=`DT_VARIANT`,e[e.DT_UINT32=22]=`DT_UINT32`,e[e.DT_UINT64=23]=`DT_UINT64`,e[e.DT_FLOAT_REF=101]=`DT_FLOAT_REF`,e[e.DT_DOUBLE_REF=102]=`DT_DOUBLE_REF`,e[e.DT_INT32_REF=103]=`DT_INT32_REF`,e[e.DT_UINT8_REF=104]=`DT_UINT8_REF`,e[e.DT_INT16_REF=105]=`DT_INT16_REF`,e[e.DT_INT8_REF=106]=`DT_INT8_REF`,e[e.DT_STRING_REF=107]=`DT_STRING_REF`,e[e.DT_COMPLEX64_REF=108]=`DT_COMPLEX64_REF`,e[e.DT_INT64_REF=109]=`DT_INT64_REF`,e[e.DT_BOOL_REF=110]=`DT_BOOL_REF`,e[e.DT_QINT8_REF=111]=`DT_QINT8_REF`,e[e.DT_QUINT8_REF=112]=`DT_QUINT8_REF`,e[e.DT_QINT32_REF=113]=`DT_QINT32_REF`,e[e.DT_BFLOAT16_REF=114]=`DT_BFLOAT16_REF`,e[e.DT_QINT16_REF=115]=`DT_QINT16_REF`,e[e.DT_QUINT16_REF=116]=`DT_QUINT16_REF`,e[e.DT_UINT16_REF=117]=`DT_UINT16_REF`,e[e.DT_COMPLEX128_REF=118]=`DT_COMPLEX128_REF`,e[e.DT_HALF_REF=119]=`DT_HALF_REF`,e[e.DT_RESOURCE_REF=120]=`DT_RESOURCE_REF`,e[e.DT_VARIANT_REF=121]=`DT_VARIANT_REF`,e[e.DT_UINT32_REF=122]=`DT_UINT32_REF`,e[e.DT_UINT64_REF=123]=`DT_UINT64_REF`})(uF||={}),(function(e){(function(e){e[e.LEGACY=0]=`LEGACY`,e[e.V1=1]=`V1`,e[e.V2=2]=`V2`})(e.CheckpointFormatVersion||={})})(uue||={})}));function fue(e,t){fF[e]={tfOpName:e,category:`custom`,inputs:[],attrs:[],customExecutor:t}}function dF(e){return fF[e]}function pue(e){delete fF[e]}var fF,pF=o((()=>{fF={}}));function Z(e,t,n,r,i){let a=t.inputParams[e];if(a&&a.inputIndexStart!==void 0){let e=a.inputIndexStart,o=a.inputIndexEnd===0?void 0:a.inputIndexEnd===void 0?e+1:a.inputIndexEnd,s=e<0?t.inputNames.length+e:e;if(a.type===`tensor`)return mF(t.inputNames[s],n,r,i);if(a.type===`tensors`){let a=t.inputs.slice(e,o);return t.inputNames.slice(e,o).filter((e,t)=>a[t]?.op!==`NoOp`).map(e=>mF(e,n,r,i))}let c=mF(t.inputNames[s],n,r,i),l=c.dataSync();return a.type===`number`?l[0]:Ve(c.shape,l)}let o=t.attrParams[e];return o&&o.value}function mF(e,t,n,r){let[i,a]=vF(e,n);if(r!=null){let e=r.getHashTableHandleByName(i);if(e!=null)return e}let o=n.currentContextIds.find(e=>!!t[_F(i,e)]);return o===void 0?void 0:t[_F(i,o)][a]}function hF(e,t,n){return t[_F(e,n.currentContextId)]}function gF(e,t){let[n,r,i]=vF(e,t);return[_F(n,t&&t.currentContextId),r,i]}function _F(e,t){return t?`${e}-${t}`:e}function vF(e,t){if(e===``)return[``,0,void 0];let n=t!=null&&t.parseNodeNameCache!=null;if(n){let n=t.parseNodeNameCache.get(e);if(n!=null)return n}let r=e.split(`:`),i;if(r.length===1)i=[e,0,void 0];else{let e=r[0],t=r.length===3?r[1]:void 0,n=Number(r[r.length-1]);i=[e,n,t]}return n&&t.parseNodeNameCache.set(e,i),i}function yF(e,t,n){let r=Z(`pad`,e,t,n);if(r===`explicit`){r=Z(`explicitPaddings`,e,t,n);let i=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)i[e][0]=r[e*2],i[e][1]=r[e*2+1];return i}return r}function bF(e){return e.kept?e:yc(e)}var xF=o((()=>{Y()})),mue=c({json:()=>SF}),SF,hue=o((()=>{SF=[{tfOpName:`Add`,category:`arithmetic`,inputs:[{start:0,name:`a`,type:`tensor`},{start:1,name:`b`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`AddV2`,category:`arithmetic`,inputs:[{start:0,name:`a`,type:`tensor`},{start:1,name:`b`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`AddN`,category:`arithmetic`,inputs:[{start:0,end:0,name:`tensors`,type:`tensors`}]},{tfOpName:`BiasAdd`,category:`arithmetic`,inputs:[{start:0,name:`a`,type:`tensor`},{start:1,name:`b`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0},{tfName:`data_format`,name:`dataFormat`,type:`string`,notSupported:!0}]},{tfOpName:`Sub`,category:`arithmetic`,inputs:[{start:0,name:`a`,type:`tensor`},{start:1,name:`b`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`RealDiv`,category:`arithmetic`,inputs:[{start:0,name:`a`,type:`tensor`},{start:1,name:`b`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Div`,category:`arithmetic`,inputs:[{start:0,name:`a`,type:`tensor`},{start:1,name:`b`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`DivNoNan`,category:`arithmetic`,inputs:[{start:0,name:`a`,type:`tensor`},{start:1,name:`b`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`FloorDiv`,category:`arithmetic`,inputs:[{start:0,name:`a`,type:`tensor`},{start:1,name:`b`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Mul`,category:`arithmetic`,inputs:[{start:0,name:`a`,type:`tensor`},{start:1,name:`b`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Maximum`,category:`arithmetic`,inputs:[{start:0,name:`a`,type:`tensor`},{start:1,name:`b`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Minimum`,category:`arithmetic`,inputs:[{start:0,name:`a`,type:`tensor`},{start:1,name:`b`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Pow`,category:`arithmetic`,inputs:[{start:0,name:`a`,type:`tensor`},{start:1,name:`b`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`SquaredDifference`,category:`arithmetic`,inputs:[{start:0,name:`a`,type:`tensor`},{start:1,name:`b`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Mod`,category:`arithmetic`,inputs:[{start:0,name:`a`,type:`tensor`},{start:1,name:`b`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`FloorMod`,category:`arithmetic`,inputs:[{start:0,name:`a`,type:`tensor`},{start:1,name:`b`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]}]})),gue=c({json:()=>CF}),CF,_ue=o((()=>{CF=[{tfOpName:`Abs`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Acos`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Asin`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Atan`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Atan2`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`y`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Ceil`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`ClipByValue`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`clipValueMin`,type:`number`},{start:2,name:`clipValueMax`,type:`number`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Complex`,category:`basic_math`,inputs:[{start:0,name:`real`,type:`tensor`},{start:1,name:`imag`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`ComplexAbs`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Cos`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Cosh`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Elu`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Exp`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Floor`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Log`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Imag`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0},{tfName:`Tout`,name:`outputType`,type:`dtype`,notSupported:!0}]},{tfOpName:`Neg`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Real`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0},{tfName:`Tout`,name:`outputType`,type:`dtype`,notSupported:!0}]},{tfOpName:`Prelu`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`alpha`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Relu`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Relu6`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Selu`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Sigmoid`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Sin`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Sinh`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Sqrt`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Rsqrt`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Square`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Tan`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Tanh`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Sign`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Round`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Expm1`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Log1p`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Reciprocal`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Softplus`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Asinh`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Acosh`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Atanh`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Erf`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`LeakyRelu`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`alpha`,name:`alpha`,type:`number`,defaultValue:.2},{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`IsNan`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`IsFinite`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`IsInf`,category:`basic_math`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]}]})),vue=c({json:()=>wF}),wF,yue=o((()=>{wF=[{tfOpName:`EmptyTensorList`,category:`control`,inputs:[{start:0,name:`elementShape`,type:`shape`},{start:1,name:`maxNumElements`,type:`number`}],attrs:[{tfName:`element_dtype`,name:`elementDType`,type:`dtype`}]},{tfOpName:`LoopCond`,category:`control`,inputs:[{start:0,name:`pred`,type:`tensor`}]},{tfOpName:`Switch`,category:`control`,inputs:[{start:0,name:`data`,type:`tensor`},{start:1,name:`pred`,type:`tensor`}]},{tfOpName:`Merge`,category:`control`,inputs:[{start:0,end:0,name:`tensors`,type:`tensors`}]},{tfOpName:`Enter`,category:`control`,inputs:[{start:0,name:`tensor`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0},{tfName:`frame_name`,name:`frameName`,type:`string`},{tfName:`is_constant`,name:`isConstant`,type:`bool`}]},{tfOpName:`Exit`,category:`control`,inputs:[{start:0,name:`tensor`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`NextIteration`,category:`control`,inputs:[{start:0,name:`tensor`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`TensorArrayV3`,category:`control`,inputs:[{start:0,name:`size`,type:`number`}],attrs:[{tfName:`dtype`,name:`dtype`,type:`dtype`},{tfName:`element_shape`,name:`elementShape`,type:`shape`},{tfName:`dynamic_size`,name:`dynamicSize`,type:`bool`},{tfName:`clear_after_read`,name:`clearAfterRead`,type:`bool`},{tfName:`identical_element_shapes`,name:`identicalElementShapes`,type:`bool`},{tfName:`tensor_array_name`,name:`name`,type:`string`}]},{tfOpName:`TensorArrayWriteV3`,category:`control`,inputs:[{start:0,name:`tensorArrayId`,type:`tensor`},{start:1,name:`index`,type:`number`},{start:2,name:`tensor`,type:`tensor`},{start:3,name:`flowIn`,type:`number`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`TensorArrayReadV3`,category:`control`,inputs:[{start:0,name:`tensorArrayId`,type:`tensor`},{start:1,name:`index`,type:`number`},{start:2,name:`flowIn`,type:`number`}],attrs:[{tfName:`dtype`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`TensorArrayGatherV3`,category:`control`,inputs:[{start:0,name:`tensorArrayId`,type:`tensor`},{start:1,name:`indices`,type:`number[]`},{start:2,name:`flowIn`,type:`number`}],attrs:[{tfName:`dtype`,name:`dtype`,type:`dtype`},{tfName:`element_shape`,name:`elementShape`,type:`shape`}]},{tfOpName:`TensorArrayScatterV3`,category:`control`,inputs:[{start:0,name:`tensorArrayId`,type:`tensor`},{start:1,name:`indices`,type:`number[]`},{start:2,name:`tensor`,type:`tensor`},{start:3,name:`flowIn`,type:`number`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`}]},{tfOpName:`TensorArrayConcatV3`,category:`control`,inputs:[{start:0,name:`tensorArrayId`,type:`tensor`},{start:1,name:`flowIn`,type:`number`}],attrs:[{tfName:`dtype`,name:`dtype`,type:`dtype`},{tfName:`element_shape_except0`,name:`elementShapeExcept0`,type:`shape`,notSupported:!0}]},{tfOpName:`TensorArraySplitV3`,category:`control`,inputs:[{start:0,name:`tensorArrayId`,type:`tensor`},{start:1,name:`tensor`,type:`tensor`},{start:2,name:`lengths`,type:`number[]`},{start:3,name:`flowIn`,type:`number`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`}]},{tfOpName:`TensorArraySizeV3`,category:`control`,inputs:[{start:0,name:`tensorArrayId`,type:`tensor`},{start:1,name:`flowIn`,type:`number`}]},{tfOpName:`TensorArrayCloseV3`,category:`control`,inputs:[{start:0,name:`tensorArrayId`,type:`tensor`}]},{tfOpName:`StatelessIf`,category:`control`,inputs:[{start:0,name:`cond`,type:`tensor`},{start:1,end:0,name:`args`,type:`tensors`}],attrs:[{tfName:`then_branch`,name:`thenBranch`,type:`func`},{tfName:`else_branch`,name:`elseBranch`,type:`func`}]},{tfOpName:`If`,category:`control`,inputs:[{start:0,name:`cond`,type:`tensor`},{start:1,end:0,name:`args`,type:`tensors`}],attrs:[{tfName:`then_branch`,name:`thenBranch`,type:`func`},{tfName:`else_branch`,name:`elseBranch`,type:`func`}]},{tfOpName:`StatelessWhile`,category:`control`,inputs:[{start:0,end:0,name:`args`,type:`tensors`}],attrs:[{tfName:`cond`,name:`cond`,type:`func`},{tfName:`body`,name:`body`,type:`func`}]},{tfOpName:`While`,category:`control`,inputs:[{start:0,end:0,name:`args`,type:`tensors`}],attrs:[{tfName:`cond`,name:`cond`,type:`func`},{tfName:`body`,name:`body`,type:`func`}]},{tfOpName:`TensorListScatter`,category:`control`,inputs:[{start:0,name:`tensor`,type:`tensor`},{start:1,name:`indices`,type:`number[]`},{start:2,name:`elementShape`,type:`shape`}],attrs:[{tfName:`element_dtype`,name:`elementDType`,type:`dtype`}]},{tfOpName:`TensorListScatterV2`,category:`control`,inputs:[{start:0,name:`tensor`,type:`tensor`},{start:1,name:`indices`,type:`number[]`},{start:2,name:`elementShape`,type:`shape`},{start:3,name:`numElements`,type:`number`}],attrs:[{tfName:`element_dtype`,name:`elementDType`,type:`dtype`}]},{tfOpName:`TensorListGather`,category:`control`,inputs:[{start:0,name:`tensorListId`,type:`tensor`},{start:1,name:`indices`,type:`number[]`},{start:2,name:`elementShape`,type:`shape`}],attrs:[{tfName:`element_dtype`,name:`elementDType`,type:`dtype`}]},{tfOpName:`TensorListGetItem`,category:`control`,inputs:[{start:0,name:`tensorListId`,type:`tensor`},{start:1,name:`index`,type:`number`},{start:2,name:`elementShape`,type:`shape`}],attrs:[{tfName:`element_dtype`,name:`elementDType`,type:`dtype`}]},{tfOpName:`TensorListSetItem`,category:`control`,inputs:[{start:0,name:`tensorListId`,type:`tensor`},{start:1,name:`index`,type:`number`},{start:2,name:`tensor`,type:`tensor`}],attrs:[{tfName:`element_dtype`,name:`elementDType`,type:`dtype`}]},{tfOpName:`TensorListReserve`,category:`control`,inputs:[{start:0,name:`elementShape`,type:`shape`},{start:1,name:`numElements`,type:`number`}],attrs:[{tfName:`element_dtype`,name:`elementDType`,type:`dtype`}]},{tfOpName:`TensorListFromTensor`,category:`control`,inputs:[{start:0,name:`tensor`,type:`tensor`},{start:1,name:`elementShape`,type:`shape`}],attrs:[{tfName:`element_dtype`,name:`elementDType`,type:`dtype`}]},{tfOpName:`TensorListStack`,category:`control`,inputs:[{start:0,name:`tensorListId`,type:`tensor`},{start:1,name:`elementShape`,type:`shape`}],attrs:[{tfName:`element_dtype`,name:`elementDType`,type:`dtype`},{tfName:`num_elements`,name:`numElements`,type:`dtype`}]},{tfOpName:`TensorListSplit`,category:`control`,inputs:[{start:0,name:`tensor`,type:`tensor`},{start:1,name:`elementShape`,type:`shape`},{start:2,name:`lengths`,type:`number[]`}],attrs:[{tfName:`element_dtype`,name:`elementDType`,type:`dtype`}]},{tfOpName:`TensorListConcat`,category:`control`,inputs:[{start:0,name:`tensorListId`,type:`tensor`}],attrs:[{tfName:`element_shape`,name:`elementShape`,type:`shape`},{tfName:`element_dtype`,name:`elementDType`,type:`dtype`}]},{tfOpName:`TensorListConcatV2`,category:`control`,inputs:[{start:0,name:`tensorListId`,type:`tensor`}],attrs:[{tfName:`element_shape`,name:`elementShape`,type:`shape`},{tfName:`element_dtype`,name:`elementDType`,type:`dtype`}]},{tfOpName:`TensorListPopBack`,category:`control`,inputs:[{start:0,name:`tensorListId`,type:`tensor`},{start:1,name:`elementShape`,type:`shape`}],attrs:[{tfName:`element_dtype`,name:`elementDType`,type:`dtype`}]},{tfOpName:`TensorListPushBack`,category:`control`,inputs:[{start:0,name:`tensorListId`,type:`tensor`},{start:1,name:`tensor`,type:`tensor`}],attrs:[{tfName:`element_dtype`,name:`elementDType`,type:`dtype`}]},{tfOpName:`TensorListLength`,category:`control`,inputs:[{start:0,name:`tensorListId`,type:`tensor`}]},{tfOpName:`TensorListResize`,category:`control`,inputs:[{start:0,name:`tensorListId`,type:`tensor`},{start:1,name:`size`,type:`number`}]}]})),bue=c({json:()=>TF}),TF,xue=o((()=>{TF=[{tfOpName:`AvgPool`,category:`convolution`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`strides`,name:`strides`,type:`number[]`},{tfName:`padding`,name:`pad`,type:`string`},{tfName:`data_format`,name:`dataFormat`,type:`string`,notSupported:!0},{tfName:`ksize`,name:`kernelSize`,type:`number[]`},{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`MaxPool`,category:`convolution`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`strides`,name:`strides`,type:`number[]`},{tfName:`padding`,name:`pad`,type:`string`},{tfName:`data_format`,name:`dataFormat`,type:`string`,notSupported:!0},{tfName:`ksize`,name:`kernelSize`,type:`number[]`},{tfName:`explicit_paddings`,name:`explicitPaddings`,type:`number[]`,defaultValue:[],notSupported:!0},{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`MaxPoolWithArgmax`,category:`convolution`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`strides`,name:`strides`,type:`number[]`},{tfName:`padding`,name:`pad`,type:`string`},{tfName:`ksize`,name:`kernelSize`,type:`number[]`},{tfName:`include_batch_in_index`,name:`includeBatchInIndex`,type:`bool`},{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`AvgPool3D`,category:`convolution`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`strides`,name:`strides`,type:`number[]`},{tfName:`padding`,name:`pad`,type:`string`},{tfName:`data_format`,name:`dataFormat`,type:`string`,notSupported:!0},{tfName:`ksize`,name:`kernelSize`,type:`number[]`},{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`MaxPool3D`,category:`convolution`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`strides`,name:`strides`,type:`number[]`},{tfName:`padding`,name:`pad`,type:`string`},{tfName:`data_format`,name:`dataFormat`,type:`string`,notSupported:!0},{tfName:`ksize`,name:`kernelSize`,type:`number[]`},{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Conv1D`,category:`convolution`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`filter`,type:`tensor`}],attrs:[{tfName:`stride`,name:`stride`,type:`number`},{tfName:`padding`,name:`pad`,type:`string`},{tfName:`data_format`,name:`dataFormat`,type:`string`,defaultValue:`NWC`},{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0},{tfName:`dilation`,name:`dilation`,type:`number`,defaultValue:1}]},{tfOpName:`Conv2D`,category:`convolution`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`filter`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0},{tfName:`strides`,name:`strides`,type:`number[]`},{tfName:`padding`,name:`pad`,type:`string`},{tfName:`useCudnnOnGpu`,name:`useCudnnOnGpu`,type:`bool`},{tfName:`data_format`,name:`dataFormat`,type:`string`,defaultValue:`NHWC`},{tfName:`explicit_paddings`,name:`explicitPaddings`,type:`number[]`,defaultValue:[]},{tfName:`dilations`,name:`dilations`,type:`number[]`}]},{tfOpName:`_FusedConv2D`,category:`convolution`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`filter`,type:`tensor`},{start:2,end:0,name:`args`,type:`tensors`}],attrs:[{tfName:`num_args`,name:`numArgs`,type:`number`},{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0},{tfName:`strides`,name:`strides`,type:`number[]`},{tfName:`padding`,name:`pad`,type:`string`},{tfName:`explicit_paddings`,name:`explicitPaddings`,type:`number[]`,defaultValue:[]},{tfName:`use_cudnn_on_gpu`,name:`useCudnnOnGpu`,type:`bool`,defaultValue:!0},{tfName:`data_format`,name:`dataFormat`,type:`string`,defaultValue:`NHWC`},{tfName:`dilations`,name:`dilations`,type:`number[]`,defaultValue:[1,1,1,1]},{tfName:`fused_ops`,name:`fusedOps`,type:`string[]`,defaultValue:[]},{tfName:`epsilon`,name:`epsilon`,type:`number`,defaultValue:1e-4},{tfName:`leakyrelu_alpha`,name:`leakyreluAlpha`,type:`number`,defaultValue:.2}]},{tfOpName:`Conv2DBackpropInput`,category:`convolution`,inputs:[{start:2,name:`x`,type:`tensor`},{start:1,name:`filter`,type:`tensor`},{start:0,name:`outputShape`,type:`number[]`}],attrs:[{tfName:`strides`,name:`strides`,type:`number[]`},{tfName:`padding`,name:`pad`,type:`string`},{tfName:`data_format`,name:`dataFormat`,type:`string`,notSupported:!0},{tfName:`explicit_paddings`,name:`explicitPaddings`,type:`number[]`,defaultValue:[]},{tfName:`dilations`,name:`dilations`,type:`number[]`,notSupported:!0}]},{tfOpName:`DepthwiseConv2d`,category:`convolution`,inputs:[{start:0,name:`input`,type:`tensor`},{start:1,name:`filter`,type:`tensor`}],attrs:[{tfName:`strides`,name:`strides`,type:`number[]`},{tfName:`padding`,name:`pad`,type:`string`},{tfName:`data_format`,name:`dataFormat`,type:`string`,defaultValue:`NHWC`},{tfName:`explicit_paddings`,name:`explicitPaddings`,type:`number[]`,defaultValue:[]},{tfName:`dilations`,name:`dilations`,type:`number[]`}]},{tfOpName:`DepthwiseConv2dNative`,category:`convolution`,inputs:[{start:0,name:`input`,type:`tensor`},{start:1,name:`filter`,type:`tensor`}],attrs:[{tfName:`strides`,name:`strides`,type:`number[]`},{tfName:`padding`,name:`pad`,type:`string`},{tfName:`data_format`,name:`dataFormat`,type:`string`,defaultValue:`NHWC`},{tfName:`explicit_paddings`,name:`explicitPaddings`,type:`number[]`,defaultValue:[]},{tfName:`dilations`,name:`dilations`,type:`number[]`}]},{tfOpName:`FusedDepthwiseConv2dNative`,category:`convolution`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`filter`,type:`tensor`},{start:2,end:0,name:`args`,type:`tensors`}],attrs:[{tfName:`num_args`,name:`numArgs`,type:`number`},{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0},{tfName:`strides`,name:`strides`,type:`number[]`},{tfName:`padding`,name:`pad`,type:`string`},{tfName:`data_format`,name:`dataFormat`,type:`string`,defaultValue:`NHWC`},{tfName:`dilations`,name:`dilations`,type:`number[]`,defaultValue:[1,1,1,1]},{tfName:`fused_ops`,name:`fusedOps`,type:`string[]`,defaultValue:[]},{tfName:`explicit_paddings`,name:`explicitPaddings`,type:`number[]`,defaultValue:[]}]},{tfOpName:`Conv3D`,category:`convolution`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`filter`,type:`tensor`}],attrs:[{tfName:`strides`,name:`strides`,type:`number[]`},{tfName:`padding`,name:`pad`,type:`string`},{tfName:`data_format`,name:`dataFormat`,type:`string`,defaultValue:`NHWC`},{tfName:`dilations`,name:`dilations`,type:`number[]`}]},{tfOpName:`Dilation2D`,category:`convolution`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`filter`,type:`tensor`}],attrs:[{tfName:`strides`,name:`strides`,type:`number[]`},{tfName:`rates`,name:`dilations`,type:`number[]`},{tfName:`padding`,name:`pad`,type:`string`}]}]})),Sue=c({json:()=>EF}),EF,Cue=o((()=>{EF=[{tfOpName:`Fill`,category:`creation`,inputs:[{start:0,name:`shape`,type:`number[]`},{start:1,name:`value`,type:`number`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`}]},{tfOpName:`LinSpace`,category:`creation`,inputs:[{start:0,name:`start`,type:`number`},{start:1,name:`stop`,type:`number`},{start:2,name:`num`,type:`number`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`OneHot`,category:`creation`,inputs:[{start:0,name:`indices`,type:`tensor`},{start:1,name:`depth`,type:`number`},{start:2,name:`onValue`,type:`number`,defaultValue:1},{start:3,name:`offValue`,type:`number`,defaultValue:0}],attrs:[{tfName:`axis`,name:`axis`,type:`number`,notSupported:!0},{tfName:`T`,name:`dtype`,type:`dtype`}]},{tfOpName:`Ones`,category:`creation`,inputs:[{start:0,name:`shape`,type:`number[]`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`}]},{tfOpName:`OnesLike`,category:`creation`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`dtype`,name:`dtype`,type:`dtype`}]},{tfOpName:`RandomStandardNormal`,category:`creation`,inputs:[{start:0,name:`shape`,type:`number[]`}],attrs:[{tfName:`seed`,name:`seed`,type:`number`,defaultValue:0},{tfName:`seed2`,name:`seed2`,type:`number`,defaultValue:0,notSupported:!0},{tfName:`dtype`,name:`dtype`,type:`dtype`},{tfName:`T`,name:`T`,type:`number`,notSupported:!0}]},{tfOpName:`RandomUniform`,category:`creation`,inputs:[{start:0,name:`shape`,type:`number[]`}],attrs:[{tfName:`minval`,name:`minval`,type:`number`,defaultValue:0},{tfName:`maxval`,name:`maxval`,type:`number`,defaultValue:1},{tfName:`dtype`,name:`dtype`,type:`dtype`},{tfName:`seed`,name:`seed`,type:`number`,defaultValue:0},{tfName:`seed2`,name:`seed2`,type:`number`,defaultValue:0,notSupported:!0},{tfName:`T`,name:`T`,type:`number`,notSupported:!0}]},{tfOpName:`RandomUniformInt`,category:`creation`,inputs:[{start:0,name:`shape`,type:`number[]`}],attrs:[{tfName:`minval`,name:`minval`,type:`number`},{tfName:`maxval`,name:`maxval`,type:`number`},{tfName:`seed`,name:`seed`,type:`number`,defaultValue:0},{tfName:`seed2`,name:`seed2`,type:`number`,defaultValue:0,notSupported:!0}]},{tfOpName:`Range`,category:`creation`,inputs:[{start:0,name:`start`,type:`number`},{start:1,name:`stop`,type:`number`},{start:2,name:`step`,type:`number`,defaultValue:0}],attrs:[{tfName:`Tidx`,name:`dtype`,type:`dtype`}]},{tfOpName:`TruncatedNormal`,category:`creation`,inputs:[{start:0,name:`shape`,type:`number[]`}],attrs:[{tfName:`means`,name:`mean`,type:`number`,defaultValue:0},{tfName:`stddev`,name:`stdDev`,type:`number`,defaultValue:1},{tfName:`seed`,name:`seed`,type:`number`},{tfName:`seed2`,name:`seed2`,type:`number`,defaultValue:0,notSupported:!0},{tfName:`dtype`,name:`dtype`,type:`dtype`},{tfName:`T`,name:`T`,type:`number`,notSupported:!0}]},{tfOpName:`Zeros`,category:`creation`,inputs:[{start:0,name:`shape`,type:`number[]`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`}]},{tfOpName:`ZerosLike`,category:`creation`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`}]},{tfOpName:`Multinomial`,category:`creation`,inputs:[{start:0,name:`logits`,type:`tensor`},{start:1,name:`numSamples`,type:`number`}],attrs:[{tfName:`seed`,name:`seed`,type:`number`},{tfName:`seed2`,name:`seed2`,type:`number`},{tfName:`T`,name:`dtype`,type:`dtype`},{tfName:`output_dtype`,name:`output_dtype`,type:`dtype`}]}]})),wue=c({json:()=>DF}),DF,Tue=o((()=>{DF=[{tfOpName:`NonMaxSuppressionV2`,category:`dynamic`,inputs:[{start:0,name:`boxes`,type:`tensor`},{start:1,name:`scores`,type:`tensor`},{start:2,name:`maxOutputSize`,type:`number`},{start:3,name:`iouThreshold`,type:`number`}]},{tfOpName:`NonMaxSuppressionV3`,category:`dynamic`,inputs:[{start:0,name:`boxes`,type:`tensor`},{start:1,name:`scores`,type:`tensor`},{start:2,name:`maxOutputSize`,type:`number`},{start:3,name:`iouThreshold`,type:`number`},{start:4,name:`scoreThreshold`,type:`number`}]},{tfOpName:`NonMaxSuppressionV4`,category:`dynamic`,inputs:[{start:0,name:`boxes`,type:`tensor`},{start:1,name:`scores`,type:`tensor`},{start:2,name:`maxOutputSize`,type:`number`},{start:3,name:`iouThreshold`,type:`number`},{start:4,name:`scoreThreshold`,type:`number`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0},{tfName:`T_threshold`,name:`threshold`,type:`dtype`,notSupported:!0},{tfName:`pad_to_max_output_size`,name:`padToMaxOutputSize`,type:`bool`}]},{tfOpName:`NonMaxSuppressionV5`,category:`dynamic`,inputs:[{start:0,name:`boxes`,type:`tensor`},{start:1,name:`scores`,type:`tensor`},{start:2,name:`maxOutputSize`,type:`number`},{start:3,name:`iouThreshold`,type:`number`},{start:4,name:`scoreThreshold`,type:`number`},{start:5,name:`softNmsSigma`,type:`number`}]},{tfOpName:`Where`,category:`dynamic`,inputs:[{start:0,name:`condition`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`ListDiff`,category:`dynamic`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`y`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]}]})),Eue=c({json:()=>OF}),OF,Due=o((()=>{OF=[{tfOpName:`LowerBound`,category:`evaluation`,inputs:[{start:0,name:`sortedSequence`,type:`tensor`},{start:1,name:`values`,type:`tensor`}]},{tfOpName:`TopKV2`,category:`evaluation`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`k`,type:`number`}],attrs:[{tfName:`sorted`,name:`sorted`,type:`bool`}]},{tfOpName:`UpperBound`,category:`evaluation`,inputs:[{start:0,name:`sortedSequence`,type:`tensor`},{start:1,name:`values`,type:`tensor`}]},{tfOpName:`Unique`,category:`evaluation`,inputs:[{start:0,name:`x`,type:`tensor`}]},{tfOpName:`UniqueV2`,category:`evaluation`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`axis`,type:`number`}]}]})),Oue=c({json:()=>kF}),kF,kue=o((()=>{kF=[{tfOpName:`PlaceholderWithDefault`,category:`graph`,inputs:[{start:0,name:`default`,type:`tensor`}],attrs:[{tfName:`shape`,name:`shape`,type:`shape`},{tfName:`dtype`,name:`dtype`,type:`dtype`}]},{tfOpName:`Placeholder`,category:`graph`,attrs:[{tfName:`shape`,name:`shape`,type:`shape`},{tfName:`dtype`,name:`dtype`,type:`dtype`}]},{tfOpName:`Const`,category:`graph`},{tfOpName:`Identity`,category:`graph`,inputs:[{start:0,name:`x`,type:`tensor`}]},{tfOpName:`IdentityN`,category:`graph`,inputs:[{start:0,end:0,name:`x`,type:`tensors`}]},{tfOpName:`Snapshot`,category:`graph`,inputs:[{start:0,name:`x`,type:`tensor`}]},{tfOpName:`Rank`,category:`graph`,inputs:[{start:0,name:`x`,type:`tensor`}]},{tfOpName:`Size`,category:`graph`,inputs:[{start:0,name:`x`,type:`tensor`}]},{tfOpName:`Shape`,category:`graph`,inputs:[{start:0,name:`x`,type:`tensor`}]},{tfOpName:`ShapeN`,category:`graph`,inputs:[{start:0,end:0,name:`x`,type:`tensors`}]},{tfOpName:`Print`,category:`graph`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`data`,type:`tensors`}],attrs:[{tfName:`message`,name:`message`,type:`string`},{tfName:`first_n`,name:`firstN`,type:`number`,notSupported:!0},{tfName:`summarize`,name:`summarize`,type:`number`,defaultValue:3}]},{tfOpName:`NoOp`,category:`graph`,inputs:[]},{tfOpName:`StopGradient`,category:`graph`,inputs:[{start:0,name:`x`,type:`tensor`}]},{tfOpName:`FakeQuantWithMinMaxVars`,category:`graph`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`min`,name:`min`,type:`number`},{tfName:`max`,name:`max`,type:`number`}]}]})),Aue=c({json:()=>AF}),AF,jue=o((()=>{AF=[{tfOpName:`HashTable`,category:`hash_table`,inputs:[],attrs:[{tfName:`shared_name`,name:`sharedName`,type:`string`},{tfName:`use_node_name_sharing`,name:`useNodeNameSharing`,type:`bool`},{tfName:`key_dtype`,name:`keyDType`,type:`dtype`},{tfName:`value_dtype`,name:`valueDType`,type:`dtype`}]},{tfOpName:`HashTableV2`,category:`hash_table`,inputs:[],attrs:[{tfName:`shared_name`,name:`sharedName`,type:`string`},{tfName:`use_node_name_sharing`,name:`useNodeNameSharing`,type:`bool`},{tfName:`key_dtype`,name:`keyDType`,type:`dtype`},{tfName:`value_dtype`,name:`valueDType`,type:`dtype`}]},{tfOpName:`LookupTableImport`,category:`hash_table`,inputs:[{start:0,name:`tableHandle`,type:`tensor`},{start:1,name:`keys`,type:`tensor`},{start:2,name:`values`,type:`tensor`}],attrs:[{tfName:`Tin`,name:`tIn`,type:`dtype`,notSupported:!0},{tfName:`Tout`,name:`tOut`,type:`dtype`,notSupported:!0}]},{tfOpName:`LookupTableImportV2`,category:`hash_table`,inputs:[{start:0,name:`tableHandle`,type:`tensor`},{start:1,name:`keys`,type:`tensor`},{start:2,name:`values`,type:`tensor`}],attrs:[{tfName:`Tin`,name:`tIn`,type:`dtype`,notSupported:!0},{tfName:`Tout`,name:`tOut`,type:`dtype`,notSupported:!0}]},{tfOpName:`LookupTableFind`,category:`hash_table`,inputs:[{start:0,name:`tableHandle`,type:`tensor`},{start:1,name:`keys`,type:`tensor`},{start:2,name:`defaultValue`,type:`tensor`}],attrs:[{tfName:`Tin`,name:`tIn`,type:`dtype`,notSupported:!0},{tfName:`Tout`,name:`tOut`,type:`dtype`,notSupported:!0}]},{tfOpName:`LookupTableFindV2`,category:`hash_table`,inputs:[{start:0,name:`tableHandle`,type:`tensor`},{start:1,name:`keys`,type:`tensor`},{start:2,name:`defaultValue`,type:`tensor`}],attrs:[{tfName:`Tin`,name:`tIn`,type:`dtype`,notSupported:!0},{tfName:`Tout`,name:`tOut`,type:`dtype`,notSupported:!0}]},{tfOpName:`LookupTableSize`,category:`hash_table`,inputs:[{start:0,name:`tableHandle`,type:`tensor`}]},{tfOpName:`LookupTableSizeV2`,category:`hash_table`,inputs:[{start:0,name:`tableHandle`,type:`tensor`}]},{tfOpName:`InitializeTable`,category:`hash_table`,inputs:[{start:0,name:`tableHandle`,type:`tensor`},{start:1,name:`keys`,type:`tensor`},{start:2,name:`values`,type:`tensor`}]},{tfOpName:`InitializeTableV2`,category:`hash_table`,inputs:[{start:0,name:`tableHandle`,type:`tensor`},{start:1,name:`keys`,type:`tensor`},{start:2,name:`values`,type:`tensor`}]}]})),Mue=c({json:()=>jF}),jF,Nue=o((()=>{jF=[{tfOpName:`ResizeBilinear`,category:`image`,inputs:[{start:0,name:`images`,type:`tensor`},{start:1,name:`size`,type:`number[]`}],attrs:[{tfName:`align_corners`,name:`alignCorners`,type:`bool`},{tfName:`half_pixel_centers`,name:`halfPixelCenters`,type:`bool`},{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`ResizeNearestNeighbor`,category:`image`,inputs:[{start:0,name:`images`,type:`tensor`},{start:1,name:`size`,type:`number[]`}],attrs:[{tfName:`align_corners`,name:`alignCorners`,type:`bool`},{tfName:`half_pixel_centers`,name:`halfPixelCenters`,type:`bool`},{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`CropAndResize`,category:`image`,inputs:[{start:0,name:`image`,type:`tensor`},{start:1,name:`boxes`,type:`tensor`},{start:2,name:`boxInd`,type:`tensor`},{start:3,name:`cropSize`,type:`number[]`}],attrs:[{tfName:`method`,name:`method`,type:`string`},{tfName:`extrapolation_value`,name:`extrapolationValue`,type:`number`}]},{tfOpName:`ImageProjectiveTransformV3`,category:`image`,inputs:[{start:0,name:`images`,type:`tensor`},{start:1,name:`transforms`,type:`tensor`},{start:2,name:`outputShape`,type:`number[]`},{start:3,name:`fillValue`,type:`number`}],attrs:[{tfName:`interpolation`,name:`interpolation`,type:`string`},{tfName:`fill_mode`,name:`fillMode`,type:`string`}]}]})),Pue=c({json:()=>MF}),MF,Fue=o((()=>{MF=[{tfOpName:`Equal`,category:`logical`,inputs:[{start:0,name:`a`,type:`tensor`},{start:1,name:`b`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`NotEqual`,category:`logical`,inputs:[{start:0,name:`a`,type:`tensor`},{start:1,name:`b`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Greater`,category:`logical`,inputs:[{start:0,name:`a`,type:`tensor`},{start:1,name:`b`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`GreaterEqual`,category:`logical`,inputs:[{start:0,name:`a`,type:`tensor`},{start:1,name:`b`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Less`,category:`logical`,inputs:[{start:0,name:`a`,type:`tensor`},{start:1,name:`b`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`LessEqual`,category:`logical`,inputs:[{start:0,name:`a`,type:`tensor`},{start:1,name:`b`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`LogicalAnd`,category:`logical`,inputs:[{start:0,name:`a`,type:`tensor`},{start:1,name:`b`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`LogicalNot`,category:`logical`,inputs:[{start:0,name:`a`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`LogicalOr`,category:`logical`,inputs:[{start:0,name:`a`,type:`tensor`},{start:1,name:`b`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Select`,category:`logical`,inputs:[{start:0,name:`condition`,type:`tensor`},{start:1,name:`a`,type:`tensor`},{start:2,name:`b`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`SelectV2`,category:`logical`,inputs:[{start:0,name:`condition`,type:`tensor`},{start:1,name:`a`,type:`tensor`},{start:2,name:`b`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`BitwiseAnd`,category:`logical`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`y`,type:`tensor`}]}]})),Iue=c({json:()=>NF}),NF,Lue=o((()=>{NF=[{tfOpName:`_FusedMatMul`,category:`matrices`,inputs:[{start:0,name:`a`,type:`tensor`},{start:1,name:`b`,type:`tensor`},{start:2,end:0,name:`args`,type:`tensors`}],attrs:[{tfName:`num_args`,name:`numArgs`,type:`number`},{tfName:`fused_ops`,name:`fusedOps`,type:`string[]`,defaultValue:[]},{tfName:`epsilon`,name:`epsilon`,type:`number`,defaultValue:1e-4},{tfName:`transpose_a`,name:`transposeA`,type:`bool`,defaultValue:!1},{tfName:`transpose_b`,name:`transposeB`,type:`bool`,defaultValue:!1},{tfName:`leakyrelu_alpha`,name:`leakyreluAlpha`,type:`number`,defaultValue:.2},{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`MatMul`,category:`matrices`,inputs:[{start:0,name:`a`,type:`tensor`},{start:1,name:`b`,type:`tensor`}],attrs:[{tfName:`transpose_a`,name:`transposeA`,type:`bool`,defaultValue:!1},{tfName:`transpose_b`,name:`transposeB`,type:`bool`,defaultValue:!1},{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`BatchMatMul`,category:`matrices`,inputs:[{start:0,name:`a`,type:`tensor`},{start:1,name:`b`,type:`tensor`}],attrs:[{tfName:`adj_x`,name:`transposeA`,type:`bool`,defaultValue:!1},{tfName:`adj_y`,name:`transposeB`,type:`bool`,defaultValue:!1},{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`BatchMatMulV2`,category:`matrices`,inputs:[{start:0,name:`a`,type:`tensor`},{start:1,name:`b`,type:`tensor`}],attrs:[{tfName:`adj_x`,name:`transposeA`,type:`bool`,defaultValue:!1},{tfName:`adj_y`,name:`transposeB`,type:`bool`,defaultValue:!1},{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Transpose`,category:`matrices`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`perm`,type:`number[]`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Einsum`,category:`matrices`,inputs:[{start:0,end:0,name:`tensors`,type:`tensors`}],attrs:[{tfName:`equation`,name:`equation`,type:`string`},{tfName:`N`,name:`n`,type:`number`,defaultValue:2},{tfName:`T`,name:`dtype`,type:`dtype`}]},{tfOpName:`MatrixBandPart`,category:`matrices`,inputs:[{start:0,name:`a`,type:`tensor`},{start:1,name:`numLower`,type:`tensor`},{start:1,name:`numUpper`,type:`tensor`}]}]})),Rue=c({json:()=>PF}),PF,zue=o((()=>{PF=[{tfOpName:`EuclideanNorm`,category:`normalization`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`axis`,type:`number[]`}],attrs:[{tfName:`keep_dims`,name:`keepDims`,type:`bool`,defaultValue:!1}]},{tfOpName:`FusedBatchNorm`,category:`normalization`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`scale`,type:`tensor`},{start:2,name:`offset`,type:`tensor`},{start:3,name:`mean`,type:`tensor`},{start:4,name:`variance`,type:`tensor`}],attrs:[{tfName:`epsilon`,name:`epsilon`,type:`number`,defaultValue:.001},{tfName:`data_format`,name:`dataFormat`,type:`string`,notSupported:!0}]},{tfOpName:`FusedBatchNormV2`,category:`normalization`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`scale`,type:`tensor`},{start:2,name:`offset`,type:`tensor`},{start:3,name:`mean`,type:`tensor`},{start:4,name:`variance`,type:`tensor`}],attrs:[{tfName:`epsilon`,name:`epsilon`,type:`number`,defaultValue:.001},{tfName:`data_format`,name:`dataFormat`,type:`string`,notSupported:!0}]},{tfOpName:`FusedBatchNormV3`,category:`normalization`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`scale`,type:`tensor`},{start:2,name:`offset`,type:`tensor`},{start:3,name:`mean`,type:`tensor`},{start:4,name:`variance`,type:`tensor`}],attrs:[{tfName:`epsilon`,name:`epsilon`,type:`number`,defaultValue:.001},{tfName:`data_format`,name:`dataFormat`,type:`string`,notSupported:!0}]},{tfOpName:`LRN`,category:`normalization`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`depth_radius`,name:`radius`,type:`number`,defaultValue:5},{tfName:`bias`,name:`bias`,type:`number`,defaultValue:1},{tfName:`alpha`,name:`alpha`,type:`number`,defaultValue:1},{tfName:`beta`,name:`beta`,type:`number`,defaultValue:.5}]},{tfOpName:`Softmax`,category:`normalization`,inputs:[{start:0,name:`x`,type:`tensor`}]},{tfOpName:`LogSoftmax`,category:`normalization`,inputs:[{start:0,name:`x`,type:`tensor`}]}]})),Bue=c({json:()=>FF}),FF,Vue=o((()=>{FF=[{tfOpName:`Bincount`,category:`reduction`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`size`,type:`number`},{start:2,name:`weights`,type:`tensor`}]},{tfOpName:`DenseBincount`,category:`reduction`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`size`,type:`number`},{start:2,name:`weights`,type:`tensor`}],attrs:[{tfName:`binary_output`,name:`binaryOutput`,type:`bool`}]},{tfOpName:`Max`,category:`reduction`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`axis`,type:`number[]`}],attrs:[{tfName:`keep_dims`,name:`keepDims`,type:`bool`}]},{tfOpName:`Mean`,category:`reduction`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`axis`,type:`number[]`}],attrs:[{tfName:`keep_dims`,name:`keepDims`,type:`bool`}]},{tfOpName:`Min`,category:`reduction`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`axis`,type:`number[]`}],attrs:[{tfName:`keep_dims`,name:`keepDims`,type:`bool`}]},{tfOpName:`Sum`,category:`reduction`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`axis`,type:`number[]`}],attrs:[{tfName:`keep_dims`,name:`keepDims`,type:`bool`}]},{tfOpName:`All`,category:`reduction`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`axis`,type:`number[]`}],attrs:[{tfName:`keep_dims`,name:`keepDims`,type:`bool`}]},{tfOpName:`Any`,category:`reduction`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`axis`,type:`number[]`}],attrs:[{tfName:`keep_dims`,name:`keepDims`,type:`bool`}]},{tfOpName:`ArgMax`,category:`reduction`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`axis`,type:`number`}]},{tfOpName:`ArgMin`,category:`reduction`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`axis`,type:`number`}]},{tfOpName:`Prod`,category:`reduction`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`axis`,type:`number[]`}],attrs:[{tfName:`keep_dims`,name:`keepDims`,type:`bool`},{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`Cumprod`,category:`reduction`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`axis`,type:`number`}],attrs:[{tfName:`exclusive`,name:`exclusive`,type:`bool`},{tfName:`reverse`,name:`reverse`,type:`bool`}]},{tfOpName:`Cumsum`,category:`reduction`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`axis`,type:`number`}],attrs:[{tfName:`exclusive`,name:`exclusive`,type:`bool`},{tfName:`reverse`,name:`reverse`,type:`bool`}]}]})),Hue=c({json:()=>IF}),IF,Uue=o((()=>{IF=[{tfOpName:`ConcatV2`,category:`slice_join`,inputs:[{start:0,end:-1,name:`tensors`,type:`tensors`},{start:-1,name:`axis`,type:`number`}],attrs:[{tfName:`N`,name:`n`,type:`number`,defaultValue:2}]},{tfOpName:`Concat`,category:`slice_join`,inputs:[{start:1,end:0,name:`tensors`,type:`tensors`},{start:0,name:`axis`,type:`number`}],attrs:[{tfName:`N`,name:`n`,type:`number`,defaultValue:2}]},{tfOpName:`GatherV2`,category:`slice_join`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`indices`,type:`tensor`},{start:2,name:`axis`,type:`number`,defaultValue:0}],attrs:[{tfName:`batch_dims`,name:`batchDims`,type:`number`,defaultValue:0}]},{tfOpName:`Gather`,category:`slice_join`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`indices`,type:`tensor`}],attrs:[{tfName:`validate_indices`,name:`validateIndices`,type:`bool`,notSupported:!0}]},{tfOpName:`Reverse`,category:`slice_join`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`dims`,type:`bool[]`}]},{tfOpName:`ReverseV2`,category:`slice_join`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`axis`,type:`number[]`}]},{tfOpName:`Slice`,category:`slice_join`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`begin`,type:`number[]`},{start:2,name:`size`,type:`number[]`}]},{tfOpName:`StridedSlice`,category:`slice_join`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`begin`,type:`number[]`},{start:2,name:`end`,type:`number[]`},{start:3,name:`strides`,type:`number[]`}],attrs:[{tfName:`begin_mask`,name:`beginMask`,type:`number`,defaultValue:0},{tfName:`end_mask`,name:`endMask`,type:`number`,defaultValue:0},{tfName:`new_axis_mask`,name:`newAxisMask`,type:`number`,defaultValue:0},{tfName:`ellipsis_mask`,name:`ellipsisMask`,type:`number`,defaultValue:0},{tfName:`shrink_axis_mask`,name:`shrinkAxisMask`,type:`number`,defaultValue:0}]},{tfOpName:`Pack`,category:`slice_join`,inputs:[{start:0,end:0,name:`tensors`,type:`tensors`}],attrs:[{tfName:`axis`,name:`axis`,type:`number`,defaultValue:0}]},{tfOpName:`Unpack`,category:`slice_join`,inputs:[{start:0,name:`tensor`,type:`tensor`}],attrs:[{tfName:`axis`,name:`axis`,type:`number`,defaultValue:0},{tfName:`num`,name:`num`,type:`number`,defaultValue:0,notSupported:!0}]},{tfOpName:`Tile`,category:`slice_join`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`reps`,type:`number[]`}]},{tfOpName:`Split`,category:`slice_join`,inputs:[{start:0,name:`axis`,type:`number`,defaultValue:0},{start:1,name:`x`,type:`tensor`}],attrs:[{tfName:`num_split`,name:`numOrSizeSplits`,type:`number`,defaultValue:1}]},{tfOpName:`SplitV`,category:`slice_join`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`numOrSizeSplits`,type:`number[]`},{start:2,name:`axis`,type:`number`,defaultValue:0}]},{tfOpName:`ScatterNd`,category:`slice_join`,inputs:[{start:0,name:`indices`,type:`tensor`},{start:1,name:`values`,type:`tensor`},{start:2,name:`shape`,type:`number[]`}]},{tfOpName:`GatherNd`,category:`slice_join`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`indices`,type:`tensor`}]},{tfOpName:`SparseToDense`,category:`slice_join`,inputs:[{start:0,name:`sparseIndices`,type:`tensor`},{start:1,name:`outputShape`,type:`number[]`},{start:2,name:`sparseValues`,type:`tensor`},{start:3,name:`defaultValue`,type:`tensor`}],attrs:[{tfName:`validate_indices`,name:`validateIndices`,type:`bool`,defaultValue:!1,notSupported:!0}]},{tfOpName:`TensorScatterUpdate`,category:`slice_join`,inputs:[{start:0,name:`tensor`,type:`tensor`},{start:1,name:`indices`,type:`tensor`},{start:2,name:`values`,type:`tensor`}]}]})),Wue=c({json:()=>LF}),LF,Gue=o((()=>{LF=[{tfOpName:`SparseFillEmptyRows`,category:`sparse`,inputs:[{start:0,name:`indices`,type:`tensor`},{start:1,name:`values`,type:`tensor`},{start:2,name:`denseShape`,type:`tensor`},{start:3,name:`defaultValue`,type:`tensor`}]},{tfOpName:`SparseReshape`,category:`sparse`,inputs:[{start:0,name:`inputIndices`,type:`tensor`},{start:1,name:`inputShape`,type:`tensor`},{start:2,name:`newShape`,type:`tensor`}],attrs:[{tfName:`T`,name:`dtype`,type:`dtype`,notSupported:!0}]},{tfOpName:`SparseSegmentMean`,category:`sparse`,inputs:[{start:0,name:`data`,type:`tensor`},{start:1,name:`indices`,type:`tensor`},{start:2,name:`segmentIds`,type:`tensor`}]},{tfOpName:`SparseSegmentSum`,category:`sparse`,inputs:[{start:0,name:`data`,type:`tensor`},{start:1,name:`indices`,type:`tensor`},{start:2,name:`segmentIds`,type:`tensor`}]}]})),Kue=c({json:()=>RF}),RF,que=o((()=>{RF=[{tfOpName:`FFT`,category:`spectral`,inputs:[{start:0,name:`x`,type:`tensor`}]},{tfOpName:`IFFT`,category:`spectral`,inputs:[{start:0,name:`x`,type:`tensor`}]},{tfOpName:`RFFT`,category:`spectral`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`fft_length`,type:`number`,notSupported:!0}]},{tfOpName:`IRFFT`,category:`spectral`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`fft_length`,type:`number`,notSupported:!0}]}]})),Jue=c({json:()=>zF}),zF,Yue=o((()=>{zF=[{tfOpName:`StaticRegexReplace`,category:`string`,inputs:[{start:0,name:`input`,type:`tensor`}],attrs:[{tfName:`pattern`,name:`pattern`,type:`string`},{tfName:`rewrite`,name:`rewrite`,type:`string`},{tfName:`replace_global`,name:`replaceGlobal`,type:`bool`}]},{tfOpName:`StringNGrams`,category:`string`,inputs:[{start:0,name:`data`,type:`tensor`},{start:1,name:`dataSplits`,type:`tensor`}],attrs:[{tfName:`separator`,name:`separator`,type:`string`},{tfName:`ngram_widths`,name:`nGramWidths`,type:`number[]`},{tfName:`left_pad`,name:`leftPad`,type:`string`},{tfName:`right_pad`,name:`rightPad`,type:`string`},{tfName:`pad_width`,name:`padWidth`,type:`number`},{tfName:`preserve_short_sequences`,name:`preserveShortSequences`,type:`bool`}],outputs:[`ngrams`,`ngrams_splits`]},{tfOpName:`StringSplit`,category:`string`,inputs:[{start:0,name:`input`,type:`tensor`},{start:1,name:`delimiter`,type:`tensor`}],attrs:[{tfName:`skip_empty`,name:`skipEmpty`,type:`bool`}],outputs:[`indices`,`values`,`shape`]},{tfOpName:`StringToHashBucketFast`,category:`string`,inputs:[{start:0,name:`input`,type:`tensor`}],attrs:[{tfName:`num_buckets`,name:`numBuckets`,type:`number`}]}]})),Xue=c({json:()=>BF}),BF,Zue=o((()=>{BF=[{tfOpName:`Cast`,category:`transformation`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`SrcT`,name:`sdtype`,type:`dtype`,notSupported:!0},{tfName:`DstT`,name:`dtype`,type:`dtype`}]},{tfOpName:`ExpandDims`,category:`transformation`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`axis`,type:`number`}]},{tfOpName:`MirrorPad`,category:`transformation`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`padding`,type:`number[]`}],attrs:[{tfName:`mode`,name:`mode`,type:`string`}]},{tfOpName:`Pad`,category:`transformation`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`padding`,type:`number[]`}],attrs:[{tfName:`constant_value`,name:`constantValue`,type:`number`,defaultValue:0}]},{tfOpName:`PadV2`,category:`transformation`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`padding`,type:`number[]`},{start:2,name:`constantValue`,type:`number`,defaultValue:0}]},{tfOpName:`Reshape`,category:`transformation`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`shape`,type:`number[]`}]},{tfOpName:`EnsureShape`,category:`transformation`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`shape`,type:`number[]`}]},{tfOpName:`Squeeze`,category:`transformation`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`axis`,tfDeprecatedName:`squeeze_dims`,name:`axis`,type:`number[]`}]},{tfOpName:`SpaceToBatchND`,category:`transformation`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`blockShape`,type:`number[]`},{start:2,name:`paddings`,type:`number[]`}]},{tfOpName:`BatchToSpaceND`,category:`transformation`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`blockShape`,type:`number[]`},{start:2,name:`crops`,type:`number[]`}]},{tfOpName:`DepthToSpace`,category:`transformation`,inputs:[{start:0,name:`x`,type:`tensor`}],attrs:[{tfName:`block_size`,name:`blockSize`,type:`number`},{tfName:`data_format`,name:`dataFormat`,type:`string`}]},{tfOpName:`BroadcastTo`,category:`transformation`,inputs:[{start:0,name:`x`,type:`tensor`},{start:1,name:`shape`,type:`number[]`}],attrs:[]},{tfOpName:`BroadcastArgs`,category:`transformation`,inputs:[{start:0,name:`s0`,type:`tensor`},{start:1,name:`s1`,type:`tensor`}],attrs:[]}]}));function Que(e){let t=k().global;if(t.atob!==void 0)return t.atob(e);if(typeof Buffer<`u`)return new Buffer(e,`base64`).toString();throw Error(`Unable to decode base64 in this environment. Missing built-in atob() or Buffer()`)}function VF(e,t){let n=Array.isArray(e)?String.fromCharCode.apply(null,e):Que(e);return t?n:n.toLowerCase()}function HF(e,t,n,r=!1){let i=e[t];return i==null?n:VF(i.s,r)}function UF(e,t,n){let r=e[t];return r?r.b:n}function WF(e,t,n){let r=e[t]||{},i=r.i==null?r.f==null?n:r.f:r.i;return typeof i==`number`?i:parseInt(i,10)}function GF(e){switch(typeof e==`string`&&(e=uF[e]),e){case uF.DT_FLOAT:case uF.DT_HALF:return`float32`;case uF.DT_INT32:case uF.DT_INT64:case uF.DT_INT8:case uF.DT_UINT8:return`int32`;case uF.DT_BOOL:return`bool`;case uF.DT_DOUBLE:return`float32`;case uF.DT_STRING:return`string`;case uF.DT_COMPLEX64:case uF.DT_COMPLEX128:return`complex64`;default:return null}}function KF(e,t,n){let r=e[t];return r&&r.func?r.func.name:n}function qF(e,t,n){let r=e[t];return r&&r.type?GF(r.type):n}function JF(e,t,n){let r=e[t];return r&&r.list&&r.list.type?r.list.type.map(e=>GF(e)):n}function YF(e){if(!e.unknownRank)return e.dim==null?[]:e.dim.map(e=>typeof e.size==`number`?e.size:parseInt(e.size,10))}function XF(e,t,n){let r=e[t];return r&&r.shape?YF(r.shape):n}function ZF(e,t,n){let r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(e=>typeof e==`number`?e:parseInt(e,10)):n}function QF(e,t,n,r=!1){let i=e[t];return i&&i.list&&i.list.s?i.list.s.map(e=>VF(e,r)):n}function $F(e,t,n){let r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map(e=>YF(e)):n}function eI(e,t,n){let r=e[t];return r&&r.list&&r.list.b?r.list.b:n}var tI,nI=o((()=>{Y(),due(),pF(),xF(),hue(),_ue(),yue(),xue(),Cue(),Tue(),Due(),kue(),jue(),Nue(),Fue(),Lue(),zue(),Vue(),Uue(),Gue(),que(),Yue(),Zue(),tI=class{static get Instance(){return this._instance||=new this}constructor(){let e=[mue,gue,vue,bue,Sue,wue,Eue,Oue,Aue,Mue,Pue,Iue,Rue,Bue,Hue,Wue,Kue,Jue,Xue];this.opMappers=[].concat(...e.map(e=>e.json)).reduce((e,t)=>(e[t.tfOpName]=t,e),{})}transformGraph(e,t={}){let n=e.node,r=[],i=[],a=[],o=n.reduce((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith(`Placeholder`)?r.push(e[t.name]):t.op===`Const`?i.push(e[t.name]):(t.input==null||t.input.length===0)&&a.push(e[t.name]),e),{}),s=[],c=[],l={},u={};t!=null&&(l=this.mapSignatureEntries(t.inputs),u=this.mapSignatureEntries(t.outputs));let d=Object.keys(o);d.forEach(e=>{let t=o[e];t.inputNames.forEach((e,n)=>{let[r,,i]=gF(e),a=o[r];if(a.outputs!=null){let e=a.outputs.indexOf(i);if(e!==-1){let i=`${r}:${e}`;t.inputNames[n]=i}}t.inputs.push(a),a.children.push(t)})}),Object.keys(u).length===0?d.forEach(e=>{let t=o[e];t.children.length===0&&c.push(t)}):Object.keys(u).forEach(e=>{let[t]=gF(e),n=o[t];n!=null&&(n.signatureKey=u[e],c.push(n))}),Object.keys(l).length>0?Object.keys(l).forEach(e=>{let[t]=gF(e),n=o[t];n&&(n.signatureKey=l[e],s.push(n))}):s=r;let f={};e.library!=null&&e.library.function!=null&&(f=e.library.function.reduce((e,t)=>(e[t.signature.name]=this.mapFunction(t),e),{}));let p={nodes:o,inputs:s,outputs:c,weights:i,placeholders:r,signature:t,functions:f};return a.length>0&&(p.initNodes=a),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){let t=dF(e.op)||this.opMappers[e.op]||{};e.attr??={};let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(e=>e.startsWith(`^`)?e.slice(1):e),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((t,n)=>{let r=n.type,i;switch(n.type){case`string`:i=HF(e.attr,n.tfName,n.defaultValue),i===void 0&&n.tfDeprecatedName&&(i=HF(e.attr,n.tfDeprecatedName,n.defaultValue));break;case`string[]`:i=QF(e.attr,n.tfName,n.defaultValue),i===void 0&&n.tfDeprecatedName&&(i=QF(e.attr,n.tfDeprecatedName,n.defaultValue));break;case`number`:i=WF(e.attr,n.tfName,n.defaultValue||0),i===void 0&&n.tfDeprecatedName&&(i=WF(e.attr,n.tfDeprecatedName,n.defaultValue));break;case`number[]`:i=ZF(e.attr,n.tfName,n.defaultValue),i===void 0&&n.tfDeprecatedName&&(i=ZF(e.attr,n.tfDeprecatedName,n.defaultValue));break;case`bool`:i=UF(e.attr,n.tfName,n.defaultValue),i===void 0&&n.tfDeprecatedName&&(i=UF(e.attr,n.tfDeprecatedName,n.defaultValue));break;case`bool[]`:i=eI(e.attr,n.tfName,n.defaultValue),i===void 0&&n.tfDeprecatedName&&(i=eI(e.attr,n.tfDeprecatedName,n.defaultValue));break;case`shape`:i=XF(e.attr,n.tfName,n.defaultValue),i===void 0&&n.tfDeprecatedName&&(i=XF(e.attr,n.tfDeprecatedName,n.defaultValue));break;case`shape[]`:i=$F(e.attr,n.tfName,n.defaultValue),i===void 0&&n.tfDeprecatedName&&(i=$F(e.attr,n.tfDeprecatedName,n.defaultValue));break;case`dtype`:i=qF(e.attr,n.tfName,n.defaultValue),i===void 0&&n.tfDeprecatedName&&(i=qF(e.attr,n.tfDeprecatedName,n.defaultValue));break;case`dtype[]`:i=JF(e.attr,n.tfName,n.defaultValue),i===void 0&&n.tfDeprecatedName&&(i=JF(e.attr,n.tfDeprecatedName,n.defaultValue));break;case`func`:i=KF(e.attr,n.tfName,n.defaultValue),i===void 0&&n.tfDeprecatedName&&(i=KF(e.attr,n.tfDeprecatedName,n.defaultValue));break;case`tensor`:case`tensors`:break;default:throw Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:i,type:r},t},{})),n}mapFunction(e){let t=e.nodeDef,n=[],r=[],i={};t!=null&&(i=t.reduce((e,t)=>(e[t.name]=this.mapNode(t),t.op===`Const`&&r.push(e[t.name]),e),{}));let a=[],o=[];e.signature.inputArg.forEach(e=>{let[t]=gF(e.name),n={name:t,op:`Placeholder`,inputs:[],inputNames:[],category:`graph`,inputParams:{},attrParams:{dtype:{value:GF(e.type),type:`dtype`}},children:[]};n.signatureKey=e.name,a.push(n),i[t]=n}),Object.keys(i).forEach(e=>{let t=i[e];t.inputNames.forEach((e,n)=>{let[r,,a]=gF(e),o=i[r];if(o.outputs!=null){let e=o.outputs.indexOf(a);if(e!==-1){let i=`${r}:${e}`;t.inputNames[n]=i}}t.inputs.push(o),o.children.push(t)})});let s=e.ret;e.signature.outputArg.forEach(e=>{let[t,n]=gF(s[e.name]),r=i[t];r!=null&&(r.defaultOutput=n,o.push(r))});let c=this.mapArgsToSignature(e);return{nodes:i,inputs:a,outputs:o,weights:r,placeholders:n,signature:c}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return t!=null&&(n=t[n]),{name:n,dtype:e.type}}}})),rI,$ue=o((()=>{xF(),nI(),rI=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(e=>this.getInput(e)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((e,t)=>(e[t]=this.getAttr(t),e),{}))}getInput(e){return mF(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(n.tensor!=null)return mF(e,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return WF(this.node.rawAttrs,e,t);if(n.s!=null)return HF(this.node.rawAttrs,e,t);if(n.b!=null)return UF(this.node.rawAttrs,e,t);if(n.shape!=null)return XF(this.node.rawAttrs,e,t);if(n.type!=null)return qF(this.node.rawAttrs,e,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return ZF(this.node.rawAttrs,e,t);if(n.list.s!=null)return QF(this.node.rawAttrs,e,t);if(n.list.shape!=null)return $F(this.node.rawAttrs,e,t);if(n.list.b!=null)return eI(this.node.rawAttrs,e,t);if(n.list.type!=null)return JF(this.node.rawAttrs,e,t)}return t}}})),iI=c({OP_SCOPE_SUFFIX:()=>uo,abs:()=>Fc,acos:()=>Rc,acosh:()=>Vc,add:()=>H,addN:()=>Wc,all:()=>qc,any:()=>Xc,argMax:()=>$c,argMin:()=>nl,asin:()=>al,asinh:()=>cl,atan:()=>dl,atan2:()=>ml,atanh:()=>_l,avgPool:()=>Vl,avgPool3d:()=>Wl,basicLSTMCell:()=>cu,batchNorm:()=>gu,batchNorm2d:()=>yu,batchNorm3d:()=>Su,batchNorm4d:()=>Tu,batchToSpaceND:()=>du,bincount:()=>Ou,bitwiseAnd:()=>ju,booleanMaskAsync:()=>yv,broadcastArgs:()=>Pu,broadcastTo:()=>Lu,buffer:()=>mc,cast:()=>V,ceil:()=>Bu,clipByValue:()=>Gu,clone:()=>yc,complex:()=>po,concat:()=>ql,concat1d:()=>Ju,concat2d:()=>Zu,concat3d:()=>ed,concat4d:()=>rd,conv1d:()=>ld,conv2d:()=>od,conv2dTranspose:()=>hd,conv3d:()=>vd,conv3dTranspose:()=>wd,cos:()=>Dd,cosh:()=>Ad,cosineWindow:()=>Ov,cumprod:()=>Nd,cumsum:()=>Id,denseBincount:()=>zd,depthToSpace:()=>Hd,depthwiseConv2d:()=>Gd,diag:()=>Jd,dilation2d:()=>Zd,div:()=>Ac,divNoNan:()=>gf,dot:()=>yf,dropout:()=>Ev,einsum:()=>Sf,elu:()=>Tf,enclosingPowerOfTwo:()=>Dv,ensureShape:()=>Of,equal:()=>sf,erf:()=>jf,euclideanNorm:()=>fp,exp:()=>hp,expandDims:()=>vp,expm1:()=>xp,eye:()=>Dp,fft:()=>u_,fill:()=>Hu,floor:()=>Ap,floorDiv:()=>Dc,fused:()=>Kv,gather:()=>Np,gatherND:()=>Tv,greater:()=>Ip,greaterEqual:()=>zp,ifft:()=>f_,imag:()=>Hp,image:()=>_b,inTopKAsync:()=>Av,irfft:()=>m_,isFinite:()=>Gp,isInf:()=>Jp,isNaN:()=>Zp,leakyRelu:()=>em,less:()=>rm,lessEqual:()=>om,linalg:()=>vb,linspace:()=>cm,localResponseNormalization:()=>lm,log:()=>dm,log1p:()=>pm,logSigmoid:()=>Em,logSoftmax:()=>jm,logSumExp:()=>Pm,logicalAnd:()=>Lm,logicalNot:()=>Bm,logicalOr:()=>Um,logicalXor:()=>Gm,losses:()=>yb,lowerBound:()=>Xm,matMul:()=>Xl,max:()=>Uf,maxPool:()=>Zm,maxPool3d:()=>$m,maxPoolWithArgmax:()=>eh,maximum:()=>th,mean:()=>rh,meshgrid:()=>lh,min:()=>Kf,minimum:()=>uh,mirrorPad:()=>fh,mod:()=>mh,moments:()=>gh,movingAverage:()=>Sv,mul:()=>U,multiRNNCell:()=>_h,multinomial:()=>vh,neg:()=>bm,norm:()=>lp,notEqual:()=>yh,oneHot:()=>xh,ones:()=>sh,onesLike:()=>wh,op:()=>R,outerProduct:()=>Dh,pad:()=>Ah,pad1d:()=>Nh,pad2d:()=>Ih,pad3d:()=>zh,pad4d:()=>Bh,pool:()=>Uh,pow:()=>Yf,prelu:()=>Gh,print:()=>xc,prod:()=>qh,raggedGather:()=>Yh,raggedRange:()=>Xh,raggedTensorToTensor:()=>Zh,rand:()=>Qh,randomGamma:()=>ug,randomNormal:()=>dg,randomStandardNormal:()=>pg,randomUniform:()=>mg,randomUniformInt:()=>gg,range:()=>_g,real:()=>bg,reciprocal:()=>Sg,relu:()=>Tg,relu6:()=>Dg,reshape:()=>W,reverse:()=>Ag,reverse1d:()=>Ng,reverse2d:()=>Pg,reverse3d:()=>Fg,reverse4d:()=>Ig,rfft:()=>__,round:()=>Lg,rsqrt:()=>zg,scalar:()=>Zf,scatterND:()=>Cv,searchSorted:()=>Jm,selu:()=>Hg,separableConv2d:()=>Gg,setdiff1dAsync:()=>Jg,sigmoid:()=>$l,sign:()=>Zg,signal:()=>gb,sin:()=>e_,sinh:()=>n_,slice:()=>nu,slice1d:()=>i_,slice2d:()=>a_,slice3d:()=>o_,slice4d:()=>s_,softmax:()=>c_,softplus:()=>Cm,spaceToBatchND:()=>Vh,sparse:()=>bb,sparseToDense:()=>wv,spectral:()=>hb,split:()=>h_,sqrt:()=>ep,square:()=>rp,squaredDifference:()=>y_,squeeze:()=>x_,stack:()=>C_,step:()=>E_,stridedSlice:()=>k_,string:()=>xb,sub:()=>q,sum:()=>K,tan:()=>M_,tanh:()=>au,tensor:()=>_o,tensor1d:()=>P_,tensor2d:()=>I_,tensor3d:()=>R_,tensor4d:()=>B_,tensor5d:()=>H_,tensor6d:()=>W_,tensorScatterUpdate:()=>Q_,tile:()=>wp,topk:()=>tv,transpose:()=>bv,truncatedNormal:()=>iv,unique:()=>sv,unsortedSegmentSum:()=>lv,unstack:()=>dv,upperBound:()=>pv,variable:()=>mv,where:()=>uf,whereAsync:()=>_v,zeros:()=>ah,zerosLike:()=>pf}),aI=o((()=>{Sb()})),oI,ede=o((()=>{aI(),xF(),oI=(e,t,n,r=iI)=>{switch(e.op){case`BiasAdd`:case`AddV2`:case`Add`:return[r.add(Z(`a`,e,t,n),Z(`b`,e,t,n))];case`AddN`:return[r.addN(Z(`tensors`,e,t,n))];case`FloorMod`:case`Mod`:return[r.mod(Z(`a`,e,t,n),Z(`b`,e,t,n))];case`Mul`:return[r.mul(Z(`a`,e,t,n),Z(`b`,e,t,n))];case`RealDiv`:case`Div`:return[r.div(Z(`a`,e,t,n),Z(`b`,e,t,n))];case`DivNoNan`:return[r.divNoNan(Z(`a`,e,t,n),Z(`b`,e,t,n))];case`FloorDiv`:return[r.floorDiv(Z(`a`,e,t,n),Z(`b`,e,t,n))];case`Sub`:return[r.sub(Z(`a`,e,t,n),Z(`b`,e,t,n))];case`Minimum`:return[r.minimum(Z(`a`,e,t,n),Z(`b`,e,t,n))];case`Maximum`:return[r.maximum(Z(`a`,e,t,n),Z(`b`,e,t,n))];case`Pow`:return[r.pow(Z(`a`,e,t,n),Z(`b`,e,t,n))];case`SquaredDifference`:return[r.squaredDifference(Z(`a`,e,t,n),Z(`b`,e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}})),sI,tde=o((()=>{aI(),xF(),sI=(e,t,n,r=iI)=>{switch(e.op){case`Abs`:case`ComplexAbs`:return[r.abs(Z(`x`,e,t,n))];case`Acos`:return[r.acos(Z(`x`,e,t,n))];case`Acosh`:return[r.acosh(Z(`x`,e,t,n))];case`Asin`:return[r.asin(Z(`x`,e,t,n))];case`Asinh`:return[r.asinh(Z(`x`,e,t,n))];case`Atan`:return[r.atan(Z(`x`,e,t,n))];case`Atan2`:return[r.atan2(Z(`x`,e,t,n),Z(`y`,e,t,n))];case`Atanh`:return[r.atanh(Z(`x`,e,t,n))];case`Ceil`:return[r.ceil(Z(`x`,e,t,n))];case`Complex`:return[r.complex(Z(`real`,e,t,n),Z(`imag`,e,t,n))];case`Cos`:return[r.cos(Z(`x`,e,t,n))];case`Cosh`:return[r.cosh(Z(`x`,e,t,n))];case`Elu`:return[r.elu(Z(`x`,e,t,n))];case`Erf`:return[r.erf(Z(`x`,e,t,n))];case`Exp`:return[r.exp(Z(`x`,e,t,n))];case`Expm1`:return[r.expm1(Z(`x`,e,t,n))];case`Floor`:return[r.floor(Z(`x`,e,t,n))];case`Log`:return[r.log(Z(`x`,e,t,n))];case`Log1p`:return[r.log1p(Z(`x`,e,t,n))];case`Imag`:return[r.imag(Z(`x`,e,t,n))];case`Neg`:return[r.neg(Z(`x`,e,t,n))];case`Reciprocal`:return[r.reciprocal(Z(`x`,e,t,n))];case`Real`:return[r.real(Z(`x`,e,t,n))];case`Relu`:return[r.relu(Z(`x`,e,t,n))];case`Round`:return[r.round(Z(`x`,e,t,n))];case`Selu`:return[r.selu(Z(`x`,e,t,n))];case`Sigmoid`:return[r.sigmoid(Z(`x`,e,t,n))];case`Sin`:return[r.sin(Z(`x`,e,t,n))];case`Sign`:return[r.sign(Z(`x`,e,t,n))];case`Sinh`:return[r.sinh(Z(`x`,e,t,n))];case`Softplus`:return[r.softplus(Z(`x`,e,t,n))];case`Sqrt`:return[r.sqrt(Z(`x`,e,t,n))];case`Square`:return[r.square(Z(`x`,e,t,n))];case`Tanh`:return[r.tanh(Z(`x`,e,t,n))];case`Tan`:return[r.tan(Z(`x`,e,t,n))];case`ClipByValue`:return[r.clipByValue(Z(`x`,e,t,n),Z(`clipValueMin`,e,t,n),Z(`clipValueMax`,e,t,n))];case`Relu6`:return[r.relu6(Z(`x`,e,t,n))];case`Rsqrt`:return[r.rsqrt(mF(e.inputNames[0],t,n))];case`LeakyRelu`:return[r.leakyRelu(Z(`x`,e,t,n),Z(`alpha`,e,t,n))];case`Prelu`:return[r.prelu(Z(`x`,e,t,n),Z(`alpha`,e,t,n))];case`IsNan`:return[r.isNaN(mF(e.inputNames[0],t,n))];case`IsInf`:return[r.isInf(mF(e.inputNames[0],t,n))];case`IsFinite`:return[r.isFinite(mF(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}}));function cI(e,t,n=``){if(!(typeof e==`number`||typeof t==`number`)){D(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let r=0;r<e.length;r++){let i=e[r],a=t[r];D(i<0||a<0||i===a,()=>n+` Shapes ${e} and ${t} must match`)}}}function lI(e){return!(typeof e==`number`||e.some(e=>e<0))}function uI(e,t,n){let r=dI(e,n),i=!lI(r);if(i&&t.length===0)throw Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(i&&t.forEach(e=>{r=dI(e.shape,r)}),!lI(r))throw Error(`Non-fully-defined elementShape: ${r}`);return r}function dI(e,t){if(typeof e==`number`)return t;if(typeof t==`number`)return e;if(e.length!==t.length)throw Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let n=[];for(let r=0;r<e.length;++r){let i=e[r],a=t[r];if(i>=0&&a>=0&&i!==a)throw Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=i>=0?i:a}return n}var fI=o((()=>{Y()})),pI,nde=o((()=>{Y(),fI(),pI=class{constructor(e,t,n,r,i,a,o){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=i,this.dynamicSize=a,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=Zf(0),No(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(e=>this.read(e))}write(e,t){if(this.closed_)throw Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),cI(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,No(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((e,n)=>this.write(e,t[n]))}gather(e,t){if(t&&t!==this.dtype)throw Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(e.length===0)return _o([],[0].concat(this.elementShape));let n=this.readMany(e);return cI(this.elementShape,n[0].shape,`TensorArray shape mismatch: `),C_(n,0)}concat(e){if(e&&e!==this.dtype)throw Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return _o([],[0].concat(this.elementShape));let t=[];for(let e=0;e<this.size();e++)t.push(e);let n=this.readMany(t);return cI(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),ql(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,dv(t,0))}split(e,t){if(t.dtype!==this.dtype)throw Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,r=e.map(e=>(n+=e,n));if(n!==t.shape[0])throw Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let i=n===0?0:t.size/n,a=[];B(()=>{t=W(t,[1,n,i]);for(let n=0;n<e.length;++n){let o=[0,n===0?0:r[n-1],0],s=[1,e[n],i];a[n]=W(nu(t,o,s),this.elementShape)}return a});let o=[];for(let t=0;t<e.length;t++)o[t]=t;this.writeMany(o,a)}}}));function rde(e,t,n){let r=e.dtype;if(e.shape.length<1)throw Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);let i=e.shape.slice(1);cI(i,t,`TensorList shape mismatch: `);let a=dv(e);return new mI(a,t,r)}function ide(e,t,n,r){return new mI([],e,t,r)}function ade(e,t,n,r){if(t.length!==e.shape[0])throw Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let i=Math.max(...t);if(r!=null&&r!==-1&&i>=r)throw Error(`Max index must be < array size (${i}  vs. ${r})`);let a=new mI([],n,e.dtype,r),o=dv(e,0);return t.forEach((e,t)=>{a.setItem(e,o[t])}),a}function ode(e,t,n){let r=0,i=t.map(e=>(r+=e,r));if(r!==e.shape[0])throw Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${e.shape}`);let a=e.shape.slice(1),o=dI(a,n),s=r===0?0:e.size/r,c=B(()=>{let n=[];e=W(e,[1,r,s]);for(let r=0;r<t.length;++r){let a=[0,r===0?0:i[r-1],0],c=[1,t[r],s];n[r]=W(nu(e,a,c),o)}return e.dispose(),n}),l=new mI([],n,e.dtype,t.length);for(let e=0;e<c.length;e++)l.setItem(e,c[e]);return l}var mI,sde=o((()=>{Y(),fI(),mI=class e{get id(){return this.idTensor.id}constructor(e,t,n,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,e?.forEach(e=>{if(n!==e.dtype)throw Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);cI(t,e.shape,`TensorList shape mismatch: `),No(e)}),this.idTensor=Zf(0),this.maxNumElements=r,No(this.idTensor)}copy(){return new e([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(n!==-1&&this.tensors.length!==n)throw Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);cI(e,this.elementShape,`TensorList shape mismatch: `);let r=uI(this.elementShape,this.tensors,e);return B(()=>{let e=this.tensors.map(e=>W(e,r));return C_(e,0)})}popBack(e,t){if(t!==this.elementDtype)throw Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw Error(`Trying to pop from an empty list.`);let n=uI(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,cI(r.shape,e,`TensorList shape mismatch: `),W(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(cI(e.shape,this.elementShape,`TensorList shape mismatch: `),this.maxNumElements===this.size())throw Error(`Trying to push element into a full list.`);No(e),this.tensors.push(e)}resize(t){if(t<0)throw Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);let n=new e([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=t;for(let e=0;e<Math.min(this.tensors.length,t);++e)n.tensors[e]=this.tensors[e];return n}getItem(e,t,n){if(n!==this.elementDtype)throw Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw Error(`element at index ${e} is null.`);cI(this.tensors[e].shape,t,`TensorList shape mismatch: `);let r=uI(this.elementShape,this.tensors,t);return W(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);cI(this.elementShape,t.shape,`TensorList shape mismatch: `),No(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);cI(this.elementShape,n,`TensorList shape mismatch: `),e=e.slice(0,this.size());let r=uI(this.elementShape,this.tensors,n);return e.length===0?_o([],[0].concat(r)):B(()=>{let t=e.map(e=>W(this.tensors[e],r));return C_(t,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);cI(this.elementShape,t,`TensorList shape mismatch: `);let n=uI(this.elementShape,this.tensors,t);return this.size()===0?_o([],[0].concat(n)):B(()=>{let e=this.tensors.map(e=>W(e,n));return ql(e,0)})}}})),hI,cde=o((()=>{Y(),nde(),sde(),xF(),hI=async(e,t,n)=>{switch(e.op){case`If`:case`StatelessIf`:{let r=Z(`thenBranch`,e,t,n),i=Z(`elseBranch`,e,t,n),a=Z(`cond`,e,t,n),o=Z(`args`,e,t,n);return(await a.data())[0]?n.functionMap[r].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap):n.functionMap[i].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap)}case`While`:case`StatelessWhile`:{let r=Z(`body`,e,t,n),i=Z(`cond`,e,t,n),a=Z(`args`,e,t,n),o=await n.functionMap[i].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap),s=a.map(e=>e.id),c=await o[0].data();o.forEach(e=>{!e.kept&&s.indexOf(e.id)===-1&&e.dispose()});let l=a;for(;c[0];){let e=l;l=await n.functionMap[r].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);let t=l.map(e=>e.id);e.forEach(e=>{!e.kept&&s.indexOf(e.id)===-1&&t.indexOf(e.id)===-1&&e.dispose()});let a=await n.functionMap[i].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);c=await a[0].data(),a.forEach(e=>{!e.kept&&s.indexOf(e.id)===-1&&t.indexOf(e.id)===-1&&e.dispose()})}return l}case`LoopCond`:{let r=Z(`pred`,e,t,n);return[bF(r)]}case`Switch`:{let r=Z(`pred`,e,t,n),i=Z(`data`,e,t,n);return i.kept||(i=bF(i)),(await r.data())[0]?[void 0,i]:[i,void 0]}case`Merge`:{let r=e.inputNames.find(e=>mF(e,t,n)!==void 0);if(r){let e=mF(r,t,n);return[bF(e)]}return}case`Enter`:{let r=Z(`frameName`,e,t,n),i=Z(`tensor`,e,t,n);return n.enterFrame(r),[bF(i)]}case`Exit`:{let r=Z(`tensor`,e,t,n);return n.exitFrame(),[bF(r)]}case`NextIteration`:{let r=Z(`tensor`,e,t,n);return n.nextIteration(),[bF(r)]}case`TensorArrayV3`:{let r=Z(`size`,e,t,n),i=Z(`dtype`,e,t,n),a=Z(`elementShape`,e,t,n),o=Z(`dynamicSize`,e,t,n),s=Z(`clearAfterRead`,e,t,n),c=Z(`identicalElementShapes`,e,t,n),l=Z(`name`,e,t,n),u=new pI(l,i,r,a,c,o,s);return n.addTensorArray(u),[u.idTensor,Zf(1)]}case`TensorArrayWriteV3`:{let r=Z(`tensorArrayId`,e,t,n),i=Z(`index`,e,t,n),a=Z(`tensor`,e,t,n),o=n.getTensorArray(r.id);return o.write(i,a),[o.idTensor]}case`TensorArrayReadV3`:{let r=Z(`tensorArrayId`,e,t,n),i=Z(`index`,e,t,n);return[n.getTensorArray(r.id).read(i)]}case`TensorArrayGatherV3`:{let r=Z(`tensorArrayId`,e,t,n),i=Z(`indices`,e,t,n),a=Z(`dtype`,e,t,n);return[n.getTensorArray(r.id).gather(i,a)]}case`TensorArrayScatterV3`:{let r=Z(`tensorArrayId`,e,t,n),i=Z(`indices`,e,t,n),a=Z(`tensor`,e,t,n),o=n.getTensorArray(r.id);return o.scatter(i,a),[o.idTensor]}case`TensorArrayConcatV3`:{let r=Z(`tensorArrayId`,e,t,n),i=n.getTensorArray(r.id),a=Z(`dtype`,e,t,n);return[i.concat(a)]}case`TensorArraySplitV3`:{let r=Z(`tensorArrayId`,e,t,n),i=Z(`tensor`,e,t,n),a=Z(`lengths`,e,t,n),o=n.getTensorArray(r.id);return o.split(a,i),[o.idTensor]}case`TensorArraySizeV3`:{let r=Z(`tensorArrayId`,e,t,n),i=n.getTensorArray(r.id);return[Zf(i.size(),`int32`)]}case`TensorArrayCloseV3`:{let r=Z(`tensorArrayId`,e,t,n),i=n.getTensorArray(r.id);return i.clearAndClose(),[i.idTensor]}case`TensorListSetItem`:{let r=Z(`tensorListId`,e,t,n),i=Z(`index`,e,t,n),a=Z(`tensor`,e,t,n),o=n.getTensorList(r.id);return o.setItem(i,a),[o.idTensor]}case`TensorListGetItem`:{let r=Z(`tensorListId`,e,t,n),i=Z(`index`,e,t,n),a=Z(`elementShape`,e,t,n),o=Z(`elementDType`,e,t,n);return[n.getTensorList(r.id).getItem(i,a,o)]}case`TensorListScatterV2`:case`TensorListScatter`:{let r=Z(`indices`,e,t,n),i=Z(`tensor`,e,t,n),a=Z(`elementShape`,e,t,n),o=Z(`numElements`,e,t,n),s=ade(i,r,a,o);return n.addTensorList(s),[s.idTensor]}case`TensorListReserve`:case`EmptyTensorList`:{let r=Z(`elementShape`,e,t,n),i=Z(`elementDType`,e,t,n),a;a=e.op===`TensorListReserve`?`numElements`:`maxNumElements`;let o=Z(a,e,t,n),s=e.op===`TensorListReserve`?-1:o,c=ide(r,i,o,s);return n.addTensorList(c),[c.idTensor]}case`TensorListGather`:{let r=Z(`tensorListId`,e,t,n),i=Z(`indices`,e,t,n),a=Z(`elementShape`,e,t,n),o=Z(`elementDType`,e,t,n);return[n.getTensorList(r.id).gather(i,o,a)]}case`TensorListStack`:{let r=Z(`tensorListId`,e,t,n),i=Z(`elementShape`,e,t,n),a=Z(`elementDType`,e,t,n),o=Z(`numElements`,e,t,n);return[n.getTensorList(r.id).stack(i,a,o)]}case`TensorListFromTensor`:{let r=Z(`tensor`,e,t,n),i=Z(`elementShape`,e,t,n),a=Z(`elementDType`,e,t,n),o=rde(r,i,a);return n.addTensorList(o),[o.idTensor]}case`TensorListConcat`:case`TensorListConcatV2`:{let r=Z(`tensorListId`,e,t,n),i=n.getTensorList(r.id),a=Z(`dtype`,e,t,n),o=Z(`elementShape`,e,t,n);return[i.concat(a,o)]}case`TensorListPushBack`:{let r=Z(`tensorListId`,e,t,n),i=Z(`tensor`,e,t,n),a=n.getTensorList(r.id);return a.pushBack(i),[a.idTensor]}case`TensorListPopBack`:{let r=Z(`tensorListId`,e,t,n),i=Z(`elementShape`,e,t,n),a=Z(`elementDType`,e,t,n);return[n.getTensorList(r.id).popBack(i,a)]}case`TensorListSplit`:{let r=Z(`tensor`,e,t,n),i=Z(`elementShape`,e,t,n),a=Z(`lengths`,e,t,n),o=ode(r,a,i);return n.addTensorList(o),[o.idTensor]}case`TensorListLength`:{let r=Z(`tensorListId`,e,t,n),i=n.getTensorList(r.id);return[Zf(i.size(),`int32`)]}case`TensorListResize`:{let r=Z(`tensorListId`,e,t,n),i=Z(`size`,e,t,n),a=n.getTensorList(r.id).resize(i);return n.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}}));function gI(e,t,n){let[r,i]=Z(`fusedOps`,e,t,n),a=r===`biasadd`,o=!a,s=i===`prelu`,c=r===`fusedbatchnorm`,l=Z(`numArgs`,e,t,n);if(a){if(s&&l!==2)throw Error(`FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.`);if(!s&&a&&l!==1)throw Error(`FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.`)}if(c)throw Error(`FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported`);let u=Z(`strides`,e,t,n),d=yF(e,t,n),f=Z(`dataFormat`,e,t,n).toUpperCase(),p=Z(`dilations`,e,t,n),[m,h]=Z(`args`,e,t,n);o&&(h=m,m=void 0);let g=Z(`leakyreluAlpha`,e,t,n);return{stride:u,pad:d,dataFormat:f,dilations:p,biasArg:m,preluArg:h,activationFunc:i,leakyreluAlpha:g}}var _I,lde=o((()=>{aI(),xF(),_I=(e,t,n,r=iI)=>{switch(e.op){case`Conv1D`:{let i=Z(`stride`,e,t,n),a=Z(`pad`,e,t,n),o=Z(`dataFormat`,e,t,n).toUpperCase(),s=Z(`dilation`,e,t,n);return[r.conv1d(Z(`x`,e,t,n),Z(`filter`,e,t,n),i,a,o,s)]}case`Conv2D`:{let i=Z(`strides`,e,t,n),a=yF(e,t,n),o=Z(`dataFormat`,e,t,n).toUpperCase(),s=Z(`dilations`,e,t,n);return[r.conv2d(Z(`x`,e,t,n),Z(`filter`,e,t,n),[i[1],i[2]],a,o,[s[1],s[2]])]}case`_FusedConv2D`:{let{stride:i,pad:a,dataFormat:o,dilations:s,biasArg:c,preluArg:l,activationFunc:u,leakyreluAlpha:d}=gI(e,t,n);return[r.fused.conv2d({x:Z(`x`,e,t,n),filter:Z(`filter`,e,t,n),strides:[i[1],i[2]],pad:a,dataFormat:o,dilations:[s[1],s[2]],bias:c,activation:u,preluActivationWeights:l,leakyreluAlpha:d})]}case`FusedDepthwiseConv2dNative`:{let{stride:i,pad:a,dataFormat:o,dilations:s,biasArg:c,preluArg:l,activationFunc:u,leakyreluAlpha:d}=gI(e,t,n);return[r.fused.depthwiseConv2d({x:Z(`x`,e,t,n),filter:Z(`filter`,e,t,n),strides:[i[1],i[2]],pad:a,dataFormat:o,dilations:[s[1],s[2]],bias:c,activation:u,preluActivationWeights:l,leakyreluAlpha:d})]}case`Conv2DBackpropInput`:case`Conv2dTranspose`:{let i=Z(`outputShape`,e,t,n),a=Z(`strides`,e,t,n),o=yF(e,t,n);return[r.conv2dTranspose(Z(`x`,e,t,n),Z(`filter`,e,t,n),i,[a[1],a[2]],o)]}case`DepthwiseConv2dNative`:case`DepthwiseConv2d`:{let i=Z(`strides`,e,t,n),a=yF(e,t,n),o=Z(`dilations`,e,t,n),s=Z(`dataFormat`,e,t,n).toUpperCase();return[r.depthwiseConv2d(Z(`input`,e,t,n),Z(`filter`,e,t,n),[i[1],i[2]],a,s,[o[1],o[2]])]}case`Conv3D`:{let i=Z(`strides`,e,t,n),a=Z(`pad`,e,t,n),o=Z(`dataFormat`,e,t,n).toUpperCase(),s=Z(`dilations`,e,t,n);return[r.conv3d(Z(`x`,e,t,n),Z(`filter`,e,t,n),[i[1],i[2],i[3]],a,o,[s[1],s[2],s[3]])]}case`AvgPool`:{let i=Z(`strides`,e,t,n),a=Z(`pad`,e,t,n),o=Z(`kernelSize`,e,t,n);return[r.avgPool(Z(`x`,e,t,n),[o[1],o[2]],[i[1],i[2]],a)]}case`MaxPool`:{let i=Z(`strides`,e,t,n),a=Z(`pad`,e,t,n),o=Z(`kernelSize`,e,t,n);return[r.maxPool(Z(`x`,e,t,n),[o[1],o[2]],[i[1],i[2]],a)]}case`MaxPoolWithArgmax`:{let i=Z(`strides`,e,t,n),a=Z(`pad`,e,t,n),o=Z(`kernelSize`,e,t,n),s=Z(`includeBatchInIndex`,e,t,n),{result:c,indexes:l}=r.maxPoolWithArgmax(Z(`x`,e,t,n),[o[1],o[2]],[i[1],i[2]],a,s);return[c,l]}case`AvgPool3D`:{let i=Z(`strides`,e,t,n),a=Z(`pad`,e,t,n),o=Z(`kernelSize`,e,t,n);return[r.avgPool3d(Z(`x`,e,t,n),[o[1],o[2],o[3]],[i[1],i[2],i[3]],a)]}case`MaxPool3D`:{let i=Z(`strides`,e,t,n),a=Z(`pad`,e,t,n),o=Z(`kernelSize`,e,t,n);return[r.maxPool3d(Z(`x`,e,t,n),[o[1],o[2],o[3]],[i[1],i[2],i[3]],a)]}case`Dilation2D`:{let i=Z(`strides`,e,t,n),a=Z(`pad`,e,t,n),o=Z(`dilations`,e,t,n),s=i[1],c=i[2],l=o[1],u=o[2];return[r.dilation2d(Z(`x`,e,t,n),Z(`filter`,e,t,n),[s,c],a,[l,u],`NHWC`)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}})),vI,ude=o((()=>{aI(),xF(),vI=(e,t,n,r=iI)=>{switch(e.op){case`Fill`:{let i=Z(`shape`,e,t,n),a=Z(`dtype`,e,t,n),o=Z(`value`,e,t,n);return[r.fill(i,o,a)]}case`LinSpace`:{let i=Z(`start`,e,t,n),a=Z(`stop`,e,t,n),o=Z(`num`,e,t,n);return[r.linspace(i,a,o)]}case`Multinomial`:{let i=Z(`logits`,e,t,n),a=Z(`numSamples`,e,t,n),o=Z(`seed`,e,t,n);return[r.multinomial(i,a,o)]}case`OneHot`:{let i=Z(`indices`,e,t,n),a=Z(`depth`,e,t,n),o=Z(`onValue`,e,t,n),s=Z(`offValue`,e,t,n),c=Z(`dtype`,e,t,n);return[r.oneHot(i,a,o,s,c)]}case`Ones`:return[r.ones(Z(`shape`,e,t,n),Z(`dtype`,e,t,n))];case`OnesLike`:return[r.onesLike(Z(`x`,e,t,n))];case`RandomStandardNormal`:return[r.randomStandardNormal(Z(`shape`,e,t,n),Z(`dtype`,e,t,n),Z(`seed`,e,t,n))];case`RandomUniform`:return[r.randomUniform(Z(`shape`,e,t,n),Z(`minval`,e,t,n),Z(`maxval`,e,t,n),Z(`dtype`,e,t,n))];case`RandomUniformInt`:return[r.randomUniformInt(Z(`shape`,e,t,n),Z(`minval`,e,t,n),Z(`maxval`,e,t,n),Z(`seed`,e,t,n))];case`Range`:{let i=Z(`start`,e,t,n),a=Z(`stop`,e,t,n),o=Z(`step`,e,t,n);return[r.range(i,a,o,Z(`dtype`,e,t,n))]}case`TruncatedNormal`:{let i=Z(`shape`,e,t,n),a=Z(`mean`,e,t,n),o=Z(`stdDev`,e,t,n),s=Z(`seed`,e,t,n);return[r.truncatedNormal(i,a,o,Z(`dtype`,e,t,n),s)]}case`Zeros`:return[r.zeros(Z(`shape`,e,t,n),Z(`dtype`,e,t,n))];case`ZerosLike`:return[r.zerosLike(Z(`x`,e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}}));function yI(e,t,n){let r=Z(`boxes`,e,t,n),i=Z(`scores`,e,t,n),a=Z(`maxOutputSize`,e,t,n),o=Z(`iouThreshold`,e,t,n),s=Z(`scoreThreshold`,e,t,n),c=Z(`softNmsSigma`,e,t,n);return{boxes:r,scores:i,maxOutputSize:a,iouThreshold:o,scoreThreshold:s,softNmsSigma:c}}var bI,dde=o((()=>{aI(),xF(),bI=async(e,t,n,r,i=iI)=>{switch(e.op){case`NonMaxSuppressionV5`:{let{boxes:r,scores:a,maxOutputSize:o,iouThreshold:s,scoreThreshold:c,softNmsSigma:l}=yI(e,t,n),u=await i.image.nonMaxSuppressionWithScoreAsync(r,a,o,s,c,l);return[u.selectedIndices,u.selectedScores]}case`NonMaxSuppressionV4`:{let{boxes:r,scores:a,maxOutputSize:o,iouThreshold:s,scoreThreshold:c}=yI(e,t,n),l=Z(`padToMaxOutputSize`,e,t,n),u=await i.image.nonMaxSuppressionPaddedAsync(r,a,o,s,c,l);return[u.selectedIndices,u.validOutputs]}case`NonMaxSuppressionV3`:case`NonMaxSuppressionV2`:{let{boxes:r,scores:a,maxOutputSize:o,iouThreshold:s,scoreThreshold:c}=yI(e,t,n);return[await i.image.nonMaxSuppressionAsync(r,a,o,s,c)]}case`Where`:{let r=i.cast(Z(`condition`,e,t,n),`bool`),a=[await i.whereAsync(r)];return r.dispose(),a}case`ListDiff`:return i.setdiff1dAsync(Z(`x`,e,t,n),Z(`y`,e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}}})),xI,fde=o((()=>{aI(),xF(),xI=(e,t,n,r=iI)=>{switch(e.op){case`LowerBound`:{let i=Z(`sortedSequence`,e,t,n),a=Z(`values`,e,t,n);return[r.lowerBound(i,a)]}case`TopKV2`:{let i=Z(`x`,e,t,n),a=Z(`k`,e,t,n),o=Z(`sorted`,e,t,n),s=r.topk(i,a,o);return[s.values,s.indices]}case`UpperBound`:{let i=Z(`sortedSequence`,e,t,n),a=Z(`values`,e,t,n);return[r.upperBound(i,a)]}case`Unique`:{let i=Z(`x`,e,t,n),a=r.unique(i);return[a.values,a.indices]}case`UniqueV2`:{let i=Z(`x`,e,t,n),a=Z(`axis`,e,t,n),o=r.unique(i,a);return[o.values,o.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}})),SI,pde=o((()=>{aI(),xF(),SI=(e,t,n,r=iI)=>{switch(e.op){case`Const`:return t[e.name];case`PlaceholderWithDefault`:let i=Z(`default`,e,t,n);return[mF(e.name,t,n)||i];case`Placeholder`:return[mF(e.name,t,n)];case`Identity`:case`StopGradient`:case`FakeQuantWithMinMaxVars`:{let r=Z(`x`,e,t,n);return[bF(r)]}case`IdentityN`:return Z(`x`,e,t,n).map(e=>bF(e));case`Snapshot`:let a=Z(`x`,e,t,n);return[bF(a)];case`Shape`:return[r.tensor1d(Z(`x`,e,t,n).shape,`int32`)];case`ShapeN`:return Z(`x`,e,t,n).map(e=>r.tensor1d(e.shape));case`Size`:return[r.scalar(Z(`x`,e,t,n).size,`int32`)];case`Rank`:return[r.scalar(Z(`x`,e,t,n).rank,`int32`)];case`NoOp`:return[r.scalar(1)];case`Print`:let o=Z(`x`,e,t,n),s=Z(`data`,e,t,n),c=Z(`message`,e,t,n),l=Z(`summarize`,e,t,n);console.warn(`The graph has a tf.print() operation,usually used for debugging, which slows down performance.`),console.log(c);for(let e=0;e<s.length;e++)console.log(Array.prototype.slice.call(s[e].dataSync()).slice(0,l));return[o];default:throw TypeError(`Node type ${e.op} is not implemented`)}}})),CI,mde=o((()=>{Y(),aI(),CI=class{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=Zf(0),this.tensorMap=new Map,No(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Zf(this.size(),`int32`)}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),B(()=>{let e=dv(t),r=n.length,i=e.length;D(r===i,()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${i} elements.`);for(let t=0;t<r;t++){let r=n[t],i=e[t];No(i),this.tensorMap.set(r,i)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return B(()=>{let e=[];for(let r=0;r<n.length;r++){let i=n[r],a=this.findWithDefault(i,t);e.push(a)}return C_(e)})}findWithDefault(e,t){return this.tensorMap.get(e)??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}})),wI,hde=o((()=>{mde(),xF(),wI=async(e,t,n,r)=>{switch(e.op){case`HashTable`:case`HashTableV2`:{let i=r.getHashTableHandleByName(e.name);if(i!=null)return[i];{let i=Z(`keyDType`,e,t,n),a=Z(`valueDType`,e,t,n),o=new CI(i,a);return r.addHashTable(e.name,o),[o.handle]}}case`InitializeTable`:case`InitializeTableV2`:case`LookupTableImport`:case`LookupTableImportV2`:{let i=Z(`tableHandle`,e,t,n,r),a=Z(`keys`,e,t,n),o=Z(`values`,e,t,n);return[await r.getHashTableById(i.id).import(a,o)]}case`LookupTableFind`:case`LookupTableFindV2`:{let i=Z(`tableHandle`,e,t,n,r),a=Z(`keys`,e,t,n),o=Z(`defaultValue`,e,t,n);return[await r.getHashTableById(i.id).find(a,o)]}case`LookupTableSize`:case`LookupTableSizeV2`:{let i=Z(`tableHandle`,e,t,n,r);return[r.getHashTableById(i.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}})),TI,gde=o((()=>{aI(),xF(),TI=(e,t,n,r=iI)=>{switch(e.op){case`ResizeBilinear`:{let i=Z(`images`,e,t,n),a=Z(`size`,e,t,n),o=Z(`alignCorners`,e,t,n),s=Z(`halfPixelCenters`,e,t,n);return[r.image.resizeBilinear(i,[a[0],a[1]],o,s)]}case`ResizeNearestNeighbor`:{let i=Z(`images`,e,t,n),a=Z(`size`,e,t,n),o=Z(`alignCorners`,e,t,n),s=Z(`halfPixelCenters`,e,t,n);return[r.image.resizeNearestNeighbor(i,[a[0],a[1]],o,s)]}case`CropAndResize`:{let i=Z(`image`,e,t,n),a=Z(`boxes`,e,t,n),o=Z(`boxInd`,e,t,n),s=Z(`cropSize`,e,t,n),c=Z(`method`,e,t,n),l=Z(`extrapolationValue`,e,t,n);return[r.image.cropAndResize(i,a,o,s,c,l)]}case`ImageProjectiveTransformV3`:{let i=Z(`images`,e,t,n),a=Z(`transforms`,e,t,n),o=Z(`outputShape`,e,t,n),s=Z(`fillValue`,e,t,n),c=Z(`interpolation`,e,t,n),l=Z(`fillMode`,e,t,n);return[r.image.transform(i,a,c.toLowerCase(),l.toLowerCase(),s,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}})),EI,_de=o((()=>{aI(),xF(),EI=(e,t,n,r=iI)=>{switch(e.op){case`Equal`:return[r.equal(Z(`a`,e,t,n),Z(`b`,e,t,n))];case`NotEqual`:return[r.notEqual(Z(`a`,e,t,n),Z(`b`,e,t,n))];case`Greater`:return[r.greater(Z(`a`,e,t,n),Z(`b`,e,t,n))];case`GreaterEqual`:return[r.greaterEqual(Z(`a`,e,t,n),Z(`b`,e,t,n))];case`Less`:return[r.less(Z(`a`,e,t,n),Z(`b`,e,t,n))];case`LessEqual`:return[r.lessEqual(Z(`a`,e,t,n),Z(`b`,e,t,n))];case`LogicalAnd`:return[r.logicalAnd(Z(`a`,e,t,n),Z(`b`,e,t,n))];case`LogicalNot`:return[r.logicalNot(Z(`a`,e,t,n))];case`LogicalOr`:return[r.logicalOr(Z(`a`,e,t,n),Z(`b`,e,t,n))];case`Select`:case`SelectV2`:return[r.where(Z(`condition`,e,t,n),Z(`a`,e,t,n),Z(`b`,e,t,n))];case`BitwiseAnd`:return[r.bitwiseAnd(Z(`a`,e,t,n),Z(`b`,e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}})),DI,vde=o((()=>{aI(),xF(),DI=(e,t,n,r=iI)=>{switch(e.op){case`BatchMatMul`:case`BatchMatMulV2`:case`MatMul`:return[r.matMul(Z(`a`,e,t,n),Z(`b`,e,t,n),Z(`transposeA`,e,t,n),Z(`transposeB`,e,t,n))];case`Einsum`:return[r.einsum(Z(`equation`,e,t,n),...Z(`tensors`,e,t,n))];case`Transpose`:return[r.transpose(Z(`x`,e,t,n),Z(`perm`,e,t,n))];case`_FusedMatMul`:let[i,a]=Z(`fusedOps`,e,t,n),o=i===`biasadd`,s=a===`prelu`,c=Z(`numArgs`,e,t,n),l=Z(`leakyreluAlpha`,e,t,n);if(o){if(s&&c!==2)throw Error(`Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.`);if(!s&&c!==1)throw Error(`Fused MatMul with BiasAdd must have one extra argument: bias.`)}let[u,d]=Z(`args`,e,t,n);return[r.fused.matMul({a:Z(`a`,e,t,n),b:Z(`b`,e,t,n),transposeA:Z(`transposeA`,e,t,n),transposeB:Z(`transposeB`,e,t,n),bias:u,activation:a,preluActivationWeights:d,leakyreluAlpha:l})];case`MatrixBandPart`:return[r.linalg.bandPart(Z(`a`,e,t,n),Z(`numLower`,e,t,n),Z(`numUpper`,e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}})),OI,yde=o((()=>{aI(),xF(),OI=(e,t,n,r=iI)=>{switch(e.op){case`EuclideanNorm`:return[r.euclideanNorm(Z(`x`,e,t,n),Z(`axis`,e,t,n),Z(`keepDims`,e,t,n))];case`FusedBatchNorm`:case`FusedBatchNormV2`:return[r.batchNorm(Z(`x`,e,t,n),Z(`mean`,e,t,n),Z(`variance`,e,t,n),Z(`offset`,e,t,n),Z(`scale`,e,t,n),Z(`epsilon`,e,t,n))];case`FusedBatchNormV3`:return[r.batchNorm(Z(`x`,e,t,n),Z(`mean`,e,t,n),Z(`variance`,e,t,n),Z(`offset`,e,t,n),Z(`scale`,e,t,n),Z(`epsilon`,e,t,n))];case`LRN`:return[r.localResponseNormalization(Z(`x`,e,t,n),Z(`radius`,e,t,n),Z(`bias`,e,t,n),Z(`alpha`,e,t,n),Z(`beta`,e,t,n))];case`Softmax`:return[r.softmax(Z(`x`,e,t,n))];case`LogSoftmax`:return[r.logSoftmax(Z(`x`,e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}})),kI,bde=o((()=>{aI(),xF(),kI=(e,t,n,r=iI)=>{switch(e.op){case`RaggedGather`:{let{outputNestedSplits:i,outputDenseValues:a}=r.raggedGather(Z(`paramsNestedSplits`,e,t,n),Z(`paramsDenseValues`,e,t,n),Z(`indices`,e,t,n),Z(`outputRaggedRank`,e,t,n));return i.concat(a)}case`RaggedRange`:{let{rtNestedSplits:i,rtDenseValues:a}=r.raggedRange(Z(`starts`,e,t,n),Z(`limits`,e,t,n),Z(`splits`,e,t,n));return[i,a]}case`RaggedTensorToTensor`:return[r.raggedTensorToTensor(Z(`shape`,e,t,n),Z(`values`,e,t,n),Z(`defaultValue`,e,t,n),Z(`rowPartitionTensors`,e,t,n),Z(`rowPartitionTypes`,e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}})),AI,xde=o((()=>{aI(),xF(),AI=(e,t,n,r=iI)=>{switch(e.op){case`Max`:{let i=Z(`axis`,e,t,n),a=Z(`keepDims`,e,t,n);return[r.max(Z(`x`,e,t,n),i,a)]}case`Mean`:{let i=Z(`axis`,e,t,n),a=Z(`keepDims`,e,t,n);return[r.mean(Z(`x`,e,t,n),i,a)]}case`Min`:{let i=Z(`axis`,e,t,n),a=Z(`keepDims`,e,t,n);return[r.min(Z(`x`,e,t,n),i,a)]}case`Sum`:{let i=Z(`axis`,e,t,n),a=Z(`keepDims`,e,t,n);return[r.sum(Z(`x`,e,t,n),i,a)]}case`All`:{let i=Z(`axis`,e,t,n),a=Z(`keepDims`,e,t,n);return[r.all(Z(`x`,e,t,n),i,a)]}case`Any`:{let i=Z(`axis`,e,t,n),a=Z(`keepDims`,e,t,n);return[r.any(Z(`x`,e,t,n),i,a)]}case`ArgMax`:{let i=Z(`axis`,e,t,n);return[r.argMax(Z(`x`,e,t,n),i)]}case`ArgMin`:{let i=Z(`axis`,e,t,n);return[r.argMin(Z(`x`,e,t,n),i)]}case`Prod`:{let i=Z(`axis`,e,t,n),a=Z(`keepDims`,e,t,n);return[r.prod(Z(`x`,e,t,n),i,a)]}case`Cumprod`:{let i=Z(`axis`,e,t,n),a=Z(`exclusive`,e,t,n),o=Z(`reverse`,e,t,n);return[r.cumprod(Z(`x`,e,t,n),i,a,o)]}case`Cumsum`:{let i=Z(`axis`,e,t,n),a=Z(`exclusive`,e,t,n),o=Z(`reverse`,e,t,n);return[r.cumsum(Z(`x`,e,t,n),i,a,o)]}case`Bincount`:let i=Z(`x`,e,t,n),a=Z(`weights`,e,t,n),o=Z(`size`,e,t,n);return[r.bincount(i,a,o)];case`DenseBincount`:{let i=Z(`x`,e,t,n),a=Z(`weights`,e,t,n),o=Z(`size`,e,t,n),s=Z(`binaryOutput`,e,t,n);return[r.denseBincount(i,a,o,s)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}})),jI,Sde=o((()=>{Y(),aI(),xF(),jI=(e,t,n,r=iI)=>{switch(e.op){case`ConcatV2`:case`Concat`:{let i=Z(`n`,e,t,n),a=Z(`axis`,e,t,n),o=Z(`tensors`,e,t,n);return o=o.slice(0,i),[r.concat(o,a)]}case`Gather`:{let i=Z(`x`,e,t,n),a=Z(`indices`,e,t,n);return[r.gather(i,r.cast(a,`int32`),0)]}case`GatherV2`:{let i=Z(`axis`,e,t,n),a=Z(`batchDims`,e,t,n),o=Z(`x`,e,t,n),s=Z(`indices`,e,t,n);return[r.gather(o,r.cast(s,`int32`),i,a)]}case`Reverse`:{let i=Z(`dims`,e,t,n),a=[];for(let e=0;e<i.length;e++)i[e]&&a.push(e);let o=Z(`x`,e,t,n);return[r.reverse(o,a)]}case`ReverseV2`:{let i=Z(`axis`,e,t,n),a=Z(`x`,e,t,n);return[r.reverse(a,i)]}case`Slice`:{let i=Z(`begin`,e,t,n),a=Z(`size`,e,t,n);return[r.slice(Z(`x`,e,t,n),i,a)]}case`StridedSlice`:{let i=Z(`begin`,e,t,n),a=Z(`end`,e,t,n),o=Z(`strides`,e,t,n),s=Z(`beginMask`,e,t,n),c=Z(`endMask`,e,t,n),l=Z(`ellipsisMask`,e,t,n),u=Z(`newAxisMask`,e,t,n),d=Z(`shrinkAxisMask`,e,t,n),f=Z(`x`,e,t,n);return[r.stridedSlice(f,i,a,o,s,c,l,u,d)]}case`Pack`:return B(()=>{let i=Z(`axis`,e,t,n),a=Z(`tensors`,e,t,n),o=a[0].shape,s=r.squeeze(a[0]).shape,c=a.map(e=>{let t=ge(e.shape,o);if(!t&&!ge(r.squeeze(e).shape,s))throw Error(`the input tensors shape does not match`);return t?e:r.reshape(e,o)});return[r.stack(c,i)]});case`Unpack`:{let i=Z(`axis`,e,t,n),a=Z(`tensor`,e,t,n);return r.unstack(a,i)}case`Tile`:{let i=Z(`reps`,e,t,n);return[r.tile(Z(`x`,e,t,n),i)]}case`Split`:case`SplitV`:{let i=Z(`axis`,e,t,n),a=Z(`numOrSizeSplits`,e,t,n),o=Z(`x`,e,t,n);return r.split(o,a,i)}case`ScatterNd`:{let i=Z(`indices`,e,t,n),a=Z(`values`,e,t,n),o=Z(`shape`,e,t,n);return[r.scatterND(i,a,o)]}case`GatherNd`:{let i=Z(`x`,e,t,n),a=Z(`indices`,e,t,n);return[r.gatherND(i,a)]}case`SparseToDense`:{let i=Z(`sparseIndices`,e,t,n),a=Z(`outputShape`,e,t,n),o=Z(`sparseValues`,e,t,n),s=Z(`defaultValue`,e,t,n);return[r.sparseToDense(i,o,a,o.dtype===s.dtype?s:r.cast(s,o.dtype))]}case`TensorScatterUpdate`:{let i=Z(`indices`,e,t,n),a=Z(`values`,e,t,n),o=Z(`tensor`,e,t,n);return[r.tensorScatterUpdate(o,i,a)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}})),MI,Cde=o((()=>{aI(),xF(),MI=(e,t,n,r=iI)=>{switch(e.op){case`SparseFillEmptyRows`:{let{outputIndices:i,outputValues:a,emptyRowIndicator:o,reverseIndexMap:s}=r.sparse.sparseFillEmptyRows(Z(`indices`,e,t,n),Z(`values`,e,t,n),Z(`denseShape`,e,t,n),Z(`defaultValue`,e,t,n));return[i,a,o,s]}case`SparseReshape`:{let{outputIndices:i,outputShape:a}=r.sparse.sparseReshape(Z(`inputIndices`,e,t,n),Z(`inputShape`,e,t,n),Z(`newShape`,e,t,n));return[i,a]}case`SparseSegmentMean`:return[r.sparse.sparseSegmentMean(Z(`data`,e,t,n),Z(`indices`,e,t,n),Z(`segmentIds`,e,t,n))];case`SparseSegmentSum`:return[r.sparse.sparseSegmentSum(Z(`data`,e,t,n),Z(`indices`,e,t,n),Z(`segmentIds`,e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}})),NI,wde=o((()=>{aI(),xF(),NI=(e,t,n,r=iI)=>{switch(e.op){case`FFT`:return[r.fft(Z(`x`,e,t,n))];case`IFFT`:return[r.ifft(Z(`x`,e,t,n))];case`RFFT`:return[r.rfft(Z(`x`,e,t,n))];case`IRFFT`:return[r.irfft(Z(`x`,e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}})),PI,Tde=o((()=>{aI(),xF(),PI=(e,t,n,r=iI)=>{switch(e.op){case`StaticRegexReplace`:return[r.string.staticRegexReplace(Z(`input`,e,t,n),Z(`pattern`,e,t,n),Z(`rewrite`,e,t,n),Z(`replaceGlobal`,e,t,n))];case`StringNGrams`:{let{nGrams:i,nGramsSplits:a}=r.string.stringNGrams(Z(`data`,e,t,n),Z(`dataSplits`,e,t,n),Z(`separator`,e,t,n),Z(`nGramWidths`,e,t,n),Z(`leftPad`,e,t,n),Z(`rightPad`,e,t,n),Z(`padWidth`,e,t,n),Z(`preserveShortSequences`,e,t,n));return[i,a]}case`StringSplit`:{let{indices:i,values:a,shape:o}=r.string.stringSplit(Z(`input`,e,t,n),Z(`delimiter`,e,t,n),Z(`skipEmpty`,e,t,n));return[i,a,o]}case`StringToHashBucketFast`:return[r.string.stringToHashBucketFast(Z(`input`,e,t,n),Z(`numBuckets`,e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}})),FI,Ede=o((()=>{aI(),xF(),FI=(e,t,n,r=iI)=>{switch(e.op){case`Cast`:return[r.cast(Z(`x`,e,t,n),Z(`dtype`,e,t,n))];case`ExpandDims`:{let i=Z(`axis`,e,t,n);return[r.expandDims(Z(`x`,e,t,n),i)]}case`Squeeze`:{let i=Z(`axis`,e,t,n);return[r.squeeze(Z(`x`,e,t,n),i)]}case`Reshape`:return[r.reshape(Z(`x`,e,t,n),Z(`shape`,e,t,n))];case`EnsureShape`:return[r.ensureShape(Z(`x`,e,t,n),Z(`shape`,e,t,n))];case`MirrorPad`:return[r.mirrorPad(Z(`x`,e,t,n),Z(`padding`,e,t,n),Z(`mode`,e,t,n))];case`PadV2`:case`Pad`:return[r.pad(Z(`x`,e,t,n),Z(`padding`,e,t,n),Z(`constantValue`,e,t,n))];case`SpaceToBatchND`:{let i=Z(`blockShape`,e,t,n),a=Z(`paddings`,e,t,n);return[r.spaceToBatchND(Z(`x`,e,t,n),i,a)]}case`BatchToSpaceND`:{let i=Z(`blockShape`,e,t,n),a=Z(`crops`,e,t,n);return[r.batchToSpaceND(Z(`x`,e,t,n),i,a)]}case`DepthToSpace`:{let i=Z(`blockSize`,e,t,n),a=Z(`dataFormat`,e,t,n).toUpperCase();return[r.depthToSpace(Z(`x`,e,t,n),i,a)]}case`BroadcastTo`:return[r.broadcastTo(Z(`x`,e,t,n),Z(`shape`,e,t,n))];case`BroadcastArgs`:return[r.broadcastArgs(Z(`s0`,e,t,n),Z(`s1`,e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}}));function II(e,t,n,r,i=B){let a=((e,t,n)=>{switch(e.category){case`arithmetic`:return i(()=>oI(e,t,n));case`basic_math`:return i(()=>sI(e,t,n));case`control`:return hI(e,t,n);case`convolution`:return i(()=>_I(e,t,n));case`creation`:return i(()=>vI(e,t,n));case`dynamic`:return bI(e,t,n);case`evaluation`:return i(()=>xI(e,t,n));case`image`:return i(()=>TI(e,t,n));case`graph`:return i(()=>SI(e,t,n));case`logical`:return i(()=>EI(e,t,n));case`matrices`:return i(()=>DI(e,t,n));case`normalization`:return i(()=>OI(e,t,n));case`ragged`:return i(()=>kI(e,t,n));case`reduction`:return i(()=>AI(e,t,n));case`slice_join`:return i(()=>jI(e,t,n));case`sparse`:return i(()=>MI(e,t,n));case`spectral`:return i(()=>NI(e,t,n));case`string`:return i(()=>PI(e,t,n));case`transformation`:return i(()=>FI(e,t,n));case`hash_table`:return wI(e,t,n,r);case`custom`:let a=dF(e.op);if(a&&a.customExecutor)return a.customExecutor(new rI(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return Ye(a)?a.then(e=>[].concat(e)):[].concat(a)}var Dde=o((()=>{Y(),$ue(),pF(),ede(),tde(),cde(),lde(),ude(),dde(),fde(),pde(),hde(),gde(),_de(),vde(),yde(),bde(),xde(),Sde(),Cde(),wde(),Tde(),Ede()})),LI,Ode=o((()=>{LI=class{constructor(e={},t={},n={},r={},i){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=i,this.rootContext={id:0,frameName:``,iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(``),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(e=>e.id===0&&e.iterationId===0?``:`${e.frameName}-${e.iterationId}`).join(`/`):``}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw Error(`Cannot exit frame, the context is empty`)}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw Error(`Cannot increase frame iteration, the context is empty`)}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}}));function RI(e,t,n,r){let i=new Set,a=[],o=null,s=null,c=new Set,l=new Set(Object.keys(e).map(e=>vF(e)[0]));r||=[];let u=new Set(r.map(e=>vF(e.name)[0])),d=[...t];for(;d.length>0;){let e=d.pop();if((zI(e)||Nde(e)||Pde(e))&&(o??(o=e,s=o.children.map(e=>e.name).filter(e=>i.has(e)))),i.add(e.name),n[e.name]==null&&!l.has(e.name)&&!u.has(e.name)){if(e.inputs.length===0){a.push(e.name);continue}e.inputs.forEach(e=>{c.has(e.name)||(c.add(e.name),d.push(e))})}}return{inputs:e,outputs:t,usedNodes:i,missingInputs:a,dynamicNode:o,syncInputs:s}}function kde(e,t){let{usedNodes:n,inputs:r}=t,i=Object.keys(r).map(e=>vF(e)[0]).map(t=>e.nodes[t]),a=e.initNodes||[],o=e=>n.has(typeof e==`string`?e:e.name);function s(e){return[...new Map(e.map(e=>[e.name,e])).values()]}let c=s([...i,...e.weights,...a]).filter(o),l=s([...c,...Object.values(e.nodes)]).filter(o),u=new Map(l.map(e=>[e.name,e])),d={};for(let e of l){d[e.name]=d[e.name]||0;for(let t of e.children)o(t)||(d[t.name]=1/0),d[t.name]=(d[t.name]||0)+1}let f=Object.entries(d).filter(([,e])=>e===0).map(([e])=>e),p=[...f];for(;f.length>0;){let e=f.pop(),t=u.get(e);for(let e of t.children.filter(o))--d[e.name]===0&&(p.push(e.name),f.push(e.name))}let m=p.map(e=>u.get(e)),h=Ade(m,c);return jde(h,c),h}function Ade(e,t){let n=new Map(e.map(e=>[e.name,e])),r=t.map(e=>e.name),i=new Set(r);for(;r.length>0;){let e=r.pop(),t=n.get(e);for(let e of t.children)!n.has(e.name)||i.has(e.name)||(i.add(e.name),r.push(e.name))}return e.filter(e=>i.has(e.name))}function jde(e,t){let n=new Map(e.map((e,t)=>[e.name,t])),r=new Set(t.map(e=>e.name)),i=e=>r.has(typeof e==`string`?e:e.name),a=new Set(e.map(e=>e.name)),o=e=>a.has(typeof e==`string`?e:e.name);for(let t of e){for(let e of t.children.filter(o)){if(!n.has(e.name))throw new BI(`Child ${e.name} of node ${t.name} is unreachable.`);if(n.get(t.name)>n.get(e.name))throw new BI(`Node ${t.name} is scheduled to run after its child ${e.name}.`)}if(!i(t))for(let e of t.inputs){if(!n.has(e.name))throw new BI(`Input ${e.name} of node ${t.name} is unreachable.`);if(n.get(e.name)>n.get(t.name))throw new BI(`Node ${t.name} is scheduled to run before its input ${e.name}.`)}}}function Mde(e){let t=new Map(e.map((e,t)=>[e.name,t])),n=2**53-1,r=e.map((e,t)=>zI(e)?n:t),i=e=>r[t.get(e.name)]??-1,a=e.map((e,t)=>e.children.map(i).reduce((e,t)=>Math.max(e,t),r[t])),o=new Map;for(let t=0;t<e.length;++t){let r=a[t];if(r===n)continue;let i=e[t],s=e[r];o.has(s.name)||o.set(s.name,[]),o.get(s.name).push(i)}return o}function zI(e){return VI.has(e.op)}function Nde(e){return HI.has(e.op)}function Pde(e){return UI.has(e.op)}var BI,VI,HI,UI,Fde=o((()=>{xF(),BI=class extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}},VI=new Set([`Switch`,`Merge`,`Enter`,`Exit`,`NextIteration`,`StatelessIf`,`StatelessWhile`,`if`,`While`]),HI=new Set([`NonMaxSuppressionV2`,`NonMaxSuppressionV3`,`NonMaxSuppressionV5`,`Where`]),UI=new Set([`HashTable`,`HashTableV2`,`LookupTableImport`,`LookupTableImportV2`,`LookupTableFind`,`LookupTableFindV2`,`LookupTableSize`,`LookupTableSizeV2`])})),WI,Ide=o((()=>{Y(),xF(),Dde(),Ode(),Fde(),WI=class e{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){let t=Object.keys(e).map(t=>e[t].map(e=>e.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{let t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(t,n){this.graph=t,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=`,`,this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(n=>{this._functionExecutorMap[n]=new e(t.functions[n],this)})}getCompilationKey(e,t){let n=e.map(e=>e.name).sort(),r=t.map(e=>e.name).sort();return n.join(this.SEPARATOR)+`--`+r.join(this.SEPARATOR)}compile(e,t){let n=RI(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:i,syncInputs:a}=n;if(i!=null)throw Error(`This execution contains the node '${i.name}', which has the dynamic op '${i.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(r.length>0){let n=t.map(e=>e.name),i=Object.keys(e);throw Error(`Cannot compute the outputs [${n}] from the provided inputs [${i}]. Missing the following inputs: [${r}]`)}let o=kde(this.graph,n),s=Mde(o);return{orderedNodes:o,nodeLiveUntilMap:s}}cloneAndKeepTensor(e){if(e==null)return null;let t=e.clone();return No(t),t}cloneTensorList(e){return e?e.map(e=>this.cloneAndKeepTensor(e)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([e,t])=>[e,this.cloneTensorList(t)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);let n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);let r=n.map(e=>this.graph.nodes[vF(e)[0]]),i=t.map(e=>vF(e)[0]),a=new Set(i),o=i.map(e=>this.graph.nodes[e]);o.length===0&&(o=this._outputs);let s=this.getCompilationKey(r,o),c=this.compiledMap.get(s);c??(c=this.compile(e,o),this.compiledMap.set(s,c));try{this.keepIntermediateTensors=k().getBool(`KEEP_INTERMEDIATE_TENSORS`)}catch(e){this.keepIntermediateTensors=!1,console.warn(e.message)}let l={},u={};return B(()=>{let n=new LI(this.weightMap,l,u,this.functionExecutorMap,this.parseNodeNameCache),r=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(t=>{let[i,a]=vF(t,n),o=[];o[a]=e[t],r[i]=o,this.keepIntermediateTensors&&(this.clonedTensorsMap[i]=this.cloneTensorList(o))});let i=this.getFrozenTensorIds(r),{orderedNodes:o,nodeLiveUntilMap:s}=c;for(let e of o){if(r[e.name])continue;let t=II(e,r,n,this._resourceManager);if(Ye(t))throw Error(`The execution of the op '${e.op}' returned a promise. Please use model.executeAsync() instead.`);r[e.name]=t,this.keepIntermediateTensors&&(this.clonedTensorsMap[e.name]=this.cloneTensorList(t)),this.checkTensorForDisposalWithNodeLiveUntilInfo(e,r,n,i,a,s.get(e.name))}return this.parent??n.dispose(i),t.map(e=>mF(e,r,n))})}getFrozenTensorIds(e){let t=[].concat.apply([],Object.keys(e).map(t=>e[t]).map(e=>e.map(e=>e.id)));return new Set(t)}checkTensorForDisposal(e,t,n,r,i,a,o){if(!(zI(t)||a.has(e))){for(let r of n[e])r!=null&&(o[r.id]=(o[r.id]||0)+t.children.length);for(let e of t.inputs){if(zI(e))continue;let t=hF(e.name,n,r);if(t!=null)for(let e of t){if(!e||e.kept||i.has(e.id))continue;let t=o[e.id];t===1?(e.dispose(),delete o[e.id]):t!=null&&o[e.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,n,r,i,a){function o(e){return zI(e)||i.has(e.name)}if(!(zI(e)||a==null))for(let e of a){if(o(e))continue;let i=hF(e.name,t,n);for(let e of i)!e||e.kept||r.has(e.id)||e.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&=(Object.values(this.clonedTensorsMap).forEach(e=>{for(let t of e)t&&!t.isDisposed&&t.dispose()}),null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,n=!1,r={},i={}){this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=k().getBool(`KEEP_INTERMEDIATE_TENSORS`)}catch(e){this.keepIntermediateTensors=!1,console.warn(e.message)}let a=new LI(this.weightMap,r,i,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let o=await this.executeWithControlFlow(e,a,t,n),s=t.map(e=>mF(e,o,a)),c=s.map(e=>e.id),l=Object.keys(e).map(t=>e[t].id),u=new Set([...c,...l,...this.weightIds]);return Object.values(o).forEach(e=>{e.forEach(e=>{e&&!e.isDisposed&&!u.has(e.id)&&e.dispose()})}),this.parent??a.dispose(u),s}async executeFunctionAsync(e,t,n){let r=e.reduce((e,t,n)=>(e[this.inputs[n].name]=t,e),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){let i=Object.keys(e),a=i.map(e=>this.graph.nodes[vF(e)[0]]),o=n.map(e=>vF(e)[0]),s=new Set(o),c=o.map(e=>this.graph.nodes[e]);c.length===0&&(c=this._outputs);let{usedNodes:l,missingInputs:u,dynamicNode:d,syncInputs:f}=RI(e,c,this.weightMap,this._initNodes),p=[...a,...this.graph.weights,...this._initNodes||[]].map(e=>({node:e,contexts:t.currentContext})),m=Object.assign({},this.weightMap);Object.keys(e).forEach(t=>{let[n,r]=vF(t),i=[];i[r]=e[t],m[n]=i});let h={},g=this.getFrozenTensorIds(m),_={};for(;p.length>0;){let e=this.processStack(a,p,t,m,_,g,s,h,l);await Promise.all(e)}d==null&&!r&&console.warn(`This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.`);let v=c.filter(e=>!zI(e)&&!mF(e.name,m,t)).map(e=>e.name);if(v.length>0){let e=``;throw d!=null&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${f}]`),Error(`Cannot compute the outputs [${v}] from the provided inputs [${i}]. Consider providing the following inputs: [${u}]. ${e}`)}return m}processStack(e,t,n,r,i,a,o,s,c){let l=[];for(;t.length>0;){let e=t.pop();n.currentContext=e.contexts;let u=``;if(e.node.op===`Enter`&&Z(`isConstant`,e.node,r,n)&&([u]=gF(e.node.name,n)),r[e.node.name]==null){let d=II(e.node,r,n,this._resourceManager);u||([u]=gF(e.node.name,n));let f=n.currentContext;Ye(d)?l.push(d.then(l=>(r[u]=l,this.keepIntermediateTensors&&(this.clonedTensorsMap[u]=this.cloneTensorList(l)),n.currentContext=f,this.checkTensorForDisposal(u,e.node,r,n,a,o,s),this.processChildNodes(e.node,t,n,r,i,c),l))):(r[u]=d,this.keepIntermediateTensors&&(this.clonedTensorsMap[u]=this.cloneTensorList(d)),this.checkTensorForDisposal(u,e.node,r,n,a,o,s),this.processChildNodes(e.node,t,n,r,i,c))}else this.processChildNodes(e.node,t,n,r,i,c)}return l}processChildNodes(e,t,n,r,i,a){e.children.forEach(e=>{let[o]=gF(e.name,n);i[o]||!a.has(e.name)||(e.op===`Merge`?e.inputNames.some(e=>!!mF(e,r,n))&&(i[o]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every(e=>!!mF(e,r,n))&&(i[o]=!0,t.push({contexts:n.currentContext,node:e})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(e=>e.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{let n=e[t],[r]=vF(t),i=this.graph.nodes[r];if(i.attrParams.shape&&i.attrParams.shape.value){let e=i.attrParams.shape.value,t=e.length===n.shape.length&&n.shape.every((t,n)=>e[n]===-1||e[n]===t);D(t,()=>`The shape of dict['${i.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`)}i.attrParams.dtype&&i.attrParams.dtype.value&&D(n.dtype===i.attrParams.dtype.value,()=>`The dtype of dict['${i.name}'] provided in model.execute(dict) must be ${i.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(e){let t={};for(let n in e){let r=this._signature?.inputs?.[n];r==null?t[n]=e[n]:t[r.name]=e[n]}return t}checkInputs(e){let t=Object.keys(e).filter(e=>{let[t]=vF(e);return this.graph.nodes[t]==null});if(t.length>0)throw Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(e=>{let t=this._signature?.outputs?.[e];return t==null?e:t.name},{})}checkOutputs(e){e.forEach(e=>{let[t]=vF(e);if(!this.graph.nodes[t])throw Error(`The output '${e}' is not found in the graph`)})}}})),GI,Lde=o((()=>{GI=class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}}));async function Rde(e,t={},n=kx){if(e==null)throw Error(`modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model`);t??={},t.fromTFHub&&typeof e==`string`&&(e=Bde(e));let r=new JI(e,t,n);return await r.load(),r}function zde(e){if(e==null)throw Error(`modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model`);let t;if(e instanceof Array){let[n,r]=e;if(!n)throw Error(`modelJSON must be the first element of the array`);if(!r||!(r instanceof ArrayBuffer))throw Error(`An ArrayBuffer of weights must be the second element of the array`);if(!(`modelTopology`in n))throw Error(`Model JSON is missing 'modelTopology'`);if(!(`weightsManifest`in n))throw Error(`Model JSON is missing 'weightsManifest'`);let i=us(n.weightsManifest),a=ss(n,i,r);t=Sx(a)}else if(`load`in e)t=e;else if(`modelTopology`in e&&`weightSpecs`in e&&`weightData`in e)t=Sx(e);else throw Error(`Unknown model format`);let n=new JI(t);return n.load(),n}function Bde(e){return e.endsWith(`/`)||(e+=`/`),`${e}${qI}${KI}`}var KI,qI,JI,Vde=o((()=>{Y(),nI(),Ide(),Lde(),_s(),KI=`?tfjs-format=file`,qI=`model.json`,JI=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},n=kx){this.modelUrl=e,this.loadOptions=t,this.version=`n/a`,this.io=n,t??(this.loadOptions={}),this.resourceManager=new GI}findIOHandler(){let e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return Ye(e)?e.then(e=>e.getWeightStream==null?this.loadSync(e):this.loadStreaming(e)):this.loadSync(e)}loadSync(e){let t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw Error(`Model artifacts missing streamWeights function`);let t=await Zo(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;let n=this.artifacts.modelTopology,r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let e=this.artifacts.userDefinedMetadata;e.signature!=null&&(r=e.signature),e.structuredOutputKeys!=null&&(this.structuredOutputKeys=e.structuredOutputKeys)}if(this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new WI(tI.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){let t=tI.Instance.transformGraph(e.modelInitializer);this.initializer=new WI(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e==`string`){let t=this.io.getSaveHandlers(e);if(t.length===0)throw Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(e.save==null)throw Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t=e instanceof wa?[e]:e,n={};return t.forEach((e,t)=>n[this.structuredOutputKeys[t]]=e),n}return e}predict(e,t){let n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){let n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){if(!(e instanceof wa)&&!Array.isArray(e)){let t=this.signature?.inputs;if(t!=null)for(let n in t){let r=t[n];r.resourceId!=null&&(e[n]=this.resourceIdToCapturedInput[r.resourceId])}return e}e=Array.isArray(e)?e:[e];let t=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+t!==this.inputNodes.length)throw Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-t} non-resource placeholders, while there are ${e.length} input tensors provided.`);let n=0;return this.inputNodes.reduce((t,r)=>{let i=this.signature?.inputs?.[r]?.resourceId;return i==null?t[r]=e[n++]:t[r]=this.resourceIdToCapturedInput[i],t},{})}normalizeOutputs(e){return e||=this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++){let i=n[r],a=t[i];this.resourceIdToCapturedInput[a.resourceId]=e[r]}}}execute(e,t){this.resourceIdToCapturedInput??this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){this.resourceIdToCapturedInput??this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Mo(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}})),YI,Hde=o((()=>{YI=`4.22.0`})),XI=o((()=>{lue(),Vde(),pF(),Hde()})),Ude=s(((e,t)=>{(function(e,t,n){function r(e){var t=this,n=o();t.next=function(){var e=2091639*t.s0+t.c*23283064365386963e-26;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=e|0)},t.c=1,t.s0=n(` `),t.s1=n(` `),t.s2=n(` `),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function a(e,t){var n=new r(e),a=t&&t.state,o=n.next;return o.int32=function(){return n.next()*4294967296|0},o.double=function(){return o()+(o()*2097152|0)*11102230246251565e-32},o.quick=o,a&&(typeof a==`object`&&i(a,n),o.state=function(){return i(n,{})}),o}function o(){var e=4022871197;return function(t){t=String(t);for(var n=0;n<t.length;n++){e+=t.charCodeAt(n);var r=.02519603282416938*e;e=r>>>0,r-=e,r*=e,e=r>>>0,r-=e,e+=r*4294967296}return(e>>>0)*23283064365386963e-26}}t&&t.exports?t.exports=a:n&&n.amd?n(function(){return a}):this.alea=a})(e,typeof t==`object`&&t,typeof define==`function`&&define)})),Wde=s(((e,t)=>{(function(e,t,n){function r(e){var t=this,n=``;t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(e|0)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=n.charCodeAt(r)|0,t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function a(e,t){var n=new r(e),a=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21);while(r===0);return r},o.int32=n.next,o.quick=o,a&&(typeof a==`object`&&i(a,n),o.state=function(){return i(n,{})}),o}t&&t.exports?t.exports=a:n&&n.amd?n(function(){return a}):this.xor128=a})(e,typeof t==`object`&&t,typeof define==`function`&&define)})),Gde=s(((e,t)=>{(function(e,t,n){function r(e){var t=this,n=``;t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^(e^e<<1))|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(e|0)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=n.charCodeAt(r)|0,r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function a(e,t){var n=new r(e),a=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21);while(r===0);return r},o.int32=n.next,o.quick=o,a&&(typeof a==`object`&&i(a,n),o.state=function(){return i(n,{})}),o}t&&t.exports?t.exports=a:n&&n.amd?n(function(){return a}):this.xorwow=a})(e,typeof t==`object`&&t,typeof define==`function`&&define)})),Kde=s(((e,t)=>{(function(e,t,n){function r(e){var t=this;t.next=function(){var e=t.x,n=t.i,r=e[n],i;return r^=r>>>7,i=r^r<<24,r=e[n+1&7],i^=r^r>>>10,r=e[n+3&7],i^=r^r>>>3,r=e[n+4&7],i^=r^r<<7,r=e[n+7&7],r^=r<<13,i^=r^r<<9,e[n]=i,t.i=n+1&7,i};function n(e,t){var n,r=[];if(t===(t|0))r[0]=t;else for(t=``+t,n=0;n<t.length;++n)r[n&7]=r[n&7]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&r[n]===0;++n);for(n==8?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}n(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function a(e,t){e??=+new Date;var n=new r(e),a=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21);while(r===0);return r},o.int32=n.next,o.quick=o,a&&(a.x&&i(a,n),o.state=function(){return i(n,{})}),o}t&&t.exports?t.exports=a:n&&n.amd?n(function(){return a}):this.xorshift7=a})(e,typeof t==`object`&&t,typeof define==`function`&&define)})),qde=s(((e,t)=>{(function(e,t,n){function r(e){var t=this;t.next=function(){var e=t.w,n=t.X,r=t.i,i,a;return t.w=e=e+1640531527|0,a=n[r+34&127],i=n[r=r+1&127],a^=a<<13,i^=i<<17,a^=a>>>15,i^=i>>>12,a=n[r]=a^i,t.i=r,a+(e^e>>>16)|0};function n(e,t){var n,r,i,a,o,s=[],c=128;for(t===(t|0)?(r=t,t=null):(t+=`\0`,r=0,c=Math.max(c,t.length)),i=0,a=-32;a<c;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),a===0&&(o=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(o=o+1640531527|0,n=s[a&127]^=r+o,i=n==0?i+1:0);for(i>=128&&(s[(t&&t.length||0)&127]=-1),i=127,a=512;a>0;--a)r=s[i+34&127],n=s[i=i+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[i]=r^n;e.w=o,e.X=s,e.i=i}n(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function a(e,t){e??=+new Date;var n=new r(e),a=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21);while(r===0);return r},o.int32=n.next,o.quick=o,a&&(a.X&&i(a,n),o.state=function(){return i(n,{})}),o}t&&t.exports?t.exports=a:n&&n.amd?n(function(){return a}):this.xor4096=a})(e,typeof t==`object`&&t,typeof define==`function`&&define)})),Jde=s(((e,t)=>{(function(e,t,n){function r(e){var t=this,n=``;t.next=function(){var e=t.b,n=t.c,r=t.d,i=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^i,i=i-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^i,t.a=i-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=e|0):n+=e;for(var r=0;r<n.length+20;r++)t.b^=n.charCodeAt(r)|0,t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function a(e,t){var n=new r(e),a=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21);while(r===0);return r},o.int32=n.next,o.quick=o,a&&(typeof a==`object`&&i(a,n),o.state=function(){return i(n,{})}),o}t&&t.exports?t.exports=a:n&&n.amd?n(function(){return a}):this.tychei=a})(e,typeof t==`object`&&t,typeof define==`function`&&define)})),Yde=s(((e,t)=>{(function(e,n,r){var i=256,a=6,o=52,s=`random`,c=r.pow(i,a),l=r.pow(2,o),u=l*2,d=i-1,f;function p(e,t,o){var d=[];t=t==1?{entropy:!0}:t||{};var f=_(g(t.entropy?[e,y(n)]:e??v(),3),d),p=new m(d),b=function(){for(var e=p.g(a),t=c,n=0;e<l;)e=(e+n)*i,t*=i,n=p.g(1);for(;e>=u;)e/=2,t/=2,n>>>=1;return(e+n)/t};return b.int32=function(){return p.g(4)|0},b.quick=function(){return p.g(4)/4294967296},b.double=b,_(y(p.S),n),(t.pass||o||function(e,t,n,i){return i&&(i.S&&h(i,p),e.state=function(){return h(p,{})}),n?(r[s]=e,t):e})(b,f,`global`in t?t.global:this==r,t.state)}function m(e){var t,n=e.length,r=this,a=0,o=r.i=r.j=0,s=r.S=[];for(n||(e=[n++]);a<i;)s[a]=a++;for(a=0;a<i;a++)s[a]=s[o=d&o+e[a%n]+(t=s[a])],s[o]=t;(r.g=function(e){for(var t,n=0,a=r.i,o=r.j,s=r.S;e--;)t=s[a=d&a+1],n=n*i+s[d&(s[a]=s[o=d&o+t])+(s[o]=t)];return r.i=a,r.j=o,n})(i)}function h(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n=[],r=typeof e,i;if(t&&r==`object`)for(i in e)try{n.push(g(e[i],t-1))}catch{}return n.length?n:r==`string`?e:e+`\0`}function _(e,t){for(var n=e+``,r,i=0;i<n.length;)t[d&i]=d&(r^=t[d&i]*19)+n.charCodeAt(i++);return y(t)}function v(){try{var t;return f&&(t=f.randomBytes)?t=t(i):(t=new Uint8Array(i),(e.crypto||e.msCrypto).getRandomValues(t)),y(t)}catch{var r=e.navigator,a=r&&r.plugins;return[+new Date,e,a,e.screen,y(n)]}}function y(e){return String.fromCharCode.apply(0,e)}if(_(r.random(),n),typeof t==`object`&&t.exports){t.exports=p;try{f=lc()}catch{}}else typeof define==`function`&&define.amd?define(function(){return p}):r[`seed`+s]=p})(typeof self<`u`?self:e,[],Math)})),ZI=s(((e,t)=>{var n=Ude(),r=Wde(),i=Gde(),a=Kde(),o=qde(),s=Jde(),c=Yde();c.alea=n,c.xor128=r,c.xorwow=i,c.xorshift7=a,c.xor4096=o,c.tychei=s,t.exports=c}));function Xde(e,t){return QI(e,t)}function QI(e,t,n=new Map,r=new Set){if(e==null)return null;if(typeof Blob==`function`&&e instanceof Blob)return e.slice();if(r.has(e))throw Error(`Circular references are not supported.`);if(n.has(e))return n.get(e);let i=t(e);if(i.recurse&&i.value!==null)throw Error(`A deep map function may not return both a value and recurse=true.`);if(i.recurse)if(nL(e)){let i=Array.isArray(e)?[]:{};for(let a in r.add(e),e){let o=e[a];i[a]=QI(o,t,n,r)}return r.delete(e),e.__proto__&&(i.__proto__=e.__proto__),i}else throw Error(`Can't recurse into non-iterable type: ${e}`);else return n.set(e,i.value),i.value}function Zde(e,t=eL){return $I(e,t)}function $I(e,t,n=new Set){let r=e[0];if(n.has(r))throw Error(`Circular references are not supported.`);let i=t(e);if(i.recurse&&i.value!==null)throw Error(`A deep zip function may not return both a value and recurse=true.`);if(i.recurse)if(nL(r)){let i=Array.isArray(r)?[]:{};for(let a in n.add(r),r){let r=e.map(e=>e[a]);i[a]=$I(r,t,n)}return n.delete(r),i}else throw Error(`Can't recurse into non-iterable type: ${r}`);else return i.value}function eL(e){return e===null?null:nL(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function tL(e,t){let n=new Map;QI(e,t,n);for(let e of Array.from(n.keys())){let t=n.get(e);if(Ye(t)){let r=await t;n.set(e,r)}}return QI(e,t,n)}function nL(e){let t=!1;if(k().get(`IS_BROWSER`))t=e instanceof TextDecoder;else{let{StringDecoder:n}=lc();t=e instanceof n}return e!=null&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||typeof e==`object`&&!(e instanceof wa)&&!(e instanceof Promise)&&!t)}function Qde(e){return e==null||$de(e)||Array.isArray(e)||typeof e==`object`&&e instanceof wa||ea(e)}function $de(e){return e===null||typeof e!=`object`&&typeof e!=`function`}var rL=o((()=>{Y()}));function efe(e){return Xde(e,tfe)}function tfe(e){return e instanceof wa?{value:e.clone(),recurse:!1}:nL(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var nfe=o((()=>{Y(),rL()})),iL,aL=o((()=>{iL=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw RangeError(`Can't create a ring buffer of unknown capacity.`);if(e<1)throw RangeError(`Can't create ring buffer of capacity < 1.`);this.data=Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw RangeError(`Can't get item at a negative index.`);return this.data[e%this.capacity]}set(e,t){if(e<0)throw RangeError(`Can't set item at a negative index.`);this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw RangeError(`Ring buffer is full.`);this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw RangeError(`Ring buffer is empty.`);this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw RangeError(`Ring buffer is full.`);this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw RangeError(`Ring buffer is empty.`);let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw RangeError(`Ring buffer is empty.`);let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}}})),oL,rfe=o((()=>{aL(),oL=class e extends iL{constructor(){super(e.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){let e=this.capacity*2,t=Array(e),n=this.length();for(let e=0;e<n;e++)t[e]=this.get(this.wrap(this.begin+e));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}},oL.INITIAL_CAPACITY=32}));function sL(e){return new dL(e)}function cL(e){return new fL(e)}function ife(e,t){return new CL(e,t)}function afe(e,t=wL.FAIL){return new TL(e,t)}var lL,uL,dL,fL,pL,mL,hL,gL,_L,vL,yL,bL,xL,SL,CL,wL,TL,EL,DL,OL=o((()=>{Y(),lL=u(ZI()),nfe(),rL(),rfe(),aL(),uL=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new yL(this,e)}filter(e){return new _L(this,e)}map(e){return new vL(this,e)}mapAsync(e){return new bL(this,e)}serialMapAsync(e){return new bL(this,e).serial()}flatmap(e){return new SL(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(e=>e===!0)}rowMajorBatch(e,t=!0){return new gL(this,e,t)}columnMajorBatch(e,t=!0,n=eL){return this.rowMajorBatch(e,t).map(e=>Zde(e,n))}concatenate(e,t){return new CL(sL([this,e]),t)}take(e){return e<0||e==null?this:new hL(this,e)}skip(e){return e<0||e==null?this:new mL(this,e)}prefetch(e){return new EL(this,e)}shuffle(e,t){return new DL(this,e,t)}serial(){return new pL(this)}},dL=class extends uL{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:efe(e),done:!1}}},fL=class extends uL{constructor(e){super(),this.nextFn=e}summary(){return`Function call`}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}},pL=class extends uL{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},mL=class extends uL{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;Mo(e.value)}return this.upstream.next()}},hL=class extends uL{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},gL=class extends uL{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},_L=class extends uL{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Mo(e.value)}}},vL=class extends uL{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Va(e.value),n=this.transform(e.value),r=Va(n);for(let e of t)Ba(e,r)||e.dispose();return{value:n,done:!1}}},yL=class extends uL{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}},bL=class extends uL{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Va(e.value),n=await this.transform(e.value),r=Va(n);for(let e of t)Ba(e,r)||e.dispose();return{value:n,done:!1}}},xL=class extends uL{constructor(){super(),this.outputQueue=new oL,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},SL=class extends xL{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=Va(e.value),n=this.transform(e.value),r=Va(n);this.outputQueue.pushAll(n);for(let e of t)Ba(e,r)||e.dispose();return!0}},CL=class extends uL{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return`TODO: fill in upstream of chained summaries -> Chained`}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){let e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}},(function(e){e[e.FAIL=0]=`FAIL`,e[e.SHORTEST=1]=`SHORTEST`,e[e.LONGEST=2]=`LONGEST`})(wL||={}),TL=class extends uL{constructor(e,t=wL.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return`{TODO: fill in upstream of zip summaries} -> Zip`}async nextState(e){await e;let t=0,n=0;function r(e){return e instanceof uL?{value:e.next().then(e=>(t++,e.done&&n++,e.value)),recurse:!1}:{value:null,recurse:!0}}let i=await tL(this.iterators,r);if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case wL.FAIL:throw Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case wL.SHORTEST:return{value:null,done:!0};case wL.LONGEST:default:}return this.count++,{value:i,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},EL=class extends uL{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new iL(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},DL=class extends EL{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=lL.alea(n||Xi().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}}}));function kL(e,t=null){return new class extends jL{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function ofe(e){return kL(async()=>sL(e),e.length)}function sfe(e){if(!nL(e))throw Error(`The argument to zip() must be an object or array.`);let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=t==null?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(let n in e)t=t==null?e[n].size:Math.min(t,e[n].size);return kL(async()=>{let t=await tL(e,e=>{if(e instanceof jL)return{value:e.iterator(),recurse:!1};if(nL(e))return{value:null,recurse:!0};throw Error(`Leaves of the structure passed to zip() must be Datasets, not primitives.`)});return afe(t,wL.SHORTEST)},t)}function cfe(e){if(e===null)return null;let t=e[0];return Qde(t)?{value:lfe(e),recurse:!1}:{value:null,recurse:!0}}function lfe(e){if(e.length===0)throw Error(`Can't make a batch of zero elements.`);return e[0]instanceof wa?C_(e):_o(e)}var AL,jL,ML=o((()=>{Y(),AL=u(ZI()),OL(),rL(),jL=class{constructor(){this.size=null}batch(e,t=!0){let n=this;D(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let r;return r=this.size===1/0||this.size==null?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),kL(async()=>(await n.iterator()).columnMajorBatch(e,t,cfe),r)}concatenate(e){let t=this,n;return n=this.size===1/0||e.size===1/0?1/0:this.size!=null&&e.size!=null?this.size+e.size:null,kL(async()=>(await t.iterator()).concatenate(await e.iterator()),n)}filter(e){let t=this,n;return n=this.size===1/0?1/0:null,kL(async()=>(await t.iterator()).filter(t=>B(()=>e(t))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return kL(async()=>(await t.iterator()).map(t=>B(()=>e(t))),this.size)}mapAsync(e){let t=this;return kL(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return kL(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){let t=this,n;return n=this.size!=null&&e>0?this.size*e:e===0?0:this.size!=null&&(e===void 0||e<0)?1/0:null,kL(async()=>{let n=cL(async()=>({value:await t.iterator(),done:!1}));return ife(n.take(e))},n)}skip(e){let t=this,n;return n=this.size!=null&&e>=0&&this.size>=e?this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?0:null,kL(async()=>(await t.iterator()).skip(e),n)}shuffle(e,t,n=!0){if(e==null||e<0)throw this.size==null?RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let r=this,i=AL.alea(t||Xi().toString());return kL(async()=>{let t=i.int32();return n&&(t+=i.int32()),(await r.iterator()).shuffle(e,t.toString())},this.size)}take(e){let t=this,n;return n=this.size!=null&&this.size>e?e:this.size!=null&&this.size<=e?this.size:null,kL(async()=>(await t.iterator()).take(e),n)}async toArray(){if(this.size===1/0)throw Error(`Can not convert infinite data stream to array.`);return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw Error(`Can not convert infinite data stream to array.`);return(await this.iterator()).toArrayForTest()}},jL.MAX_BUFFER_SIZE=1e4})),NL,PL=o((()=>{ML(),NL=class extends jL{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(e=>(e.endsWith(`\r`)&&(e=e.slice(0,-1)),e))}}})),FL,IL,LL,RL,zL,BL,VL,HL=o((()=>{Y(),ML(),PL(),FL=`"`,IL=Symbol(`out`),LL=Symbol(`field`),RL=Symbol(`quote`),zL=Symbol(`quoteafterquote`),BL=Symbol(`quoteinquote`),VL=class extends jL{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw Error(`Column names must be provided if there is no header line.`);this.fullColumnNames&&e&&D(e.length===this.fullColumnNames.length,()=>`The length of provided columnNames (`+this.fullColumnNames.length.toString()+`) does not match the length of the header line read from file (`+e.length.toString()+`).`),this.fullColumnNames||=e;let t=this.fullColumnNames.reduce((e,t)=>(e[t]=e[t]+1||1,e),{}),n=Object.keys(t).filter(e=>t[e]>1);if(D(n.length===0,()=>`Duplicate column names found: `+n.toString()),this.columnConfigs){for(let e of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(e)===-1)throw Error(`The key "`+e+`" provided in columnConfigs does not match any of the column names (`+this.fullColumnNames.toString()+`).`)}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw Error(`No data was found for CSV parsing.`);let t=e.value;return this.parseRow(t,!1)}else return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=`,`,this.delimWhitespace=!1,this.base=new NL(e),t||={},this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(D(t.delimiter==null,()=>`Delimiter should not be provided when delimWhitespace is true.`),this.delimWhitespace=!0,this.delimiter=` `):this.delimiter=t.delimiter?t.delimiter:`,`}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(e=>this.makeDataElement(e))}makeDataElement(e){let t=this.parseRow(e),n={},r={};for(let i=0;i<this.fullColumnNames.length;i++){let a=this.fullColumnNames[i],o=this.columnConfigs?this.columnConfigs[a]:null;if(!(this.configuredColumnsOnly&&!o)){let s=t[i],c=null;if(s===``)if(o&&o.default!==void 0)c=o.default;else if(o&&(o.required||o.isLabel))throw Error(`Required column ${a} is empty in this line: ${e}`);else c=void 0;else{let e=Number(s);if(isNaN(e))c=o&&o.dtype===`bool`?this.getBoolean(s):s;else if(!o||!o.dtype)c=e;else switch(o.dtype){case`float32`:c=e;break;case`int32`:c=Math.floor(e);break;case`bool`:c=this.getBoolean(s);break;default:c=e}}o&&o.isLabel?r[a]=c:n[a]=c}}return Object.keys(r).length===0?n:{xs:n,ys:r}}getBoolean(e){return e===`1`||e.toLowerCase()===`true`?1:0}parseRow(e,t=!0){let n=[],r=0,i=e.length,a=IL;for(let t=0;t<i;t++)switch(a){case IL:switch(e.charAt(t)){case FL:r=t+1,a=RL;break;case this.delimiter:if(r=t+1,this.delimiter===` `&&this.delimWhitespace)break;n.push(``),a=IL;break;default:a=LL,r=t;break}break;case LL:switch(e.charAt(t)){case this.delimiter:n.push(e.substring(r,t)),a=IL,r=t+1;break;default:}break;case RL:switch(e.charAt(t)){case FL:a=zL;break;default:}break;case zL:switch(e.charAt(t)){case this.delimiter:n.push(e.substring(r,t-1)),a=IL,r=t+1;break;case FL:a=RL;break;default:a=BL;break}break;case BL:switch(e.charAt(t)){case FL:a=RL;break;default:}break;default:}if(a===zL?n.push(e.substring(r,i-1)):n.push(e.substring(r)),t&&n.length!==this.fullColumnNames.length)throw Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}}})),UL,ufe=o((()=>{Y(),OL(),UL=class e extends uL{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;let t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=e.includeSpectrogram!==!1,this.includeWaveform=e.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw Error(`Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.`)}summary(){return`microphone`}static async create(t={}){if(!k().get(`IS_BROWSER`))throw Error(`microphone API is only supported in browser environment.`);let n=new e(t);return await n.start(),n}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(e){throw Error(`Error thrown while initializing video stream: ${e.message}`)}if(!this.stream)throw Error(`Could not obtain audio from microphone.`);if(this.audioContext=new(window.AudioContext||window.webkitAudioContext),!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let e=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,e.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t,n=await this.getAudioData();if(this.includeSpectrogram){let t=this.flattenQueue(n.freqDataQueue);e=this.getTensorFromAudioDataArray(t,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let e=this.flattenQueue(n.timeDataQueue);t=this.getTensorFromAudioDataArray(e,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let e=[],t=[],n=0;return new Promise(r=>{let i=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(i),r({freqDataQueue:e,timeDataQueue:t}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw Error(`Can not convert infinite audio stream to array.`)}getSampleRate(){return this.sampleRateHz}flattenQueue(e){let t=e[0].length,n=new Float32Array(e.length*t);return e.forEach((e,r)=>n.set(e,r*t)),n}getTensorFromAudioDataArray(e,t){let n=new Float32Array(O(t));return n.set(e,n.length-e.length),_o(n,t)}}})),WL,dfe=o((()=>{Y(),OL(),WL=class e extends uL{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=P_([0],`int32`),this.webcamConfig.centerCrop){let e=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,t=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,n=(1-e)/2,r=(1-t)/2,i=n+e,a=t+r;this.cropBox=I_([r,n,a,i],[1,4])}else this.cropBox=I_([0,0,1,1],[1,4])}summary(){return`webcam`}static async create(t,n={}){if(!k().get(`IS_BROWSER`))throw Error(`tf.data.webcam is only supported in browser environment.`);if(!t){if(t=document.createElement(`video`),!n.resizeWidth||!n.resizeHeight)throw Error(`Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.`);t.width=n.resizeWidth,t.height=n.resizeHeight}let r=new e(t,n);return await r.start(),r}async start(){this.webcamConfig.facingMode&&D(this.webcamConfig.facingMode===`user`||this.webcamConfig.facingMode===`environment`,()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:`user`,width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw Error(`Could not obtain video from webcam.`);try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}})}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=Gx(this.webcamVideoElement)}catch(e){throw Error(`Error thrown converting video to pixels: ${JSON.stringify(e)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(e){throw Error(`Error thrown cropping the video: ${e.message}`)}finally{e.dispose()}else return{value:e,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(e){return B(()=>{let t=vp(V(e,`float32`),0),n;n=_b.cropAndResize(t,this.cropBox,this.cropBoxInd,this.cropSize,`bilinear`);let r=n.shape;return W(n,r.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(e=>e.stop());try{this.webcamVideoElement.srcObject=null}catch(e){console.log(e),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw Error(`Can not convert infinite video stream to array.`)}}})),GL,KL=o((()=>{GL=class{}})),qL,JL,YL,ffe=o((()=>{OL(),qL=class extends uL{split(e){return new JL(this,e)}},JL=class extends qL{constructor(e,t){super(),this.upstream=e,this.impl=new YL(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},YL=class extends xL{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=``}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return this.carryover===``?!1:(this.outputQueue.push(this.carryover),this.carryover=``,!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let e of t.slice(0,-1))this.outputQueue.push(e);return this.carryover=t[t.length-1],!0}}})),XL,ZL,QL,pfe=o((()=>{Y(),OL(),ffe(),XL=class extends uL{decodeUTF8(){return new ZL(this)}},ZL=class extends qL{constructor(e){super(),this.upstream=e,this.impl=new QL(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},QL=class extends xL{constructor(e){if(super(),this.upstream=e,k().get(`IS_BROWSER`))this.decoder=new TextDecoder(`utf-8`);else{let{StringDecoder:e}=lc();this.decoder=new e(`utf8`)}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e=await this.upstream.next(),t;if(e.done)return!1;t=e.value;let n;return n=k().get(`IS_BROWSER`)?this.decoder.decode(t,{stream:!0}):this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(n),!0}}})),$L,eR=o((()=>{Y(),pfe(),$L=class extends XL{constructor(e,t={}){super(),this.file=e,this.options=t,D(e instanceof Uint8Array||(k().get(`IS_BROWSER`)?e instanceof File||e instanceof Blob:!1),()=>`FileChunkIterator only supports File, Blob and Uint8Array right now.`),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((e,t)=>{let n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{let r=new FileReader;r.onload=n=>{let i=r.result;if(i instanceof ArrayBuffer&&(i=new Uint8Array(i)),!(i instanceof Uint8Array))return t(TypeError(`FileReader returned unknown type.`));e(i)},r.onabort=e=>t(Error(`Aborted`)),r.onerror=e=>t(Error(e.type));let i=this.file.slice(this.offset,n);r.readAsArrayBuffer(i)}this.offset=n}),done:!1}}}}));async function mfe(e,t={},n){let r,i;typeof e==`string`?r=e:(r=e.url,i=tR(e));let a=await(n||Zi)(r,i);if(a.ok){let e=new Uint8Array(await a.arrayBuffer());return new $L(e,t)}else throw Error(a.statusText)}var tR,hfe=o((()=>{Y(),eR(),tR=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity})}));
/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* =============================================================================
*/
function nR(e){return typeof e==`string`&&e.slice(0,7)===`file://`}var rR=o((()=>{})),iR,aR=o((()=>{Y(),KL(),eR(),rR(),iR=class extends GL{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){return nR(this.input)&&k().get(`IS_NODE`)&&(this.input=lc().readFileSync(this.input.slice(7))),new $L(this.input,this.options)}}})),oR,sR=o((()=>{KL(),hfe(),rR(),aR(),oR=class extends GL{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return nR(this.url)?new iR(this.url,this.fileOptions).iterator():mfe(this.url,this.fileOptions)}}}));function gfe(e,t={}){return new VL(new oR(e),t)}function _fe(e){let t=cL(e);return kL(async()=>t)}function vfe(e){return kL(async()=>{let t=await e();return cL(()=>t.next())})}async function yfe(e,t){return WL.create(e,t)}async function bfe(e){return UL.create(e)}var xfe=o((()=>{ML(),HL(),OL(),ufe(),dfe(),sR()})),cR,Sfe=o((()=>{cR=`4.22.0`})),Cfe=c({CSVDataset:()=>VL,Dataset:()=>jL,FileDataSource:()=>iR,TextLineDataset:()=>NL,URLDataSource:()=>oR,array:()=>ofe,csv:()=>gfe,func:()=>_fe,generator:()=>vfe,microphone:()=>bfe,version_data:()=>cR,webcam:()=>yfe,zip:()=>sfe}),wfe=o((()=>{ML(),HL(),PL(),xfe(),aR(),sR(),Sfe()}));function lR(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{e!=null&&D(e.dtype!==`complex64`,()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var uR=o((()=>{Y()})),dR,fR,Tfe=o((()=>{Y(),uR(),dR=hv,fR=class e extends ne{nextDataId(){return e.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new te(this,ko())}write(e,t,n){this.firstUse&&(this.firstUse=!1,k().get(`IS_NODE`)&&li(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if(t===`string`&&n!=null&&n.length>0&&Ne(n[0])){let i=n.map(e=>Qi(e));r=this.write(i,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){let t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){let t=this.data.get(e);t.refCount--}}move(e,t,n,r,i){this.data.set(e,{values:t,dtype:r,refCount:i})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){let{dtype:t,complexTensorInfos:n}=this.data.get(e);if(t===`complex64`){let e=this.readSync(n.real.dataId),t=this.readSync(n.imag.dataId);return US(e,t)}return He(this.data.get(e).values,t)}bufferSync(e){let t=this.readSync(e.dataId);if(e.dtype===`string`)try{let n=t.map(e=>$i(e));return mc(e.shape,e.dtype,n)}catch{throw Error(`Failed to decode encoded string bytes into utf-8`)}return mc(e.shape,e.dtype,t)}makeOutput(e,t,n){return ko().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;let{complexTensorInfos:n}=this.data.get(e);n!=null&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){let t=Xi();return e(),{kernelMs:Xi()-t}}memory(){return{unreliable:!0,reasons:[`The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less.`]}}where(e){lR([e],`where`);let t=this.readSync(e.dataId);return dR(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}},fR.nextDataId=0}));function pR(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}var mR,hR,gR=o((()=>{Y(),uR(),mR=e=>{let{x:t}=e.inputs,n=e.backend;lR(t,`abs`);let r=new Float32Array(O(t.shape)),i=n.data.get(t.dataId).values;return r=pR(i),n.makeOutput(r,t.shape,t.dtype)},hR={kernelName:`Abs`,backendName:`cpu`,kernelFunc:mR}}));function _R(e){return(t,n,r,i,a)=>{let o=nf(t,n),s=o.length,c=ze(o),l=O(o),u=Ee(a,l),d=t.length,f=n.length,p=ze(t),m=ze(n),h=ef(t,o),g=ef(n,o);if(h.length+g.length===0)for(let t=0;t<u.length;++t)u[t]=e(r[t%r.length],i[t%i.length]);else for(let t=0;t<u.length;++t){let n=Je(t,s,c),a=n.slice(-d);h.forEach(e=>a[e]=0);let o=qe(a,d,p),l=n.slice(-f);g.forEach(e=>l[e]=0);let _=qe(l,f,m);u[t]=e(r[o],i[_])}return[u,o]}}var vR=o((()=>{Y()}));function yR(e){let{inputs:t,backend:n}=e,{real:r,imag:i}=t,a=n.data.get(r.dataId).values,o=n.data.get(i.dataId).values,s=n.makeTensorInfo(r.shape,`complex64`),c=n.data.get(s.dataId);return c.complexTensorInfos={real:n.makeTensorInfo(r.shape,`float32`,a),imag:n.makeTensorInfo(i.shape,`float32`,o)},s}var bR,xR=o((()=>{Y(),bR={kernelName:Nt,backendName:`cpu`,kernelFunc:yR}}));function SR(e,t,n=`float32`){if(n===`complex64`){let n=SR(e,t,`float32`),r=SR(e,t,`float32`);return yR({inputs:{real:n,imag:r},backend:e})}let r=We(O(t),n);return e.makeTensorInfo(t,n,r)}var CR=o((()=>{Y(),xR()}));function wR(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var TR,ER=o((()=>{Y(),TR={kernelName:vn,backendName:`cpu`,kernelFunc:wR}}));function DR(e){let{inputs:t,backend:n}=e,{input:r}=t,i=n.data.get(r.dataId).complexTensorInfos.real,a=n.data.get(i.dataId).values;return n.makeTensorInfo(i.shape,i.dtype,a)}var OR,kR=o((()=>{Y(),OR={kernelName:lr,backendName:`cpu`,kernelFunc:DR}}));function AR(e,t,n,r){if(r===`int32`){let n=Int32Array.from(e);return[t,`int32`,n]}if(r===`bool`){let r=Yi([0],n),[i,a]=_R((e,t)=>e===t?0:1)(t,[],e,r,`bool`);return[a,`bool`,i]}throw Error(`Error in Cast: failed to cast ${n} to ${r}`)}function jR(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{dtype:a}=r;if(a===`complex64`){if(i.dtype===`complex64`)return wR({inputs:{x:i},backend:n});let e=SR(n,i.shape,i.dtype),t=jR({inputs:{x:i},backend:n,attrs:{dtype:`float32`}}),r=yR({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if(i.dtype===`complex64`){let e=DR({inputs:{input:i},backend:n}),t=jR({inputs:{x:e},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(e),t}if(!Ae(i.dtype,a)){let e=wR({inputs:{x:i},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:a}}let o=n.data.get(i.dataId).values,[s,c,l]=AR(o,i.shape,i.dtype,a);return n.makeTensorInfo(s,c,l)}var MR,NR=o((()=>{Y(),vR(),CR(),xR(),ER(),kR(),MR={kernelName:At,backendName:`cpu`,kernelFunc:jR}}));function PR(e,t,n,r){return n==null?({inputs:n,backend:i})=>{let{a,b:o}=n,s=i;lR([a,o],e);let c=s.data.get(a.dataId).values,l=s.data.get(o.dataId).values,u=a.dtype===`string`?CC(c):c,d=a.dtype===`string`?CC(l):l,f=r||a.dtype,[p,m]=t(a.shape,o.shape,u,d,f);return s.makeTensorInfo(m,f,p)}:({inputs:e,backend:i})=>{let{a,b:o}=e,s=i;if(a.dtype===`complex64`||o.dtype===`complex64`){let e=jR({inputs:{x:a},backend:s,attrs:{dtype:`complex64`}}),t=s.data.get(e.dataId),r=t.complexTensorInfos.real,i=t.complexTensorInfos.imag,c=s.data.get(r.dataId).values,l=s.data.get(i.dataId).values,u=jR({inputs:{x:o},backend:s,attrs:{dtype:`complex64`}}),d=s.data.get(u.dataId),f=d.complexTensorInfos.real,p=d.complexTensorInfos.imag,m=s.data.get(f.dataId).values,h=s.data.get(p.dataId).values,[g,_,v]=n(a.shape,o.shape,c,l,m,h),y=s.makeTensorInfo(v,`float32`,g),b=s.makeTensorInfo(v,`float32`,_),x=yR({inputs:{real:y,imag:b},backend:s});return s.disposeIntermediateTensorInfo(e),s.disposeIntermediateTensorInfo(u),s.disposeIntermediateTensorInfo(y),s.disposeIntermediateTensorInfo(b),x}else{let e=s.data.get(a.dataId).values,n=s.data.get(o.dataId).values,i=r||a.dtype,[c,l]=t(a.shape,o.shape,e,n,i);return s.makeTensorInfo(l,i,c)}}}function FR(e){return(t,n,r,i,a,o)=>{let s=nf(t,n),c=O(s),l=s.length,u=ze(s),d=Ee(`float32`,c),f=Ee(`float32`,c),p=ef(t,s),m=ef(n,s),h=US(r,i),g=US(a,o),_=t.length,v=ze(t),y=n.length,b=ze(n);if(p.length+m.length===0)for(let t=0;t<d.length;t++){let n=t%h.length,r=t%g.length,i=e(h[n*2],h[n*2+1],g[r*2],g[r*2+1]);d[t]=i.real,f[t]=i.imag}else for(let t=0;t<d.length;t++){let n=Je(t,l,u),r=n.slice(-_);p.forEach(e=>r[e]=0);let i=qe(r,_,v),a=n.slice(-y);m.forEach(e=>a[e]=0);let o=qe(a,y,b),s=e(h[i*2],h[i*2+1],g[o*2],g[o*2+1]);d[t]=s.real,f[t]=s.imag}return[d,f,s]}}var IR=o((()=>{Y(),uR(),NR(),xR()})),LR,RR,zR,BR,VR=o((()=>{Y(),vR(),IR(),LR=_R(((e,t)=>e+t)),RR=FR(((e,t,n,r)=>({real:e+n,imag:t+r}))),zR=PR(`Add`,LR,RR),BR={kernelName:`Add`,backendName:`cpu`,kernelFunc:zR}}));function HR(e,t,n,r,i){let a=O(r),o=We(i,n);for(let n=0;n<e.length;n++){let r=e[n];if(r<0)throw Error(`Input x must be non-negative!`);r>=i||(a>0?o[r]+=t[n]:o[r]+=1)}return o}function UR(e,t,n,r=!1){let i=e.shape[0],a=e.shape[1],o=mc([i,n],t.dtype);for(let s=0;s<i;s++)for(let i=0;i<a;i++){let a=e.get(s,i);if(a<0)throw Error(`Input x must be non-negative!`);a>=n||(r?o.set(1,s,a):t.size>0?o.set(o.get(s,a)+t.get(s,i),s,a):o.set(o.get(s,a)+1,s,a))}return o}var WR=o((()=>{Y()})),GR,KR,qR,JR=o((()=>{Y(),vR(),IR(),GR=_R(((e,t)=>e&t)),KR=PR(Dt,GR),qR={kernelName:Dt,backendName:`cpu`,kernelFunc:KR}}));function YR(e){return(t,n,r)=>{let i=De(n,t.length);for(let n=0;n<t.length;++n)i[n]=e(t[n],r);return i}}var XR=o((()=>{Y()}));function ZR(e,t,n){let r=YR(t);return QR(e,r,n)}function QR(e,t,n){return({inputs:r,attrs:i,backend:a})=>{let{x:o}=r;lR(o,e);let s=a,c=s.data.get(o.dataId).values,l;if(o.dtype===`string`){if(!Array.isArray(c))throw Error(`String tensor's value was not an instance of Array`);l=CC(c)}else l=c;let u=n||o.dtype,d=t(l,u,i);return s.makeTensorInfo(o.shape,u,d)}}var $R=o((()=>{Y(),uR(),XR()})),ez,tz,nz,rz=o((()=>{Y(),XR(),$R(),ez=YR(e=>Math.ceil(e)),tz=QR(jt,ez),nz={kernelName:jt,backendName:`cpu`,kernelFunc:tz}}));function iz(e,t,n,r){let i=De(n,O(t));if(r&&n!==`string`){let t=0;e.forEach(e=>{let n=O(e.shape);i.set(e.vals,t),t+=n})}else{let r=0;e.forEach(e=>{let a=n===`string`?CC(e.vals):e.vals,o=0;for(let n=0;n<e.shape[0];++n){let s=n*t[1]+r;for(let t=0;t<e.shape[1];++t)i[s+t]=a[o++]}r+=e.shape[1]})}return i}var az=o((()=>{Y()})),oz,sz,cz,lz=o((()=>{Y(),vR(),IR(),oz=_R((e,t)=>e===t?1:0),sz=PR(on,oz,null,`bool`),cz={kernelName:on,backendName:`cpu`,kernelFunc:sz}})),uz,dz,fz,pz=o((()=>{Y(),XR(),$R(),uz=YR(e=>Math.exp(e)),dz=QR(`Exp`,uz,`float32`),fz={kernelName:`Exp`,backendName:`cpu`,kernelFunc:dz}})),mz,hz,gz,_z=o((()=>{Y(),XR(),$R(),mz=YR(e=>Math.expm1(e)),hz=QR(cn,mz),gz={kernelName:cn,backendName:`cpu`,kernelFunc:hz}})),vz,yz,bz,xz=o((()=>{Y(),XR(),$R(),vz=YR(e=>Math.floor(e)),yz=QR(dn,vz),bz={kernelName:dn,backendName:`cpu`,kernelFunc:yz}})),Sz,Cz,wz,Tz=o((()=>{Y(),vR(),IR(),Sz=_R((e,t)=>Math.floor(e/t)),Cz=PR(fn,Sz,null,`int32`),wz={kernelName:fn,backendName:`cpu`,kernelFunc:Cz}}));function Ez(e,t,n,r,i,a,o,s,c){let l=mc([r,a],n);for(let n=0;n<r;n++){let r=[],u=0;for(let t=0;t<i;t++){let a=e[n*i+t];u+=a*o[t],r.push(a)}if(u<0||u>=c/a)throw Error(`Invalid indices: ${r} does not index into ${s}`);for(let e=0;e<a;e++)l.values[n*a+e]=t.get(...t.indexToLoc(u*a+e))}return l}var Dz=o((()=>{Y()}));function Oz(e,t,n){let r=mc(n,e.dtype);for(let n=0;n<r.size;++n){let i=r.indexToLoc(n).slice(),a=i[0],o=i[2],s=t.locToIndex([a,o]);i[2]=t.values[s];let c=e.locToIndex(i);0<=c&&c<e.values.length&&(r.values[n]=e.values[c])}return r}var kz=o((()=>{Y()})),Az,jz,Mz,Nz=o((()=>{Y(),vR(),IR(),Az=_R((e,t)=>e>t?1:0),jz=PR(gn,Az,null,`bool`),Mz={kernelName:gn,backendName:`cpu`,kernelFunc:jz}})),Pz,Fz,Iz,Lz=o((()=>{Y(),vR(),IR(),Pz=_R((e,t)=>e>=t?1:0),Fz=PR(_n,Pz,null,`bool`),Iz={kernelName:_n,backendName:`cpu`,kernelFunc:Fz}})),Rz,zz,Bz,Vz=o((()=>{Y(),vR(),IR(),Rz=_R((e,t)=>e<t?1:0),zz=PR(Tn,Rz,null,`bool`),Bz={kernelName:Tn,backendName:`cpu`,kernelFunc:zz}})),Hz,Uz,Wz,Gz=o((()=>{Y(),vR(),IR(),Hz=_R((e,t)=>e<=t?1:0),Uz=PR(En,Hz,null,`bool`),Wz={kernelName:En,backendName:`cpu`,kernelFunc:Uz}}));function Kz(e,t,n){let r=(t-e)/(n-1),i=We(n,`float32`);i[0]=e;for(let e=1;e<i.length;e++)i[e]=i[e-1]+r;return i}var qz=o((()=>{Y()})),Jz,Yz,Xz,Zz=o((()=>{Y(),XR(),$R(),Jz=YR(e=>Math.log(e)),Yz=QR(`Log`,Jz),Xz={kernelName:`Log`,backendName:`cpu`,kernelFunc:Yz}}));function Qz(e,t,n,r){let i=Ee(r,O(n));for(let n=0;n<i.length;++n){let r=n*t,a=e[r];for(let n=0;n<t;++n){let t=e[r+n];(Number.isNaN(t)||t>a)&&(a=t)}i[n]=a}return i}var $z=o((()=>{Y()})),eB,tB,nB,rB=o((()=>{Y(),vR(),IR(),eB=_R(((e,t)=>Math.max(e,t))),tB=PR(Ln,eB),nB={kernelName:Ln,backendName:`cpu`,kernelFunc:tB}})),iB,aB,oB,sB=o((()=>{Y(),vR(),IR(),iB=_R(((e,t)=>Math.min(e,t))),aB=PR(Wn,iB),oB={kernelName:Wn,backendName:`cpu`,kernelFunc:aB}})),cB,lB,uB,dB,fB=o((()=>{Y(),vR(),IR(),cB=_R(((e,t)=>e*t)),lB=FR(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}))),uB=PR(qn,cB,lB),dB={kernelName:qn,backendName:`cpu`,kernelFunc:uB}}));function pB(e,t,n){let r=qi(-1,n);return cB([],t,r,e,n)}function Efe(e){let{inputs:t,backend:n}=e,{x:r}=t;lR(r,`neg`);let i=n.data.get(r.dataId).values,[a,o]=pB(i,r.shape,r.dtype);return n.makeTensorInfo(o,r.dtype,a)}var mB,hB=o((()=>{Y(),uR(),fB(),mB={kernelName:`Neg`,backendName:`cpu`,kernelFunc:Efe}})),gB,_B,vB,yB=o((()=>{Y(),vR(),IR(),gB=_R(((e,t)=>e===t?0:1)),_B=PR(Jn,gB,null,`bool`),vB={kernelName:Jn,backendName:`cpu`,kernelFunc:_B}}));function bB(e,t,n,r,i){let a=t.length,o=O(t),s=ze(t),c=ze(i),l=Ee(n,O(i));for(let t=0;t<o;++t){let n=Je(t,a,s),i=Array(n.length);for(let e=0;e<i.length;e++)i[e]=n[r[e]];let o=qe(i,a,c);l[o]=e[t]}return l}var xB=o((()=>{Y()}));function SB(e){let{inputs:t,attrs:n,backend:r}=e,{x:i}=t,{perm:a}=n;lR(i,`transpose`);let o=i.shape.length,s=Array(o);for(let e=0;e<s.length;e++)s[e]=i.shape[a[e]];let c=r.data.get(i.dataId).values,l=bB(c,i.shape,i.dtype,a,s);return{dataId:r.write(l,s,i.dtype),shape:s,dtype:i.dtype}}var CB,wB=o((()=>{Y(),uR(),xB(),CB={kernelName:Zr,backendName:`cpu`,kernelFunc:SB}}));function TB(e,t,n,r){let[i,a]=Ff(e,r),o=Ea(t,`int32`),s=We(O(i),o),c=O(a);for(let e=0;e<s.length;++e){let t=e*c,r=1;for(let e=0;e<c;++e)r*=n[t+e];s[e]=r}return{outVals:s,outShape:i,outDtype:o}}function Dfe(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a,keepDims:o}=r;lR(i,`prod`);let s=i.shape.length,c=we(a,i.shape),l=Rf(c,s),u=c,d=i,f=[];l!=null&&(d=SB({inputs:{x:i},backend:n,attrs:{perm:l}}),f.push(d),u=Bf(u.length,s));let p=n.data.get(d.dataId).values,{outVals:m,outShape:h,outDtype:g}=TB(d.shape,d.dtype,p,u),_=h;return o&&(_=If(h,c)),f.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(_,g,m)}var EB,DB=o((()=>{Y(),uR(),wB(),EB={kernelName:ir,backendName:`cpu`,kernelFunc:Dfe}}));function Ofe(e,t,n){e.forEach((e,r)=>{if(e<0||e>=n){let i=Je(r,t.length,ze(t)).join(`,`);throw Error(`indices[${i}] = ${e} is not in [0, ${n})`)}})}function kfe(e,t){for(let n=0;n<e.length;++n){let r=e[n],i=n===e.length-1?t:e[n+1].length;if(r.length===0)throw Error(`Ragged splits may not be empty`);if(r[0]<0)throw Error(`Ragged splits must be non-negative`);if(r[r.length-1]>i)throw Error(`Ragged splits must not point past values`);for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw Error(`Ragged splits must be sorted in ascending order`)}}function Afe(e,t,n,r){let i=[],a=0,o=t.length-1+n.length,s=Array(o).fill(null).map(()=>[0]);kfe(n,r);let c=1;for(let e=0;e<t.length-1;++e){c*=t[e];let n=t[e+1];for(let t=1;t<c+1;++t)s[e].push(t*n)}for(let r=0;r<e.length;++r){let o=e[r],c=e[r]+1;for(let e=0;e<n.length;++e){let r=n[e],i=e+t.length-1;if(i>=0){let e=s[i],t=e[e.length-1]-r[o];for(let e=o;e<c;++e)s[i].push(r[e+1]+t)}o=r[o],c=r[c]}c!==o&&(i.push([o,c]),a+=c-o)}return{outSplits:s,valueSlices:i,numValues:a}}function jfe(e){let t=[];for(let n=0;n<e.length;++n){let r=e[n].length,i=De(`int32`,r);t.push(i),e[n].forEach((e,t)=>i[t]=e)}return t}function OB(e,t){let n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function Mfe(e,t,n,r,i,a){let o=OB(t,2)[1],s=OB(a,2)[1],c=0;for(let t of n)for(let n=t[0];n<t[1];++n){for(let t=0;t<r;++t)i[c*s+t]=e[n*o+t];++c}}function Nfe(e,t,n,r,i){let a=t.slice();a[0]=i;let o=De(n,O(a)),s=e.length,c=s===0?0:s/t[0];return Mfe(e,t,r,c,o,a),[o,a]}function kB(e,t,n,r,i,a,o,s){if(e.length===0)throw Error(`paramsNestedSplits must be non empty`);if(t[0].length===0)throw Error(`Split tensors must not be scalars`);let c=t[0][0]-1;if(Ofe(a,o,c),r.length===0)throw Error(`params.rank must be nonzero`);let l=r[0],{outSplits:u,valueSlices:d,numValues:f}=Afe(a,o,e,l),p=jfe(u),m=Nfe(n,r,i,d,f);return[p,m[0],m[1]]}var AB=o((()=>{Y()}));function jB(e,t,n,r,i,a,o){if(t.length>1)throw Error(`starts must be a scalar or vector`);if(i.length>1)throw Error(`limits must be a scalar or vector`);if(o.length>1)throw Error(`deltas must be a scalar or vector`);let s=t.length===0,c=i.length===0,l=o.length===0,u=[];s||u.push(t[0]),c||u.push(i[0]),l||u.push(o[0]);for(let e=1;e<u.length;++e)if(u[e]!==u[e-1])throw Error(`starts, limits, and deltas must have the same shape`);let d=u.length===0?1:u[0],f=De(`int32`,d+1);f[0]=0;for(let t=0;t<d;++t){let n=s?e[0]:e[t],i=c?r[0]:r[t],o=l?a[0]:a[t];if(o===0)throw Error(`Requires delta != 0`);let u;if(o>0&&i<n||o<0&&i>n)u=0;else if(u=Math.ceil(Math.abs((i-n)/o)),u>MB)throw Error(`Requires ((limit - start) / delta) <= ${MB}`);f[t+1]=f[t]+u}let p=f[d],m=De(n,p),h=0;for(let t=0;t<d;++t){let n=f[t+1]-f[t],r=s?e[0]:e[t],i=l?a[0]:a[t];for(let e=0;e<n;++e)m[h++]=r,r+=i}return[f,m]}var MB,NB=o((()=>{Y(),MB=2147483647}));function PB(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function FB(e,t){let n=[];for(let r of e){if(r<0){if(!t)throw Error(`Dimension ${r} must be >= 0`);if(r<-1)throw Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function IB(e,t,n,r,i,a,o,s,c,l){return new RB(e,t,n,r,i,a,o,s,c,l).compute()}var LB,RB,zB=o((()=>{Y(),LB=TS,RB=class e{constructor(e,t,n,r,i,a,o,s,c,l){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=i,this.defaultValue=a,this.defaultValueShape=o,this.rowPartitionValues=s,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=SS(l),this.raggedRank=CS(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===LB.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===LB.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(t){let n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case LB.VALUE_ROWIDS:return e.getMaxWidthValueRowID(n);case LB.ROW_SPLITS:return e.getMaxWidthRowSplit(n);default:throw Error(`Cannot handle partition type ${LB[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(e){let t=e.length;if(t===0||t===1)return 0;let n=0;for(let r=0;r<t-1;++r){let t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){let t=e.length;if(t===0)return 0;let n=0,r=e[0],i=0;for(let a=1;a<t;++a){let t=e[a];t!==r&&(r=t,i=Math.max(a-n,i),n=a)}return Math.max(t-n,i)}tensorShapeFromTensor(e,t,n=!0){if(t.length===0){if(e[0]===-1)return[];throw Error(`The only valid scalar shape tensor is the fully unknown shape specified as -1.`)}return FB(e,n)}calculateOutputSize(e){let t=this.valuesShape,n=this.defaultValueShape;wS(n,t);let r=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=xS(this.raggedRank,r,t);i[0]<0&&(i[0]=e);for(let e=1;e<=this.raggedRank;++e)i[e]<0&&(i[e]=this.getMaxWidth(e));return i}calculateFirstParentOutputIndex(e,t,n){let r=Math.min(e,n),i=[],a=0;for(let e=0;e<r;++e,a+=t)i.push(a);for(let t=r;t<e;++t)i.push(-1);return D(i.length===e,()=>`Final length of result must be equal to firstDimension.`),i}calculateOutputIndexRowSplit(e,t,n,r){let i=e.length,a=[];for(let o=0;o<i-1;++o){let i=e[o+1]-e[o],s=Math.min(r,i),c=t[o];c===-1&&(s=0);for(let e=0;e<s;++e)a.push(c),c+=n;for(let e=0;e<i-s;++e)a.push(-1)}if(i>0&&a.length!==e[i-1])throw Error(`Invalid row split size.`);return a}calculateOutputIndexValueRowID(e,t,n,r){let i=e.length,a=[];if(i===0)return[];let o=0,s=e[0];if(s>=t.length)throw Error(`Got currentValueRowId=${s}, which is not less than ${t.length}`);let c=t[s];a.push(c);for(let l=1;l<i;++l){let i=e[l];if(i===s)c>=0&&(++o,o<r?c+=n:c=-1);else{if(o=0,s=i,i>=t.length)throw Error(`Got nextValueRowId=${i} which is not less than ${t.length}`);c=t[i]}a.push(c)}if(a.length!==e.length)throw Error(`Invalid row ids.`);return a}calculateOutputIndex(e,t,n,r){let i=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case LB.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,t,n,r);case LB.ROW_SPLITS:if(i.length-1>t.length)throw Error(`Row partition size is greater than output size: ${i.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(i,t,n,r);default:throw Error(`Unsupported partition type: ${LB[a]}`)}}getFirstDimensionSize(){let e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw Error(`No row_partition_types given.`);let t=this.rowPartitionTypes[0];switch(t){case LB.FIRST_DIM_SIZE:return e[0];case LB.VALUE_ROWIDS:throw Error(`Cannot handle VALUE_ROWIDS in first dimension.`);case LB.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw Error(`Cannot handle type ${LB[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw Error(`Invalid first partition input. Tensor requires at least one element.`);let e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=Array(this.raggedRank+1);n[n.length-1]=1;for(let e=n.length-2;e>=0;--e)n[e]=n[e+1]*t[e+1];let r=FB(t,!1),i=De(this.valuesDType,O(r));if(n[0]*t[0]>0){let a=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e)a=this.calculateOutputIndex(e-1,a,n[e],t[e]);this.setOutput(this.raggedRank,a,i,r)}return[r,i]}setOutput(e,t,n,r){if(n.length===0)return;let i=this.values,a=n,o=r.slice();o=o.slice(e+1);let s=O(o),c=t.length,l=this.defaultValue;if(l.length!==s&&l.length!==1){let e=this.defaultValueShape;B(()=>{let t=W(l,e);l=Lu(t,o).dataSync()})}let u=0,d=0,f=0;for(let e=0;e<=c;++e){let r=e<c?t[e]:-1;if(r===f){++f;continue}if(d<f){let e=i.subarray(u*s),t=a.subarray(d*s),n=(f-d)*s;PB(t,e,n)}if(e>=c){let e=n.length;r=Math.floor(e/s)}if(r>f)if(this.defaultValue.length===1)a.subarray(f*s,r*s).fill(this.defaultValue[0]),f=r;else for(;r>f;){let e=a.slice(f*s);PB(e,l,s),++f}r<0?(u=e+1,d=f):(u=e,d=f,f=d+1)}}}}));function BB(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return We(0,r);let i=Math.abs(Math.ceil((t-e)/n)),a=We(i,r);t<e&&n===1&&(n=-1),a[0]=e;for(let e=1;e<a.length;e++)a[e]=a[e-1]+n;return a}var VB=o((()=>{Y()})),HB,UB,WB,GB=o((()=>{Y(),XR(),$R(),HB=YR(e=>1/Math.sqrt(e)),UB=QR(br,HB),WB={kernelName:br,backendName:`cpu`,kernelFunc:UB}}));function KB(e,t,n,r,i,a,o,s,c,l){let u=[r/i,i],d=e.values,f=t.values;if(r===0)return mc(n,t.dtype);let p=c instanceof xa?c:mc(u,t.dtype);typeof c==`string`||typeof c==`number`?p.values.fill(c):typeof c==`boolean`&&p.values.fill(+c);for(let e=0;e<a;e++){let a=[],c=0;for(let t=0;t<o;t++){let n=d[e*o+t];a.push(n),c+=n*s[t]}if(c<0||c>=r/i)throw Error(`Invalid indices: ${a} does not index into ${n}`);for(let n=0;n<i;n++)l?p.values[c*i+n]+=f[e*i+n]:p.values[c*i+n]=t.rank===0?f[0]:f[e*i+n]}return p}var qB=o((()=>{Y()})),JB,YB,XB,ZB=o((()=>{Y(),XR(),$R(),JB=YR(e=>1/(1+Math.exp(-e))),YB=ZR(kr,e=>1/(1+Math.exp(-e))),XB={kernelName:kr,backendName:`cpu`,kernelFunc:YB}}));function QB(e,t,n,r,i){let a=aS(r,t,n),o=O(n),s=ze(r);if(a){let n=oS(t,s);return i===`string`?e.slice(n,n+o):e.subarray(n,n+o)}let c=i===`string`?CC(e):e,l=mc(r,i,c),u=mc(n,i);for(let e=0;e<u.size;++e){let n=u.indexToLoc(e),r=n.map((e,n)=>e+t[n]);u.set(l.get(...r),...n)}return i===`string`?wC(u.values):u.values}function $B(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{begin:a,size:o}=r;lR(i,`slice`);let[s,c]=sS(i,a,o);Yx(i,s,c);let l=n.data.get(i.dataId).values,u=QB(l,s,c,i.shape,i.dtype);return n.makeTensorInfo(c,i.dtype,u)}var eV,tV=o((()=>{Y(),uR(),eV={kernelName:Er,backendName:`cpu`,kernelFunc:$B}}));function nV(e,t,n,r,i,a,o){let s=t[0],c=a[0],l=Array(c),u=Array(s),d=t[1];if(c===0){if(s!==0)throw Error(sC(s));let e=De(n,0),t=De(i,0);return[e,[0,d],t,l,u]}let f=!0,p=0,m=Array(c).fill(0);for(let t=0;t<s;++t){let n=e[t*d];if(n<0)throw Error(cC(t,n));if(n>=c)throw Error(lC(t,n,c));++m[n],f&&=n>=p,p=n}let h=!0;for(let e=0;e<c;++e){let t=m[e]===0;l[e]=t,h&&=!t,m[e]=Math.max(m[e],1),e>0&&(m[e]+=m[e-1])}if(h&&f){let t=e,n=r;for(let e=0;e<s;++e)u[e]=e;return[t,[s,d],n,l,u]}else{let t=m[c-1],a=De(n,t*d),f=De(i,t),p=Array(c).fill(0);for(let t=0;t<s;++t){let n=e[t*d],i=p[n],o=(n===0?0:m[n-1])+i;p[n]++;for(let n=0;n<d;++n)a[o*d+n]=e[t*d+n];f[o]=r[t],u[t]=o}for(let e=0;e<c;++e)if(p[e]===0){let t=e===0?0:m[e-1];a[t*d+0]=e;for(let e=1;e<d;++e)a[t*d+e]=0;f[t]=o}return[a,[t,d],f,l,u]}}var rV=o((()=>{Y()}));function iV(e,t,n,r,i){let a=O(r),o=t[0],s=i.length,c=[],l=1,u=-1;for(let e=0;e<s;++e){let t=i[e];if(t===-1){if(u!==-1)throw Error(uC(u,e));u=e,c.push(1)}else{if(t<0)throw Error(dC(e,t));l*=t,c.push(t)}}if(u!==-1){if(l<=0)throw Error(fC());let e=Math.trunc(a/l);if(l*e!==a)throw Error(pC(r,c));c[u]=e}if(O(c)!==a)throw Error(mC(r,c));let d=r.length,f=[];if(d>0){f[d-1]=1;for(let e=d-2;e>=0;--e)f[e]=f[e+1]*r[e+1]}let p=[];if(s>0){p[s-1]=1;for(let e=s-2;e>=0;--e)p[e]=p[e+1]*c[e+1]}let m=De(n,o*s);for(let t=0;t<o;++t){let n=0;for(let r=0;r<d;++r)n+=e[t*d+r]*f[r];for(let e=0;e<s;++e)m[t*s+e]=Math.trunc(n/p[e]),n%=p[e]}return[m,[o,s],c]}var aV=o((()=>{Y()}));function oV(e,t,n,r,i,a=!1,o=0){let s=r.length,c=[t[0],e.length/t[0]],l=c[1],u=s>0?i[s-1]+1:0;if(u<0)throw Error(hC());let d=t.slice();d[0]=u;let f=d.reduce((e,t)=>e*t,1),p=De(n,f);if(s===0)return u>0&&p.fill(o),[p,d];if(u<=0)throw Error(hC());let m=0,h=1,g=0,_=i[m];for(;;){let t=0;if(h<s){if(t=i[h],_===t){++h;continue}if(_>=t)throw Error(gC())}if(_<0||_>=u)throw Error(_C(_,u));_>g&&p.fill(o,g*l,_*l);for(let t=m;t<h;++t){let n=r[t];if(n<0||n>=c[0])throw Error(vC(t,r[t],c[0]));for(let t=0;t<l;t++)p[_*l+t]+=e[n*l+t]}if(a)for(let e=0;e<l;e++)p[_*l+e]/=h-m;if(m=h,++h,g=_+1,_=t,h>s)break}return g<u&&p.fill(o,g*l,u*l),[p,d]}var sV=o((()=>{Y()})),cV,lV,uV,dV=o((()=>{Y(),XR(),$R(),cV=YR(e=>Math.sqrt(e)),lV=ZR(jr,e=>Math.sqrt(e)),uV={kernelName:jr,backendName:`cpu`,kernelFunc:lV}})),fV,pV,mV,hV=o((()=>{Y(),vR(),IR(),fV=_R(((e,t)=>{let n=e-t;return n*n})),pV=PR(Br,fV),mV={kernelName:Br,backendName:`cpu`,kernelFunc:pV}})),gV,_V,vV,yV=o((()=>{Y(),XR(),$R(),gV=YR((e,t)=>{let{pattern:n,replaceGlobal:r,rewrite:i}=t;return e.replace(new RegExp(n,r?`g`:``),i)}),_V=QR(Hr,gV),vV={kernelName:Hr,backendName:`cpu`,kernelFunc:_V}}));function bV(e,t,n,r){let i=mc(e,t.dtype);for(let e=0;e<i.size;e++){let a=i.indexToLoc(e),o=Array(a.length);for(let e=0;e<o.length;e++)o[e]=a[e]*n[e]+r[e];i.set(t.get(...o),...a)}return i}var xV=o((()=>{Y()}));function SV(e,t,n,r,i,a,o,s){return new CV(n,r,i,a,o,s).compute(e,t)}var CV,wV=o((()=>{Y(),CV=class{constructor(e,t,n,r,i,a){this.separator=Qi(e),this.nGramWidths=t,this.leftPad=Qi(n),this.rightPad=Qi(r),this.padWidth=i,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,i,a){for(let o=0;o<i;++o){let s=this.getPadWidth(a),c=Math.max(0,s-o),l=Math.max(0,s-(i-(o+1))),u=a-(c+l),d=t+(c>0?0:o-s),f=0;f+=c*this.leftPad.length;for(let t=0;t<u;++t)f+=e[d+t].length;f+=l*this.rightPad.length;let p=c+l+u-1;f+=p*this.separator.length,n[r+o]=new Uint8Array(f);let m=n[r+o],h=0,g=e=>e.forEach(e=>m[h++]=e);for(let e=0;e<c;++e)g(this.leftPad),g(this.separator);for(let t=0;t<u-1;++t)g(e[d+t]),g(this.separator);if(u>0){g(e[d+u-1]);for(let e=0;e<l;++e)g(this.separator),g(this.rightPad)}else{for(let e=0;e<l-1;++e)g(this.rightPad),g(this.separator);g(this.rightPad)}}}compute(e,t){let n=e.length,r=t.length;if(r>0){let e=t[0];if(e!==0)throw Error(`First split value must be 0, got ${e}`);for(let i=1;i<r;++i){let r=t[i]>=e;if(r&&=t[i]<=n,!r)throw Error(`Invalid split value ${t[i]}, must be in [${e}, ${n}]`);e=t[i]}if(e!==n)throw Error(`Last split value must be data size. Expected ${n}, got ${e}`)}let i=r-1,a=De(`int32`,r);if(n===0||r===0){let e=Array(n);for(let e=0;e<=i;++e)a[e]=0;return[e,a]}a[0]=0;for(let e=1;e<=i;++e){let n=t[e]-t[e-1],r=0;this.nGramWidths.forEach(e=>{r+=this.getNumNGrams(n,e)}),this.preserveShort&&n>0&&r===0&&(r=1),a[e]=a[e-1]+r}let o=Array(a[i]);for(let n=0;n<i;++n){let r=t[n],i=a[n];if(this.nGramWidths.forEach(a=>{let s=t[n+1]-t[n],c=this.getNumNGrams(s,a);this.createNGrams(e,r,o,i,c,a),i+=c}),this.preserveShort&&i===a[n]){let a=t[n+1]-t[n];if(a===0)continue;let s=a+2*this.padWidth;this.createNGrams(e,r,o,i,1,s)}}return[o,a]}}}));function Pfe(e,t,n,r){if(!e.length)return;if(t.length===0){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(t.length===1){let i=t[0],a=e.indexOf(i);for(;a!==-1;){let t=e.subarray(0,a);(!n||t.length!==0)&&r.push(t),e=e.subarray(a+1),a=e.indexOf(i)}(!n||e.length!==0)&&r.push(e);return}let i=0;for(let a=0;a<e.length+1;a++)if(a===e.length||t.indexOf(e[a])!==-1){let t=e.subarray(i,a);(!n||t.length!==0)&&r.push(t),i=a+1}}function TV(e,t,n){let r=e.length,i=[],a=0,o=0,s=Array(r);for(let c=0;c<r;++c){let r=i.length;Pfe(e[c],t,n,i);let l=i.length-r;s[c]=l,a+=l,o=Math.max(o,l)}let c=De(`int32`,a*2),l=Array(a),u=[r,o],d=0;for(let e=0;e<r;++e)for(let t=0;t<s[e];++t)c[d*2]=e,c[d*2+1]=t,l[d]=i[d],++d;return[c,l,u]}var EV=o((()=>{Y()}));function DV(e,t){let n=De(`int32`,e.length);for(let r=0;r<e.length;++r)n[r]=zi(e[r]).modulo(t).getLowBitsUnsigned();return n}var OV=o((()=>{Y()})),kV,AV,jV,MV,NV=o((()=>{Y(),vR(),IR(),kV=_R(((e,t)=>e-t)),AV=FR(((e,t,n,r)=>({real:e-n,imag:t-r}))),jV=PR(`Sub`,kV,AV),MV={kernelName:`Sub`,backendName:`cpu`,kernelFunc:jV}}));function PV(e,t){let n=Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];let r=mc(n,e.dtype);for(let t=0;t<r.values.length;++t){let n=r.indexToLoc(t),i=Array(e.rank);for(let t=0;t<i.length;t++)i[t]=n[t]%e.shape[t];let a=e.locToIndex(i);r.values[t]=e.values[a]}return r}var FV=o((()=>{Y()}));function IV(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){let i=r-n+1,a=t-n+1,o=Math.log(i),s=.5*Math.exp(2*o/3),c=.5*Math.sqrt(o*s*(i-s)/i)*Math.sign(a-i/2),l=Math.max(n,Math.floor(t-a*s/i+c)),u=Math.min(r,Math.floor(t+(i-a)*s/i+c));IV(e,t,l,u)}let i=e[t],a=n,o=r;for(ce(e,n,t),RV(e[r],i)>0&&ce(e,n,r);a<o;){for(ce(e,a,o),a++,o--;RV(e[a],i)<0;)a+=1;for(;RV(e[o],i)>0;)--o}RV(e[n],i)===0?ce(e,n,o):(o+=1,ce(e,o,r)),o<=t&&(n=o+1),t<=o&&(r=o-1)}}function LV(e,t,n,r,i){let a=t[t.length-1],[o,s]=[e.length/a,a],c=Ee(n,o*r),l=Ee(`int32`,o*r);for(let t=0;t<o;t++){let n=t*s,a=e.subarray(n,n+s),o=Array(a.length);a.forEach((e,t)=>o[t]={value:e,index:t}),r<o.length&&(IV(o,r),o=o.slice(0,r)),i&&o.sort(RV);let u=t*r,d=c.subarray(u,u+r),f=l.subarray(u,u+r);for(let e=0;e<r;e++)d[e]=o[e].value,f[e]=o[e].index}let u=t.slice();return u[u.length-1]=r,[mc(u,n,c),mc(u,`int32`,l)]}var RV,zV=o((()=>{Y(),RV=(e,t)=>{let n=t.value-e.value;return n===0?e.index-t.index:n}}));function BV(e,t,n,r){let i=we(t,n)[0],a=[1,n[0],1];for(let e=0;e<i;e++)a[0]*=n[e];a[1]=n[i];for(let e=i+1;e<n.length;e++)a[2]*=n[e];let o=new Map,s=new Int32Array(n[i]),c=new xa(a,r,e),l=[],u=a[0]===1&&a[2]===1;for(let t=0;t<n[i];t++){let n;if(u)n=e[t].toString();else{let e=[];for(let n=0;n<a[0];n++)for(let r=0;r<a[2];r++)e.push(c.get(n,t,r));n=e.join(`,`)}let r=o.get(n);if(r!=null)s[t]=r;else{let e=o.size;o.set(n,e),s[t]=e,l.push(t)}}let d=a.slice();d[1]=o.size;let f=new xa(d,r);l.forEach((e,t)=>{for(let n=0;n<a[0];n++)for(let r=0;r<a[2];r++)f.set(c.get(n,e,r),n,t,r)});let p=n.slice();return p[i]=d[1],{outputValues:f.values,outputShape:p,indices:s}}var VV=o((()=>{Y()})),HV=c({addImpl:()=>LR,bincountImpl:()=>HR,bincountReduceImpl:()=>UR,bitwiseAndImpl:()=>GR,castImpl:()=>AR,ceilImpl:()=>ez,concatImpl:()=>iz,equalImpl:()=>oz,expImpl:()=>uz,expm1Impl:()=>mz,floorDivImpl:()=>Sz,floorImpl:()=>vz,gatherNdImpl:()=>Ez,gatherV2Impl:()=>Oz,greaterEqualImpl:()=>Pz,greaterImpl:()=>Az,lessEqualImpl:()=>Hz,lessImpl:()=>Rz,linSpaceImpl:()=>Kz,logImpl:()=>Jz,maxImpl:()=>Qz,maximumImpl:()=>eB,minimumImpl:()=>iB,multiplyImpl:()=>cB,negImpl:()=>pB,notEqualImpl:()=>gB,prodImpl:()=>TB,raggedGatherImpl:()=>kB,raggedRangeImpl:()=>jB,raggedTensorToTensorImpl:()=>IB,rangeImpl:()=>BB,rsqrtImpl:()=>HB,scatterImpl:()=>KB,sigmoidImpl:()=>JB,simpleAbsImpl:()=>pR,sliceImpl:()=>QB,sparseFillEmptyRowsImpl:()=>nV,sparseReshapeImpl:()=>iV,sparseSegmentReductionImpl:()=>oV,sqrtImpl:()=>cV,squaredDifferenceImpl:()=>fV,staticRegexReplaceImpl:()=>gV,stridedSliceImpl:()=>bV,stringNGramsImpl:()=>SV,stringSplitImpl:()=>TV,stringToHashBucketFastImpl:()=>DV,subImpl:()=>kV,tileImpl:()=>PV,topKImpl:()=>LV,transposeImpl:()=>bB,uniqueImpl:()=>BV}),UV=o((()=>{gR(),VR(),WR(),JR(),NR(),rz(),az(),lz(),pz(),_z(),xz(),Tz(),Dz(),kz(),Nz(),Lz(),Vz(),Gz(),qz(),Zz(),$z(),rB(),sB(),fB(),hB(),yB(),DB(),AB(),NB(),zB(),VB(),GB(),qB(),ZB(),tV(),rV(),aV(),sV(),dV(),hV(),yV(),xV(),wV(),EV(),OV(),NV(),FV(),zV(),xB(),VV()})),WV,Ffe=o((()=>{WV=`4.22.0`})),Ife=o((()=>{Y(),Tfe(),UV(),Ffe(),Vo(`cpu`,()=>new fR,1)})),GV,KV,qV=o((()=>{Y(),$R(),GV=ZR(`Elu`,e=>e>=0?e:Math.exp(e)-1),KV={kernelName:`Elu`,backendName:`cpu`,kernelFunc:GV}}));function JV(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{alpha:a}=r;lR([i],`leakyRelu`);let o=O(i.shape),s=n.data.get(i.dataId).values,c=Ee(`float32`,o);for(let e=0;e<s.length;e++)c[e]=s[e]<0?a*s[e]:s[e];return n.makeTensorInfo(i.shape,`float32`,c)}var YV,XV=o((()=>{Y(),uR(),YV={kernelName:wn,backendName:`cpu`,kernelFunc:JV}}));function ZV(e){let{inputs:t,backend:n}=e,{x:r,alpha:i}=t;lR([r,i],`prelu`);let a=n.data.get(r.dataId).values,o=n.data.get(i.dataId).values,[s,c]=QV(r.shape,i.shape,a,o,`float32`);return n.makeTensorInfo(c,`float32`,s)}var QV,$V,eH=o((()=>{Y(),uR(),vR(),QV=_R((e,t)=>e<0?t*e:e),$V={kernelName:rr,backendName:`cpu`,kernelFunc:ZV}})),tH,nH,rH=o((()=>{Y(),$R(),tH=ZR(dr,e=>Math.max(0,e)),nH={kernelName:dr,backendName:`cpu`,kernelFunc:tH}})),iH,aH,oH=o((()=>{Y(),$R(),iH=ZR(_r,e=>Math.min(Math.max(0,e),6)),aH={kernelName:_r,backendName:`cpu`,kernelFunc:iH}}));function sH(e,t,n,r,i){if(n===`linear`)return wR({inputs:{x:t},backend:e});if(n===`relu`)return tH({inputs:{x:t},backend:e});if(n===`elu`)return GV({inputs:{x:t},backend:e});if(n===`relu6`)return iH({inputs:{x:t},backend:e});if(n===`prelu`)return ZV({inputs:{x:t,alpha:r},backend:e});if(n===`leakyrelu`)return JV({inputs:{x:t},backend:e,attrs:{alpha:i}});if(n===`sigmoid`)return YB({inputs:{x:t},backend:e});throw Error(`Activation ${n} has not been implemented for the CPU backend.`)}var cH=o((()=>{qV(),ER(),XV(),eH(),rH(),oH(),ZB()}));function lH(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{shape:a}=r,o=O(i.shape),s=Ce(a,o),c=O(s);D(o===c,()=>`The new shape (${s}) has ${c} elements and the old shape (${i.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),n.incRef(i.dataId);let l=n.data.get(i.dataId);if(l.complexTensorInfos!=null){let e=l.complexTensorInfos.real,t=l.complexTensorInfos.imag;e.shape=s,t.shape=s}return{dataId:i.dataId,shape:s,dtype:i.dtype}}var uH,dH=o((()=>{Y(),uH={kernelName:fr,backendName:`cpu`,kernelFunc:lH}}));function fH(e){let{inputs:t,backend:n,attrs:r}=e,{a:i,b:a}=t,{transposeA:o,transposeB:s}=r;lR([i,a],`matMul`);let c=i.shape.length,l=a.shape.length,u=o?i.shape[c-2]:i.shape[c-1],d=s?a.shape[l-1]:a.shape[l-2],f=o?i.shape[c-1]:i.shape[c-2],p=s?a.shape[l-2]:a.shape[l-1],m=i.shape.slice(0,-2),h=a.shape.slice(0,-2),g=O(m),_=O(h),v=nf(i.shape.slice(0,-2),a.shape.slice(0,-2)).concat([f,p]);D(u===d,()=>`Error in matMul: inner shapes (${u}) and (${d}) of Tensors with shapes ${i.shape} and ${a.shape} and transposeA=${o} and transposeB=${s} must match.`);let y=o?[g,u,f]:[g,f,u],b=s?[_,p,d]:[_,d,p],x=lH({inputs:{x:i},backend:n,attrs:{shape:y}}),S=lH({inputs:{x:a},backend:n,attrs:{shape:b}}),C=o?x.shape[1]:x.shape[2],w=o?x.shape[2]:x.shape[1],T=s?S.shape[1]:S.shape[2],ee=Math.max(g,_),E=n.data.get(x.dataId).values,te=n.data.get(S.dataId).values,ne=ze(x.shape),re=ze(S.shape),[ie,ae,oe]=o?[ne[0],1,ne[1]]:[ne[0],ne[1],1],[se,ce,le]=s?[1,re[1],re[0]]:[re[1],1,re[0]],ue=w*T,de=mc([ee,w,T],x.dtype),fe=de.values,pe=n.blockSize;for(let e=0;e<ee;e++){let t=e%g,n=e%_;for(let r=0;r<w;r+=pe){let i=Math.min(r+pe,w);for(let a=0;a<T;a+=pe){let o=Math.min(a+pe,T);for(let s=0;s<C;s+=pe){let c=Math.min(s+pe,C);for(let l=r;l<i;l++)for(let r=a;r<o;r++){let i=0;for(let e=s;e<c;e++){let a=E[t*ie+l*ae+e*oe],o=te[e*se+r*ce+n*le];i+=a*o}fe[e*ue+(l*T+r)]+=i}}}}}return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(S),n.makeTensorInfo(v,de.dtype,de.values)}var pH,mH=o((()=>{Y(),uR(),dH(),pH={kernelName:wt,backendName:`cpu`,kernelFunc:fH}}));function Lfe(e){let{inputs:t,backend:n,attrs:r}=e,{a:i,b:a,bias:o,preluActivationWeights:s}=t,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:d}=r,f,p,m,h=[];f=fH({inputs:{a:i,b:a},attrs:{transposeA:c,transposeB:l},backend:n}),o&&(p=zR({inputs:{a:f,b:o},backend:n}),h.push(f),f=p),u&&(m=sH(n,f,u,s,d),h.push(f),f=m);for(let e of h)n.disposeIntermediateTensorInfo(e);return f}var hH,Rfe=o((()=>{Y(),cH(),VR(),mH(),hH={kernelName:oi,backendName:`cpu`,kernelFunc:Lfe}})),gH,_H,zfe=o((()=>{Y(),$R(),gH=ZR(ut,e=>Math.acos(e)),_H={kernelName:ut,backendName:`cpu`,kernelFunc:gH}})),vH,yH,Bfe=o((()=>{Y(),$R(),vH=ZR(dt,e=>Math.acosh(e)),yH={kernelName:dt,backendName:`cpu`,kernelFunc:vH}}));function Vfe(e){let{inputs:t,backend:n}=e,r=t;lR(t,`addN`);let i=r.map(e=>n.data.get(e.dataId).values),a=mc(r[0].shape,r[0].dtype),o=a.values;for(let e=0;e<r.length;e++){let t=i[e];for(let e=0;e<o.length;e++)o[e]+=t[e]}return n.makeTensorInfo(a.shape,a.dtype,a.values)}var bH,Hfe=o((()=>{Y(),uR(),bH={kernelName:ft,backendName:`cpu`,kernelFunc:Vfe}}));function Ufe(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a,keepDims:o}=r;lR(i,`all`);let s=we(a,i.shape),c=s,l=Rf(c,i.shape.length),u=i;l!=null&&(u=SB({inputs:{x:i},backend:n,attrs:{perm:l}}),c=Bf(c.length,i.shape.length)),Lf(`all`,c,u.shape.length);let[d,f]=Ff(u.shape,c),p=O(f),m=We(O(d),u.dtype),h=n.data.get(u.dataId).values;for(let e=0;e<m.length;++e){let t=e*p,n=h[t];for(let e=0;e<p;++e){let r=h[t+e];n&&=r}m[e]=n}l!=null&&n.disposeIntermediateTensorInfo(u);let g=n.makeTensorInfo(d,u.dtype,m);if(o){let e=If(d,s),t=lH({inputs:{x:g},backend:n,attrs:{shape:e}});return n.disposeIntermediateTensorInfo(g),t}return g}var xH,SH=o((()=>{Y(),uR(),dH(),wB(),xH={kernelName:`All`,backendName:`cpu`,kernelFunc:Ufe}}));function CH(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a,keepDims:o}=r;lR(i,`any`);let s=we(a,i.shape),c=s,l=Rf(c,i.shape.length),u=i;l!=null&&(u=SB({inputs:{x:i},backend:n,attrs:{perm:l}}),c=Bf(c.length,i.shape.length)),Lf(`any`,c,u.shape.length);let[d,f]=Ff(u.shape,c),p=O(f),m=We(O(d),u.dtype),h=n.data.get(u.dataId).values;for(let e=0;e<m.length;++e){let t=e*p,n=h[t];for(let e=0;e<p;++e){let r=h[t+e];n||=r}m[e]=n}l!=null&&n.disposeIntermediateTensorInfo(u);let g=n.makeTensorInfo(d,u.dtype,m);if(o){let e=If(d,s),t=lH({inputs:{x:g},backend:n,attrs:{shape:e}});return n.disposeIntermediateTensorInfo(g),t}return g}var wH,TH=o((()=>{Y(),uR(),dH(),wB(),wH={kernelName:`Any`,backendName:`cpu`,kernelFunc:CH}}));function EH(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a}=r;lR(i,`argMax`);let o=we(a,i.shape),s=Rf(o,i.shape.length),c=i,l=[];s!=null&&(c=SB({inputs:{x:i},backend:n,attrs:{perm:s}}),l.push(c),o=Bf(o.length,c.shape.length)),o=[o[0]],Lf(`argMax`,o,c.shape.length);let[u,d]=Ff(c.shape,o),f=O(u),p=We(f,`int32`),m=O(d),h=n.data.get(c.dataId).values;for(let e=0;e<p.length;++e){let t=e*m,n=h[t],r=0;for(let e=0;e<m;++e){let i=h[t+e];i>n&&(n=i,r=e)}p[e]=r}return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(u,`int32`,p)}var DH,OH=o((()=>{Y(),uR(),wB(),DH={kernelName:pt,backendName:`cpu`,kernelFunc:EH}}));function kH(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a}=r;lR(i,`argMin`);let o=we(a,i.shape),s=Rf(o,i.shape.length),c=i,l=[];s!=null&&(c=SB({inputs:{x:i},backend:n,attrs:{perm:s}}),l.push(c),o=Bf(o.length,c.shape.length)),o=[o[0]],Lf(`argMin`,o,c.shape.length);let[u,d]=Ff(c.shape,o),f=O(u),p=We(f,`int32`),m=O(d),h=n.data.get(c.dataId).values;for(let e=0;e<p.length;++e){let t=e*m,n=h[t],r=0;for(let e=0;e<m;++e){let i=h[t+e];i<n&&(n=i,r=e)}p[e]=r}return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(u,`int32`,p)}var AH,jH=o((()=>{Y(),uR(),wB(),AH={kernelName:mt,backendName:`cpu`,kernelFunc:kH}})),MH,NH,PH=o((()=>{Y(),$R(),MH=ZR(ht,e=>Math.asin(e)),NH={kernelName:ht,backendName:`cpu`,kernelFunc:MH}})),FH,IH,LH=o((()=>{Y(),$R(),FH=ZR(gt,e=>Math.asinh(e)),IH={kernelName:gt,backendName:`cpu`,kernelFunc:FH}})),RH,zH,BH=o((()=>{Y(),$R(),RH=ZR(_t,e=>Math.atan(e)),zH={kernelName:_t,backendName:`cpu`,kernelFunc:RH}})),VH,HH,UH,WH=o((()=>{Y(),vR(),IR(),VH=_R((e,t)=>Math.atan2(e,t)),HH=PR(yt,VH),UH={kernelName:yt,backendName:`cpu`,kernelFunc:HH}})),GH,KH,qH=o((()=>{Y(),$R(),GH=ZR(vt,e=>Math.atanh(e)),KH={kernelName:vt,backendName:`cpu`,kernelFunc:GH}}));function JH(e,t,n,r,i,a){let o=i.strideHeight,s=i.strideWidth,c=i.dilationHeight,l=i.dilationWidth,u=i.effectiveFilterHeight,d=i.effectiveFilterWidth,f=i.padInfo.top,p=i.padInfo.left,m=a===`max`?-1/0:1/0,h=mc(i.outShape,n),g=h.values,_=i.outShape[1]*i.outShape[2]*i.outShape[3],v=i.outShape[2]*i.outShape[3],y=i.outShape[3];for(let t=0;t<i.batchSize;++t){let n=t*_,h=t*r[0];for(let t=0;t<i.inChannels;++t)for(let _=0;_<i.outHeight;++_){let b=_*o-f,x=Math.max(0,b),S=Math.min(i.inHeight,u+b),C=n+_*v;for(let n=0;n<i.outWidth;++n){let o=n*s-p,u=Math.max(0,o),f=Math.min(i.inWidth,d+o),_=m,v=0,b=0;for(let n=x;n<S;n+=c){let i=h+n*r[1];for(let n=u;n<f;n+=l){let o=i+n*r[2],s=e[o+t];a===`max`&&s>_?_=s:a===`avg`&&(v+=s,b++)}if(isNaN(_))break}let w=C+n*y+t;g[w]=a===`avg`?v/b:_}}}return h}function YH(e,t,n,r,i=!1,a=!1){let o=mc(r.outShape,`int32`),s=r.strideHeight,c=r.strideWidth,l=r.dilationHeight,u=r.dilationWidth,d=r.effectiveFilterHeight,f=r.effectiveFilterWidth,p=r.padInfo.top,m=r.padInfo.left,h=mc(t,n,e);for(let e=0;e<r.batchSize;++e)for(let t=0;t<r.inChannels;++t)for(let n=0;n<r.outHeight;++n){let g=n*s-p,_=g;for(;_<0;)_+=l;let v=Math.min(r.inHeight,d+g);for(let s=0;s<r.outWidth;++s){let d=s*c-m,p=d;for(;p<0;)p+=u;let y=Math.min(r.inWidth,f+d),b=-1/0,x=-1;for(let n=_;n<v;n+=l){let o=n-g;for(let s=p;s<y;s+=u){let c=s-d,l=h.get(e,n,s,t);l>b&&(b=l,x=i?a?((e*r.inHeight+n)*r.inWidth+s)*r.inChannels+t:(n*r.inWidth+s)*r.inChannels+t:o*f+c)}}o.set(x,e,n,s,t)}}return o}function XH(e,t,n,r,i,a){let o=i.strideDepth,s=i.strideHeight,c=i.strideWidth,l=i.dilationDepth,u=i.dilationHeight,d=i.dilationWidth,f=i.effectiveFilterDepth,p=i.effectiveFilterHeight,m=i.effectiveFilterWidth,h=i.padInfo.front,g=i.padInfo.top,_=i.padInfo.left,v=a===`max`?-1/0:1/0,y=mc(i.outShape,n),b=y.values,x=i.outShape[1]*i.outShape[2]*i.outShape[3]*i.outShape[4],S=i.outShape[2]*i.outShape[3]*i.outShape[4],C=i.outShape[3]*i.outShape[4],w=i.outShape[4];for(let t=0;t<i.batchSize;++t){let n=t*x,y=t*r[0];for(let t=0;t<i.inChannels;++t)for(let x=0;x<i.outDepth;++x){let T=x*o-h,ee=T;for(;ee<0;)ee+=l;let E=Math.min(i.inDepth,f+T),te=n+x*S;for(let n=0;n<i.outHeight;++n){let o=n*s-g,f=o;for(;f<0;)f+=u;let h=Math.min(i.inHeight,p+o),x=te+n*C;for(let n=0;n<i.outWidth;++n){let o=n*c-_,s=o;for(;s<0;)s+=d;let p=Math.min(i.inWidth,m+o),g=x+n*w,S=v,C=0,T=0;for(let n=ee;n<E;n+=l){let i=y+n*r[1];for(let n=f;n<h;n+=u){let o=i+n*r[2];for(let n=s;n<p;n+=d){let i=o+n*r[3],s=e[i+t];if(a===`max`&&s>S?S=s:a===`avg`&&(C+=s,T++),isNaN(S))break}if(isNaN(S))break}if(isNaN(S))break}let te=g+t;b[te]=a===`avg`?C/Math.max(T,1):S}}}}return y}function ZH(e,t){let n=mc(t.outShape,`int32`),r=t.strideDepth,i=t.strideHeight,a=t.strideWidth,o=t.dilationDepth,s=t.dilationHeight,c=t.dilationWidth,l=t.effectiveFilterDepth,u=t.effectiveFilterHeight,d=t.effectiveFilterWidth,f=t.padInfo.front,p=t.padInfo.top,m=t.padInfo.left;for(let h=0;h<t.batchSize;++h)for(let g=0;g<t.inChannels;++g)for(let _=0;_<t.outDepth;++_){let v=_*r-f,y=v;for(;y<0;)y+=o;let b=Math.min(t.inDepth,l+v);for(let r=0;r<t.outHeight;++r){let l=r*i-p,f=l;for(;f<0;)f+=s;let x=Math.min(t.inHeight,u+l);for(let i=0;i<t.outWidth;++i){let p=i*a-m,S=p;for(;S<0;)S+=c;let C=Math.min(t.inWidth,d+p),w=-1/0,T=-1;for(let t=y;t<b;t+=o){let n=t-v;for(let r=f;r<x;r+=s){let i=r-l;for(let a=S;a<C;a+=c){let o=a-p,s=e.get(h,t,r,a,g);s>=w&&(w=s,T=n*u*d+i*u+o)}}}n.set(T,h,_,r,i,g)}}}return n}var QH=o((()=>{Y()}));function $H(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t;lR(i,`avgPool`);let{filterSize:a,strides:o,pad:s,dimRoundingMode:c}=r;D(Pl(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);let l=bl(i.shape,a,o,1,s,c),u;if(l.filterWidth===1&&l.filterHeight===1&&ge(l.inShape,l.outShape))u=wR({inputs:{x:i},backend:n});else{let e=n.data.get(i.dataId).values,t=ze(i.shape),r=JH(e,i.shape,i.dtype,t,l,`avg`);u=n.makeTensorInfo(l.outShape,i.dtype,r.values)}return u}var eU,tU=o((()=>{Y(),uR(),QH(),ER(),eU={kernelName:bt,backendName:`cpu`,kernelFunc:$H}}));function nU(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{filterSize:a,strides:o,pad:s,dimRoundingMode:c,dataFormat:l}=r;lR(i,`avgPool3d`);let u=xl(i.shape,a,o,1,s,c,l),d=n.data.get(i.dataId).values,f=XH(d,i.shape,i.dtype,ze(i.shape),u,`avg`);return n.makeTensorInfo(f.shape,`float32`,f.values)}var rU,iU=o((()=>{Y(),uR(),QH(),rU={kernelName:St,backendName:`cpu`,kernelFunc:nU}}));function aU(e){let{inputs:t,backend:n,attrs:r}=e,{dy:i,input:a}=t,{filterSize:o,strides:s,pad:c,dimRoundingMode:l}=r;lR([i,a],`avgPool3DGrad`);let u=xl(a.shape,o,s,1,c,l),d=u.strideDepth,f=u.strideHeight,p=u.strideWidth,m=u.filterDepth,h=u.filterHeight,g=u.filterWidth,_=u.dilationDepth,v=u.dilationHeight,y=u.dilationWidth,b=u.effectiveFilterDepth,x=u.effectiveFilterHeight,S=u.effectiveFilterWidth,C=b-1-u.padInfo.front,w=S-1-u.padInfo.left,T=x-1-u.padInfo.top,ee=mc(a.shape,`float32`),E=1/(m*h*g),te=n.bufferSync(i);for(let e=0;e<u.batchSize;++e)for(let t=0;t<u.inChannels;++t)for(let n=0;n<u.inDepth;++n)for(let r=0;r<u.inHeight;++r)for(let i=0;i<u.inWidth;++i){let a=n-C,o=r-T,s=i-w,c=0;for(let n=0;n<b;n+=_){let r=(a+n)/d;if(!(r<0||r>=u.outDepth||Math.floor(r)!==r))for(let n=0;n<x;n+=v){let i=(o+n)/f;if(!(i<0||i>=u.outHeight||Math.floor(i)!==i))for(let n=0;n<S;n+=y){let a=(s+n)/p;if(a<0||a>=u.outWidth||Math.floor(a)!==a)continue;let o=te.get(e,r,i,a,t);c+=o}}}ee.set(c*E,e,n,r,i,t)}return n.makeTensorInfo(ee.shape,ee.dtype,ee.values)}var oU,sU=o((()=>{Y(),uR(),oU={kernelName:Ct,backendName:`cpu`,kernelFunc:aU}}));function cU(e){let{inputs:t,backend:n,attrs:r}=e,{dy:i,input:a}=t,o=a;lR([i,a],`avgPoolGrad`);let{filterSize:s,strides:c,pad:l}=r,u=bl(o.shape,s,c,1,l),d=u.strideHeight,f=u.strideWidth,p=u.filterHeight,m=u.filterWidth,h=u.dilationHeight,g=u.dilationWidth,_=u.effectiveFilterHeight,v=u.effectiveFilterWidth,y=v-1-u.padInfo.left,b=_-1-u.padInfo.top,x=mc(o.shape,`float32`),S=1/(p*m),C=n.data.get(i.dataId).values,w=mc(i.shape,`float32`,C);for(let e=0;e<u.batchSize;++e)for(let t=0;t<u.inChannels;++t)for(let n=0;n<u.inHeight;++n)for(let r=0;r<u.inWidth;++r){let i=n-b,a=r-y,o=0;for(let n=0;n<_;n+=h){let r=(i+n)/d;if(!(r<0||r>=u.outHeight||Math.floor(r)!==r))for(let n=0;n<v;n+=g){let i=(a+n)/f;if(i<0||i>=u.outWidth||Math.floor(i)!==i)continue;let s=w.get(e,r,i,t);o+=s}}x.set(o*S,e,n,r,t)}return n.makeTensorInfo(x.shape,x.dtype,x.values)}var lU,uU=o((()=>{Y(),uR(),lU={kernelName:xt,backendName:`cpu`,kernelFunc:cU}}));function dU(e){let{inputs:t,backend:n,attrs:r}=e,{x:i,scale:a,offset:o,mean:s,variance:c}=t;D(s.shape.length===c.shape.length,()=>`Batch normalization gradient requires mean and variance to have equal ranks.`),D(o==null||s.shape.length===o.shape.length,()=>`Batch normalization gradient requires mean and offset to have equal ranks.`),D(a==null||s.shape.length===a.shape.length,()=>`Batch normalization gradient requires mean and scale to have equal ranks.`),lR([i,s,c,a,o],`batchNorm`);let{varianceEpsilon:l}=r;l??=.001;let u=n.data.get(i.dataId).values,d=n.data.get(s.dataId).values,f=n.data.get(c.dataId).values,p=a?n.data.get(a.dataId).values:new Float32Array([1]),m=o?n.data.get(o.dataId).values:new Float32Array([0]),h=new Float32Array(u.length),g=m.length,_=p.length,v=f.length,y=d.length,b=0,x=0,S=0,C=0;for(let e=0;e<u.length;++e)h[e]=m[b++]+(u[e]-d[x++])*p[S++]/Math.sqrt(f[C++]+l),b>=g&&(b=0),x>=y&&(x=0),S>=_&&(S=0),C>=v&&(C=0);return n.makeTensorInfo(i.shape,i.dtype,h)}var fU,pU=o((()=>{Y(),uR(),fU={kernelName:pn,backendName:`cpu`,kernelFunc:dU}}));function mU(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{blockShape:a,crops:o}=r;lR([i],`batchToSpaceND`);let s=a.reduce((e,t)=>e*t),c=kS(i.shape,a,s),l=AS(c.length,a.length),u=jS(i.shape,a,s),d=MS(o,a.length),f=NS(u,o,a.length),p=lH({inputs:{x:i},backend:n,attrs:{shape:c}}),m=SB({inputs:{x:p},backend:n,attrs:{perm:l}}),h=lH({inputs:{x:m},backend:n,attrs:{shape:u}}),g=$B({inputs:{x:h},backend:n,attrs:{begin:d,size:f}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(h),g}var hU,gU=o((()=>{Y(),uR(),dH(),tV(),wB(),hU={kernelName:Tt,backendName:`cpu`,kernelFunc:mU}}));function _U(e){let{inputs:t,backend:n,attrs:r}=e,{x:i,weights:a}=t,{size:o}=r,s=n.data.get(i.dataId).values,c=n.data.get(a.dataId).values,l=HR(s,c,a.dtype,a.shape,o);return n.makeTensorInfo([o],a.dtype,l)}var vU,yU=o((()=>{Y(),WR(),vU={kernelName:Et,backendName:`cpu`,kernelFunc:_U}}));function bU(e){let{inputs:t,backend:n}=e,{s0:r,s1:i}=t,a=n.data.get(r.dataId).values,o=n.data.get(i.dataId).values,s=nf(Array.from(a),Array.from(o));return n.makeTensorInfo([s.length],`int32`,Int32Array.from(s))}var xU,SU=o((()=>{Y(),xU={kernelName:kt,backendName:`cpu`,kernelFunc:bU}})),CU,wU,TU=o((()=>{Y(),$R(),CU=ZR(Mt,(e,t)=>{let n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),wU={kernelName:Mt,backendName:`cpu`,kernelFunc:CU}})),EU,DU,OU=o((()=>{Y(),EU=e=>{let{x:t}=e.inputs,n=e.backend,r=new Float32Array(O(t.shape)),i=n.data.get(t.dataId),a=i.complexTensorInfos.real,o=i.complexTensorInfos.imag,s=n.data.get(a.dataId).values,c=n.data.get(o.dataId).values;for(let e=0;e<s.length;e++){let t=s[e],n=c[e];r[e]=Math.hypot(t,n)}return n.makeOutput(r,t.shape,`float32`)},DU={kernelName:Pt,backendName:`cpu`,kernelFunc:EU}}));function kU(e){let{inputs:t,backend:n}=e,{input:r}=t,i=n.data.get(r.dataId).complexTensorInfos.imag,a=n.data.get(i.dataId).values;return n.makeTensorInfo(i.shape,i.dtype,a)}var AU,jU=o((()=>{Y(),AU={kernelName:bn,backendName:`cpu`,kernelFunc:kU}}));function MU(e){let{inputs:t,backend:n,attrs:r}=e,{axis:i}=r,a=we(i,t[0].shape)[0],o=t.map(e=>e.shape);yS(o,a);let s=bS(t.map(e=>e.shape),a);if(O(s)===0)return n.makeTensorInfo(s,t[0].dtype,[]);let c=t.filter(e=>O(e.shape)>0);if(c.length===1)return wR({inputs:{x:c[0]},backend:n});if(c[0].dtype===`complex64`){let e=c.map(e=>DR({inputs:{input:e},backend:n})),t=c.map(e=>kU({inputs:{input:e},backend:n})),r=MU({inputs:e,backend:n,attrs:{axis:a}}),i=MU({inputs:t,backend:n,attrs:{axis:a}}),o=yR({inputs:{real:r,imag:i},backend:n});return e.forEach(e=>n.disposeIntermediateTensorInfo(e)),t.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),o}let l=c.map(e=>{let t=[-1,O(e.shape.slice(a))];return lH({inputs:{x:e},backend:n,attrs:{shape:t}})}),u=l.map(e=>({vals:n.data.get(e.dataId).values,shape:e.shape}));s=bS(l.map(e=>e.shape),1);let d=l[0].shape[0]===1,f=iz(u,s,t[0].dtype,d),p=bS(c.map(e=>e.shape),a),m=n.makeTensorInfo(p,t[0].dtype,f);return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),m}var NU,PU=o((()=>{Y(),xR(),az(),ER(),jU(),kR(),dH(),NU={kernelName:Ft,backendName:`cpu`,kernelFunc:MU}}));function FU(e){let{inputs:t,backend:n,attrs:r}=e,{x:i,filter:a}=t,{strides:o,pad:s,dataFormat:c,dilations:l,dimRoundingMode:u}=r;lR([i,a],`conv2d`);let d=Il(c),f=Sl(i.shape,a.shape,o,l,s,u,!1,d),p=f.filterHeight,m=f.filterWidth,h=f.dilationHeight,g=f.dilationWidth,_=f.padInfo.left,v=f.padInfo.top,y=f.dataFormat===`channelsLast`,b=new xa(f.outShape,i.dtype),x=ze(i.shape),S=ze(a.shape),C=x[0],w=y?x[1]:x[2],T=y?x[2]:1,ee=y?1:x[1],E=b.strides[0],te=y?b.strides[1]:b.strides[2],ne=y?b.strides[2]:1,re=y?1:b.strides[1],ie=n.data.get(i.dataId).values,ae=n.data.get(a.dataId).values,oe=b.values;for(let e=0;e<f.batchSize;++e){let t=e*C,n=e*E;for(let e=0;e<f.outHeight;++e){let r=n+e*te,i=e*f.strideHeight-v;for(let e=0;e<p;++e){let n=i+e*h;if(n<0||n>=f.inHeight)continue;let a=e*S[0],o=t+n*w;for(let e=0;e<f.outWidth;++e){let t=r+e*ne,n=e*f.strideWidth-_;for(let e=0;e<m;++e){let r=n+e*g;if(r<0||r>=f.inWidth)continue;let i=a+e*S[1],s=o+r*T,c=i;for(let e=0;e<f.inChannels;++e){let n=ie[s+e*ee];for(let e=0;e<f.outChannels;++e)oe[t+e*re]+=n*ae[c+e];c+=f.outChannels}}}}}}return n.makeTensorInfo(b.shape,b.dtype,oe)}var IU,LU=o((()=>{Y(),uR(),IU={kernelName:It,backendName:`cpu`,kernelFunc:FU}}));function RU(e){let{inputs:t,backend:n,attrs:r}=e,{x:i,dy:a}=t,{strides:o,pad:s,dataFormat:c,dimRoundingMode:l,filterShape:u}=r;lR([i,a],`conv2dBackpropFilter`);let d=Il(c),f=Sl(i.shape,u,o,1,s,l,!1,d),{strideHeight:p,strideWidth:m,filterHeight:h,filterWidth:g}=f,_=f.dataFormat===`channelsLast`,v=new xa(f.filterShape,`float32`),y=f.padInfo.left,b=f.padInfo.top,x=n.data.get(i.dataId).values,S=n.data.get(a.dataId).values,C=new xa(i.shape,i.dtype,x),w=new xa(a.shape,a.dtype,S);for(let e=0;e<h;++e){let t=Math.max(0,Math.ceil((b-e)/p)),n=Math.min(f.outHeight,(f.inHeight+b-e)/p);for(let r=0;r<g;++r){let i=Math.max(0,Math.ceil((y-r)/m)),a=Math.min(f.outWidth,(f.inWidth+y-r)/m);for(let o=0;o<f.inChannels;++o)for(let s=0;s<f.outChannels;++s){let c=0;for(let l=0;l<f.batchSize;++l)for(let u=t;u<n;++u){let t=e+u*p-b;for(let e=i;e<a;++e){let n=r+e*m-y;_?c+=C.get(l,t,n,o)*w.get(l,u,e,s):c+=C.get(l,o,t,n)*w.get(l,s,u,e)}}v.set(c,e,r,o,s)}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}var zU,BU=o((()=>{Y(),uR(),zU={kernelName:Lt,backendName:`cpu`,kernelFunc:RU}}));function VU(e){let{inputs:t,backend:n,attrs:r}=e,{dy:i,filter:a}=t,{inputShape:o,strides:s,pad:c,dataFormat:l,dimRoundingMode:u}=r;lR([i,a],`conv2dBackpropInput`);let d=ze(a.shape),f=ze(i.shape),p=Il(l),m=Sl(o,a.shape,s,1,c,u,!1,p),h=new xa(m.inShape,`float32`),g=h.values,_=n.data.get(i.dataId).values,v=n.data.get(a.dataId).values,[y,b,x]=d,{batchSize:S,filterHeight:C,filterWidth:w,inChannels:T,inHeight:ee,inWidth:E,outChannels:te,outHeight:ne,outWidth:re,strideHeight:ie,strideWidth:ae}=m;p=m.dataFormat;let oe=C-1-m.padInfo.top,se=w-1-m.padInfo.left,ce=p===`channelsLast`,le=h.strides[0],ue=ce?h.strides[1]:h.strides[2],de=ce?h.strides[2]:1,D=ce?1:h.strides[1],fe=f[0],pe=ce?f[1]:f[2],O=ce?f[2]:1,me=ce?1:f[1];for(let e=0;e<S;++e)for(let t=0;t<T;++t)for(let n=0;n<ee;++n){let r=n-oe,i=Math.max(0,Math.ceil(r/ie)),a=Math.min(ne,(C+r)/ie);for(let o=0;o<E;++o){let s=o-se,c=Math.max(0,Math.ceil(s/ae)),l=Math.min(re,(w+s)/ae),u=0;for(let n=i;n<a;++n){let i=n*ie-r;for(let r=c;r<l;++r){let a=r*ae-s,o=fe*e+pe*n+O*r,c=y*(C-1-i)+b*(w-1-a)+x*t;for(let e=0;e<te;++e){let t=_[o+me*e],n=v[c+e];u+=t*n}}}let d=le*e+ue*n+de*o+D*t;g[d]=u}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}var HU,UU=o((()=>{Y(),uR(),HU={kernelName:Rt,backendName:`cpu`,kernelFunc:VU}}));function WU(e){let{inputs:t,backend:n,attrs:r}=e,{x:i,filter:a}=t,{strides:o,pad:s,dilations:c}=r;lR([i,a],`conv3d`);let l=Cl(i.shape,a.shape,o,c,s),{filterDepth:u,filterHeight:d,filterWidth:f,dilationDepth:p,dilationHeight:m,dilationWidth:h,padInfo:g}=l,_=g.front,v=g.left,y=g.top,b=new xa(l.outShape,i.dtype),x=n.data.get(i.dataId).values,S=n.data.get(a.dataId).values,C=b.values,w=ze(i.shape),T=ze(a.shape);for(let e=0;e<l.batchSize;++e){let t=e*w[0],n=e*b.strides[0];for(let e=0;e<l.outDepth;++e){let r=n+e*b.strides[1],i=e*l.strideDepth-_;for(let e=0;e<u;++e){let n=i+e*p;if(n<0||n>=l.inDepth)continue;let a=e*T[0],o=t+n*w[1];for(let e=0;e<l.outHeight;++e){let t=r+e*b.strides[2],n=e*l.strideHeight-y;for(let e=0;e<d;++e){let r=n+e*m;if(r<0||r>=l.inHeight)continue;let i=a+e*T[1],s=o+r*w[2];for(let e=0;e<l.outWidth;++e){let n=t+e*l.outChannels,r=e*l.strideWidth-v;for(let e=0;e<f;++e){let t=r+e*h;if(t<0||t>=l.inWidth)continue;let a=i+e*T[2],o=s+t*l.inChannels,c=a;for(let e=0;e<l.inChannels;++e){let t=x[o+e];for(let e=0;e<l.outChannels;++e)C[n+e]+=t*S[c+e];c+=l.outChannels}}}}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}var GU,KU=o((()=>{Y(),uR(),GU={kernelName:zt,backendName:`cpu`,kernelFunc:WU}}));function qU(e){let{inputs:t,backend:n,attrs:r}=e,{x:i,dy:a}=t,{strides:o,pad:s,filterShape:c}=r;lR([i,a],`conv3dBackpropFilterV2`);let l=ze(i.shape),u=ze(a.shape),d=Cl(i.shape,c,o,1,s),f=d.strideDepth,p=d.strideHeight,m=d.strideWidth,h=d.filterDepth,g=d.filterHeight,_=d.filterWidth,v=new xa(d.filterShape,`float32`),y=v.values,[b,x,S,C]=v.strides,w=n.data.get(a.dataId).values,[T,ee,E,te]=u,ne=n.data.get(i.dataId).values,[re,ie,ae,oe]=l,se=d.padInfo.front,ce=d.padInfo.left,le=d.padInfo.top;for(let e=0;e<h;++e){let t=Math.max(0,Math.ceil((se-e)/f)),n=Math.min(d.outDepth,(d.inDepth+se-e)/f),r=e*b;for(let i=0;i<g;++i){let a=Math.max(0,Math.ceil((le-i)/p)),o=Math.min(d.outHeight,(d.inHeight+le-i)/p),s=i*x+r;for(let r=0;r<_;++r){let c=Math.max(0,Math.ceil((ce-r)/m)),l=Math.min(d.outWidth,(d.inWidth+ce-r)/m),u=r*S+s;for(let s=0;s<d.inChannels;++s){let h=s*C+u;for(let u=0;u<d.outChannels;++u){let g=0;for(let h=0;h<d.batchSize;++h){let d=h*re,_=h*T;for(let h=t;h<n;++h){let t=(e+h*f-se)*ie+d,n=h*ee+_;for(let e=a;e<o;++e){let a=(i+e*p-le)*ae+t,o=e*E+n;for(let e=c;e<l;++e){let t=(r+e*m-ce)*oe+a,n=e*te+o;g+=ne[t+s]*w[n+u]}}}}y[h+u]=g}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}var JU,YU=o((()=>{Y(),uR(),JU={kernelName:Bt,backendName:`cpu`,kernelFunc:qU}}));function XU(e){let{inputs:t,backend:n,attrs:r}=e,{dy:i,filter:a}=t,{pad:o,strides:s,inputShape:c}=r;lR([i],`conv3dBackpropInputV2`);let l=ze(i.shape),u=ze(a.shape),d=Cl(c,a.shape,s,1,o),f=new xa(d.inShape,`float32`),p=f.values,[m,h,g,_]=f.strides,v=n.data.get(i.dataId).values,[y,b,x,S]=l,C=n.data.get(a.dataId).values,[w,T,ee,E]=u,{batchSize:te,filterDepth:ne,filterHeight:re,filterWidth:ie,inChannels:ae,inDepth:oe,inHeight:se,inWidth:ce,outChannels:le,outDepth:ue,outHeight:de,outWidth:D,strideDepth:fe,strideHeight:pe,strideWidth:O}=d,me=ne-1-d.padInfo.front,he=re-1-d.padInfo.top,ge=ie-1-d.padInfo.left;for(let e=0;e<te;++e)for(let t=0;t<ae;++t)for(let n=0;n<oe;++n){let r=n-me,i=Math.max(0,Math.ceil(r/fe)),a=Math.min(ue,(ne+r)/fe);for(let o=0;o<se;++o){let s=o-he,c=Math.max(0,Math.ceil(s/pe)),l=Math.min(de,(re+s)/pe);for(let u=0;u<ce;++u){let d=u-ge,f=Math.max(0,Math.ceil(d/O)),te=Math.min(D,(ie+d)/O),ae=0;for(let n=i;n<a;++n){let i=n*fe-r;for(let r=c;r<l;++r){let a=r*pe-s;for(let o=f;o<te;++o){let s=o*O-d,c=y*e+b*n+x*r+S*o,l=w*(ne-1-i)+T*(re-1-a)+ee*(ie-1-s)+E*t;for(let e=0;e<le;++e){let t=v[c+e],n=C[l+e];ae+=t*n}}}}p[m*e+h*n+g*o+_*u+t]=ae}}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}var ZU,QU=o((()=>{Y(),uR(),ZU={kernelName:Vt,backendName:`cpu`,kernelFunc:XU}})),$U,eW,tW=o((()=>{Y(),$R(),$U=ZR(`Cos`,e=>Math.cos(e)),eW={kernelName:`Cos`,backendName:`cpu`,kernelFunc:$U}})),nW,rW,iW=o((()=>{Y(),$R(),nW=ZR(Ht,e=>Math.cosh(e)),rW={kernelName:Ht,backendName:`cpu`,kernelFunc:nW}}));function aW(e){let{inputs:t,backend:n,attrs:r}=e,{image:i,boxes:a,boxInd:o}=t,{cropSize:s,method:c,extrapolationValue:l}=r,[u,d,f,p]=i.shape,m=a.shape[0],[h,g]=s,_=mc([m,h,g,p],`float32`),v=n.data.get(a.dataId).values,y=n.data.get(o.dataId).values,b=n.data.get(i.dataId).values,x=ze(i.shape),S=ze(_.shape);for(let e=0;e<m;e++){let t=e*4,n=v[t],r=v[t+1],i=v[t+2],a=v[t+3],o=y[e];if(o>=u)continue;let s=h>1?(i-n)*(d-1)/(h-1):0,m=g>1?(a-r)*(f-1)/(g-1):0;for(let t=0;t<h;t++){let u=h>1?n*(d-1)+t*s:.5*(n+i)*(d-1);if(u<0||u>d-1){for(let n=0;n<g;n++)for(let r=0;r<p;r++){let i=r+n*S[2]+t*S[1]+e*S[0];_.values[i]=l}continue}if(c===`bilinear`){let n=Math.floor(u),i=Math.ceil(u),s=u-n;for(let c=0;c<g;c++){let u=g>1?r*(f-1)+c*m:.5*(r+a)*(f-1);if(u<0||u>f-1){for(let n=0;n<p;n++){let r=n+c*S[2]+t*S[1]+e*S[0];_.values[r]=l}continue}let d=Math.floor(u),h=Math.ceil(u),v=u-d;for(let r=0;r<p;r++){let a=r+d*x[2]+n*x[1]+o*x[0],l=b[a];a=r+h*x[2]+n*x[1]+o*x[0];let u=b[a];a=r+d*x[2]+i*x[1]+o*x[0];let f=b[a];a=r+h*x[2]+i*x[1]+o*x[0];let p=b[a],m=l+(u-l)*v,g=f+(p-f)*v;a=r+c*S[2]+t*S[1]+e*S[0],_.values[a]=m+(g-m)*s}}}else for(let n=0;n<g;++n){let i=g>1?r*(f-1)+n*m:.5*(r+a)*(f-1);if(i<0||i>f-1){for(let r=0;r<p;r++){let i=r+n*S[2]+t*S[1]+e*S[0];_.values[i]=l}continue}let s=Math.round(i),c=Math.round(u);for(let r=0;r<p;r++){let i=r+s*x[2]+c*x[1]+o*x[0],a=r+n*S[2]+t*S[1]+e*S[0];_.values[a]=b[i]}}}}return n.makeTensorInfo(_.shape,_.dtype,_.values)}var oW,sW=o((()=>{Y(),oW={kernelName:Gt,backendName:`cpu`,kernelFunc:aW}}));function cW(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a,exclusive:o,reverse:s}=r;lR(i,`cumprod`);let c=Rf([a],i.shape.length),l=i;c!=null&&(l=SB({inputs:{x:i},backend:n,attrs:{perm:c}}));let u=Bf(1,i.shape.length)[0];if(u!==l.shape.length-1)throw Error(`backend.cumprod in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${u}`);let d=Ea(l.dtype,`int32`),f=Ue(O(l.shape),d),p=n.data.get(l.dataId).values,m=l.shape[l.shape.length-1],h=s?(e,t)=>e+m-t-1:(e,t)=>e+t;for(let e=0;e<p.length;e+=m)for(let t=0;t<m;t++){let n=h(e,t);if(t===0)f[n]=o?1:p[n];else{let r=h(e,t-1);f[n]=o?p[r]*f[r]:p[n]*f[r]}}let g=n.makeTensorInfo(l.shape,d,f);if(c!=null){let e=zf(c),t=SB({inputs:{x:g},backend:n,attrs:{perm:e}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),t}return g}var lW,uW=o((()=>{Y(),uR(),wB(),lW={kernelName:Ut,backendName:`cpu`,kernelFunc:cW}}));function dW(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a,exclusive:o,reverse:s}=r;lR(i,`cumsum`);let c=Rf([a],i.shape.length),l=i;c!=null&&(l=SB({inputs:{x:i},backend:n,attrs:{perm:c}}));let u=Bf(1,i.shape.length)[0];if(u!==l.shape.length-1)throw Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${u}`);let d=Ea(l.dtype,`int32`),f=We(O(l.shape),d),p=n.data.get(l.dataId).values,m=l.shape[l.shape.length-1],h=s?(e,t)=>e+m-t-1:(e,t)=>e+t;for(let e=0;e<p.length;e+=m)for(let t=0;t<m;t++){let n=h(e,t);if(t===0)f[n]=o?0:p[n];else{let r=h(e,t-1);f[n]=o?p[r]+f[r]:p[n]+f[r]}}let g=n.makeTensorInfo(l.shape,d,f);if(c!=null){let e=zf(c),t=SB({inputs:{x:g},backend:n,attrs:{perm:e}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),t}return g}var fW,pW=o((()=>{Y(),uR(),wB(),fW={kernelName:Wt,backendName:`cpu`,kernelFunc:dW}}));function mW(e){let{inputs:t,backend:n,attrs:r}=e,{x:i,weights:a}=t,{size:o,binaryOutput:s}=r;if(i.shape.length===1){let e=n.data.get(i.dataId).values,t=n.data.get(a.dataId).values,r=HR(e,t,a.dtype,a.shape,o);return n.makeTensorInfo([o],a.dtype,r)}else if(i.shape.length===2){let e=n.bufferSync(i),t=n.bufferSync(a),r=UR(e,t,o,s);return n.makeTensorInfo(r.shape,a.dtype,r.values)}throw Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}var hW,gW=o((()=>{Y(),WR(),hW={kernelName:Kt,backendName:`cpu`,kernelFunc:mW}}));function _W(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{blockSize:a,dataFormat:o}=r;D(o===`NHWC`,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);let s=i.shape[0],c=i.shape[1],l=i.shape[2],u=i.shape[3],d=c*a,f=l*a,p=u/(a*a),m=n.data.get(i.dataId).values,h=new Float32Array(s*d*f*p),g=0;for(let e=0;e<s;++e)for(let t=0;t<d;++t){let n=Math.floor(t/a),r=t%a;for(let t=0;t<f;++t){let i=Math.floor(t/a),o=t%a,s=(r*a+o)*p;for(let t=0;t<p;++t){let r=t+s+u*(i+l*(n+c*e));h[g++]=m[r]}}}return n.makeTensorInfo([s,d,f,p],i.dtype,h)}var vW,yW=o((()=>{Y(),vW={kernelName:qt,backendName:`cpu`,kernelFunc:_W}}));function bW(e){let{inputs:t,backend:n,attrs:r}=e,{x:i,filter:a}=t,{strides:o,pad:s,dilations:c,dimRoundingMode:l}=r;lR([i,a],`depthwiseConv2DNative`);let u=ze(i.shape),d=ze(a.shape),f=c;f??=[1,1],D(Pl(o,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${f}'`);let p=Sl(i.shape,a.shape,o,f,s,l,!0),{filterHeight:m,filterWidth:h,dilationHeight:g,dilationWidth:_,padInfo:v}=p,y=v.left,b=v.top,x=p.outChannels/p.inChannels,S=new xa(p.outShape,i.dtype),C=n.data.get(i.dataId).values,w=n.data.get(a.dataId).values,T=S.values;for(let e=0;e<p.batchSize;++e){let t=e*u[0],n=e*S.strides[0];for(let e=0;e<p.outHeight;++e){let r=n+e*S.strides[1],i=e*p.strideHeight-b;for(let e=0;e<m;++e){let n=i+e*g;if(n<0||n>=p.inHeight)continue;let a=e*d[0],o=t+n*u[1];for(let e=0;e<p.outWidth;++e){let t=r+e*S.strides[2],n=e*p.strideWidth-y;for(let e=0;e<h;++e){let r=n+e*_;if(r<0||r>=p.inWidth)continue;let i=a+e*d[1],s=o+r*p.inChannels,c=t,l=i;for(let e=0;e<p.inChannels;++e){let t=C[s+e];for(let e=0;e<x;++e)T[c+e]+=t*w[l+e];c+=x,l+=x}}}}}}return n.makeTensorInfo(S.shape,S.dtype,S.values)}var xW,SW=o((()=>{Y(),uR(),xW={kernelName:Jt,backendName:`cpu`,kernelFunc:bW}}));function CW(e){let{inputs:t,backend:n,attrs:r}=e,{x:i,dy:a}=t,{strides:o,dilations:s,pad:c,dimRoundingMode:l,filterShape:u}=r;lR([i,a],`depthwiseConv2dNativeBackpropFilter`);let d=Sl(i.shape,u,o,s,c,l,!0),{strideHeight:f,strideWidth:p,filterHeight:m,filterWidth:h}=d,g=new xa(d.filterShape,`float32`),_=d.padInfo.left,v=d.padInfo.top,y=d.outChannels/d.inChannels,b=n.data.get(i.dataId).values,x=new xa(i.shape,i.dtype,b),S=n.data.get(a.dataId).values,C=new xa(a.shape,a.dtype,S);for(let e=0;e<m;++e){let t=Math.max(0,Math.ceil((v-e)/f)),n=Math.min(d.outHeight,(d.inHeight+v-e)/f);for(let r=0;r<h;++r){let i=Math.max(0,Math.ceil((_-r)/p)),a=Math.min(d.outWidth,(d.inWidth+_-r)/p);for(let o=0;o<d.outChannels;++o){let s=Math.trunc(o/y),c=o%y,l=0;for(let c=0;c<d.batchSize;++c)for(let u=t;u<n;++u){let t=e+u*f-v;for(let e=i;e<a;++e){let n=r+e*p-_;l+=x.get(c,t,n,s)*C.get(c,u,e,o)}}g.set(l,e,r,s,c)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}var wW,TW=o((()=>{Y(),uR(),wW={kernelName:Yt,backendName:`cpu`,kernelFunc:CW}}));function EW(e){let{inputs:t,backend:n,attrs:r}=e,{dy:i,filter:a}=t,{strides:o,dilations:s,pad:c,dimRoundingMode:l,inputShape:u}=r;lR([i,a],`depthwiseConv2DNativeBackpropInput`);let d=ze(i.shape),f=ze(a.shape),p=Sl(u,a.shape,o,s,c,l,!0),m=new xa(p.inShape,`float32`),h=m.values,[g,_,v]=m.strides,y=n.data.get(i.dataId).values,[b,x,S]=d,C=n.data.get(a.dataId).values,[w,T,ee]=f,{batchSize:E,filterHeight:te,filterWidth:ne,inChannels:re,inHeight:ie,inWidth:ae,outChannels:oe,outHeight:se,outWidth:ce,strideHeight:le,strideWidth:ue}=p,de=te-1-p.padInfo.top,D=ne-1-p.padInfo.left,fe=oe/re;for(let e=0;e<E;++e)for(let t=0;t<re;++t)for(let n=0;n<ie;++n){let r=n-de,i=Math.max(0,Math.ceil(r/le)),a=Math.min(se,(te+r)/le);for(let o=0;o<ae;++o){let s=o-D,c=Math.max(0,Math.ceil(s/ue)),l=Math.min(ce,(ne+s)/ue),u=0;for(let n=i;n<a;++n){let i=n*le-r;for(let r=c;r<l;++r){let a=r*ue-s,o=b*e+x*n+S*r,c=w*(te-1-i)+T*(ne-1-a)+ee*t;for(let e=0;e<fe;++e){let n=t*fe+e,r=y[o+n],i=C[c+e];u+=r*i}}}h[g*e+_*n+v*o+t]=u}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}var DW,OW=o((()=>{Y(),uR(),DW={kernelName:Xt,backendName:`cpu`,kernelFunc:EW}}));function kW(e){let{inputs:t,backend:n}=e,{x:r}=t,i=O(r.shape),a=n.data.get(r.dataId).values,o=mc([i,i],r.dtype),s=o.values;for(let e=0;e<a.length;e++)s[e*i+e]=a[e];let c=[...r.shape,...r.shape];return n.makeTensorInfo(c,o.dtype,o.values)}var AW,jW=o((()=>{Y(),AW={kernelName:Zt,backendName:`cpu`,kernelFunc:kW}})),MW,NW=o((()=>{Y(),MW={kernelName:Qt,backendName:`cpu`,kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:i}=e,{strides:a,pad:o,dilations:s}=n,c=t,l=c.data.get(r.dataId).values,u=r.shape.length,d=c.data.get(i.dataId).values,f=i.shape.length,{batchSize:p,inHeight:m,inWidth:h,inChannels:g,outHeight:_,outWidth:v,padInfo:y,strideHeight:b,strideWidth:x,filterHeight:S,filterWidth:C,dilationHeight:w,dilationWidth:T,outShape:ee}=yl(r.shape,i.shape,a,o,`NHWC`,s),E=O(ee),te=ee.length,ne=De(r.dtype,E);for(let e=0;e<p;++e)for(let t=0;t<_;++t){let n=t*b-y.top;for(let a=0;a<v;++a){let o=a*x-y.left;for(let s=0;s<g;++s){let c=-(2**53-1);for(let t=0;t<S;++t){let a=n+t*w;if(a>=0&&a<m)for(let n=0;n<C;++n){let p=o+n*T;if(p>=0&&p<h){let o=qe([e,a,p,s],u,ze(r.shape)),m=qe([t,n,s],f,ze(i.shape)),h=l[o]+d[m];h>c&&(c=h)}}}let p=qe([e,t,a,s],te,ze(ee));ne[p]=c}}}return{dataId:c.write(Yi(ne,r.dtype),ee,r.dtype),shape:ee,dtype:r.dtype}}}})),PW,FW=o((()=>{Y(),PW={kernelName:en,backendName:`cpu`,kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:i,dy:a}=e,{strides:o,pad:s,dilations:c}=n,l=t,u=Ve(r.shape,l.data.get(r.dataId).values),d=Ve(i.shape,l.data.get(i.dataId).values),{batchSize:f,inHeight:p,inWidth:m,inChannels:h,outHeight:g,outWidth:_,padInfo:v,strideHeight:y,strideWidth:b,filterHeight:x,filterWidth:S,dilationHeight:C,dilationWidth:w,outShape:T}=yl(r.shape,i.shape,o,s,`NHWC`,c);D(a.rank===T.length,()=>`Error in ${en}, dy must have the same rank as output ${T.length}, but got ${a.rank}`);let ee=Ve(T,l.data.get(a.dataId).values),E=Ge(i.shape,i.dtype);for(let e=0;e<f;++e)for(let t=0;t<g;++t){let n=t*y-v.top;for(let r=0;r<_;++r){let i=r*b-v.left;for(let a=0;a<h;++a){let o=-(2**53-1),s=0,c=0;for(let t=0;t<x;++t){let r=n+t*C;if(r>=0&&r<p)for(let n=0;n<S;++n){let l=i+n*w;if(l>=0&&l<m){let i=u[e][r][l][a]+d[t][n][a];i>o&&(o=i,s=t,c=n)}}}E[s][c][a]+=ee[e][t][r][a]}}}return{dataId:l.write(Yi(E,r.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}}})),IW,LW=o((()=>{Y(),IW={kernelName:$t,backendName:`cpu`,kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:i,dy:a}=e,{strides:o,pad:s,dilations:c}=n,l=t,u=Ve(r.shape,l.data.get(r.dataId).values),d=Ve(i.shape,l.data.get(i.dataId).values),{batchSize:f,inHeight:p,inWidth:m,inChannels:h,outHeight:g,outWidth:_,padInfo:v,strideHeight:y,strideWidth:b,filterHeight:x,filterWidth:S,dilationHeight:C,dilationWidth:w,outShape:T}=yl(r.shape,i.shape,o,s,`NHWC`,c);D(a.rank===T.length,()=>`Error in ${$t}, dy must have the same rank as output ${T.length}, but got ${a.rank}`);let ee=Ve(T,l.data.get(a.dataId).values),E=Ge(r.shape,r.dtype);for(let e=0;e<f;++e)for(let t=0;t<g;++t){let n=t*y-v.top;for(let r=0;r<_;++r){let i=r*b-v.left;for(let a=0;a<h;++a){let o=-(2**53-1),s=n<0?0:n,c=i<0?0:i;for(let t=0;t<x;++t){let r=n+t*C;if(r>=0&&r<p)for(let n=0;n<S;++n){let l=i+n*w;if(l>=0&&l<m){let i=u[e][r][l][a]+d[t][n][a];i>o&&(o=i,s=r,c=l)}}}E[e][s][c][a]+=ee[e][t][r][a]}}}return{dataId:l.write(Yi(E,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}}}));function RW(e){let{inputs:t,backend:n,attrs:r}=e,{image:i}=t,{canvas:a,options:o}=r,{contextOptions:s,imageOptions:c}=o||{},l=c?.alpha||1,u=s?.contextType||`2d`;if(u!==`2d`)throw Error(`Context type ${s.contextType} is not supported by the CPU backend.`);let d=a.getContext(u,s?.contextAttributes||{});if(d==null)throw Error(`Could not get the context with ${u} type.`);let[f,p]=i.shape.slice(0,2),m=i.shape.length===2?1:i.shape[2],h=n.data.get(i.dataId).values,g=i.dtype===`float32`?255:1,_=new Uint8ClampedArray(p*f*4);for(let e=0;e<f*p;++e){let t=[0,0,0,255*l];for(let n=0;n<m;n++){let r=h[e*m+n];if(i.dtype===`float32`){if(r<0||r>1)throw Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${r}.`)}else if(i.dtype===`int32`&&(r<0||r>255))throw Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${r}.`);m===1?(t[0]=r*g,t[1]=r*g,t[2]=r*g):t[n]=r*g}let n=e*4;_[n+0]=Math.round(t[0]),_[n+1]=Math.round(t[1]),_[n+2]=Math.round(t[2]),_[n+3]=Math.round(t[3])}a.width=p,a.height=f;let v=new ImageData(_,p,f);return d.putImageData(v,0,0),i}var zW,BW=o((()=>{Y(),zW={kernelName:tn,backendName:`cpu`,kernelFunc:RW}}));function VW(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a,keepDims:o}=r;lR(i,`sum`);let s;s=i.dtype===`bool`?jR({inputs:{x:i},backend:n,attrs:{dtype:`int32`}}):wR({inputs:{x:i},backend:n});let c=s.shape.length,l=we(a,s.shape),u=Rf(l,c),d=l,f=s;u!=null&&(f=SB({inputs:{x:s},backend:n,attrs:{perm:u}}),d=Bf(d.length,c)),Lf(`sum`,d,f.shape.length);let[p,m]=Ff(f.shape,d),h=Ea(f.dtype,`int32`),g=SR(n,p,h),_=O(m),v=n.data.get(g.dataId).values,y=n.data.get(f.dataId).values;for(let e=0;e<v.length;++e){let t=e*_,n=0;for(let e=0;e<_;++e)n+=y[t+e];v[e]=n}if(o){let e=If(g.shape,l),t=g;g=lH({inputs:{x:g},backend:n,attrs:{shape:e}}),n.disposeIntermediateTensorInfo(t)}return n.disposeIntermediateTensorInfo(s),u!=null&&n.disposeIntermediateTensorInfo(f),g}var HW,UW=o((()=>{Y(),uR(),CR(),NR(),ER(),dH(),wB(),HW={kernelName:`Sum`,backendName:`cpu`,kernelFunc:VW}}));function WW(e){let{inputs:t,backend:n,attrs:r}=e,{equation:i}=r,a=t,{allDims:o,summedDims:s,idDims:c}=ZS(i,a.length);$S(o.length,c,a);let{path:l,steps:u}=eC(s,c),d=u.length,f=null,p=o.length,m=[];for(let e=0;e<d;++e){for(let t of u[e]){let{permutationIndices:e,expandDims:r}=QS(p,c[t]),i;tC(e)?i=a[t]:(i=SB({inputs:{x:a[t]},backend:n,attrs:{perm:e}}),m.push(i));let o=i.shape.slice();for(let e=0;e<r.length;++e)o.splice(r[e],0,1);ge(i.shape,o)||(i=lH({inputs:{x:i},backend:n,attrs:{shape:o}}),m.push(i)),f===null?f=i:(f=uB({inputs:{a:i,b:f},backend:n}),m.push(f))}e<d-1&&(l[e]>=0&&(f=VW({inputs:{x:f},backend:n,attrs:{axis:l[e]-(o.length-p),keepDims:!1}}),m.push(f)),p--)}for(let e of m)e!==f&&n.disposeIntermediateTensorInfo(e);return f}var GW,KW=o((()=>{Y(),fB(),dH(),UW(),wB(),GW={kernelName:rn,backendName:`cpu`,kernelFunc:WW}}));function qW(e){let{inputs:t,backend:n}=e,{dy:r,y:i}=t;lR([r,i],`eluGrad`);let a=new Float32Array(O(i.shape)),o=n.data.get(i.dataId).values,s=n.data.get(r.dataId).values;for(let e=0;e<o.length;++e){let t=o[e];t>=0?a[e]=s[e]:a[e]=s[e]*(t+1)}return n.makeTensorInfo(i.shape,`float32`,a)}var JW,YW=o((()=>{Y(),uR(),JW={kernelName:an,backendName:`cpu`,kernelFunc:qW}})),XW,ZW,QW,$W,eG,tG,nG,rG,iG=o((()=>{Y(),$R(),XW=LS,ZW=RS,QW=zS,$W=BS,eG=VS,tG=HS,nG=ZR(`Erf`,e=>{let t=Math.sign(e),n=Math.abs(e),r=1/(1+XW*n);return t*(1-((((tG*r+eG)*r+$W)*r+QW)*r+ZW)*r*Math.exp(-n*n))}),rG={kernelName:`Erf`,backendName:`cpu`,kernelFunc:nG}}));function aG(e){let{inputs:t,backend:n,attrs:r}=e,{input:i}=t,{dim:a}=r,o=i.shape.length,s=i.shape.slice(),c=a;return a<0&&(D(-(o+1)<=a,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),c=o+a+1),s.splice(c,0,1),lH({inputs:{x:i},backend:n,attrs:{shape:s}})}var oG,sG=o((()=>{Y(),dH(),oG={kernelName:sn,backendName:`cpu`,kernelFunc:aG}})),cG,lG,uG,dG=o((()=>{Y(),vR(),IR(),cG=_R((e,t)=>e/t),lG=PR(nn,cG),uG={kernelName:nn,backendName:`cpu`,kernelFunc:lG}}));function fG(e,t,n){let r=e.shape,i=r[0],a=r[1],o=n.data.get(e.dataId),s=o.complexTensorInfos.real,c=o.complexTensorInfos.imag,l=[i,a],u=O(l),d=Ee(`float32`,u),f=Ee(`float32`,u);for(let e=0;e<i;e++){let r=$B({inputs:{x:s},backend:n,attrs:{begin:[e,0],size:[1,a]}}),i=$B({inputs:{x:c},backend:n,attrs:{begin:[e,0],size:[1,a]}}),o=yR({inputs:{real:r,imag:i},backend:n}),{real:l,imag:u}=pG(o,t,n),p=US(l,u);for(let t=0;t<a;t++){let n=qS(p,t);d[e*a+t]=n.real,f[e*a+t]=n.imag}n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o)}let p=n.makeTensorInfo(l,`float32`,d),m=n.makeTensorInfo(l,`float32`,f),h=yR({inputs:{real:p,imag:m},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),h}function pG(e,t,n){let r=O(e.shape),i=n.data.get(e.dataId),a=n.data.get(i.complexTensorInfos.real.dataId).values,o=n.data.get(i.complexTensorInfos.imag.dataId).values;if(mG(r)){let i=hG(a,o,r,t,n),s=[e.shape[0],e.shape[1]];if(t){let e=n.makeTensorInfo(s,`float32`,i.real),t=n.makeTensorInfo(s,`float32`,i.imag),a=n.makeTensorInfo([],`float32`,qi(r,`float32`)),o=wR({inputs:{x:a},backend:n}),c=uG.kernelFunc({inputs:{a:e,b:a},backend:n}),l=uG.kernelFunc({inputs:{a:t,b:o},backend:n}),u=n.data.get(c.dataId).values,d=n.data.get(l.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),{real:u,imag:d}}return i}else{let e=US(a,o),n=gG(e,r,t);return WS(n)}}function mG(e){return(e&e-1)==0}function hG(e,t,n,r,i){if(n===1)return{real:e,imag:t};let a=US(e,t),o=n/2,s=GS(a),c=s.real,l=s.imag,u=[c.length],d=i.makeTensorInfo(u,`float32`,c),f=i.makeTensorInfo(u,`float32`,l),p=yR({inputs:{real:d,imag:f},backend:i}),m=KS(a),h=m.real,g=m.imag,_=[h.length],v=i.makeTensorInfo(_,`float32`,h),y=i.makeTensorInfo(_,`float32`,g),b=yR({inputs:{real:v,imag:y},backend:i}),x=hG(c,l,o,r,i),S=x.real,C=x.imag,w=[S.length],T=i.makeTensorInfo(w,`float32`,S),ee=i.makeTensorInfo(w,`float32`,C),E=yR({inputs:{real:T,imag:ee},backend:i}),te=hG(h,g,o,r,i),ne=te.real,re=te.imag,ie=[ne.length],ae=i.makeTensorInfo(ie,`float32`,ne),oe=i.makeTensorInfo(ie,`float32`,re),se=yR({inputs:{real:ae,imag:oe},backend:i}),ce=YS(n,r),le=[ce.real.length],ue=i.makeTensorInfo(le,`float32`,ce.real),de=i.makeTensorInfo(le,`float32`,ce.imag),D=yR({inputs:{real:ue,imag:de},backend:i}),fe=uB({inputs:{a:D,b:se},backend:i}),pe=zR({inputs:{a:E,b:fe},backend:i}),O=jV({inputs:{a:E,b:fe},backend:i}),me=DR({inputs:{input:pe},backend:i}),he=DR({inputs:{input:O},backend:i}),ge=kU({inputs:{input:pe},backend:i}),_e=kU({inputs:{input:O},backend:i}),ve=MU({inputs:[me,he],backend:i,attrs:{axis:0}}),ye=MU({inputs:[ge,_e],backend:i,attrs:{axis:0}}),be=i.data.get(ve.dataId).values,xe=i.data.get(ye.dataId).values;return i.disposeIntermediateTensorInfo(d),i.disposeIntermediateTensorInfo(f),i.disposeIntermediateTensorInfo(p),i.disposeIntermediateTensorInfo(v),i.disposeIntermediateTensorInfo(y),i.disposeIntermediateTensorInfo(b),i.disposeIntermediateTensorInfo(T),i.disposeIntermediateTensorInfo(ee),i.disposeIntermediateTensorInfo(E),i.disposeIntermediateTensorInfo(ae),i.disposeIntermediateTensorInfo(oe),i.disposeIntermediateTensorInfo(se),i.disposeIntermediateTensorInfo(ue),i.disposeIntermediateTensorInfo(de),i.disposeIntermediateTensorInfo(D),i.disposeIntermediateTensorInfo(fe),i.disposeIntermediateTensorInfo(pe),i.disposeIntermediateTensorInfo(O),i.disposeIntermediateTensorInfo(me),i.disposeIntermediateTensorInfo(ge),i.disposeIntermediateTensorInfo(he),i.disposeIntermediateTensorInfo(_e),i.disposeIntermediateTensorInfo(ve),i.disposeIntermediateTensorInfo(ye),{real:be,imag:xe}}function gG(e,t,n){let r=new Float32Array(t*2);for(let i=0;i<t;i++){let a=0,o=0;for(let r=0;r<t;r++){let s=XS(i*r,t,n),c=qS(e,r);a+=c.real*s.real-c.imag*s.imag,o+=c.real*s.imag+c.imag*s.real}n&&(a/=t,o/=t),JS(r,a,o,i)}return r}var _G=o((()=>{Y(),VR(),xR(),PU(),ER(),jU(),fB(),kR(),dG(),tV(),NV()}));function vG(e){let{inputs:t,backend:n}=e,{input:r}=t,i=O(r.shape),a=r.shape[r.shape.length-1],o=i/a,s=lH({inputs:{x:r},backend:n,attrs:{shape:[o,a]}}),c=fG(s,!1,n),l=lH({inputs:{x:c},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(c),l}var yG,bG=o((()=>{Y(),_G(),dH(),yG={kernelName:`FFT`,backendName:`cpu`,kernelFunc:vG}}));function xG(e){let{backend:t,attrs:n}=e,{shape:r,value:i,dtype:a}=n,o=a||Ie(i),s=De(o,O(r));return SG(s,i,o),t.makeTensorInfo(r,o,s)}function SG(e,t,n){e.fill(t)}var CG,wG=o((()=>{Y(),CG={kernelName:ln,backendName:`cpu`,kernelFunc:xG}})),TG,EG=o((()=>{Y(),TG={kernelName:un,backendName:`cpu`,kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,i=n,a=Ee(r.dtype,O(r.shape)),[o,s,c,l]=r.shape,u=i.data.get(r.dataId).values;for(let e=0;e<o;e++){let t=e*c*s*l;for(let e=0;e<s;e++){let n=e*(c*l);for(let e=0;e<c;e++){let r=e*l;for(let i=0;i<l;i++){let o=Math.round(c-e-1),s=t+n+r+i,d=u[s];if(o>=0&&o<c){let e=o*l,r=t+n+e+i;d=u[r]}a[s]=d}}}}return{dataId:i.write(a,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}}}));function DG(e){let{inputs:t,backend:n,attrs:r}=e,{x:i,filter:a,bias:o,preluActivationWeights:s}=t,{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:f,activation:p,leakyreluAlpha:m}=r,h=FU({inputs:{x:i,filter:a},backend:n,attrs:{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:f}});if(o){let e=h;if(u===`NCHW`&&o.shape.length===1&&o.shape[0]!==1){let e=lH({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});h=zR({inputs:{a:h,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else h=zR({inputs:{a:h,b:o},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){let e=h;if(u===`NCHW`&&p===`prelu`&&s.shape.length===1&&s.shape[0]!==1){let e=lH({inputs:{x:s},backend:n,attrs:{shape:[s.shape[0],1,1]}});h=sH(n,h,p,e,m),n.disposeIntermediateTensorInfo(e)}else h=sH(n,h,p,s,m);n.disposeIntermediateTensorInfo(e)}return h}var OG,kG=o((()=>{Y(),cH(),VR(),LU(),dH(),OG={kernelName:si,backendName:`cpu`,kernelFunc:DG}}));function AG(e){let{inputs:t,backend:n,attrs:r}=e,{x:i,filter:a,bias:o,preluActivationWeights:s}=t,{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:f,activation:p,leakyreluAlpha:m}=r,h=bW({inputs:{x:i,filter:a},backend:n,attrs:{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:f}});if(o){let e=h;h=zR({inputs:{a:h,b:o},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){let e=h;h=sH(n,h,p,s,m),n.disposeIntermediateTensorInfo(e)}return h}var jG,MG=o((()=>{Y(),cH(),VR(),SW(),jG={kernelName:ci,backendName:`cpu`,kernelFunc:AG}}));function NG(e){let{inputs:t,backend:n}=e,{params:r,indices:i}=t,a=O(r.shape),o=i.shape,s=o[o.length-1],[c,l,u,d]=Kx(r,i);if(l===0)return n.makeTensorInfo(c,r.dtype,[]);let f=n.data.get(i.dataId).values,p=n.bufferSync(r),m=Ez(f,p,r.dtype,l,s,u,d,r.shape,a);return n.makeTensorInfo(c,r.dtype,m.values)}var PG,FG=o((()=>{Y(),Dz(),PG={kernelName:hn,backendName:`cpu`,kernelFunc:NG}}));function IG(e){let{inputs:t,backend:n,attrs:r}=e,{x:i,indices:a}=t,{axis:o,batchDims:s}=r;lR([i,a],`gatherV2`);let c=we(o,i.shape)[0],l=n.data.get(a.dataId).values,u=i.shape[c];for(let e=0;e<l.length;++e){let t=l[e];D(t<=u-1&&t>=0,()=>`GatherV2: the index value ${t} is not in [0, ${u-1}]`)}let d=s;s??(d=0);let f=O(a.shape),p=xC(i,a,c,d),m=lH({inputs:{x:i},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),h=lH({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,f/p.batchSize]}}),g=[p.batchSize,p.outerSize,f/p.batchSize,p.sliceSize],_=n.bufferSync(h),v=n.bufferSync(m),y=Oz(v,_,g);return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(h),n.makeTensorInfo(p.outputShape,y.dtype,y.values)}var LG,RG=o((()=>{Y(),uR(),kz(),dH(),LG={kernelName:mn,backendName:`cpu`,kernelFunc:IG}}));function zG(e){let{inputs:t,backend:n}=e,{input:r}=t,i=O(r.shape),a=r.shape[r.shape.length-1],o=i/a,s=lH({inputs:{x:r},backend:n,attrs:{shape:[o,a]}}),c=fG(s,!0,n),l=lH({inputs:{x:c},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(c),l}var BG,VG=o((()=>{Y(),_G(),dH(),BG={kernelName:yn,backendName:`cpu`,kernelFunc:zG}})),HG,UG,WG=o((()=>{Y(),$R(),HG=ZR(xn,e=>Number.isFinite(e)?1:0,`bool`),UG={kernelName:xn,backendName:`cpu`,kernelFunc:HG}})),GG,KG,qG=o((()=>{Y(),$R(),GG=ZR(Sn,e=>Math.abs(e)===1/0?1:0,`bool`),KG={kernelName:Sn,backendName:`cpu`,kernelFunc:GG}})),JG,YG,XG=o((()=>{Y(),$R(),JG=ZR(Cn,e=>Number.isNaN(e)?1:0,`bool`),YG={kernelName:Cn,backendName:`cpu`,kernelFunc:JG}}));function ZG(e){let{backend:t,attrs:n}=e,{start:r,stop:i,num:a}=n,o=Kz(r,i,a);return t.makeTensorInfo([o.length],`float32`,o)}var QG,$G=o((()=>{Y(),qz(),QG={kernelName:Dn,backendName:`cpu`,kernelFunc:ZG}})),eK,tK,nK=o((()=>{Y(),$R(),eK=ZR(On,e=>Math.log1p(e)),tK={kernelName:On,backendName:`cpu`,kernelFunc:eK}})),rK,iK,aK,oK=o((()=>{Y(),vR(),IR(),rK=_R((e,t)=>e&&t),iK=PR(kn,rK,null,`bool`),aK={kernelName:kn,backendName:`cpu`,kernelFunc:iK}})),sK,cK,lK=o((()=>{Y(),$R(),sK=ZR(An,e=>e?0:1,`bool`),cK={kernelName:An,backendName:`cpu`,kernelFunc:sK}})),uK,dK,fK,pK=o((()=>{Y(),vR(),IR(),uK=_R((e,t)=>e||t),dK=PR(jn,uK,null,`bool`),fK={kernelName:jn,backendName:`cpu`,kernelFunc:dK}}));function mK(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{depthRadius:a,bias:o,alpha:s,beta:c}=r;lR(i,`LRN`);let l=i.shape[3],u=l-1,d=n.data.get(i.dataId).values,f=O(i.shape),p=new Float32Array(f);function m(e){let t=e%l,n=e-t+Math.max(0,t-a),r=e-t+Math.min(t+a,u),i=0;for(;n<=r;n++){let e=d[n];i+=e*e}return i}for(let e=0;e<f;e++){let t=m(e);p[e]=d[e]*(o+s*t)**+-c}return n.makeTensorInfo(i.shape,i.dtype,p)}var hK,gK=o((()=>{Y(),uR(),hK={kernelName:`LRN`,backendName:`cpu`,kernelFunc:mK}}));function _K(e){let{inputs:t,backend:n,attrs:r}=e,{x:i,y:a,dy:o}=t,{depthRadius:s,bias:c,alpha:l,beta:u}=r;lR(o,`LRNGrad`);let d=O(o.shape),f=o.shape[3],p=n.data.get(o.dataId).values,m=n.data.get(i.dataId).values,h=n.data.get(a.dataId).values,g=new Float32Array(d),_=d;for(let e=0;e<_;e++){let t=e%f,n=e-t+Math.max(0,t-s),r=e-t+Math.min(f,t+s+1),i=0;for(let e=n;e<r;e++)i+=m[e]**2;i=l*i+c;for(let t=n;t<r;t++){let n=-2*l*u*m[t]*h[e]/i;e===t&&(n+=i**+-u),n*=p[e],g[t]+=n}}return n.makeTensorInfo(o.shape,i.dtype,g)}var vK,yK=o((()=>{Y(),uR(),vK={kernelName:Fn,backendName:`cpu`,kernelFunc:_K}}));function bK(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{reductionIndices:a,keepDims:o}=r,s=n,c=i.shape,l=c.length,u=we(a,c),d=u,f=Rf(d,l),p=s.data.get(i.dataId).values;if(f!=null){let e=Array(l);for(let t=0;t<e.length;t++)e[t]=c[f[t]];p=bB(p,c,i.dtype,f,e),d=Bf(d.length,l),c=e}lR(i,`max`),Lf(`max`,d,l);let[m,h]=Ff(c,d),g=O(h),_=Qz(p,g,m,i.dtype),v=s.write(_,m,i.dtype),y=m;return o&&(y=If(m,u)),{dataId:v,shape:y,dtype:i.dtype}}var xK,SK=o((()=>{Y(),uR(),$z(),xB(),xK={kernelName:`Max`,backendName:`cpu`,kernelFunc:bK}}));function CK(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t;lR(i,`maxPool`);let{filterSize:a,strides:o,pad:s,dimRoundingMode:c}=r;D(Pl(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);let l=bl(i.shape,a,o,1,s,c),u;if(l.filterWidth===1&&l.filterHeight===1&&ge(l.inShape,l.outShape))u=wR({inputs:{x:i},backend:n});else{let e=n.data.get(i.dataId).values,t=ze(i.shape),r=JH(e,i.shape,i.dtype,t,l,`max`);u=n.makeTensorInfo(l.outShape,i.dtype,r.values)}return u}var wK,TK=o((()=>{Y(),uR(),QH(),ER(),wK={kernelName:Rn,backendName:`cpu`,kernelFunc:CK}}));function EK(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{filterSize:a,strides:o,pad:s,dimRoundingMode:c,dataFormat:l}=r;lR(i,`maxPool3d`);let u=xl(i.shape,a,o,1,s,c,l),d=n.data.get(i.dataId).values,f=XH(d,i.shape,i.dtype,ze(i.shape),u,`max`);return n.makeTensorInfo(f.shape,`float32`,f.values)}var DK,OK=o((()=>{Y(),uR(),QH(),DK={kernelName:Bn,backendName:`cpu`,kernelFunc:EK}}));function kK(e){let{inputs:t,backend:n,attrs:r}=e,{dy:i,input:a}=t,{filterSize:o,strides:s,pad:c,dimRoundingMode:l}=r;lR([i,a],`maxPool3DGrad`);let u=xl(a.shape,o,s,1,c,l),d=n.bufferSync(a),f=ZH(d,u),p=u.strideDepth,m=u.strideHeight,h=u.strideWidth,g=u.dilationDepth,_=u.dilationHeight,v=u.dilationWidth,y=u.effectiveFilterDepth,b=u.effectiveFilterHeight,x=u.effectiveFilterWidth,S=y-1-u.padInfo.front,C=x-1-u.padInfo.left,w=b-1-u.padInfo.top,T=mc(a.shape,`float32`),ee=n.bufferSync(i);for(let e=0;e<u.batchSize;++e)for(let t=0;t<u.inChannels;++t)for(let n=0;n<u.inDepth;++n)for(let r=0;r<u.inHeight;++r)for(let i=0;i<u.inWidth;++i){let a=n-S,o=r-w,s=i-C,c=0;for(let n=0;n<y;n+=g){let r=(a+n)/p;if(!(r<0||r>=u.outDepth||Math.floor(r)!==r))for(let i=0;i<b;i+=_){let a=(o+i)/m;if(!(a<0||a>=u.outHeight||Math.floor(a)!==a))for(let o=0;o<x;o+=v){let l=(s+o)/h;if(l<0||l>=u.outWidth||Math.floor(l)!==l)continue;let d=y*b*x-1-f.get(e,r,a,l,t),p=n*b*x+i*x+o,m=d===p?1:0;if(m===0)continue;let g=ee.get(e,r,a,l,t);c+=g*m}}}T.set(c,e,n,r,i,t)}return n.makeTensorInfo(T.shape,T.dtype,T.values)}var AK,jK=o((()=>{Y(),uR(),QH(),AK={kernelName:Vn,backendName:`cpu`,kernelFunc:kK}}));function MK(e){let{inputs:t,backend:n,attrs:r}=e,{dy:i,input:a,output:o}=t,s=a;lR([a,o],`maxPoolGrad`);let{filterSize:c,strides:l,pad:u,dimRoundingMode:d}=r,f=bl(s.shape,c,l,1,u,d),p=n.data.get(s.dataId).values,m=mc(f.outShape,s.dtype,YH(p,s.shape,s.dtype,f).values),h=f.strideHeight,g=f.strideWidth,_=f.dilationHeight,v=f.dilationWidth,y=f.effectiveFilterHeight,b=f.effectiveFilterWidth,x=b-1-f.padInfo.left,S=y-1-f.padInfo.top,C=mc(s.shape,`float32`),w=n.data.get(i.dataId).values,T=mc(i.shape,`float32`,w);for(let e=0;e<f.batchSize;++e)for(let t=0;t<f.inChannels;++t)for(let n=0;n<f.inHeight;++n)for(let r=0;r<f.inWidth;++r){let i=n-S,a=r-x,o=0;for(let n=0;n<y;n+=_){let r=(i+n)/h;if(!(r<0||r>=f.outHeight||Math.floor(r)!==r))for(let i=0;i<b;i+=v){let s=(a+i)/g;if(s<0||s>=f.outWidth||Math.floor(s)!==s)continue;let c=y*b-1-m.get(e,r,s,t),l=n*b+i,u=c===l?1:0;if(u===0)continue;let d=T.get(e,r,s,t);o+=d*u}}C.set(o,e,n,r,t)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}var NK,PK=o((()=>{Y(),uR(),QH(),NK={kernelName:zn,backendName:`cpu`,kernelFunc:MK}}));function FK(e,t,n,r,i){let a=ze(t),o=JH(e,t,n,a,i,`max`),s=YH(e,t,n,i,!0,r);return[o.values,s.values]}var IK=o((()=>{Y(),QH()})),LK,RK=o((()=>{Y(),uR(),IK(),LK={kernelName:Hn,backendName:`cpu`,kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:i,strides:a,pad:o,includeBatchInIndex:s}=t,c=n;lR(r,`MaxPoolWithArgmax`);let l=c.data.get(r.dataId).values,u=bl(r.shape,i,a,[1,1],o),[d,f]=FK(l,r.shape,r.dtype,s,u),p=c.write(d,u.outShape,r.dtype),m=c.write(f,u.outShape,r.dtype);return[{dataId:p,shape:u.outShape,dtype:r.dtype},{dataId:m,shape:u.outShape,dtype:`int32`}]}}}));function zK(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a,keepDims:o}=r,s=we(a,i.shape),c=Ff(i.shape,s)[1],l=O(c),u=[],d=n.makeTensorInfo([],`float32`,new Float32Array([l]));u.push(d);let f=jR({inputs:{x:i},backend:n,attrs:{dtype:`float32`}});u.push(f);let p=lG({inputs:{a:f,b:d},backend:n});u.push(p);let m=VW({inputs:{x:p},backend:n,attrs:{axis:a,keepDims:o}});return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),m}var BK,VK=o((()=>{Y(),NR(),dG(),UW(),BK={kernelName:Un,backendName:`cpu`,kernelFunc:zK}}));function HK(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a,keepDims:o}=r;lR(i,`min`);let s=we(a,i.shape),c=s,l=Rf(c,i.shape.length),u=i;l!=null&&(u=SB({inputs:{x:i},backend:n,attrs:{perm:l}}),c=Bf(c.length,i.shape.length)),Lf(`min`,c,u.shape.length);let[d,f]=Ff(u.shape,c),p=O(f),m=We(O(d),u.dtype),h=n.data.get(u.dataId).values;for(let e=0;e<m.length;++e){let t=e*p,n=h[t];for(let e=0;e<p;++e){let r=h[t+e];(Number.isNaN(r)||r<n)&&(n=r)}m[e]=n}l!=null&&n.disposeIntermediateTensorInfo(u);let g=n.makeTensorInfo(d,u.dtype,m);if(o){let e=If(d,s),t=lH({inputs:{x:g},backend:n,attrs:{shape:e}});return n.disposeIntermediateTensorInfo(g),t}return g}var UK,WK=o((()=>{Y(),uR(),dH(),wB(),UK={kernelName:`Min`,backendName:`cpu`,kernelFunc:HK}}));function GK(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{paddings:a,mode:o}=r;lR(i,`mirrorPad`);let s=a.map((e,t)=>e[0]+i.shape[t]+e[1]),c=a.map(e=>e[0]),l=a.map((e,t)=>e[0]+i.shape[t]),u=o===`reflect`?0:1,d=n.data.get(i.dataId).values,f=i.shape.length,p=ze(i.shape),m=O(s),h=s.length,g=ze(s),_=Ee(i.dtype,m);for(let e=0;e<m;e++){let t=Je(e,h,g);for(let e=0;e<h;e++)t[e]<c[e]?t[e]=c[e]*2-t[e]-u:t[e]>=l[e]&&(t[e]=(l[e]-1)*2-t[e]+u);t=t.map((e,t)=>e-c[t]);let n=qe(t,f,p);_[e]=d[n]}return{dataId:n.write(_,s,i.dtype),shape:s,dtype:i.dtype}}var KK,qK=o((()=>{Y(),uR(),KK={kernelName:Gn,backendName:`cpu`,kernelFunc:GK}})),JK,YK,XK,ZK=o((()=>{Y(),vR(),IR(),JK=_R(((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),YK=PR(`Mod`,JK),XK={kernelName:`Mod`,backendName:`cpu`,kernelFunc:YK}})),QK=s(((e,t)=>{(function(e,t,n){function r(e){var t=this,n=o();t.next=function(){var e=2091639*t.s0+t.c*23283064365386963e-26;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=e|0)},t.c=1,t.s0=n(` `),t.s1=n(` `),t.s2=n(` `),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function a(e,t){var n=new r(e),a=t&&t.state,o=n.next;return o.int32=function(){return n.next()*4294967296|0},o.double=function(){return o()+(o()*2097152|0)*11102230246251565e-32},o.quick=o,a&&(typeof a==`object`&&i(a,n),o.state=function(){return i(n,{})}),o}function o(){var e=4022871197;return function(t){t=String(t);for(var n=0;n<t.length;n++){e+=t.charCodeAt(n);var r=.02519603282416938*e;e=r>>>0,r-=e,r*=e,e=r>>>0,r-=e,e+=r*4294967296}return(e>>>0)*23283064365386963e-26}}t&&t.exports?t.exports=a:n&&n.amd?n(function(){return a}):this.alea=a})(e,typeof t==`object`&&t,typeof define==`function`&&define)})),$K=s(((e,t)=>{(function(e,t,n){function r(e){var t=this,n=``;t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(e|0)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=n.charCodeAt(r)|0,t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function a(e,t){var n=new r(e),a=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21);while(r===0);return r},o.int32=n.next,o.quick=o,a&&(typeof a==`object`&&i(a,n),o.state=function(){return i(n,{})}),o}t&&t.exports?t.exports=a:n&&n.amd?n(function(){return a}):this.xor128=a})(e,typeof t==`object`&&t,typeof define==`function`&&define)})),eq=s(((e,t)=>{(function(e,t,n){function r(e){var t=this,n=``;t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^(e^e<<1))|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(e|0)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=n.charCodeAt(r)|0,r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function a(e,t){var n=new r(e),a=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21);while(r===0);return r},o.int32=n.next,o.quick=o,a&&(typeof a==`object`&&i(a,n),o.state=function(){return i(n,{})}),o}t&&t.exports?t.exports=a:n&&n.amd?n(function(){return a}):this.xorwow=a})(e,typeof t==`object`&&t,typeof define==`function`&&define)})),tq=s(((e,t)=>{(function(e,t,n){function r(e){var t=this;t.next=function(){var e=t.x,n=t.i,r=e[n],i;return r^=r>>>7,i=r^r<<24,r=e[n+1&7],i^=r^r>>>10,r=e[n+3&7],i^=r^r>>>3,r=e[n+4&7],i^=r^r<<7,r=e[n+7&7],r^=r<<13,i^=r^r<<9,e[n]=i,t.i=n+1&7,i};function n(e,t){var n,r=[];if(t===(t|0))r[0]=t;else for(t=``+t,n=0;n<t.length;++n)r[n&7]=r[n&7]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&r[n]===0;++n);for(n==8?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}n(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function a(e,t){e??=+new Date;var n=new r(e),a=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21);while(r===0);return r},o.int32=n.next,o.quick=o,a&&(a.x&&i(a,n),o.state=function(){return i(n,{})}),o}t&&t.exports?t.exports=a:n&&n.amd?n(function(){return a}):this.xorshift7=a})(e,typeof t==`object`&&t,typeof define==`function`&&define)})),nq=s(((e,t)=>{(function(e,t,n){function r(e){var t=this;t.next=function(){var e=t.w,n=t.X,r=t.i,i,a;return t.w=e=e+1640531527|0,a=n[r+34&127],i=n[r=r+1&127],a^=a<<13,i^=i<<17,a^=a>>>15,i^=i>>>12,a=n[r]=a^i,t.i=r,a+(e^e>>>16)|0};function n(e,t){var n,r,i,a,o,s=[],c=128;for(t===(t|0)?(r=t,t=null):(t+=`\0`,r=0,c=Math.max(c,t.length)),i=0,a=-32;a<c;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),a===0&&(o=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(o=o+1640531527|0,n=s[a&127]^=r+o,i=n==0?i+1:0);for(i>=128&&(s[(t&&t.length||0)&127]=-1),i=127,a=512;a>0;--a)r=s[i+34&127],n=s[i=i+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[i]=r^n;e.w=o,e.X=s,e.i=i}n(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function a(e,t){e??=+new Date;var n=new r(e),a=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21);while(r===0);return r},o.int32=n.next,o.quick=o,a&&(a.X&&i(a,n),o.state=function(){return i(n,{})}),o}t&&t.exports?t.exports=a:n&&n.amd?n(function(){return a}):this.xor4096=a})(e,typeof t==`object`&&t,typeof define==`function`&&define)})),rq=s(((e,t)=>{(function(e,t,n){function r(e){var t=this,n=``;t.next=function(){var e=t.b,n=t.c,r=t.d,i=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^i,i=i-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^i,t.a=i-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=e|0):n+=e;for(var r=0;r<n.length+20;r++)t.b^=n.charCodeAt(r)|0,t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function a(e,t){var n=new r(e),a=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21);while(r===0);return r},o.int32=n.next,o.quick=o,a&&(typeof a==`object`&&i(a,n),o.state=function(){return i(n,{})}),o}t&&t.exports?t.exports=a:n&&n.amd?n(function(){return a}):this.tychei=a})(e,typeof t==`object`&&t,typeof define==`function`&&define)})),iq=s(((e,t)=>{(function(e,n,r){var i=256,a=6,o=52,s=`random`,c=r.pow(i,a),l=r.pow(2,o),u=l*2,d=i-1,f;function p(e,t,o){var d=[];t=t==1?{entropy:!0}:t||{};var f=_(g(t.entropy?[e,y(n)]:e??v(),3),d),p=new m(d),b=function(){for(var e=p.g(a),t=c,n=0;e<l;)e=(e+n)*i,t*=i,n=p.g(1);for(;e>=u;)e/=2,t/=2,n>>>=1;return(e+n)/t};return b.int32=function(){return p.g(4)|0},b.quick=function(){return p.g(4)/4294967296},b.double=b,_(y(p.S),n),(t.pass||o||function(e,t,n,i){return i&&(i.S&&h(i,p),e.state=function(){return h(p,{})}),n?(r[s]=e,t):e})(b,f,`global`in t?t.global:this==r,t.state)}function m(e){var t,n=e.length,r=this,a=0,o=r.i=r.j=0,s=r.S=[];for(n||(e=[n++]);a<i;)s[a]=a++;for(a=0;a<i;a++)s[a]=s[o=d&o+e[a%n]+(t=s[a])],s[o]=t;(r.g=function(e){for(var t,n=0,a=r.i,o=r.j,s=r.S;e--;)t=s[a=d&a+1],n=n*i+s[d&(s[a]=s[o=d&o+t])+(s[o]=t)];return r.i=a,r.j=o,n})(i)}function h(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n=[],r=typeof e,i;if(t&&r==`object`)for(i in e)try{n.push(g(e[i],t-1))}catch{}return n.length?n:r==`string`?e:e+`\0`}function _(e,t){for(var n=e+``,r,i=0;i<n.length;)t[d&i]=d&(r^=t[d&i]*19)+n.charCodeAt(i++);return y(t)}function v(){try{var t;return f&&(t=f.randomBytes)?t=t(i):(t=new Uint8Array(i),(e.crypto||e.msCrypto).getRandomValues(t)),y(t)}catch{var r=e.navigator,a=r&&r.plugins;return[+new Date,e,a,e.screen,y(n)]}}function y(e){return String.fromCharCode.apply(0,e)}if(_(r.random(),n),typeof t==`object`&&t.exports){t.exports=p;try{f=lc()}catch{}}else typeof define==`function`&&define.amd?define(function(){return p}):r[`seed`+s]=p})(typeof self<`u`?self:e,[],Math)})),aq=s(((e,t)=>{var n=QK(),r=$K(),i=eq(),a=tq(),o=nq(),s=rq(),c=iq();c.alea=n,c.xor128=r,c.xorwow=i,c.xorshift7=a,c.xor4096=o,c.tychei=s,t.exports=c}));function oq(e){let{inputs:t,backend:n,attrs:r}=e,{logits:i}=t,{dim:a}=r,o=i.shape.length,s=a;if(s===-1&&(s=o-1),s!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${s}`);let c=we([s],i.shape),l=bK({inputs:{x:i},backend:n,attrs:{reductionIndices:c,keepDims:!1}}),u=If(l.shape,c),d=lH({inputs:{x:l},backend:n,attrs:{shape:u}}),f=jV({inputs:{a:i,b:d},backend:n}),p=dz({inputs:{x:f},backend:n}),m=VW({inputs:{x:p},backend:n,attrs:{axis:c,keepDims:!1}}),h=lH({inputs:{x:m},backend:n,attrs:{shape:u}}),g=lG({inputs:{a:p,b:h},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(h),g}var sq,cq=o((()=>{Y(),pz(),SK(),dG(),dH(),NV(),UW(),sq={kernelName:Pr,backendName:`cpu`,kernelFunc:oq}}));function lq(e){let{inputs:t,backend:n,attrs:r}=e,{logits:i}=t,{numSamples:a,seed:o,normalized:s}=r;lR(i,`multinomial`);let c=s?i:oq({inputs:{logits:i},backend:n,attrs:{dim:-1}}),l=c.shape[0],u=c.shape[1],d=n.data.get(c.dataId).values,f=[l,a],p=We(O(f),`int32`);for(let e=0;e<l;++e){let t=e*u,n=new Float32Array(u-1);n[0]=d[t];for(let e=1;e<n.length;++e)n[e]=n[e-1]+d[t+e];let r=uq.alea(o.toString()),i=e*a;for(let e=0;e<a;++e){let t=r();p[i+e]=n.length;for(let r=0;r<n.length;r++)if(t<n[r]){p[i+e]=r;break}}}return s||n.disposeIntermediateTensorInfo(c),n.makeTensorInfo(f,`int32`,p)}var uq,dq,fq=o((()=>{Y(),uq=u(aq()),uR(),cq(),dq={kernelName:Kn,backendName:`cpu`,kernelFunc:lq}}));function pq(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:i,scores:a}=t,{maxOutputSize:o,iouThreshold:s,scoreThreshold:c}=r;lR(i,`NonMaxSuppression`);let l=n.data.get(i.dataId).values,u=n.data.get(a.dataId).values,{selectedIndices:d}=mq(l,u,o,s,c);return n.makeTensorInfo([d.length],`int32`,new Int32Array(d))}var mq,hq,gq=o((()=>{Y(),uR(),mq=sy,hq={kernelName:Yn,backendName:`cpu`,kernelFunc:pq}}));function _q(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:i,scores:a}=t,{maxOutputSize:o,iouThreshold:s,scoreThreshold:c,padToMaxOutputSize:l}=r;lR(i,`NonMaxSuppressionPadded`);let u=n.data.get(i.dataId).values,d=n.data.get(a.dataId).values,{selectedIndices:f,validOutputs:p}=vq(u,d,o,s,c,l);return[n.makeTensorInfo([f.length],`int32`,new Int32Array(f)),n.makeTensorInfo([],`int32`,new Int32Array([p]))]}var vq,yq,bq=o((()=>{Y(),uR(),vq=cy,yq={kernelName:Xn,backendName:`cpu`,kernelFunc:_q}}));function xq(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:i,scores:a}=t,{maxOutputSize:o,iouThreshold:s,scoreThreshold:c,softNmsSigma:l}=r;lR(i,`NonMaxSuppressionWithScore`);let u=n.data.get(i.dataId).values,d=n.data.get(a.dataId).values,{selectedIndices:f,selectedScores:p}=Sq(u,d,o,s,c,l);return[n.makeTensorInfo([f.length],`int32`,new Int32Array(f)),n.makeTensorInfo([p.length],`float32`,new Float32Array(p))]}var Sq,Cq,wq=o((()=>{Y(),uR(),Sq=ly,Cq={kernelName:Zn,backendName:`cpu`,kernelFunc:xq}}));function Tq(e){let{inputs:t,backend:n,attrs:r}=e,{indices:i}=t,{dtype:a,depth:o,onValue:s,offValue:c}=r;lR(i,`oneHot`);let l=O(i.shape),u=new Float32Array(l*o);u.fill(c);let d=n.data.get(i.dataId).values;for(let e=0;e<l;++e)d[e]>=0&&d[e]<o&&(u[e*o+d[e]]=s);return n.makeTensorInfo([...i.shape,o],a,u)}var Eq,Dq=o((()=>{Y(),uR(),Eq={kernelName:$n,backendName:`cpu`,kernelFunc:Tq}}));function Oq(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype===`string`)throw Error(`zerosLike is not supported for string tensors`);if(r.dtype===`complex64`){let e=DR({inputs:{input:r},backend:n}),t=Oq({inputs:{x:e},backend:n}),i=kU({inputs:{input:r},backend:n}),a=Oq({inputs:{x:i},backend:n}),o=yR({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),o}else return xG({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var kq,Aq=o((()=>{Y(),xR(),wG(),jU(),kR(),kq={kernelName:ni,backendName:`cpu`,kernelFunc:Oq}}));function jq(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype===`string`)throw Error(`onesLike is not supported for string tensors`);if(r.dtype===`complex64`){let e=DR({inputs:{input:r},backend:n}),t=jq({inputs:{x:e},backend:n}),i=kU({inputs:{input:r},backend:n}),a=Oq({inputs:{x:i},backend:n}),o=yR({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),o}else return xG({backend:n,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}var Mq,Nq=o((()=>{Y(),xR(),wG(),jU(),kR(),Aq(),Mq={kernelName:Qn,backendName:`cpu`,kernelFunc:jq}}));function Pq(e){let{inputs:t,backend:n,attrs:r}=e,{axis:i}=r;if(t.length===1)return aG({inputs:{input:t[0]},backend:n,attrs:{dim:i}});let a=t[0].shape,o=t[0].dtype;t.forEach(e=>{fe(a,e.shape,`All tensors passed to stack must have matching shapes`),D(o===e.dtype,()=>`All tensors passed to stack must have matching dtypes`)});let s=[],c=t.map(e=>{let t=aG({inputs:{input:e},backend:n,attrs:{dim:i}});return s.push(t),t}),l=MU({inputs:c,backend:n,attrs:{axis:i}});return s.forEach(e=>n.disposeIntermediateTensorInfo(e)),l}var Fq,Iq=o((()=>{Y(),PU(),sG(),Fq={kernelName:er,backendName:`cpu`,kernelFunc:Pq}}));function Lq(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{paddings:a,constantValue:o}=r;lR(i,`pad`);let s=a.map((e,t)=>e[0]+i.shape[t]+e[1]),c=a.map(e=>e[0]),l=n.data.get(i.dataId).values,u=O(i.shape),d=i.shape.length,f=ze(i.shape),p=O(s),m=s.length,h=ze(s),g=Ee(i.dtype,p);o!==0&&g.fill(o);for(let e=0;e<u;e++){let t=Je(e,d,f).map((e,t)=>e+c[t]),n=qe(t,m,h);g[n]=l[e]}return{dataId:n.write(g,s,i.dtype),shape:s,dtype:i.dtype}}var Rq,zq=o((()=>{Y(),uR(),Rq={kernelName:tr,backendName:`cpu`,kernelFunc:Lq}})),Bq,Vq,Hq,Uq=o((()=>{Y(),vR(),IR(),Bq=_R((e,t)=>e**+t),Vq=PR(`Pow`,Bq),Hq={kernelName:`Pow`,backendName:`cpu`,kernelFunc:Vq}}));function Wq(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:i,paramsDenseValues:a,indices:o}=t,{outputRaggedRank:s}=r,c=i.map(e=>n.data.get(e.dataId).values),l=i.map(e=>e.shape),u=n.data.get(a.dataId).values,d=n.data.get(o.dataId).values,[f,p,m]=kB(c,l,u,a.shape,a.dtype,d,o.shape,s),h=f.map(e=>n.makeTensorInfo([e.length],`int32`,e)),g=n.makeTensorInfo(m,a.dtype,p);return h.concat([g])}var Gq,Kq=o((()=>{Y(),AB(),Gq={kernelName:ar,backendName:`cpu`,kernelFunc:Wq}}));function qq(e){let{inputs:t,backend:n}=e,{starts:r,limits:i,deltas:a}=t,o=n.data.get(r.dataId).values,s=n.data.get(i.dataId).values,c=n.data.get(a.dataId).values,[l,u]=jB(o,r.shape,r.dtype,s,i.shape,c,a.shape),d=n.makeTensorInfo([l.length],`int32`,l),f=n.makeTensorInfo([u.length],r.dtype,u);return[d,f]}var Jq,Yq=o((()=>{Y(),NB(),Jq={kernelName:or,backendName:`cpu`,kernelFunc:qq}}));function Xq(e){let{inputs:t,backend:n,attrs:r}=e,{shape:i,values:a,defaultValue:o,rowPartitionTensors:s}=t,{rowPartitionTypes:c}=r,l=n.data.get(i.dataId).values,u=n.data.get(a.dataId).values,d=n.data.get(o.dataId).values,f=s.map(e=>n.data.get(e.dataId).values),p=s.map(e=>e.shape),[m,h]=IB(l,i.shape,u,a.shape,a.dtype,d,o.shape,f,p,c);return n.makeTensorInfo(m,a.dtype,h)}var Zq,Qq=o((()=>{Y(),zB(),Zq={kernelName:sr,backendName:`cpu`,kernelFunc:Xq}}));function $q(e){let{backend:t,attrs:n}=e,{start:r,stop:i,dtype:a,step:o}=n,s=BB(r,i,o,a);return t.makeTensorInfo([s.length],a,s)}var eJ,tJ=o((()=>{Y(),VB(),eJ={kernelName:cr,backendName:`cpu`,kernelFunc:$q}})),nJ,rJ,iJ=o((()=>{Y(),$R(),nJ=ZR(ur,e=>1/e),rJ={kernelName:ur,backendName:`cpu`,kernelFunc:nJ}}));function aJ(e){let{inputs:t,backend:n,attrs:r}=e,{images:i}=t,{alignCorners:a,halfPixelCenters:o,size:s}=r;lR(i,`resizeBilinear`);let c=ze(i.shape),[l,u]=s,[d,f,p,m]=i.shape,h=n.data.get(i.dataId).values,g=new Float32Array(O([d,l,u,m])),_=[a&&l>1?f-1:f,a&&u>1?p-1:p],v=[a&&l>1?l-1:l,a&&u>1?u-1:u],y=0,b=_[0]/v[0],x=_[1]/v[1];for(let e=0;e<d;e++)for(let t=0;t<l;t++){let n;n=o?b*(t+.5)-.5:b*t;let r=Math.max(0,Math.floor(n)),i=n-r,a=Math.min(f-1,Math.ceil(n)),s=e*c[0]+r*c[1],l=e*c[0]+a*c[1];for(let e=0;e<u;e++){let t;t=o?x*(e+.5)-.5:x*e;let n=Math.max(0,Math.floor(t)),r=t-n,a=Math.min(p-1,Math.ceil(t)),u=s+n*c[2],d=l+n*c[2],f=s+a*c[2],_=l+a*c[2];for(let e=0;e<m;e++){let t=h[u+e],n=h[d+e],a=h[f+e],o=h[_+e],s=t+(a-t)*r,c=n+(o-n)*r,l=s+(c-s)*i;g[y++]=l}}}return n.makeTensorInfo([d,l,u,m],`float32`,g)}var oJ,sJ=o((()=>{Y(),uR(),oJ={kernelName:hr,backendName:`cpu`,kernelFunc:aJ}}));function cJ(e){let{inputs:t,backend:n,attrs:r}=e,{images:i,dy:a}=t,{alignCorners:o}=r;lR([a,i],`resizeBilinearGrad`);let s=ze(i.shape),[c,l,u,d]=i.shape,[,f,p]=a.shape,m=new Float32Array(c*l*u*d),h=[o&&f>1?l-1:l,o&&p>1?u-1:u],g=[o&&f>1?f-1:f,o&&p>1?p-1:p],_=h[0]/g[0],v=h[1]/g[1],y=n.data.get(a.dataId).values,b=0;for(let e=0;e<c;e++){let t=e*s[0];for(let e=0;e<f;e++){let n=e*_,r=Math.floor(n),i=Math.min(Math.ceil(n),l-1),a=t+r*s[1],o=t+i*s[1],c=n-r,f=1-c;for(let e=0;e<p;e++){let t=e*v,n=Math.floor(t),r=Math.min(Math.ceil(t),u-1),i=t-n,l=1-i,p=a+n*s[2],h=a+r*s[2],g=o+n*s[2],_=o+r*s[2],x=f*l,S=f*i,C=c*l,w=c*i;for(let e=0;e<d;e++){let t=y[b++];m[p+e]+=t*x,m[h+e]+=t*S,m[g+e]+=t*C,m[_+e]+=t*w}}}}return n.makeTensorInfo([c,u,l,d],`float32`,m)}var lJ,uJ=o((()=>{Y(),uR(),lJ={kernelName:gr,backendName:`cpu`,kernelFunc:cJ}}));function dJ(e){let{inputs:t,backend:n,attrs:r}=e,{images:i}=t,{alignCorners:a,halfPixelCenters:o,size:s}=r;lR(i,`resizeNearestNeighbor`);let c=ze(i.shape),[l,u]=s,[d,f,p,m]=i.shape,h=n.data.get(i.dataId).values,g=new Float32Array(d*l*u*m),_=[a&&l>1?f-1:f,a&&u>1?p-1:p],v=[a&&l>1?l-1:l,a&&u>1?u-1:u],y=_[0]/v[0],b=_[1]/v[1],x=0;for(let e=0;e<d;e++){let t=e*c[0];for(let e=0;e<l;e++){let n=o?y*(e+.5):y*e,r=Math.min(f-1,a?Math.round(n):Math.floor(n));o&&(r=Math.max(0,r));let i=t+r*c[1];for(let e=0;e<u;e++){let t=o?b*(e+.5):b*e,n=Math.min(p-1,a?Math.round(t):Math.floor(t));o&&(n=Math.max(0,n));let r=i+n*c[2];for(let e=0;e<m;e++){let t=h[r+e];g[x++]=t}}}}return n.makeTensorInfo([d,l,u,m],i.dtype,g)}var fJ,pJ=o((()=>{Y(),uR(),fJ={kernelName:pr,backendName:`cpu`,kernelFunc:dJ}}));function mJ(e){let{inputs:t,backend:n,attrs:r}=e,{images:i,dy:a}=t,{alignCorners:o}=r;lR([a,i],`resizeNearestNeighborGrad`);let s=ze(i.shape),c=ze(a.shape),[l,u,d,f]=i.shape,[,p,m]=a.shape,h=new Float32Array(l*u*d*f),g=n.data.get(a.dataId).values,_=[o&&p>1?u-1:u,o&&m>1?d-1:d],v=[o&&p>1?p-1:p,o&&m>1?m-1:m],y=_[0]/v[0],b=_[1]/v[1],x=1/y,S=1/b,C=Math.ceil(x)*2+2,w=Math.ceil(S)*2+2;for(let e=0;e<l;e++){let t=e*s[0];for(let e=0;e<u;e++){let n=t+e*s[1],r=Math.floor(e*x),i=Math.floor(r-C/2);for(let r=0;r<d;r++){let a=n+r*s[2],l=Math.floor(r*S),_=Math.floor(l-w/2);for(let n=0;n<f;n++){let s=0;for(let a=0;a<C;a++){let l=a+i;if(l<0||l>=p)continue;let f=t+l*c[1],h=l*y,v=Math.min(u-1,o?Math.round(h):Math.floor(h));if(e===v)for(let e=0;e<w;e++){let t=e+_;if(t<0||t>=m)continue;let i=f+t*c[2],a=t*b,l=Math.min(d-1,o?Math.round(a):Math.floor(a));r===l&&(s+=g[i+n])}}h[a+n]=s}}}}return n.makeTensorInfo(i.shape,i.dtype,h)}var hJ,gJ=o((()=>{Y(),uR(),hJ={kernelName:mr,backendName:`cpu`,kernelFunc:mJ}}));function _J(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{dims:a}=r;lR(i,`reverse`);let o=i.shape.length,s=we(a,i.shape);if(o===0)return wR({inputs:{x:i},backend:n});let c=new xa(i.shape,i.dtype),l=n.bufferSync(i);for(let e=0;e<c.size;e++){let t=c.indexToLoc(e),n=t.slice();s.forEach(e=>n[e]=i.shape[e]-1-n[e]),c.set(l.get(...n),...t)}return n.makeTensorInfo(c.shape,c.dtype,c.values)}var vJ,yJ=o((()=>{Y(),uR(),ER(),vJ={kernelName:vr,backendName:`cpu`,kernelFunc:_J}})),bJ,xJ=o((()=>{Y(),bJ={kernelName:ai,backendName:`cpu`,kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:i,fillValue:a,center:o}=t,s=n,c=Ee(r.dtype,O(r.shape)),[l,u,d,f]=r.shape,[p,m]=OS(o,u,d),h=Math.sin(i),g=Math.cos(i),_=s.data.get(r.dataId).values;for(let e=0;e<l;e++){let t=e*d*u*f;for(let e=0;e<u;e++){let n=e*(d*f);for(let r=0;r<d;r++){let i=r*f;for(let o=0;o<f;o++){let s=[l,e,r,o],v=s[2],y=s[1],b=(v-p)*g-(y-m)*h,x=(v-p)*h+(y-m)*g;b=Math.round(b+p),x=Math.round(x+m);let S=a;if(typeof a!=`number`&&(S=o===3?255:a[o]),b>=0&&b<d&&x>=0&&x<u){let e=x*(d*f),n=b*f,r=t+e+n+o;S=_[r]}let C=t+n+i+o;c[C]=S}}}}return{dataId:s.write(c,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}}})),SJ,CJ,wJ=o((()=>{Y(),$R(),SJ=ZR(yr,e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2==0?t:t+1}),CJ={kernelName:yr,backendName:`cpu`,kernelFunc:SJ}}));function TJ(e){let{inputs:t,backend:n,attrs:r}=e,{indices:i,updates:a}=t,{shape:o}=r,{sliceRank:s,numUpdates:c,sliceSize:l,strides:u,outputSize:d}=Y_(a,i,o),f=n.bufferSync(i),p=n.bufferSync(a),m=KB(f,p,o,d,l,c,s,u,0,!0);return n.makeTensorInfo(o,m.dtype,m.values)}var EJ,DJ=o((()=>{Y(),qB(),EJ={kernelName:xr,backendName:`cpu`,kernelFunc:TJ}}));function OJ(e,t){let n=0,r=e.length,i=0;for(;n<r;)i=Math.floor((n+r)/2),e[i]<t?n=i+1:r=i;return r}function kJ(e,t){let n=0,r=e.length,i=0;for(;n<r;)i=Math.floor((n+r)/2),e[i]<=t?n=i+1:r=i;return r}function AJ(e,t,n,r,i,a){let o=De(`int32`,n*i);for(let s=0;s<n;++s){let n=e.slice(s*r,(s+1)*r),c=s*i;for(let e=0;e<i;++e)o[c+e]=a===`left`?OJ(n,t[e+c]):kJ(n,t[e+c])}return o}var jJ=o((()=>{Y()}));function MJ(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:i,values:a}=t,{side:o}=r,s=n.data.get(i.dataId).values,c=n.data.get(a.dataId).values,l=AJ(s,c,i.shape[0],i.shape[1],a.shape[1],o);return n.makeTensorInfo(a.shape,`int32`,l)}var NJ,PJ=o((()=>{Y(),jJ(),NJ={kernelName:Cr,backendName:`cpu`,kernelFunc:MJ}}));function FJ(e){let{inputs:t,backend:n}=e,{condition:r,t:i,e:a}=t;lR([r,i,a],`select`);let o=r.shape.length,s=n.data.get(r.dataId).values,c=n.data.get(i.dataId).values,l=n.data.get(a.dataId).values,u=Ea(i.dtype,a.dtype),d=We(O(i.shape),u),f=0,p=o===0||o>1||i.shape.length===1?1:O(i.shape.slice(1));for(let e=0;e<s.length;e++)for(let t=0;t<p;t++)s[e]===1?d[f++]=c[e]:d[f++]=l[e];return n.makeTensorInfo(i.shape,u,d)}var IJ,LJ=o((()=>{Y(),uR(),IJ={kernelName:wr,backendName:`cpu`,kernelFunc:FJ}})),RJ,zJ,BJ,VJ,HJ=o((()=>{Y(),$R(),RJ=PS,zJ=FS,BJ=ZR(Tr,e=>e>=0?zJ*e:RJ*(Math.exp(e)-1)),VJ={kernelName:Tr,backendName:`cpu`,kernelFunc:BJ}})),UJ,WJ,GJ=o((()=>{Y(),$R(),UJ=ZR(Or,e=>e<0?-1:e>0?1:0),WJ={kernelName:Or,backendName:`cpu`,kernelFunc:UJ}})),KJ,qJ,JJ=o((()=>{Y(),$R(),KJ=ZR(`Sin`,e=>Math.sin(e)),qJ={kernelName:`Sin`,backendName:`cpu`,kernelFunc:KJ}})),YJ,XJ,ZJ=o((()=>{Y(),$R(),YJ=ZR(Dr,e=>Math.sinh(e)),XJ={kernelName:Dr,backendName:`cpu`,kernelFunc:YJ}})),QJ,$J,eY,tY=o((()=>{Y(),$R(),QJ=Math.log(1.1920928955078125e-7)+2,$J=ZR(Ar,e=>{let t=e>-QJ,n=e<QJ,r=Math.exp(e),i;return i=n?r:t?e:Math.log(1+r),i}),eY={kernelName:Ar,backendName:`cpu`,kernelFunc:$J}}));function nY(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{blockShape:a,paddings:o}=r;lR([i],`spaceToBatchND`);let s=O(a),c=[[0,0]];c.push(...o);for(let e=1+a.length;e<i.shape.length;++e)c.push([0,0]);let l=Rq.kernelFunc({inputs:{x:i},backend:n,attrs:{paddings:c,constantValue:0}}),u=kS(l.shape,a,s,!1),d=AS(u.length,a.length,!1),f=jS(l.shape,a,s,!1),p=lH({inputs:{x:l},backend:n,attrs:{shape:u}}),m=SB({inputs:{x:p},backend:n,attrs:{perm:d}}),h=lH({inputs:{x:m},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),h}var rY,iY=o((()=>{Y(),uR(),zq(),dH(),wB(),rY={kernelName:Mr,backendName:`cpu`,kernelFunc:nY}}));function aY(e){let{inputs:t,backend:n}=e,{indices:r,values:i,denseShape:a,defaultValue:o}=t;if(a.shape.length!==1)throw Error(`Dense shape must be a vector, saw:
        ${a.shape}`);if(r.shape.length!==2)throw Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(i.shape.length!==1)throw Error(`Values must be a vector, saw:
        ${i.shape}`);if(o.shape.length!==0)throw Error(`Default value must be a scalar, saw:
        ${o.shape}`);let s=n.data.get(r.dataId).values,c=n.data.get(i.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(o.dataId).values[0],[d,f,p,m,h]=nV(s,r.shape,r.dtype,c,i.dtype,l,u);return[n.makeTensorInfo(f,r.dtype,d),n.makeTensorInfo([f[0]],i.dtype,p),n.makeTensorInfo([m.length],`bool`,new Uint8Array(m.map(e=>Number(e)))),n.makeTensorInfo([h.length],r.dtype,new Int32Array(h))]}var oY,sY=o((()=>{Y(),rV(),oY={kernelName:Fr,backendName:`cpu`,kernelFunc:aY}}));function cY(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:i,newShape:a}=t;if(r.shape.length!==2)throw Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(i.shape.length!==1)throw Error(`Input shape should be a vector but received shape
        ${i.shape}`);if(a.shape.length!==1)throw Error(`Target shape should be a vector but received shape ${a.shape}`);let o=Array.from(n.data.get(i.dataId).values),s=n.data.get(r.dataId).values,c=Array.from(n.data.get(a.dataId).values),[l,u,d]=iV(s,r.shape,r.dtype,o,c);return[n.makeTensorInfo(u,r.dtype,l),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}var lY,uY=o((()=>{Y(),aV(),lY={kernelName:Ir,backendName:`cpu`,kernelFunc:cY}}));function dY(e){let{inputs:t,backend:n}=e,{data:r,indices:i,segmentIds:a}=t;if(r.shape.length<1)throw Error(`Data should be at least 1 dimensional but received scalar`);if(i.shape.length!==1)throw Error(`Indices should be a vector but received shape
          ${i.shape}`);if(a.shape.length!==1)throw Error(`Segment ids should be a vector but received shape
          ${a.shape}`);if(i.shape[0]!==a.shape[0])throw Error(`segmentIds and indices should have same size.`);let o=n.data.get(r.dataId).values,s=n.data.get(i.dataId).values,c=n.data.get(a.dataId).values,[l,u]=oV(o,r.shape,r.dtype,s,c,!0);return n.makeTensorInfo(u,r.dtype,l)}var fY,pY=o((()=>{Y(),sV(),fY={kernelName:Lr,backendName:`cpu`,kernelFunc:dY}}));function mY(e){let{inputs:t,backend:n}=e,{data:r,indices:i,segmentIds:a}=t;if(r.shape.length<1)throw Error(`Data should be at least 1 dimensional but received scalar`);if(i.shape.length!==1)throw Error(`Indices should be a vector but received shape
         ${i.shape}`);if(a.shape.length!==1)throw Error(`Segment ids should be a vector but received shape
         ${a.shape}`);if(i.shape[0]!==a.shape[0])throw Error(`segmentIds and indices should have same size.`);let o=n.data.get(r.dataId).values,s=n.data.get(i.dataId).values,c=n.data.get(a.dataId).values,[l,u]=oV(o,r.shape,r.dtype,s,c);return n.makeTensorInfo(u,r.dtype,l)}var hY,gY=o((()=>{Y(),sV(),hY={kernelName:Rr,backendName:`cpu`,kernelFunc:mY}}));function _Y(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:i,sparseValues:a,defaultValue:o}=t,{outputShape:s}=r,{sliceRank:c,numUpdates:l,sliceSize:u,strides:d,outputSize:f}=Y_(a,i,s),p=n.bufferSync(i),m;switch(a.dtype){case`bool`:{let e=n.bufferSync(a),t=!!n.data.get(o.dataId).values[0];m=KB(p,e,s,f,u,l,c,d,t,!1);break}case`float32`:{let e=n.bufferSync(a),t=n.data.get(o.dataId).values[0];m=KB(p,e,s,f,u,l,c,d,t,!1);break}case`int32`:{let e=n.bufferSync(a),t=n.data.get(o.dataId).values[0];m=KB(p,e,s,f,u,l,c,d,t,!1);break}case`string`:{let e=n.bufferSync(a),t=$i(n.data.get(o.dataId).values[0]);m=KB(p,e,s,f,u,l,c,d,t,!1);break}default:throw Error(`Unsupported type ${a.dtype}`)}return n.makeTensorInfo(s,m.dtype,m.values)}var vY,yY=o((()=>{Y(),qB(),vY={kernelName:zr,backendName:`cpu`,kernelFunc:_Y}}));function bY(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{numOrSizeSplits:a,axis:o}=r,s=we(o,i.shape)[0],c=oC(i,a,s),l=Array(i.shape.length).fill(0),u=i.shape.slice();return c.map(e=>{let t=[...u];t[s]=e;let r=$B({inputs:{x:i},backend:n,attrs:{begin:l,size:t}});return l[s]+=e,r})}var xY,SY=o((()=>{Y(),tV(),xY={kernelName:Nr,backendName:`cpu`,kernelFunc:bY}})),CY,wY=o((()=>{Y(),uR(),CY={kernelName:Vr,backendName:`cpu`,kernelFunc:({inputs:e,backend:t})=>{let{x:n}=e,r=t;lR(n,`square`);let i=r.data.get(n.dataId).values,a=new Float32Array(i.length);for(let e=0;e<i.length;++e){let t=i[e];a[e]=t*t}return{dataId:r.write(a,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}}})),TY,EY,DY=o((()=>{Y(),$R(),TY=ZR(ri,(e,t)=>{let n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),EY={kernelName:ri,backendName:`cpu`,kernelFunc:TY}}));function OY(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{begin:a,end:o,strides:s,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:f}=r;lR(i,`stridedSlice`);let{finalShapeSparse:p,finalShape:m,isIdentity:h,sliceDim0:g,isSimpleSlice:_,begin:v,end:y,strides:b}=cS(i.shape,a,o,s,c,l,u,d,f),x;if(h)x=lH({inputs:{x:i},backend:n,attrs:{shape:m}});else if(g||_){D(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);let e=Xx(v,y,b),t=$B({inputs:{x:i},backend:n,attrs:{begin:v,size:e}});x=lH({inputs:{x:t},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(t)}else{let e=n.bufferSync(i),t=bV(p,e,b,v);x=n.makeTensorInfo(m,t.dtype,t.values)}return x}var kY,AY=o((()=>{Y(),uR(),dH(),tV(),xV(),kY={kernelName:Ur,backendName:`cpu`,kernelFunc:OY}}));function jY(e){let{inputs:t,backend:n,attrs:r}=e,{separator:i,nGramWidths:a,leftPad:o,rightPad:s,padWidth:c,preserveShortSequences:l}=r,{data:u,dataSplits:d}=t,f=n.data.get(u.dataId).values,p=n.data.get(d.dataId).values,[m,h]=SV(f,p,i,a,o,s,c,l);return[n.makeTensorInfo([m.length],`string`,m),n.makeTensorInfo(d.shape,`int32`,h)]}var MY,NY=o((()=>{Y(),wV(),MY={kernelName:Wr,backendName:`cpu`,kernelFunc:jY}}));function PY(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:i}=r,{input:a,delimiter:o}=t;if(a.dtype!==`string`)throw Error(`Input must be of datatype string`);if(a.shape.length!==1)throw Error(`Input must be a vector, got shape: ${a.shape}`);if(o.shape.length!==0)throw Error(`Delimiter must be a scalar, got shape: ${o.shape}`);let s=n.data.get(a.dataId).values,c=n.data.get(o.dataId).values[0],[l,u,d]=TV(s,c,i),f=u.length;return[n.makeTensorInfo([f,2],`int32`,l),n.makeTensorInfo([f],`string`,u),n.makeTensorInfo([2],`int32`,new Int32Array(d))]}var FY,IY=o((()=>{Y(),EV(),FY={kernelName:Gr,backendName:`cpu`,kernelFunc:PY}}));function LY(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:i}=r,{input:a}=t;if(a.dtype!==`string`)throw Error(`Input must be of datatype string`);if(i<=0)throw Error(`Number of buckets must be at least 1`);let o=n.data.get(a.dataId).values,s=DV(o,i);return n.makeTensorInfo(a.shape,`int32`,s)}var RY,zY=o((()=>{Y(),OV(),RY={kernelName:Kr,backendName:`cpu`,kernelFunc:LY}})),BY,VY,HY=o((()=>{Y(),$R(),BY=ZR(`Tan`,e=>Math.tan(e)),VY={kernelName:`Tan`,backendName:`cpu`,kernelFunc:BY}})),UY,WY,GY=o((()=>{Y(),$R(),UY=ZR(qr,e=>Math.tanh(e)),WY={kernelName:qr,backendName:`cpu`,kernelFunc:UY}}));function KY(e){let{inputs:t,backend:n}=e,{tensor:r,indices:i,updates:a}=t,{sliceRank:o,numUpdates:s,sliceSize:c,strides:l,outputSize:u}=Y_(a,i,r.shape),d=n.bufferSync(i),f=n.bufferSync(a),p=n.bufferSync(r),m=KB(d,f,r.shape,u,c,s,o,l,p,!1);return n.makeTensorInfo(r.shape,m.dtype,m.values)}var qY,JY=o((()=>{Y(),qB(),qY={kernelName:Sr,backendName:`cpu`,kernelFunc:KY}}));function YY(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{reps:a}=r;lR(i,`tile`);let o=PV(n.bufferSync(i),a);return n.makeTensorInfo(o.shape,o.dtype,o.values)}var XY,ZY=o((()=>{Y(),uR(),FV(),XY={kernelName:Jr,backendName:`cpu`,kernelFunc:YY}}));function QY(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{k:a,sorted:o}=r;lR(i,`topk`);let s=n.data.get(i.dataId).values,[c,l]=LV(s,i.shape,i.dtype,a,o);return[n.makeTensorInfo(c.shape,c.dtype,c.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}var $Y,eX=o((()=>{Y(),uR(),zV(),$Y={kernelName:Yr,backendName:`cpu`,kernelFunc:QY}}));function tX(e){let{inputs:t,attrs:n,backend:r}=e,{image:i,transforms:a}=t,{interpolation:o,fillMode:s,fillValue:c,outputShape:l}=n,[u,d,f,p]=i.shape,[m,h]=l??[d,f],g=[u,m,h,p],_=ze(i.shape),v=_[0],y=_[1],b=_[2],x=ze(g),S=x[0],C=x[1],w=x[2],T=Ee(i.dtype,O(g));T.fill(c);let ee=r.data.get(i.dataId).values,E=r.data.get(a.dataId).values;for(let e=0;e<u;++e){let t=a.shape[0]===1?E:E.subarray(e*8,e*8+8);for(let n=0;n<m;++n)for(let r=0;r<h;++r)for(let i=0;i<p;++i){let a,l=t[6]*r+t[7]*n+1;if(l===0)continue;let u=(t[0]*r+t[1]*n+t[2])/l,p=(t[3]*r+t[4]*n+t[5])/l,m=nX(u,f,s),h=nX(p,d,s);switch(o){case`nearest`:a=cX(ee,d,f,v,y,b,e,h,m,i,c);break;case`bilinear`:a=lX(ee,d,f,v,y,b,e,h,m,i,c);break;default:throw Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}let g=e*S+n*C+r*w+i;T[g]=a}return r.makeTensorInfo(g,i.dtype,T)}return{dataId:r.write(T,g,i.dtype),shape:i.shape,dtype:i.dtype}}function nX(e,t,n){switch(n){case`reflect`:return rX(e,t);case`wrap`:return iX(e,t);case`nearest`:return oX(e,t);case`constant`:default:return aX(e,t)}}function rX(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{let e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return oe(0,n,t-1)}function iX(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{let e=t-1;n-=t*Math.trunc(n/e)}return oe(0,n,t-1)}function aX(e,t){return e}function oX(e,t){return oe(0,e,t-1)}function sX(e,t,n,r,i,a,o,s,c,l,u){let d=o*r+s*i+c*a+l;return 0<=s&&s<t&&0<=c&&c<n?e[d]:u}function cX(e,t,n,r,i,a,o,s,c,l,u){return sX(e,t,n,r,i,a,o,Math.round(s),Math.round(c),l,u)}function lX(e,t,n,r,i,a,o,s,c,l,u){let d=Math.floor(s),f=Math.floor(c),p=d+1,m=f+1,h=(m-c)*sX(e,t,n,r,i,a,o,d,f,l,u)+(c-f)*sX(e,t,n,r,i,a,o,d,m,l,u),g=(m-c)*sX(e,t,n,r,i,a,o,p,f,l,u)+(c-f)*sX(e,t,n,r,i,a,o,p,m,l,u);return(p-s)*h+(s-d)*g}var uX,dX=o((()=>{Y(),uX={kernelName:Xr,backendName:`cpu`,kernelFunc:tX}}));function fX(e){let{inputs:t,attrs:n,backend:r}=e,{axis:i}=n,{x:a}=t;lR(a,`unique`);let o=r.data.get(a.dataId).values,{outputValues:s,outputShape:c,indices:l}=BV(o,i,a.shape,a.dtype);return[r.makeTensorInfo(c,a.dtype,s),r.makeTensorInfo([l.length],`int32`,l)]}var pX,mX=o((()=>{Y(),uR(),VV(),pX={kernelName:Qr,backendName:`cpu`,kernelFunc:fX}}));function hX(e){let{inputs:t,backend:n,attrs:r}=e,{value:i}=t,{axis:a}=r;a<0&&(a+=i.shape.length);let o=i.shape.length,s=i.shape[a],c=Array(o-1),l=0;for(let e=0;e<o;e++)e!==a&&(c[l++]=i.shape[e]);let u=Array(o).fill(0),d=i.shape.slice();d[a]=1;let f=Array(s);for(let e=0;e<f.length;e++){u[a]=e;let t=$B({inputs:{x:i},backend:n,attrs:{begin:u,size:d}});f[e]=lH({inputs:{x:t},backend:n,attrs:{shape:c}}),n.disposeIntermediateTensorInfo(t)}return f}var gX,_X=o((()=>{Y(),dH(),tV(),gX={kernelName:$r,backendName:`cpu`,kernelFunc:hX}}));function vX(e){let{inputs:t,backend:n,attrs:r}=e,{x:i,segmentIds:a}=t,{numSegments:o}=r;lR(i,`unsortedSegmentSum`);let s=i.shape.length,c=a.shape.length,l=[],u=[],d=s-c,f=a;for(let e=0;e<d;++e){let t=aG({inputs:{input:f},backend:n,attrs:{dim:e+1}});f=t,u.push(t)}for(let e=0;e<o;++e){let t=qi(e,`int32`),r=n.makeTensorInfo([],`int32`,t),a=sz({inputs:{a:r,b:f},backend:n}),o=jR({inputs:{x:a},backend:n,attrs:{dtype:`float32`}}),s=uB({inputs:{a:o,b:i},backend:n}),c=VW({inputs:{x:s},backend:n,attrs:{axis:0,keepDims:!1}});l.push(c),u.push(r),u.push(a),u.push(o),u.push(s),u.push(c)}let p=Pq({inputs:l,backend:n,attrs:{axis:0}});return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),p}var yX,bX=o((()=>{Y(),uR(),NR(),lz(),sG(),fB(),Iq(),UW(),yX={kernelName:ei,backendName:`cpu`,kernelFunc:vX}})),xX,SX=o((()=>{Y(),Rfe(),gR(),zfe(),Bfe(),VR(),Hfe(),SH(),TH(),OH(),jH(),PH(),LH(),BH(),WH(),qH(),tU(),iU(),sU(),uU(),mH(),pU(),gU(),yU(),JR(),SU(),NR(),rz(),TU(),xR(),OU(),PU(),LU(),BU(),UU(),KU(),YU(),QU(),tW(),iW(),sW(),uW(),pW(),gW(),yW(),SW(),TW(),OW(),jW(),NW(),FW(),LW(),BW(),KW(),qV(),YW(),lz(),iG(),pz(),sG(),_z(),bG(),wG(),EG(),xz(),Tz(),kG(),MG(),FG(),RG(),Nz(),Lz(),ER(),VG(),jU(),WG(),qG(),XG(),XV(),Vz(),Gz(),$G(),Zz(),nK(),oK(),lK(),pK(),gK(),yK(),SK(),rB(),TK(),OK(),jK(),PK(),RK(),VK(),WK(),sB(),qK(),ZK(),fq(),fB(),hB(),gq(),bq(),wq(),yB(),Dq(),Nq(),Iq(),zq(),Uq(),eH(),DB(),Kq(),Yq(),Qq(),tJ(),kR(),dG(),iJ(),rH(),oH(),dH(),sJ(),uJ(),pJ(),gJ(),yJ(),xJ(),wJ(),GB(),DJ(),PJ(),LJ(),HJ(),ZB(),GJ(),JJ(),ZJ(),tV(),cq(),tY(),iY(),sY(),uY(),pY(),gY(),yY(),SY(),dV(),wY(),hV(),yV(),DY(),AY(),NY(),IY(),zY(),NV(),UW(),HY(),GY(),JY(),ZY(),eX(),dX(),wB(),mX(),_X(),bX(),Aq(),xX=[hH,hR,_H,yH,BR,bH,xH,wH,DH,AH,NH,IH,zH,UH,KH,eU,rU,oU,lU,pH,fU,hU,vU,qR,xU,MR,nz,wU,bR,DU,NU,IU,zU,HU,GU,JU,ZU,eW,rW,oW,lW,fW,hW,vW,xW,wW,DW,AW,MW,PW,IW,zW,GW,KV,JW,cz,rG,fz,oG,gz,yG,CG,TG,bz,wz,OG,jG,PG,LG,Mz,Iz,TR,BG,AU,UG,KG,YG,YV,Bz,Wz,QG,Xz,tK,aK,cK,fK,hK,vK,xK,nB,wK,DK,AK,NK,LK,BK,UK,oB,KK,XK,dq,dB,mB,hq,yq,Cq,vB,Eq,Mq,Fq,Rq,Hq,$V,EB,Gq,Jq,Zq,eJ,OR,uG,rJ,nH,aH,uH,oJ,lJ,fJ,hJ,vJ,bJ,CJ,WB,EJ,NJ,IJ,VJ,XB,WJ,qJ,XJ,eV,sq,eY,rY,oY,lY,fY,hY,vY,xY,uV,CY,mV,vV,EY,kY,MY,FY,RY,MV,HW,VY,WY,qY,XY,$Y,uX,CB,pX,gX,yX,kq];for(let e of xX)hi(e)})),CX=o((()=>{Ife(),SX()}));function wX(e,t){OX[e]=t}function TX(e,t){if(!(e in OX)||t!=null){let n=DX(e,t);if(n!==null)OX[e]=n;else return console.log(`Could not get context for WebGL version`,e),null}let n=OX[e];return n==null||n.isContextLost()?(delete OX[e],TX(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),OX[e])}function EX(e){if(!k().getBool(`IS_SAFARI`)&&typeof OffscreenCanvas<`u`&&e===2)return new OffscreenCanvas(300,150);if(typeof document<`u`)return document.createElement(`canvas`);throw Error(`Cannot create a canvas in this context`)}function DX(e,t){if(e!==1&&e!==2)throw Error(`Cannot get WebGL rendering context, WebGL is disabled.`);let n=t??EX(e);return n.addEventListener(`webglcontextlost`,t=>{t.preventDefault(),delete OX[e]},!1),k().getBool(`SOFTWARE_WEBGL_ENABLED`)&&(kX.failIfMajorPerformanceCaveat=!1),e===1?n.getContext(`webgl`,kX)||n.getContext(`experimental-webgl`,kX):n.getContext(`webgl2`,kX)}var OX,kX,AX=o((()=>{Y(),OX={},kX={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0}}));function jX(e,t){return[t,e]}function MX(e,t){return e*t}function NX(e){let t=O(e),n=Math.ceil(t/4);return ye(n)}function PX(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function FX(e,t){let[n,r]=PX(e,t);return n*r*4}function IX(e,t){let n=e,r,i,a,o,s,c,l,u,d,f;return k().getNumber(`WEBGL_VERSION`)===2?(r=n.R32F,i=n.R16F,a=n.RGBA16F,o=n.RGBA32F,s=n.RED,l=4,u=1,d=n.HALF_FLOAT,f=n.FLOAT,c=n.RGBA8):(r=e.RGBA,i=e.RGBA,a=e.RGBA,o=n.RGBA,s=e.RGBA,l=4,u=4,d=t==null?null:t.HALF_FLOAT_OES,f=e.FLOAT,c=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:i,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:o,textureFormatFloat:s,downloadTextureFormat:c,downloadUnpackNumChannels:l,defaultNumChannels:u,textureTypeHalfFloat:d,textureTypeFloat:f}}var LX,RX,zX,BX=o((()=>{Y(),(function(e){e[e.DENSE=0]=`DENSE`,e[e.SHARED_BATCH=1]=`SHARED_BATCH`})(LX||={}),(function(e){e[e.RENDER=0]=`RENDER`,e[e.UPLOAD=1]=`UPLOAD`,e[e.PIXELS=2]=`PIXELS`,e[e.DOWNLOAD=3]=`DOWNLOAD`})(RX||={}),(function(e){e[e.UNPACKED_FLOAT16=0]=`UNPACKED_FLOAT16`,e[e.UNPACKED_FLOAT32=1]=`UNPACKED_FLOAT32`,e[e.PACKED_4X1_UNSIGNED_BYTE=2]=`PACKED_4X1_UNSIGNED_BYTE`,e[e.PACKED_2X2_FLOAT32=3]=`PACKED_2X2_FLOAT32`,e[e.PACKED_2X2_FLOAT16=4]=`PACKED_2X2_FLOAT16`})(zX||={})})),VX=c({assertNotComplex:()=>MZ,bindCanvasToFramebuffer:()=>uZ,bindColorTextureToFramebuffer:()=>dZ,bindTextureToProgramUniformSampler:()=>lZ,bindTextureUnit:()=>aZ,bindVertexBufferToProgramAttribute:()=>iZ,callAndCheck:()=>Q,canBeRepresented:()=>UX,createFragmentShader:()=>qX,createFramebuffer:()=>rZ,createProgram:()=>YX,createStaticIndexBuffer:()=>$X,createStaticVertexBuffer:()=>QX,createTexture:()=>tZ,createVertexShader:()=>KX,getBatchDim:()=>_Z,getExtensionOrThrow:()=>GX,getFramebufferErrorMessage:()=>mZ,getMaxTexturesInShader:()=>wZ,getNumChannels:()=>eZ,getProgramUniformLocation:()=>cZ,getProgramUniformLocationOrThrow:()=>sZ,getRowsCols:()=>vZ,getShapeAs3D:()=>yZ,getTextureShapeFromLogicalShape:()=>bZ,getWebGLDisjointQueryTimerVersion:()=>TZ,getWebGLErrorMessage:()=>WX,getWebGLMaxTextureSize:()=>CZ,hasExtension:()=>EZ,isCapableOfRenderingToFloatTexture:()=>OZ,isDownloadFloatTextureEnabled:()=>kZ,isReshapeFree:()=>SZ,isWebGLFenceEnabled:()=>jZ,isWebGLVersionEnabled:()=>DZ,linkProgram:()=>XX,logShaderSourceAndInfoLog:()=>JX,resetMaxTextureSize:()=>Wfe,resetMaxTexturesInShader:()=>Gfe,unbindColorTextureFromFramebuffer:()=>fZ,unbindTextureUnit:()=>oZ,validateFramebuffer:()=>pZ,validateProgram:()=>ZX,validateTextureSize:()=>nZ});function Q(e,t){let n=t();return k().getBool(`DEBUG`)&&HX(e),n}function HX(e){let t=e.getError();if(t!==e.NO_ERROR)throw Error(`WebGL Error: `+WX(e,t))}function UX(e){return!!(k().getBool(`WEBGL_RENDER_FLOAT32_ENABLED`)||e===0||NZ<Math.abs(e)&&Math.abs(e)<PZ)}function WX(e,t){switch(t){case e.NO_ERROR:return`NO_ERROR`;case e.INVALID_ENUM:return`INVALID_ENUM`;case e.INVALID_VALUE:return`INVALID_VALUE`;case e.INVALID_OPERATION:return`INVALID_OPERATION`;case e.INVALID_FRAMEBUFFER_OPERATION:return`INVALID_FRAMEBUFFER_OPERATION`;case e.OUT_OF_MEMORY:return`OUT_OF_MEMORY`;case e.CONTEXT_LOST_WEBGL:return`CONTEXT_LOST_WEBGL`;default:return`Unknown error code ${t}`}}function GX(e,t){return hZ(e,()=>e.getExtension(t),`Extension "`+t+`" not supported on this browser.`)}function KX(e,t){let n=hZ(e,()=>e.createShader(e.VERTEX_SHADER),`Unable to create vertex WebGLShader.`);if(Q(e,()=>e.shaderSource(n,t)),Q(e,()=>e.compileShader(n)),e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw console.log(e.getShaderInfoLog(n)),Error(`Failed to compile vertex shader.`);return n}function qX(e,t){let n=hZ(e,()=>e.createShader(e.FRAGMENT_SHADER),`Unable to create fragment WebGLShader.`);if(Q(e,()=>e.shaderSource(n,t)),Q(e,()=>e.compileShader(n)),k().get(`ENGINE_COMPILE_ONLY`))return n;if(e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw JX(t,e.getShaderInfoLog(n)),Error(`Failed to compile fragment shader.`);return n}function JX(e,t){let n=FZ.exec(t);if(n==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(e);return}let r=+n[1],i=e.split(`
`),a=i.length.toString().length+2,o=i.map((e,t)=>xe((t+1).toString(),a)+e),s=0;for(let e=0;e<o.length;e++)s=Math.max(o[e].length,s);let c=o.slice(0,r-1),l=o.slice(r-1,r),u=o.slice(r);console.log(c.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${xe(l[0],s)}`,`border:1px solid red; background-color:#e3d2d2; color:#a61717`),console.log(u.join(`
`))}function YX(e){return hZ(e,()=>e.createProgram(),`Unable to create WebGLProgram.`)}function XX(e,t){if(Q(e,()=>e.linkProgram(t)),!k().get(`ENGINE_COMPILE_ONLY`)&&e.getProgramParameter(t,e.LINK_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),Error(`Failed to link vertex and fragment shaders.`)}function ZX(e,t){if(Q(e,()=>e.validateProgram(t)),e.getProgramParameter(t,e.VALIDATE_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),Error(`Shader program validation failed.`)}function QX(e,t){let n=hZ(e,()=>e.createBuffer(),`Unable to create WebGLBuffer`);return Q(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),Q(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function $X(e,t){let n=hZ(e,()=>e.createBuffer(),`Unable to create WebGLBuffer`);return Q(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),Q(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function eZ(){return k().getNumber(`WEBGL_VERSION`)===2?1:4}function tZ(e){return hZ(e,()=>e.createTexture(),`Unable to create WebGLTexture.`)}function nZ(e,t){let n=k().getNumber(`WEBGL_MAX_TEXTURE_SIZE`);if(e<=0||t<=0){let n=`[${e}x${t}]`;throw Error(`Requested texture size `+n+` is invalid.`)}if(e>n||t>n){let r=`[${e}x${t}]`,i=`[${n}x${n}]`;throw Error(`Requested texture size `+r+` greater than WebGL maximum on this browser / GPU `+i+`.`)}}function rZ(e){return hZ(e,()=>e.createFramebuffer(),`Unable to create WebGLFramebuffer.`)}function iZ(e,t,n,r,i,a,o){let s=e.getAttribLocation(t,n);return s===-1?!1:(Q(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),Q(e,()=>e.vertexAttribPointer(s,i,e.FLOAT,!1,a,o)),Q(e,()=>e.enableVertexAttribArray(s)),!0)}function aZ(e,t,n){gZ(e,n),Q(e,()=>e.activeTexture(e.TEXTURE0+n)),Q(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function oZ(e,t){gZ(e,t),Q(e,()=>e.activeTexture(e.TEXTURE0+t)),Q(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function sZ(e,t,n){return hZ(e,()=>e.getUniformLocation(t,n),`uniform "`+n+`" not present in program.`)}function cZ(e,t,n){return e.getUniformLocation(t,n)}function lZ(e,t,n,r){Q(e,()=>aZ(e,t,r)),Q(e,()=>e.uniform1i(n,r))}function uZ(e){Q(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Q(e,()=>e.viewport(0,0,e.canvas.width,e.canvas.height)),Q(e,()=>e.scissor(0,0,e.canvas.width,e.canvas.height))}function dZ(e,t,n){Q(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),Q(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function fZ(e,t){Q(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),Q(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function pZ(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw Error(`Error binding framebuffer: `+mZ(e,t))}function mZ(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return`FRAMEBUFFER_INCOMPLETE_ATTACHMENT`;case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return`FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT`;case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return`FRAMEBUFFER_INCOMPLETE_DIMENSIONS`;case e.FRAMEBUFFER_UNSUPPORTED:return`FRAMEBUFFER_UNSUPPORTED`;default:return`unknown error ${t}`}}function hZ(e,t,n){let r=Q(e,()=>t());if(r==null)throw Error(n);return r}function gZ(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){let e=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw Error(`textureUnit must be in ${e}.`)}}function _Z(e,t=2){return O(e.slice(0,e.length-t))}function vZ(e){if(e.length===0)throw Error(`Cannot get rows and columns of an empty shape array.`);return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function yZ(e){let t=[1,1,1];return e.length===0||e.length===1&&e[0]===1||(t=[_Z(e),...vZ(e)]),t}function bZ(e,t=!1){let n=k().getNumber(`WEBGL_MAX_TEXTURE_SIZE`),r=k().getNumber(`WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE`);r===1/0&&k().getBool(`WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE`)&&(r=n/2),t&&(n*=2,r*=2,e=e.map((t,n)=>n>=e.length-2?se(e[n]):e[n]),e.length===1&&(e=[2,e[0]])),e.length!==2&&(e=Te(e).newShape);let i=O(e),a=null;e.length<=1&&i<=n?a=[1,i]:e.length===2&&e[0]<=n&&e[1]<=n?a=e:e.length===3&&e[0]*e[1]<=n&&e[2]<=n?a=[e[0]*e[1],e[2]]:e.length===3&&e[0]<=n&&e[1]*e[2]<=n?a=[e[0],e[1]*e[2]]:e.length===4&&e[0]*e[1]*e[2]<=n&&e[3]<=n?a=[e[0]*e[1]*e[2],e[3]]:e.length===4&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(a=[e[0],e[1]*e[2]*e[3]]);let o=a!=null&&Math.max(...a)>r&&Math.min(...a)<=(t?2:1)&&Math.min(...a)>0;if(a==null||o)if(t){let t=_Z(e),n=2,r=2;e.length&&([n,r]=vZ(e)),i=t*(n/2)*(r/2),a=ye(i).map(e=>e*2)}else a=ye(i);return a}function xZ(e){return e%2==0}function SZ(e,t){if(e=e.slice(-2),t=t.slice(-2),ge(e,t)||!e.length||!t.length||e[0]===0||e[1]===0||t[0]===0||t[1]===0)return!0;if(e.length!==t.length){let n=e[e.length-1],r=t[t.length-1];if(n===r||xZ(n)&&xZ(r)&&(e[0]===1||t[0]===1))return!0}return e[1]===t[1]&&xZ(e[0])&&xZ(t[0])}function CZ(e){if(IZ==null){let t=TX(e);IZ=t.getParameter(t.MAX_TEXTURE_SIZE)}return IZ}function Wfe(){IZ=null}function Gfe(){LZ=null}function wZ(e){if(LZ==null){let t=TX(e);LZ=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,LZ)}function TZ(e){if(e===0)return 0;let t,n=TX(e);return t=EZ(n,`EXT_disjoint_timer_query_webgl2`)&&e===2?2:EZ(n,`EXT_disjoint_timer_query`)?1:0,t}function EZ(e,t){return e.getExtension(t)!=null}function DZ(e){try{if(TX(e)!=null)return!0}catch(e){return console.log(`Error when getting WebGL context: `,e),!1}return!1}function OZ(e){if(e===0)return!1;let t=TX(e);if(e===1){if(!EZ(t,`OES_texture_float`))return!1}else if(!EZ(t,`EXT_color_buffer_float`))return!1;return AZ(t)}function kZ(e){if(e===0)return!1;let t=TX(e);if(e===1){if(!EZ(t,`OES_texture_float`)||!EZ(t,`WEBGL_color_buffer_float`))return!1}else{if(EZ(t,`EXT_color_buffer_float`))return AZ(t);let e=`EXT_color_buffer_half_float`;if(EZ(t,e)){let n=t.getExtension(e);return Kfe(t,n)}return!1}return AZ(t)}function AZ(e){let t=IX(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);let r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),i}function Kfe(e,t){let n=IX(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(i),a}function jZ(e){return e===2?TX(e).fenceSync!=null:!1}function MZ(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{e!=null&&D(e.dtype!==`complex64`,()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var NZ,PZ,FZ,IZ,LZ,RZ=o((()=>{Y(),AX(),BX(),NZ=5.96e-8,PZ=65504,FZ=/ERROR: [0-9]+:([0-9]+):/g})),zZ,qfe=o((()=>{Y(),RZ(),zZ=k(),zZ.registerFlag(`HAS_WEBGL`,()=>zZ.getNumber(`WEBGL_VERSION`)>0),zZ.registerFlag(`WEBGL_VERSION`,()=>DZ(2)?2:DZ(1)?1:0),zZ.registerFlag(`WEBGL_CHECK_NUMERICAL_PROBLEMS`,()=>!1),zZ.registerFlag(`WEBGL_BUFFER_SUPPORTED`,()=>zZ.get(`WEBGL_VERSION`)===2),zZ.registerFlag(`WEBGL_CPU_FORWARD`,()=>!0),zZ.registerFlag(`WEBGL_FORCE_F16_TEXTURES`,()=>!1),zZ.registerFlag(`WEBGL_PACK`,()=>zZ.getBool(`HAS_WEBGL`)),zZ.registerFlag(`WEBGL_PACK_NORMALIZATION`,()=>zZ.getBool(`WEBGL_PACK`)),zZ.registerFlag(`WEBGL_PACK_CLIP`,()=>zZ.getBool(`WEBGL_PACK`)),zZ.registerFlag(`WEBGL_PACK_DEPTHWISECONV`,()=>zZ.getBool(`WEBGL_PACK`)),zZ.registerFlag(`WEBGL_PACK_BINARY_OPERATIONS`,()=>zZ.getBool(`WEBGL_PACK`)),zZ.registerFlag(`WEBGL_PACK_UNARY_OPERATIONS`,()=>zZ.getBool(`WEBGL_PACK`)),zZ.registerFlag(`WEBGL_PACK_ARRAY_OPERATIONS`,()=>zZ.getBool(`WEBGL_PACK`)),zZ.registerFlag(`WEBGL_PACK_IMAGE_OPERATIONS`,()=>zZ.getBool(`WEBGL_PACK`)),zZ.registerFlag(`WEBGL_PACK_REDUCE`,()=>zZ.getBool(`WEBGL_PACK`)),zZ.registerFlag(`WEBGL_LAZILY_UNPACK`,()=>zZ.getBool(`WEBGL_PACK`)),zZ.registerFlag(`WEBGL_CONV_IM2COL`,()=>zZ.getBool(`WEBGL_PACK`)),zZ.registerFlag(`WEBGL_PACK_CONV2DTRANSPOSE`,()=>zZ.getBool(`WEBGL_PACK`)),zZ.registerFlag(`WEBGL_MAX_TEXTURE_SIZE`,()=>CZ(zZ.getNumber(`WEBGL_VERSION`))),zZ.registerFlag(`WEBGL_MAX_TEXTURES_IN_SHADER`,()=>wZ(zZ.getNumber(`WEBGL_VERSION`))),zZ.registerFlag(`WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION`,()=>{let e=zZ.getNumber(`WEBGL_VERSION`);return e===0?0:TZ(e)}),zZ.registerFlag(`WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE`,()=>zZ.getNumber(`WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION`)>0&&!eo()),zZ.registerFlag(`WEBGL_RENDER_FLOAT32_CAPABLE`,()=>OZ(zZ.getNumber(`WEBGL_VERSION`))),zZ.registerFlag(`WEBGL_RENDER_FLOAT32_ENABLED`,()=>zZ.getBool(`WEBGL_FORCE_F16_TEXTURES`)?!1:zZ.getBool(`WEBGL_RENDER_FLOAT32_CAPABLE`)),zZ.registerFlag(`WEBGL_DOWNLOAD_FLOAT_ENABLED`,()=>kZ(zZ.getNumber(`WEBGL_VERSION`))),zZ.registerFlag(`WEBGL_FENCE_API_ENABLED`,()=>jZ(zZ.getNumber(`WEBGL_VERSION`))),zZ.registerFlag(`WEBGL_SIZE_UPLOAD_UNIFORM`,()=>zZ.getBool(`WEBGL_RENDER_FLOAT32_ENABLED`)?4:0),zZ.registerFlag(`WEBGL_DELETE_TEXTURE_THRESHOLD`,()=>-1,e=>{if(typeof e!=`number`)throw Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)}),zZ.registerFlag(`WEBGL_FLUSH_THRESHOLD`,()=>eo()?1:-1,e=>{if(typeof e!=`number`)throw Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)}),zZ.registerFlag(`CPU_HANDOFF_SIZE_THRESHOLD`,()=>128),zZ.registerFlag(`WEBGL_USE_SHAPES_UNIFORMS`,()=>!1),zZ.registerFlag(`TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD`,()=>1e5),zZ.registerFlag(`TOPK_K_CPU_HANDOFF_THRESHOLD`,()=>128),zZ.registerFlag(`WEBGL_EXP_CONV`,()=>!1),zZ.registerFlag(`SOFTWARE_WEBGL_ENABLED`,()=>zZ.getBool(`IS_TEST`)),zZ.registerFlag(`WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE`,()=>1/0),zZ.registerFlag(`WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE`,()=>!1),zZ.registerFlag(`WEBGL2_ISNAN_CUSTOM`,()=>!1),zZ.registerFlag(`ENGINE_COMPILE_ONLY`,()=>!1)}));function BZ(){let e,t,n,r,i,a,o,s,c,l;return k().getNumber(`WEBGL_VERSION`)===2?(e=`#version 300 es`,t=`in`,n=`out`,r=`in`,i=`texture`,a=`outputColor`,o=`out vec4 outputColor;`,s=k().getBool(`WEBGL2_ISNAN_CUSTOM`)?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:``,c=``,l=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(e=``,t=`attribute`,n=`varying`,r=`varying`,i=`texture2D`,a=`gl_FragColor`,o=``,s=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,c=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,l=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:i,output:a,defineOutput:o,defineSpecialNaN:s,defineSpecialInf:c,defineRound:l}}var VZ=o((()=>{Y()}));function HZ(e,t,n=`index`){let r=ze(t);return r.map((t,i)=>{let a=`int ${e[i]} = ${n} / ${t}`,o=i===r.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * ${t}`:`index -= ${e[i]} * ${t}`;return`${a}; ${o};`}).join(``)}function UZ(e,t,n=`index`){let r=ze(t);return r.map((t,i)=>{let a=`int ${e[i]} = ${n} / outShapeStrides[${i}]`,o=i===r.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * outShapeStrides[${i}]`:`index -= ${e[i]} * outShapeStrides[${i}]`;return`${a}; ${o};`}).join(``)}function Jfe(e,t){let n=e.length,r=e.map(e=>`${t}[${e}]`),i=Array(n-1);i[n-2]=r[n-1];for(let e=n-3;e>=0;--e)i[e]=`(${i[e+1]} * ${r[e+1]})`;return i}function Yfe(e,t,n=`index`){let r=e.map((e,t)=>t),i=Jfe(r,t);return i.map((t,r)=>{let a=`int ${e[r]} = ${n} / ${i[r]}`,o=r===i.length-1?`int ${e[r+1]} = ${n} - ${e[r]} * ${i[r]}`:`index -= ${e[r]} * ${i[r]}`;return`${a}; ${o};`}).join(``)}function WZ(e){let t=ze(e).map(e=>e.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function GZ(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var KZ,qZ=o((()=>{Y(),KZ=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`}));function Xfe(e,t,n){let r=[];if(e.forEach(e=>{let t=O(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:``};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){let{uniformShape:t}=eQ(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`);break;default:break}r.push(`uniform ivec2 ${e.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push(`uniform int outShape;`);break;case 2:r.push(`uniform ivec2 outShape;`),r.push(`uniform int outShapeStrides;`);break;case 3:r.push(`uniform ivec3 outShape;`),r.push(`uniform ivec2 outShapeStrides;`);break;case 4:r.push(`uniform ivec4 outShape;`),r.push(`uniform ivec3 outShapeStrides;`);break;default:break}r.push(`uniform ivec2 outTexShape;`)}n.customUniforms&&n.customUniforms.forEach(e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:``};`)});let i=r.join(`
`),a=e.map(e=>Zfe(e,t,n.packedInputs,n.enableShapeUniforms)).join(`
`),o=t.texShape,s=BZ(),c=epe(s),l,u,d=rpe(s);return t.isPacked?(l=Qfe(t.logicalShape,o,n.enableShapeUniforms),u=npe(s)):(l=$fe(t.logicalShape,o,n.enableShapeUniforms),u=tpe(s)),n.packedInputs&&(d+=sQ),[d,c,u,i,l,a,n.userCode].join(`
`)}function JZ(e,t=!1){let n=e.shapeInfo.logicalShape;switch(n.length){case 0:return hpe(e,t);case 1:return _pe(e,t);case 2:return ype(e,t);case 3:return xpe(e,t);case 4:return Cpe(e,t);case 5:return wpe(e);case 6:return Tpe(e);default:throw Error(`${n.length}-D input sampling is not yet supported`)}}function YZ(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return mpe(e);case 1:return gpe(e,t);case 2:return vpe(e,t);case 3:return bpe(e,t);default:return Spe(e,t)}}function Zfe(e,t,n=!1,r){let i=``;n?i+=YZ(e,r):i+=JZ(e,r);let a=e.shapeInfo.logicalShape,o=t.logicalShape;return a.length<=o.length&&(n?i+=Epe(e,t):i+=Dpe(e,t)),i}function Qfe(e,t,n){switch(e.length){case 0:return XZ();case 1:return ipe(e,t,n);case 2:return fpe(e,t,n);case 3:return ope(e,t,n);default:return cpe(e,t,n)}}function $fe(e,t,n){switch(e.length){case 0:return XZ();case 1:return ape(e,t,n);case 2:return ppe(e,t,n);case 3:return spe(e,t,n);case 4:return lpe(e,t,n);case 5:return upe(e,t);case 6:return dpe(e,t);default:throw Error(`${e.length}-D output sampling is not yet supported`)}}function epe(e){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${e.texture2D}(textureSampler, uv).r;
    }
  `}function tpe(e){return`
    void setOutput(float val) {
      ${e.output} = vec4(val, 0, 0, 0);
    }
  `}function npe(e){return`
    void setOutput(vec4 val) {
      ${e.output} = val;
    }
  `}function rpe(e){return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFs} vec2 resultUV;
    ${e.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e.defineSpecialNaN}
    ${e.defineSpecialInf}
    ${e.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${iQ}
    ${aQ}
    ${oQ}
  `}function XZ(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function ipe(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return r[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function ape(e,t,n){return t[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function ope(e,t,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],i=Math.ceil(e[2]/2),a=i*Math.ceil(e[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec3(b, r, c);
    }
  `}function spe(e,t,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${UZ([`r`,`c`,`d`],e)}
    return ivec3(r, c, d);
  }
`;let r=HZ([`r`,`c`,`d`],e);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function cpe(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],i=Math.ceil(e[e.length-1]/2),a=i*Math.ceil(e[e.length-2]/2),o=a,s=``,c=`b, r, c`;for(let t=2;t<e.length-1;t++)o*=e[e.length-t-1],s=`
      int b${t} = index / ${o};
      index -= b${t} * ${o};
    `+s,c=`b${t}, `+c;return`
    ivec${e.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${s}

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec${e.length}(${c});
    }
  `}function lpe(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${UZ([`r`,`c`,`d`,`d2`],e)}
      return ivec4(r, c, d, d2);
    }
  `;let r=HZ([`r`,`c`,`d`,`d2`],e);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function upe(e,t){let n=HZ([`r`,`c`,`d`,`d2`,`d3`],e);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function dpe(e,t){let n=HZ([`r`,`c`,`d`,`d2`,`d3`,`d4`],e);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function fpe(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(ge(e,t))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;let i=Math.ceil(e[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec2(r, c);
    }
  `}function ppe(e,t,n){return ge(e,t)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:e[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:e[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${e[1]};
      int c = index - r * ${e[1]};
      return ivec2(r, c);
    }
  `}function ZZ(e){return`offset${e}`}function mpe(e){let t=e.name,n=`get`+t.charAt(0).toUpperCase()+t.slice(1),r=BZ();return`
    vec4 ${n}() {
      return ${r.texture2D}(${t}, halfCR);
    }
  `}function hpe(e,t){let n=e.name,r=`get`+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;let[i,a]=e.shapeInfo.texShape;if(i===1&&a===1)return`
      float ${r}() {
        return sampleTexture(${n}, halfCR);
      }
    `;let o=ZZ(n);if(t)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${o});
      return sampleTexture(${n}, uv);
    }
  `;let[s,c]=e.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${s}, ${c}, ${o});
      return sampleTexture(${n}, uv);
    }
  `}function gpe(e,t){let n=e.name,r=`get`+n.charAt(0).toUpperCase()+n.slice(1),i=e.shapeInfo.texShape,a=BZ();if(t)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${a.texture2D}(${n}, uv);
    }
  `;let o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${a.texture2D}(${n}, uv);
    }
  `}function _pe(e,t){let n=e.name,r=`get`+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${QZ(e)}
      }
    `;let i=e.shapeInfo.texShape,a=i[0],o=i[1];if(o===1&&a===1)return`
      float ${r}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;let s=ZZ(n);return o===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${s}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${s}) + 0.5) / ${a}.0);
        return sampleTexture(${n}, uv);
      }
    `:a===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${s}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${s}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:t?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${s});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${a}, ${o}, index + ${s});
      return sampleTexture(${n}, uv);
    }
  `}function vpe(e,t){let n=e.shapeInfo.logicalShape,r=e.name,i=`get`+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,o=a[0],s=a[1],c=BZ();if(a!=null&&ge(n,a))return t?`
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${c.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}.0, ${o}.0);

        return ${c.texture2D}(${r}, uv);
      }
    `;if(t)return`
    vec4 ${i}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${c.texture2D}(${r}, uv);
    }
  `;let l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],u=Math.ceil(n[1]/2);return`
    vec4 ${i}(int row, int col) {
      vec2 uv = packedUVfrom2D(${u}, ${l[0]}, ${l[1]}, row, col);
      return ${c.texture2D}(${r}, uv);
    }
  `}function ype(e,t){let n=e.shapeInfo.logicalShape,r=e.name,i=`get`+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape;if(a!=null&&ge(n,a)){if(t)return`
      float ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;let e=a[0],n=a[1];return`
    float ${i}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}.0, ${e}.0);
      return sampleTexture(${r}, uv);
    }
  `}let{newShape:o,keptDims:s}=Te(n),c=o;if(c.length<n.length){let n=tQ(e,c);return`
      ${JZ(n,t)}
      float ${i}(int row, int col) {
        return ${i}(${nQ([`row`,`col`],s)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${i}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${QZ(e)}
      }
    `;let l=a[0],u=a[1],d=ZZ(r);return u===1?t?`
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);
      return sampleTexture(${r}, uv);
    }
  `:l===1?t?`
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:t?`
      float ${i}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${d};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${i}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${d};
    vec2 uv = uvFromFlat(${l}, ${u}, index);
    return sampleTexture(${r}, uv);
  }
`}function bpe(e,t){let n=e.shapeInfo.logicalShape,r=e.name,i=`get`+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,o=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(n[0]===1){let r=n.slice(1),a=[1,2],o=tQ(e,r);return`
        ${YZ(o,t)}
        vec4 ${i}(int b, int row, int col) {
          return ${i}(${nQ([`b`,`row`,`col`],a)});
        }
      `}let s=BZ();if(t)return`
    vec4 ${i}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${s.texture2D}(${r}, uv);
    }
  `;let c=o[0],l=o[1],u=Math.ceil(n[2]/2),d=u*Math.ceil(n[1]/2);return`
    vec4 ${i}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${c}, ${l}, ${d}, ${u}, b, row, col);
      return ${s.texture2D}(${r}, uv);
    }
  `}function xpe(e,t){let n=e.shapeInfo.logicalShape,r=e.name,i=`get`+r.charAt(0).toUpperCase()+r.slice(1),a=n[1]*n[2],o=n[2],{newShape:s,keptDims:c}=Te(n),l=s;if(l.length<n.length){let n=tQ(e,l);return`
        ${JZ(n,t)}
        float ${i}(int row, int col, int depth) {
          return ${i}(${nQ([`row`,`col`,`depth`],c)});
        }
      `}if(e.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${a}, ${o}, 1)));
        ${QZ(e)}
      }
    `;let u=e.shapeInfo.texShape,d=u[0],f=u[1],p=e.shapeInfo.flatOffset;if(f===a&&p==null)return t?`
      float ${i}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${i}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${f}.0, ${d}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(f===o&&p==null)return t?`
      float ${i}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${i}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${f}.0, ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `;let m=ZZ(r);return t?`
    float ${i}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${m};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${i}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a} + col * ${o} + depth + ${m};
        vec2 uv = uvFromFlat(${d}, ${f}, index);
        return sampleTexture(${r}, uv);
      }
  `}function Spe(e,t){let n=e.name,r=`get`+n.charAt(0).toUpperCase()+n.slice(1),i=BZ();if(t)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${i.texture2D}(${n}, uv);
    }
  `;let a=e.shapeInfo.logicalShape,o=a.length,s=e.shapeInfo.texShape,c=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],l=c[0],u=c[1],d=Math.ceil(a[o-1]/2),f=d*Math.ceil(a[o-2]/2),p=`int b, int row, int col`,m=`b * ${f} + (row / 2) * ${d} + (col / 2)`;for(let e=2;e<o-1;e++)p=`int b${e}, `+p,f*=a[o-e-1],m=`b${e} * ${f} + `+m;return`
    vec4 ${r}(${p}) {
      int index = ${m};
      int texR = index / ${u};
      int texC = index - texR * ${u};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${l});
      return ${i.texture2D}(${n}, uv);
    }
  `}function Cpe(e,t){let n=e.shapeInfo.logicalShape,r=e.name,i=`get`+r.charAt(0).toUpperCase()+r.slice(1),a=n[3],o=n[2]*a,s=n[1]*o,{newShape:c,keptDims:l}=Te(n);if(c.length<n.length){let n=tQ(e,c);return`
      ${JZ(n,t)}
      float ${i}(int row, int col, int depth, int depth2) {
        return ${i}(${nQ([`row`,`col`,`depth`,`depth2`],l)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${s}, ${o}, ${a}, 1)));
        ${QZ(e)}
      }
    `;let u=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,f=d[0],p=d[1],m=`int stride2 = ${r}Shape[3];`,h=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(p===s&&u==null)return t?`
      float ${i}(int row, int col, int depth, int depth2) {
        ${m}
        ${h}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${a}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(p===a&&u==null)return t?`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;let _=ZZ(r);return t?`
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${m}
      ${h}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${_});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${s} + col * ${o} +
          depth * ${a} + depth2;
      vec2 uv = uvFromFlat(${f}, ${p}, index + ${_});
      return sampleTexture(${r}, uv);
    }
  `}function wpe(e){let t=e.shapeInfo.logicalShape,n=e.name,r=`get`+n.charAt(0).toUpperCase()+n.slice(1),i=t[4],a=t[3]*i,o=t[2]*a,s=t[1]*o,{newShape:c,keptDims:l}=Te(t);if(c.length<t.length){let t=tQ(e,c);return`
      ${JZ(t)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${nQ([`row`,`col`,`depth`,`depth2`,`depth3`],l)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${s}, ${o}, ${a}, ${i})) +
          depth3;
        ${QZ(e)}
      }
    `;let u=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,f=d[0],p=d[1];if(p===s&&u==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${a}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(p===i&&u==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;let m=ZZ(n);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${s} + col * ${o} + depth * ${a} +
          depth2 * ${i} + depth3 + ${m};
      vec2 uv = uvFromFlat(${f}, ${p}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Tpe(e){let t=e.shapeInfo.logicalShape,n=e.name,r=`get`+n.charAt(0).toUpperCase()+n.slice(1),{newShape:i,keptDims:a}=Te(t);if(i.length<t.length){let t=tQ(e,i);return`
      ${JZ(t)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${nQ([`row`,`col`,`depth`,`depth2`,`depth3`,`depth4`],a)});
      }
    `}let o=t[5],s=t[4]*o,c=t[3]*s,l=t[2]*c,u=t[1]*l;if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${l}, ${c}, ${s})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${QZ(e)}
      }
    `;let d=e.shapeInfo.flatOffset,f=e.shapeInfo.texShape,p=f[0],m=f[1];if(m===u&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${l}, ${c}, ${s}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${m}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(m===o&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${m}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;let h=ZZ(n);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${l} + depth * ${c} +
          depth2 * ${s} + depth3 * ${o} + depth4 + ${h};
      vec2 uv = uvFromFlat(${p}, ${m}, index);
      return sampleTexture(${n}, uv);
    }
  `}function QZ(e){let t=e.name,n=O(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function Epe(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),i=`get`+r+`AtOutCoords`,a=e.shapeInfo.logicalShape.length,o=t.logicalShape.length,s=rQ(e.shapeInfo.logicalShape,t.logicalShape),c=$Z(o),l=o-a,u,d=[`x`,`y`,`z`,`w`,`u`,`v`];u=a===0?``:o<2&&s.length>=1?`coords = 0;`:s.map(e=>`coords.${d[e+l]} = 0;`).join(`
`);let f=``;f=o<2&&a>0?`coords`:e.shapeInfo.logicalShape.map((e,t)=>`coords.${d[t+l]}`).join(`, `);let p=`return outputValue;`,m=O(e.shapeInfo.logicalShape)===1,h=O(t.logicalShape)===1;if(a===1&&!m&&!h)p=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(m&&!h)p=o===1?`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:`
        return vec4(outputValue.x);
      `;else if(s.length){let e=a-2,t=a-1;s.indexOf(e)>-1&&s.indexOf(t)>-1?p=`return vec4(outputValue.x);`:s.indexOf(e)>-1?p=`return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);`:s.indexOf(t)>-1&&(p=`return vec4(outputValue.xx, outputValue.zz);`)}return`
    vec4 ${i}() {
      ${c} coords = getOutputCoords();
      ${u}
      vec4 outputValue = get${r}(${f});
      ${p}
    }
  `}function Dpe(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),i=`get`+r+`AtOutCoords`,a=t.texShape,o=e.shapeInfo.texShape,s=e.shapeInfo.logicalShape.length,c=t.logicalShape.length;if(!e.shapeInfo.isUniform&&s===c&&e.shapeInfo.flatOffset==null&&ge(o,a))return`
      float ${i}() {
        return sampleTexture(${n}, resultUV);
      }
    `;let l=$Z(c),u=rQ(e.shapeInfo.logicalShape,t.logicalShape),d=c-s,f,p=[`x`,`y`,`z`,`w`,`u`,`v`];f=s===0?``:c<2&&u.length>=1?`coords = 0;`:u.map(e=>`coords.${p[e+d]} = 0;`).join(`
`);let m=``;return m=c<2&&s>0?`coords`:e.shapeInfo.logicalShape.map((e,t)=>`coords.${p[t+d]}`).join(`, `),`
    float ${i}() {
      ${l} coords = getOutputCoords();
      ${f}
      return get${r}(${m});
    }
  `}function $Z(e){if(e<=1)return`int`;if(e===2)return`ivec2`;if(e===3)return`ivec3`;if(e===4)return`ivec4`;if(e===5)return`ivec5`;if(e===6)return`ivec6`;throw Error(`GPU for rank ${e} is not yet supported`)}function eQ(e,t,n){let{newShape:r,keptDims:i}=Te(t),a=t.length,o=e&&a===3&&t[0]===1,s=o?t.slice(1):r,c=!e&&a>1&&!ge(t,n)&&r.length<a||o;return{useSqueezeShape:c,uniformShape:c?s:t,keptDims:i}}function tQ(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function nQ(e,t){return t.map(t=>e[t]).join(`, `)}var rQ,iQ,aQ,oQ,sQ,cQ=o((()=>{Y(),VZ(),qZ(),{getBroadcastDims:rQ}=SC,iQ=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,aQ=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,oQ=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,sQ=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`}));function Ope(e,t,n,r){let i=n.map((e,n)=>{let r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:e.isUniform?!1:e.texData.isPacked,flatOffset:null};return e.texData!=null&&e.texData.slice!=null&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}}),a=i.map(e=>e.shapeInfo),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},s=Xfe(i,o,t),c=qX(e.gl,s),l=e.createProgram(c);return k().get(`ENGINE_COMPILE_ONLY`)?{program:t,fragmentShader:c,source:s,webGLProgram:l,inShapeInfos:a,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(l),Object.assign({program:t,fragmentShader:c,source:s,webGLProgram:l,inShapeInfos:a,outShapeInfo:o},lQ(e,t,l)))}function lQ(e,t,n){let r=[],i=[],a,o,s,c=null,l=null;l=e.getUniformLocation(n,`NAN`,!1),k().getNumber(`WEBGL_VERSION`)===1&&(c=e.getUniformLocation(n,`INFINITY`,!1));for(let i of t.variableNames){let a={name:i,uniform:e.getUniformLocation(n,i,!1),offset:e.getUniformLocation(n,`offset${i}`,!1)};t.enableShapeUniforms&&(a.shape=e.getUniformLocation(n,`${i}Shape`,!1),a.texShape=e.getUniformLocation(n,`${i}TexShape`,!1)),r.push(a)}if(t.enableShapeUniforms&&(a=e.getUniformLocation(n,`outShape`,!1),s=e.getUniformLocation(n,`outShapeStrides`,!1),o=e.getUniformLocation(n,`outTexShape`,!1)),t.customUniforms)for(let r of t.customUniforms)i.push(e.getUniformLocation(n,r.name,!1));return{variablesLocations:r,customUniformLocations:i,infLoc:c,nanLoc:l,outShapeLocation:a,outShapeStridesLocation:s,outTexShapeLocation:o}}function uQ(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((e,n)=>{let r=e.logicalShape,i=t[n],a=i.shape;if(!ge(r,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${a} must match`);if(e.isUniform&&i.isUniform)return;let o=e.texShape,s=i.isUniform?null:i.texData.texShape;if(!ge(o,s))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${s} must match`)})}function kpe(e,t,n,r,i){t.program.enableShapeUniforms||(uQ(t.inShapeInfos,n),uQ([t.outShapeInfo],[r]));let a=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(a.texture,o[0],o[1]):e.setOutputMatrixTexture(a.texture,o[0],o[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),k().getNumber(`WEBGL_VERSION`)===1&&t.infLoc!==null&&e.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&e.gl.uniform1f(t.nanLoc,NaN);for(let r=0;r<n.length;++r){let i=n[r],{uniform:a,offset:o,shape:s,texShape:c}=t.variablesLocations[r];if(s){let{uniformShape:n}=eQ(t.program.packedInputs,i.shape,i.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(s,new Int32Array(n));break;case 2:e.gl.uniform2iv(s,new Int32Array(n));break;case 3:e.gl.uniform3iv(s,new Int32Array(n));break;case 4:e.gl.uniform4iv(s,new Int32Array(n));break;default:break}}if(c&&e.gl.uniform2i(c,i.texData.texShape[0],i.texData.texShape[1]),a!=null){if(i.isUniform){if(O(i.shape)<2)e.gl.uniform1f(a,i.uniformValues[0]);else{let t=i.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(a,t)}continue}i.texData.slice!=null&&o!=null&&e.gl.uniform1i(o,i.texData.slice.flatOffset),e.setInputMatrixTexture(i.texData.texture.texture,a,r)}}let s=t.outShapeLocation;if(s)switch(r.shape.length){case 1:e.gl.uniform1iv(s,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(s,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(s,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(s,new Int32Array(r.shape));break;default:break}if(t.outShapeStridesLocation){let n=ze(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n));break;default:break}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&i)for(let n=0;n<t.program.customUniforms.length;++n){let r=t.program.customUniforms[n],a=t.customUniformLocations[n],o=i[n];if(r.type===`float`)e.gl.uniform1fv(a,o);else if(r.type===`vec2`)e.gl.uniform2fv(a,o);else if(r.type===`vec3`)e.gl.uniform3fv(a,o);else if(r.type===`vec4`)e.gl.uniform4fv(a,o);else if(r.type===`int`)e.gl.uniform1iv(a,o);else if(r.type===`ivec2`)e.gl.uniform2iv(a,o);else if(r.type===`ivec3`)e.gl.uniform3iv(a,o);else if(r.type===`ivec4`)e.gl.uniform4iv(a,o);else throw Error(`uniform type ${r.type} is not supported yet.`)}e.executeProgram()}function Ape(e,t,n){let r=``;t.concat(n).forEach(t=>{let i=t.texData!=null&&t.texData.slice!=null&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){let a=t.texData.texShape,{useSqueezeShape:o,uniformShape:s,keptDims:c}=eQ(e.packedInputs,t.shape,a),l=``,u=``,d=``;if(s.length===1&&e.packedInputs){let e=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];l=`${e[0]>1}_${e[1]>1}`}else if(s.length===2&&!e.packedInputs)u=`${s[0]>1}_${s[1]>1}`;else if(s.length>2&&!e.packedInputs){let e=ze(s);d=`${e[0]===a[1]}_${e[e.length-1]===a[1]}`}let f=t.shape.length,p=s.length===2&&ge(t.shape,a),m=O(t.shape)===1,h=ef(t.shape,n.shape),g=!e.packedInputs&&f===n.shape.length&&ge(a,n.texData.texShape),_=e.packedInputs||s.length>2?``:`${a[0]>1}_${a[1]>1}`;r+=`${f}_${g}_${o?c:``}_${s.length}_${m}_${h}_${p}_${l}_${u}_${d}_${_}_${i}`}else{let e=t.isUniform?`uniform`:t.texData.texShape;r+=`${t.shape}_${e}_${i}`}});let i=e.userCode,a=e.constructor.name;return a+=`_`+r+`_`+i+`${k().getNumber(`WEBGL_VERSION`)}`,a}function dQ(e){return k().getBool(`WEBGL_USE_SHAPES_UNIFORMS`)&&e<=4}var fQ=o((()=>{Y(),cQ(),RZ()})),pQ,jpe=o((()=>{VZ(),fQ(),qZ(),BX(),pQ=class{constructor(e){this.variableNames=[`A`],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=LX.DENSE,this.customUniforms=[{name:`texShape`,type:`ivec2`}];let t=BZ();this.outputShape=e,this.enableShapeUniforms=dQ(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?UZ([`r`,`c`,`d`],e):HZ([`r`,`c`,`d`],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}})),mQ,Mpe=o((()=>{VZ(),fQ(),qZ(),BX(),mQ=class{constructor(e){this.variableNames=[`A`],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=LX.DENSE,this.customUniforms=[{name:`texShape`,type:`ivec2`}];let t=BZ();this.outputShape=e,this.enableShapeUniforms=dQ(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?UZ([`r`,`c`,`d`],e):HZ([`r`,`c`,`d`],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}})),hQ,Npe=o((()=>{VZ(),qZ(),BX(),hQ=class{constructor(e){this.variableNames=[`A`],this.outTexUsage=RX.DOWNLOAD;let t=BZ();this.outputShape=e,this.userCode=`
      ${KZ}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}})),gQ,Ppe=o((()=>{VZ(),qZ(),BX(),gQ=class{constructor(e){this.variableNames=[`A`],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=RX.DOWNLOAD;let t=BZ();this.outputShape=e,this.userCode=`
      ${KZ}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}})),_Q,vQ,Fpe=o((()=>{VZ(),fQ(),qZ(),_Q={R:0,G:1,B:2,A:3},vQ=class{constructor(e,t=!1,n=`RGBA`){this.variableNames=[`A`],this.customUniforms=[{name:`texShape`,type:`ivec2`}];let r=BZ();this.outputShape=e,this.enableShapeUniforms=dQ(this.outputShape.length);let i=`result`;t&&(i=`floor(result * 255. + 0.5)`);let a=``;for(let e=0;e<n.length;e++){let t=n[e];a+=`
          if(offset == ${e}) {
            result = values[${_Q[t]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?GZ():WZ(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${n.length});

        flatIndex = idiv(flatIndex, ${n.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${a}
        }
        ${r.output} = vec4(${i}, 0., 0., 0.);
      }
    `}}})),yQ,Ipe=o((()=>{VZ(),fQ(),qZ(),yQ=class{constructor(e,t=!1){this.variableNames=[`A`],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:`texShape`,type:`ivec2`}];let n=BZ();this.outputShape=e,this.enableShapeUniforms=dQ(this.outputShape.length);let r=``,i=`result`;t&&(i=`floor(result * 255. + 0.5)`);for(let t=0;t<=1;t++)for(let i=0;i<=1;i++){let a=t*2+i;r+=`
          localCoords = coords;
          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?`outShape[2]`:`${e[2]}`}) {
          localCoords[2] += ${i};
          if (localCoords[1] + ${t} < ${this.enableShapeUniforms?`outShape[1]`:`${e[1]}`}) {
            localCoords[1] += ${t};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${a}] = values[0];
            } else if (offset == 1) {
              result[${a}] = values[1];
            } else if (offset == 2) {
              result[${a}] = values[2];
            } else {
              result[${a}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?GZ():WZ(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${n.output} = ${i};
        }
    `}}})),Lpe=c({bindVertexProgramAttributeStreams:()=>PQ,createBufferFromOutputTexture:()=>LQ,createFloat16MatrixTexture:()=>DQ,createFloat16PackedMatrixTexture:()=>NQ,createFloat32MatrixTexture:()=>TQ,createIndexBuffer:()=>SQ,createPackedMatrixTexture:()=>jQ,createUnsignedBytesMatrixTexture:()=>kQ,createVertexBuffer:()=>xQ,createVertexShader:()=>bQ,downloadByteEncodedFloatMatrixFromOutputTexture:()=>zQ,downloadFloat32MatrixFromBuffer:()=>RQ,downloadMatrixFromPackedOutputTexture:()=>VQ,downloadPackedMatrixFromBuffer:()=>BQ,getInternalFormatForFloat16MatrixTexture:()=>EQ,getInternalFormatForFloat16PackedMatrixTexture:()=>MQ,getInternalFormatForFloat32MatrixTexture:()=>wQ,getInternalFormatForPackedMatrixTexture:()=>AQ,getInternalFormatForUnsignedBytesMatrixTexture:()=>OQ,uploadDenseMatrixToTexture:()=>FQ,uploadPixelDataToTexture:()=>IQ});function bQ(e){let t=BZ(),n=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return KX(e,n)}function xQ(e){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return QX(e,t)}function SQ(e){let t=new Uint16Array([0,1,2,2,1,3]);return $X(e,t)}function CQ(e,t,n,r,i,a){nZ(t,n);let o=tZ(e),s=e.TEXTURE_2D;return Q(e,()=>e.bindTexture(s,o)),Q(e,()=>e.texParameteri(s,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),Q(e,()=>e.texParameteri(s,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),Q(e,()=>e.texParameteri(s,e.TEXTURE_MIN_FILTER,e.NEAREST)),Q(e,()=>e.texParameteri(s,e.TEXTURE_MAG_FILTER,e.NEAREST)),k().getNumber(`WEBGL_VERSION`)===1?Q(e,()=>e.texImage2D(s,0,r,t,n,0,i,a,null)):Q(e,()=>e.texStorage2D(s,1,r,t,n)),Q(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:o,texShape:[n,t]}}function wQ(e){return e.internalFormatFloat}function TQ(e,t,n,r){let[i,a]=jX(t,n);return CQ(e,i,a,wQ(r),r.textureFormatFloat,e.FLOAT)}function EQ(e){return e.internalFormatHalfFloat}function DQ(e,t,n,r){let[i,a]=jX(t,n);return CQ(e,i,a,EQ(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function OQ(e){return e.downloadTextureFormat}function kQ(e,t,n,r){let[i,a]=jX(t,n);return CQ(e,i,a,OQ(r),e.RGBA,e.UNSIGNED_BYTE)}function AQ(e){return e.internalFormatPackedFloat}function jQ(e,t,n,r){let[i,a]=PX(t,n);return CQ(e,i,a,AQ(r),e.RGBA,e.FLOAT)}function MQ(e){return e.internalFormatPackedHalfFloat}function NQ(e,t,n,r){let[i,a]=PX(t,n);return CQ(e,i,a,MQ(r),e.RGBA,r.textureTypeHalfFloat)}function PQ(e,t,n){return Q(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),iZ(e,t,`clipSpacePos`,n,3,20,0)&&iZ(e,t,`uv`,n,2,20,12)}function FQ(e,t,n,r,i,a){Q(e,()=>e.bindTexture(e.TEXTURE_2D,t));let o,s,c;i instanceof Uint8Array?(o=new Uint8Array(n*r*4),s=e.UNSIGNED_BYTE,c=e.RGBA):(o=new Float32Array(n*r*4),s=e.FLOAT,c=a.internalFormatPackedFloat),o.set(i),k().getNumber(`WEBGL_VERSION`)===2?Q(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,s,o)):Q(e,()=>e.texImage2D(e.TEXTURE_2D,0,c,n,r,0,e.RGBA,s,o)),Q(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function IQ(e,t,n){Q(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?k().getNumber(`WEBGL_VERSION`)===2?Q(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):Q(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):k().getNumber(`WEBGL_VERSION`)===2?Q(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):Q(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),Q(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function LQ(e,t,n,r){let i=e.createBuffer();Q(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,i));let a=16*t*n;return Q(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,a,e.STREAM_READ)),Q(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),Q(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),i}function RQ(e,t,n){let r=e,i=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,i),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),i}function zQ(e,t,n,r){let[i,a]=jX(t,n),o=new Uint8Array(MX(t*n,4));return Q(e,()=>e.readPixels(0,0,i,a,r.downloadTextureFormat,e.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function BQ(e,t,n,r,i,a,o,s){let c=e,l=new Float32Array(FX(a,o));return c.bindBuffer(c.PIXEL_PACK_BUFFER,t),c.getBufferSubData(c.PIXEL_PACK_BUFFER,0,l),c.bindBuffer(c.PIXEL_PACK_BUFFER,null),l}function VQ(e,t,n){let r=new Float32Array(t*n*4);return Q(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r)),r}var HQ=o((()=>{Y(),VZ(),BX(),RZ()}));function Rpe(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}var UQ,WQ=o((()=>{Y(),AX(),HQ(),BX(),RZ(),UQ=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=k().getNumber(`WEBGL_VERSION`);if(e==null?this.gl=TX(t):(this.gl=e,wX(t,e)),e=this.gl,k().getNumber(`WEBGL_VERSION`)===2){let t=e;this.createVertexArray=()=>Q(t,()=>t.createVertexArray()),this.bindVertexArray=e=>Q(t,()=>t.bindVertexArray(e)),this.deleteVertexArray=e=>Q(t,()=>t.deleteVertexArray(e)),this.getVertexArray=()=>Q(t,()=>t.getParameter(t.VERTEX_ARRAY_BINDING))}else if(e!=null){let t=e.getExtension(`OES_vertex_array_object`);if(t==null)throw Error(`All WebGL1 implementations are expected to offer OES_vertex_array_object.`);this.createVertexArray=()=>Q(e,()=>t.createVertexArrayOES()),this.bindVertexArray=n=>Q(e,()=>t.bindVertexArrayOES(n)),this.deleteVertexArray=n=>Q(e,()=>t.deleteVertexArrayOES(n)),this.getVertexArray=()=>Q(e,()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES))}let n=`WEBGL_color_buffer_float`,r=`EXT_color_buffer_half_float`;if(this.parallelCompilationExtension=this.gl.getExtension(`KHR_parallel_shader_compile`),k().getNumber(`WEBGL_VERSION`)===1){let e=`OES_texture_half_float`;if(this.textureFloatExtension=GX(this.gl,`OES_texture_float`),EZ(this.gl,e))this.textureHalfFloatExtension=GX(this.gl,e);else if(k().get(`WEBGL_FORCE_F16_TEXTURES`))throw Error(`GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.`);if(this.colorBufferFloatExtension=this.gl.getExtension(n),EZ(this.gl,r))this.colorBufferHalfFloatExtension=GX(this.gl,r);else if(k().get(`WEBGL_FORCE_F16_TEXTURES`))throw Error(`GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.`)}else if(n=`EXT_color_buffer_float`,EZ(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(EZ(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw Error(`GL context does not support color renderable floats`);this.vertexBuffer=xQ(this.gl),this.indexBuffer=SQ(this.gl),this.framebuffer=rZ(this.gl),this.textureConfig=IX(this.gl,this.textureHalfFloatExtension)}get debug(){return k().getBool(`DEBUG`)}dispose(){if(this.disposed)return;this.program!=null&&console.warn(`Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing.`),this.outputTexture!=null&&console.warn(`Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.`);let e=this.gl;Q(e,()=>e.finish()),Q(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Q(e,()=>e.deleteFramebuffer(this.framebuffer)),Q(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Q(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Q(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),TQ(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),DQ(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),kQ(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),IQ(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),FQ(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),NQ(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),jQ(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(fZ(this.gl,this.framebuffer),this.outputTexture=null),Q(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>zQ(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,r,i,a){return BQ(this.gl,e,t,n,r,i,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return RQ(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let r=LQ(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(k().getBool(`WEBGL_FENCE_API_ENABLED`)){let r=e,i=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let e=r.clientWaitSync(i,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=i}else k().getNumber(`WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION`)>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,k().getNumber(`WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION`))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>VQ(this.gl,t,n))}createProgram(e){this.throwIfDisposed();let t=this.gl;this.vertexShader??=bQ(t);let n=YX(t);Q(t,()=>t.attachShader(n,this.vertexShader)),Q(t,()=>t.attachShader(n,e)),XX(t,n);let r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&ZX(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);let t=this.gl;Q(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),PQ(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(Q(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&ZX(this.gl,this.program),Q(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?sZ(this.gl,e,t):cZ(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Q(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),lZ(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[r,i]=PX(t,n);this.setOutputMatrixTextureDriver(e,r,i)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw Error(`setOutputPackedMatrixWriteRegion not implemented.`)}debugValidate(){this.program!=null&&ZX(this.gl,this.program),pZ(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let e=this.getVertexArray();console.assert(e===this.program.vao,`VAO changed between setProgram and executeProgram!`),this.debugValidate()}Q(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Q(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension??=GX(this.gl,k().getNumber(`WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION`)===2?`EXT_disjoint_timer_query_webgl2`:`EXT_disjoint_timer_query`),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(k().getNumber(`WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION`)===2){let e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(k().getNumber(`WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION`)===2){let e=this.gl,t=this.getQueryTimerExtensionWebGL2();e.endQuery(t.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Se(()=>this.disposed||this.isQueryAvailable(e,k().getNumber(`WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION`))),this.getQueryTime(e,k().getNumber(`WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION`))}getQueryTime(e,t){if(t===0)return null;if(t===2){let t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}else{let t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){let t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return this.disjoint??=this.gl.getParameter(n.GPU_DISJOINT_EXT),r&&!this.disjoint}else{let t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint??=this.gl.getParameter(t.GPU_DISJOINT_EXT),n&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=Rpe(this.itemsToPoll.map(e=>e.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;`setTimeoutCustom`in k().platform&&(n=k().platform.setTimeoutCustom.bind(k().platform)),Se(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),dZ(this.gl,e,this.framebuffer),this.debug&&pZ(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture==null?fZ(this.gl,this.framebuffer):(dZ(this.gl,this.outputTexture,this.framebuffer),this.debug&&pZ(this.gl))}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let r=this.gl;dZ(r,e,this.framebuffer),this.debug&&pZ(r),this.outputTexture=e,Q(r,()=>r.viewport(0,0,t,n)),Q(r,()=>r.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),Q(this.gl,()=>this.gl.scissor(e,t,n,r))}throwIfDisposed(){if(this.disposed)throw Error(`Attempted to use disposed GPGPUContext.`)}throwIfNoProgram(){if(this.program==null)throw Error(`No GPU program is currently set.`)}}})),GQ,KQ,qQ,JQ,YQ,XQ,ZQ,QQ,$Q,e$,t$,n$,r$,i$,a$,o$,s$,c$,l$,u$,d$,f$,p$,m$,h$,g$,_$,v$,y$,b$,x$,S$,C$,w$,T$,E$,D$,O$,k$,A$,j$,M$,N$,P$,F$,I$,L$,R$,z$,B$=o((()=>{UV(),{addImpl:GQ,bincountImpl:KQ,bincountReduceImpl:qQ,bitwiseAndImpl:JQ,castImpl:YQ,ceilImpl:XQ,concatImpl:ZQ,equalImpl:QQ,expImpl:$Q,expm1Impl:e$,floorImpl:t$,gatherNdImpl:n$,gatherV2Impl:r$,greaterImpl:i$,greaterEqualImpl:a$,lessImpl:o$,lessEqualImpl:s$,linSpaceImpl:c$,logImpl:l$,maxImpl:u$,maximumImpl:d$,minimumImpl:f$,multiplyImpl:p$,negImpl:m$,notEqualImpl:h$,prodImpl:g$,raggedGatherImpl:_$,raggedRangeImpl:v$,raggedTensorToTensorImpl:y$,rangeImpl:b$,rsqrtImpl:x$,scatterImpl:S$,sigmoidImpl:C$,simpleAbsImpl:w$,sliceImpl:T$,sparseFillEmptyRowsImpl:E$,sparseReshapeImpl:D$,sparseSegmentReductionImpl:O$,sqrtImpl:k$,staticRegexReplaceImpl:A$,stridedSliceImpl:j$,stringNGramsImpl:M$,stringSplitImpl:N$,stringToHashBucketFastImpl:P$,subImpl:F$,tileImpl:I$,topKImpl:L$,transposeImpl:R$,uniqueImpl:z$}=HV}));
/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/
function V$(e,t){return[`x`,`y`,`z`,`w`,`u`,`v`].slice(0,t).map(t=>`${e}.${t}`)}function H$(e,t){return t===1?[e]:V$(e,t)}function zpe(e,t){if(e===1)return`rc`;let n=``;for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=`,`);return n}var U$=o((()=>{})),W$,Bpe=o((()=>{fQ(),U$(),cQ(),W$=class{constructor(e){if(this.variableNames=[`A`],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=dQ(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let e=H$(`rc`,this.rank),t=$Z(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),i=this.getOutput(e);this.userCode=`
        void main() {
          ${t} rc = getOutputCoords();

          if(${n}) {
            setOutput(vec4(0));
          } else {
            ${r}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let i=`${n===0?`r`:`rp1`}, ${r===0?`c`:`cp1`}`;for(let t=2;t<this.rank;t++)i=`${e[e.length-1-t]},`+i;t.push(i)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?`outShape`:this.outputShape[0]}`;let t=``;for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+=`||`);return t}getSetup(e){if(this.rank===1)return``;let t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){let t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?`outShape`:this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}}));function Vpe(e,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?Yfe([`r`,`c`,`d`],`inputShape`):HZ([`r`,`c`,`d`],e)}
      return ivec3(r, c, d);
    }
  `}var G$,K$=o((()=>{fQ(),qZ(),G$=class{constructor(e,t){this.variableNames=[`A`],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:`inputShape`,type:`ivec3`}],this.outputShape=e,this.enableShapeUniforms=dQ(this.outputShape.length);let n=``;for(let e=0;e<4;e++){let t=`thisRC = rc;`;e%2==1&&(t+=`thisRC.z += 1;`),e>1&&(t+=`thisRC.y += 1;`),n+=`
        ${t}
        ${e>0?`if(thisRC.y < rows && thisRC.z < cols){`:``}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${e}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${e>0?`}`:``}
      `}this.userCode=`
      ${Vpe(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?GZ():WZ(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?`outShape[1]`:e[1]};
        int cols = ${this.enableShapeUniforms?`outShape[2]`:e[2]};

        ${n}

        setOutput(result);
      }
    `}}}));function Hpe(e,t){let n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F||t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw Error(`Unknown internal format ${t}`)}function q$(e,t,n,r,i){let a=Upe(t,r),o;if(i){let[t,n]=PX(e[0],e[1]);o=t*n}else{let[t,n]=jX(e[0],e[1]);o=t*n}let s=Hpe(n,a);return o*s}function Upe(e,t){switch(e){case zX.PACKED_2X2_FLOAT32:return AQ(t);case zX.PACKED_2X2_FLOAT16:return MQ(t);case zX.UNPACKED_FLOAT32:return wQ(t);case zX.UNPACKED_FLOAT16:return EQ(t);case zX.PACKED_4X1_UNSIGNED_BYTE:return OQ(t);default:throw Error(`Unknown physical texture type ${e}`)}}function Wpe(e){return k().getBool(`WEBGL_RENDER_FLOAT32_ENABLED`)?e?zX.PACKED_2X2_FLOAT32:zX.UNPACKED_FLOAT32:e?zX.PACKED_2X2_FLOAT16:zX.UNPACKED_FLOAT16}function J$(e,t){if(e===RX.UPLOAD)return zX.PACKED_2X2_FLOAT32;if(e===RX.RENDER||e==null)return Wpe(t);if(e===RX.DOWNLOAD||e===RX.PIXELS)return zX.PACKED_4X1_UNSIGNED_BYTE;throw Error(`Unknown logical texture type ${e}`)}function Y$(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var X$,Gpe=o((()=>{Y(),HQ(),BX(),X$=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){let r=J$(t,n),i=Y$(e,r,n);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);let a=q$(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();let e=this.freeTextures[i].pop();return this.usedTextures[i].push(e),e}let o;return r===zX.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===zX.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===zX.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===zX.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===zX.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[i].push(o),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),o}releaseTexture(e,t,n,r){if(this.freeTextures==null)return;let i=J$(n,r),a=Y$(t,i,r);a in this.freeTextures||(this.freeTextures[a]=[]);let o=q$(t,i,this.gpgpu.gl,this.gpgpu.textureConfig,r),s=k().getNumber(`WEBGL_DELETE_TEXTURE_THRESHOLD`);s!==-1&&this._numBytesAllocated>s?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=o):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;let c=this.usedTextures[a],l=c&&c.indexOf(e);if(l==null||l<0)throw Error(`Cannot release a texture that was never provided by this texture manager`);c[l]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log(`Free/Used`,`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let e in this.freeTextures)this.freeTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(let e in this.usedTextures)this.usedTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}})),Z$,Q$,$$,e1,t1,n1,r1,i1,a1,o1=o((()=>{fQ(),Z$=class{constructor(e,t){this.variableNames=[`A`],this.outputShape=e,this.enableShapeUniforms=dQ(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},Q$=`if (isnan(x)) return x;`,$$=`return x;`,e1=`return abs(x);`,t1=`return (x >= 0.0) ? x : (exp(x) - 1.0);`,n1=Q$+`
  return (x < 0.0) ? 0.0 : x;
`,r1=Q$+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,i1=`return x;`,a1=`return 1.0 / (1.0 + exp(-1.0 * x));`})),s1,c1,l1,u1,d1,f1,p1=o((()=>{fQ(),s1=`return x;`,c1=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,l1=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,u1=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,d1=`return 1.0 / (1.0 + exp(-1.0 * x));`,f1=class{constructor(e,t){this.variableNames=[`A`],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=dQ(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}})),m1,Kpe=o((()=>{fQ(),U$(),cQ(),m1=class{constructor(e){this.variableNames=[`A`],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=dQ(this.outputShape.length);let t=e.length,n=H$(`rc`,t),r=$Z(t),i=zpe(t,n),a=n.slice(-2),o=t<=1?`rc`:`vec2(${a.join(`,`)})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${i});

        setOutput(getChannel(packedInput, ${o}));
      }
    `}}}));function qpe(e){return e in v1||(v1[e]={}),v1[e]}function Jpe(){return k().global.screen==null?1024:k().global.screen.height*k().global.screen.width*window.devicePixelRatio*b1/1024/1024}function Ype(e,t){if(t===`float32`||t===`complex64`)return e;if(t===`int32`||t===`bool`){let n=t===`int32`?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}else throw Error(`Unknown dtype ${t}`)}var h1,g1,_1,v1,y1,b1,x1,S1=o((()=>{qfe(),Y(),AX(),jpe(),Mpe(),Npe(),Ppe(),Fpe(),Ipe(),WQ(),fQ(),B$(),Bpe(),K$(),BX(),Gpe(),o1(),p1(),Kpe(),RZ(),h1=hv,g1=1e-7,_1=1e-4,v1={},y1=k().getNumber(`CPU_HANDOFF_SIZE_THRESHOLD`),b1=600,x1=class e extends ne{nextDataId(){return e.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!k().getBool(`HAS_WEBGL`))throw Error(`WebGL is not supported on this device`);let t;if(e!=null){if(e instanceof UQ)t=e;else{let n=TX(k().getNumber(`WEBGL_VERSION`),e);t=new UQ(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let e=TX(k().getNumber(`WEBGL_VERSION`));t=new UQ(e),this.binaryCache=qpe(k().getNumber(`WEBGL_VERSION`)),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new X$(this.gpgpu),this.numMBBeforeWarning=Jpe(),this.texData=new te(this,ko())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,r,i,a){let o=this.makeTensorInfo(t,n),s=this.texData.get(o.dataId);s.isPacked=!1,s.texture={texture:e,texShape:[r,i]},s.texShape=[r,i];let c=yZ(t),l=new vQ(c,!1,a),u=this.runWebGLProgram(l,[o],n,[[r,i]]);return u.shape=t,s.texture=null,this.disposeIntermediateTensorInfo(o),u.dataId}write(e,t,n){if((k().getBool(`WEBGL_CHECK_NUMERICAL_PROBLEMS`)||k().getBool(`DEBUG`))&&this.checkNumericalProblems(e),n===`complex64`&&e!=null)throw Error(`Cannot write to a complex64 dtype. Please use tf.complex(real, imag).`);let r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:RX.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){let t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){let t=this.texData.get(e);t.refCount--}}move(e,t,n,r,i){if(k().getBool(`DEBUG`)&&this.checkNumericalProblems(t),r===`complex64`)throw Error(`Cannot write to a complex64 dtype. Please use tf.complex(real, imag).`);this.texData.set(e,{shape:n,dtype:r,values:t,usage:RX.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let{values:t,dtype:n,complexTensorInfos:r,slice:i,shape:a,isPacked:o}=this.texData.get(e);if(i!=null){let t;t=o?new f1(a,i1):new Z$(a,i1);let r=this.runWebGLProgram(t,[{dataId:e,shape:a,dtype:n}],n),i=this.readSync(r.dataId);return this.disposeIntermediateTensorInfo(r),i}if(t!=null)return this.convertAndCacheOnCPU(e);if(n===`string`)return t;let s=this.activeTimers!=null,c;s&&(c=Xi());let l;if(n===`complex64`){let e=this.readSync(r.real.dataId),t=this.readSync(r.imag.dataId);l=US(e,t)}else l=this.getValuesFromTexture(e);return s&&(this.downloadWaitMs+=Xi()-c),this.convertAndCacheOnCPU(e,l)}async read(e){if(this.pendingRead.has(e)){let t=this.pendingRead.get(e);return new Promise(e=>t.push(e))}let{values:t,shape:n,slice:r,dtype:i,complexTensorInfos:a,isPacked:o}=this.texData.get(e);if(r!=null){let t;t=o?new f1(n,i1):new Z$(n,i1);let r=this.runWebGLProgram(t,[{dataId:e,shape:n,dtype:i}],i),a=this.read(r.dataId);return this.disposeIntermediateTensorInfo(r),a}if(t!=null)return this.convertAndCacheOnCPU(e);if(k().getBool(`DEBUG`)&&!k().getBool(`WEBGL_DOWNLOAD_FLOAT_ENABLED`)&&k().getNumber(`WEBGL_VERSION`)===2)throw Error(`tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.`);let s=null,c;if(i!==`complex64`&&k().get(`WEBGL_BUFFER_SUPPORTED`)){c=this.decode(e);let t=this.texData.get(c.dataId);s=this.gpgpu.createBufferFromTexture(t.texture.texture,...NX(n))}this.pendingRead.set(e,[]),i!==`complex64`&&await this.gpgpu.createAndWaitForFence();let l;if(i===`complex64`){let e=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),t=e[0],n=e[1];l=US(t,n)}else if(s==null)l=this.getValuesFromTexture(e);else{let e=O(n);l=this.gpgpu.downloadFloat32MatrixFromBuffer(s,e)}if(c!=null&&this.disposeIntermediateTensorInfo(c),s!=null){let e=this.gpgpu.gl;Q(e,()=>e.deleteBuffer(s))}let u=this.convertAndCacheOnCPU(e,l),d=this.pendingRead.get(e);return this.pendingRead.delete(e),d.forEach(e=>e(u)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&ko().removeDataId(e,this),this.pendingDeletes--),u}readToGPU(e,t={}){let{values:n,shape:r,slice:i,dtype:a,isPacked:o,texture:s}=this.texData.get(e);if(a===`complex64`)throw Error(`Does not support reading texture for complex64 dtype.`);if(i!=null){let n;n=o?new f1(r,i1):new Z$(r,i1);let i=this.runWebGLProgram(n,[{dataId:e,shape:r,dtype:a}],a),s=this.readToGPU(i,t);return this.disposeIntermediateTensorInfo(i),s}if(s==null)throw n==null?Error(`There is no data on GPU or CPU.`):Error(`Data is not on GPU but on CPU.`);let c=this.decode(e,t.customTexShape),l=ko().makeTensorFromTensorInfo(c),u=this.texData.get(c.dataId);return Object.assign({tensorRef:l},u.texture)}bufferSync(e){let t=this.readSync(e.dataId);if(e.dtype===`string`)try{let n=t.map(e=>$i(e));return mc(e.shape,e.dtype,n)}catch{throw Error(`Failed to decode encoded string bytes into utf-8`)}return mc(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){let n=e[t];if(!UX(n))throw k().getBool(`WEBGL_RENDER_FLOAT32_CAPABLE`)?Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${n} cannot be represented on this device.`)}}getValuesFromTexture(e){let{shape:t,dtype:n,isPacked:r}=this.texData.get(e),i=O(t);if(k().getBool(`WEBGL_DOWNLOAD_FLOAT_ENABLED`)){let n=this.decode(e),r=this.texData.get(n.dataId),a=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...NX(t)).subarray(0,i);return this.disposeIntermediateTensorInfo(n),a}let a=k().getBool(`WEBGL_PACK`)&&r===!0,o=a?yZ(t):t,s=a?new gQ(o):new hQ(o),c=this.runWebGLProgram(s,[{shape:o,dtype:n,dataId:e}],`float32`),l=this.texData.get(c.dataId),u=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture.texture,l.texShape[0],l.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(c),u}timerAvailable(){return k().getNumber(`WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE`)>0}time(e){let t=this.activeTimers,n=[],r=!1;this.programTimersStack==null?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();let i=ta(this.activeTimers.map(e=>e.query)).filter(e=>e!=null),a=ta(this.activeTimers.map(e=>e.name)).filter(e=>e!=null);this.activeTimers=t,r&&(this.programTimersStack=null);let o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(k().getNumber(`WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE`)>0){let e=await Promise.all(i);o.kernelMs=le(e),o.getExtraProfileInfo=()=>e.map((e,t)=>({name:a[t],ms:e})).map(e=>`${e.name}: ${e.ms}`).join(`, `)}else o.kernelMs={error:`WebGL query timers are not supported in this environment.`};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return k().getNumber(`WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE`)>0?this.gpgpu.beginQuery():{startMs:Xi(),endMs:null}}endTimer(e){return k().getNumber(`WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE`)>0?(this.gpgpu.endQuery(),e):(e.endMs=Xi(),e)}async getQueryTime(e){if(k().getNumber(`WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE`)>0)return this.gpgpu.waitForQueryAndGetTime(e);let t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:n}=this.texData.get(e);return n!=null&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:t,dtype:n,texShape:r,usage:i,isPacked:a,slice:o}=this.texData.get(e),s=o&&o.origDataId||e,c=this.dataRefCount.get(s);c>1?this.dataRefCount.set(s,c-1):(this.dataRefCount.delete(s),t!=null&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,i,a)));let l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=y1){return k().getBool(`WEBGL_CPU_FORWARD`)&&e.every(e=>this.texData.get(e.dataId).texture==null&&O(e.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){li(`tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead`);let t=e.dataSync();return h1(e.shape,t)}packedUnaryOp(e,t,n){let r=new f1(e.shape,t),i=this.compileAndRun(r,[e],n);return ko().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!==`complex64`){let t=w$(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(k().getBool(`WEBGL_PACK_UNARY_OPERATIONS`))return this.packedUnaryOp(e,e1,e.dtype);let t=new Z$(e.shape,e1),n=this.compileAndRun(t,[e]);return ko().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if(t===`string`&&n!=null&&n.length>0&&Ne(n[0])){let i=n.map(e=>Qi(e));r=this.write(i,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return ko().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){let t=new m1(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){let t=new W$(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){let n=[_Z(e.shape),...vZ(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},i=[_Z(t),...vZ(t)],a=new G$(i,n),o=[n],s=this.runWebGLProgram(a,[r],e.dtype,o,!0);return{dataId:s.dataId,shape:t,dtype:s.dtype}}decode(e,t){let{isPacked:n,shape:r,dtype:i}=this.texData.get(e);if(t!=null){let e=O(r),n=t[0]*t[1]*4;D(e<=n,()=>`customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.`)}let a=yZ(r),o;o=n?new mQ(a):new pQ(a);let s=[t??NX(a)],c=this.runWebGLProgram(o,[{shape:a,dtype:i,dataId:e}],i,s,!0,t);return{dtype:i,shape:r,dataId:c.dataId}}runWebGLProgram(e,t,n,r,i=!1,a){let o=this.makeTensorInfo(e.outputShape,n),s=this.texData.get(o.dataId);if(e.packedOutput&&(s.isPacked=!0),e.outPackingScheme===LX.DENSE&&(s.texShape=(a??NX(e.outputShape)).map(e=>e*2)),e.outTexUsage!=null&&(s.usage=e.outTexUsage),O(o.shape)===0)return s.values=Ee(o.dtype,0),o;let c=[],l=t.map(t=>{if(t.dtype===`complex64`)throw Error(`GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.`);let n=this.texData.get(t.dataId);if(n.texture==null){if(!e.packedInputs&&O(t.shape)<=k().getNumber(`WEBGL_SIZE_UPLOAD_UNIFORM`))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),c.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!SZ(n.shape,t.shape)){let e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),c.push(t),n=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:n,isUniform:!1}});this.uploadToGPU(o.dataId);let u={shape:o.shape,texData:s,isUniform:!1},d=Ape(e,l,u),f=this.getAndSaveBinary(d,()=>Ope(this.gpgpu,e,l,u)),p=this.activeTimers!=null,m;p&&(m=this.startTimer()),k().get(`ENGINE_COMPILE_ONLY`)||kpe(this.gpgpu,f,l,u,r),c.forEach(e=>this.disposeIntermediateTensorInfo(e)),p&&(m=this.endTimer(m),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(m)}));let h=k().getNumber(`WEBGL_FLUSH_THRESHOLD`);if(h>0){let e=Xi();e-this.lastGlFlushTime>h&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!k().getBool(`WEBGL_LAZILY_UNPACK`)&&s.isPacked&&i===!1){let e=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),e}return o}compileAndRun(e,t,n,r,i=!1){return n||=t[0].dtype,this.runWebGLProgram(e,t,n,r,i)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||=(k().getBool(`IS_TEST`)||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<`u`&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),!0)}floatPrecision(){return this.floatPrecisionValue??=B(()=>{if(!k().get(`WEBGL_RENDER_FLOAT32_ENABLED`)){let e=k().getBool(`DEBUG`);k().set(`DEBUG`,!1);let t=this.abs(Zf(1e-8)).dataSync()[0];if(k().set(`DEBUG`,e),t>0)return 32}return 16}),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?g1:_1}uploadToGPU(e){let t=this.texData.get(e),{shape:n,dtype:r,values:i,texture:a,usage:o,isPacked:s}=t;if(a!=null)return;let c=this.activeTimers!=null,l;c&&(l=Xi());let u=t.texShape;if(u??(u=bZ(n,s),t.texShape=u),i!=null){let e=yZ(n),a,o=u[1],d=u[0],f=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(s||!f)&&([o,d]=PX(u[0],u[1])),a=s?new yQ(e,f):new vQ(e,f);let p=f?[d,o]:u,m=this.makeTensorInfo(p,r),h=this.texData.get(m.dataId);f?h.usage=RX.PIXELS:h.usage=RX.UPLOAD,h.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(m.dataId),o,d,i);let g=[[d,o]],_=this.runWebGLProgram(a,[m],r,g,!0),v=this.texData.get(_.dataId);t.texShape=v.texShape,t.isPacked=v.isPacked,t.usage=v.usage,k().get(`ENGINE_COMPILE_ONLY`)?this.disposeData(_.dataId):(t.texture=v.texture,t.values=null,this.texData.delete(_.dataId)),this.disposeIntermediateTensorInfo(m),c&&(this.uploadWaitMs+=Xi()-l)}else t.texture=this.acquireTexture(u,o,r,s)}convertAndCacheOnCPU(e,t){let n=this.texData.get(e),{dtype:r}=n;return t!=null&&(n.values=Ype(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*je(t)}checkCompileCompletion(){for(let[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){let e=[];if(this.gpgpu.parallelCompilationExtension){for(let[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(let[,t]of Object.entries(this.binaryCache)){let n=new Promise(e=>{try{this.checkCompletion_(t),e(!0)}catch(e){throw e}});e.push(n)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await _S(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(JX(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),Error(`Failed to compile fragment shader.`)):Error(`Failed to link vertex and fragment shaders.`);return!0}getUniformLocations(){for(let e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);let{variablesLocations:t,customUniformLocations:n,infLoc:r,nanLoc:i,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:s}=lQ(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=i,e.outShapeLocation=a,e.outShapeStridesLocation=o,e.outTexShapeLocation=s}}createTensorFromGPUData(e,t,n){e.channels=e.channels||`RGBA`;let{texture:r,height:i,width:a,channels:o}=e,s=ko().backend;if(!s.gpgpu.gl.isTexture(r))throw Error(`The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.`);let c=s.writeTexture(r,t,n,i,a,o);return ko().makeTensorFromDataId(c,t,n,s)}},x1.nextDataId=0})),C1,Xpe=o((()=>{C1=`4.22.0`}));function w1(){k().set(`WEBGL_FORCE_F16_TEXTURES`,!0)}var T1=o((()=>{Y(),HQ(),RZ(),S1(),AX(),WQ()})),E1,Zpe=o((()=>{Y(),S1(),Xpe(),T1(),T1(),to()&&Vo(`webgl`,()=>new x1,2),E1={forceHalfFloat:w1}})),D1,O1,k1=o((()=>{Y(),fQ(),D1=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,O1=class{constructor(e,t,n){this.variableNames=[`A`,`B`],this.outputShape=nf(t,n),this.enableShapeUniforms=dQ(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}})),A1,j1,M1=o((()=>{Y(),fQ(),U$(),cQ(),A1=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`,j1=class{constructor(e,t,n,r=!1){this.variableNames=[`A`,`B`],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=nf(t,n);let i=this.outputShape.length;this.enableShapeUniforms=dQ(i);let a=``;if(r)if(i===0||O(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${$Z(i)} coords = getOutputCoords();
        `,i===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let e=H$(`coords`,i);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (${e[i-2]} + 1) >= outShape[${i} - 2];
            bool nextColOutOfBounds =
              (${e[i-1]} + 1) >= outShape[${i} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (${e[i-2]} + 1) >= ${this.outputShape[i-2]};
            bool nextColOutOfBounds =
              (${e[i-1]} + 1) >= ${this.outputShape[i-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}}}));function N1(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var P1,F1=o((()=>{Y(),P1={kernelName:vn,backendName:`webgl`,kernelFunc:N1}}));function I1(e){let{inputs:t,backend:n}=e,{real:r,imag:i}=t,a=n.makeTensorInfo(r.shape,`complex64`),o=n.texData.get(a.dataId),s=N1({inputs:{x:r},backend:n}),c=N1({inputs:{x:i},backend:n});return o.complexTensorInfos={real:s,imag:c},a}var L1,R1=o((()=>{Y(),F1(),L1={kernelName:Nt,backendName:`webgl`,kernelFunc:I1}}));function Qpe(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{alpha:a}=r,o=n.makeTensorInfo([],`float32`,qi(a,`float32`)),s=k().getBool(`WEBGL_PACK_BINARY_OPERATIONS`)?new j1(B1,i.shape,o.shape):new O1(z1,i.shape,o.shape),c=n.runWebGLProgram(s,[i,o],`float32`);return n.disposeIntermediateTensorInfo(o),c}var z1,B1,V1,H1=o((()=>{Y(),k1(),M1(),z1=`return (a < 0.) ? b * a : a;`,B1=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`,V1={kernelName:wn,backendName:`webgl`,kernelFunc:Qpe}}));function $pe(e){let{inputs:t,backend:n}=e,{x:r,alpha:i}=t,a=k().getBool(`WEBGL_PACK_BINARY_OPERATIONS`)?new j1(W1,r.shape,i.shape):new O1(U1,r.shape,i.shape);return n.runWebGLProgram(a,[r,i],`float32`)}var U1,W1,G1,K1=o((()=>{Y(),k1(),M1(),U1=`return (a < 0.) ? b * a : a;`,W1=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`,G1={kernelName:rr,backendName:`webgl`,kernelFunc:$pe}}));function q1({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:i,backend:a})=>{let{x:o}=i,s=a,c=r||o.dtype;if(s.shouldExecuteOnCPU([o])&&n!=null){let e=s.texData.get(o.dataId),t=n(e.values,c);return s.makeTensorInfo(o.shape,c,t)}let l=k().getBool(`WEBGL_PACK_UNARY_OPERATIONS`)&&t!=null,u;return u=l?new f1(o.shape,t):new Z$(o.shape,e),s.runWebGLProgram(u,[o],c)}}function J1({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:i,dtype:a}){return({inputs:o,backend:s})=>{let{a:c,b:l}=o,u=s;if(r&&c.dtype===`complex64`){let t=u.texData.get(c.dataId),n=u.texData.get(l.dataId),[r,i]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map(t=>{let[n,r]=t,i={dataId:n.dataId,dtype:n.dtype,shape:c.shape},a={dataId:r.dataId,dtype:r.dtype,shape:l.shape},o=new O1(e,c.shape,l.shape);return u.runWebGLProgram(o,[i,a],Ea(n.dtype,r.dtype))}),a=I1({inputs:{real:r,imag:i},backend:u});return u.disposeIntermediateTensorInfo(r),u.disposeIntermediateTensorInfo(i),a}let d=a||Ea(c.dtype,l.dtype);if((c.dtype===`string`||l.dtype===`string`||u.shouldExecuteOnCPU([c,l]))&&i!=null){let e=u.texData.get(c.dataId).values,t=u.texData.get(l.dataId).values,n=c.dtype===`string`?CC(e):e,r=c.dtype===`string`?CC(t):t,[a,o]=i(c.shape,l.shape,n,r,d),s=u.makeTensorInfo(o,d),f=u.texData.get(s.dataId);return f.values=a,s}let f=k().getBool(`WEBGL_PACK_BINARY_OPERATIONS`)&&t!=null,p;return p=f?new j1(t,c.shape,l.shape,n):new O1(e,c.shape,l.shape),u.runWebGLProgram(p,[c,l],d)}}function Y1(e,t=!1){if(e===`linear`)return t?s1:$$;if(e===`relu`)return t?l1:n1;if(e===`elu`)return t?c1:t1;if(e===`relu6`)return t?u1:r1;if(e===`prelu`)return t?W1:U1;if(e===`leakyrelu`)return t?B1:z1;if(e===`sigmoid`)return t?d1:a1;throw Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var X1,Z1=o((()=>{Y(),k1(),M1(),R1(),H1(),K1(),o1(),p1(),X1=`if (isnan(x)) return x;`})),Q1,$1=o((()=>{fQ(),Q1=class{constructor(e,t,n,r=!1,i=!1,a=!1,o=null,s=!1,c=!1){this.variableNames=[`matrixA`,`matrixB`],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=dQ(this.outputShape.length);let l=r?e[1]:e[2],u=Math.ceil(l/2),d=r?`i * 2, rc.y`:`rc.y, i * 2`,f=i?`rc.z, i * 2`:`i * 2, rc.z`,p=r?[`a.xxyy`,`a.zzww`]:[`a.xxzz`,`a.yyww`],m=i?[`b.xzxz`,`b.ywyw`]:[`b.xyxy`,`b.zwzw`],h=``,g=``;o&&(h=s?`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:c?`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:`vec4 activation(vec4 x) {
          ${o}
        }`,g=`result = activation(result);`);let _=a?`result += getBiasAtOutCoords();`:``;a&&this.variableNames.push(`bias`),s&&this.variableNames.push(`preluActivationWeights`),c&&this.variableNames.push(`leakyreluAlpha`);let v=`rc.x`,y=`rc.x`;e[0]<t[0]?v=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(y=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${h}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${u}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${v};
        int batchB = ${y};
        for (int i = 0; i < ${u}; i++) {
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${f});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${p[0]} * ${m[0]});
          result += (${p[1]} * ${m[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${_}

        ${g}

        setOutput(result);
      }
    `}}})),e0,t0,eme=o((()=>{Y(),e0={REAL:`return areal * breal - aimag * bimag;`,IMAG:`return areal * bimag + aimag * breal;`},t0=class{constructor(e,t,n){this.variableNames=[`AReal`,`AImag`,`BReal`,`BImag`],this.outputShape=nf(t,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}}));function n0(e){let{inputs:t,backend:n}=e,{a:r,b:i}=t,a=Ea(r.dtype,i.dtype);if(r.dtype===`complex64`){let e=n.texData.get(r.dataId),t=n.texData.get(i.dataId),a=new t0(e0.REAL,r.shape,i.shape),o=new t0(e0.IMAG,r.shape,i.shape),s=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:i.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:i.shape}],c=n.runWebGLProgram(a,s,`float32`),l=n.runWebGLProgram(o,s,`float32`),u=I1({inputs:{real:c,imag:l},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),u}if(n.shouldExecuteOnCPU([r,i])){let e=n.texData.get(r.dataId),t=n.texData.get(i.dataId),[o,s]=p$(r.shape,i.shape,e.values,t.values,a),c=n.makeTensorInfo(s,a),l=n.texData.get(c.dataId);return l.values=o,c}let o;return o=k().getBool(`WEBGL_PACK_BINARY_OPERATIONS`)?new j1(r0,r.shape,i.shape):new O1(r0,r.shape,i.shape),n.runWebGLProgram(o,[r,i],a)}var r0,i0,a0=o((()=>{Y(),eme(),k1(),M1(),B$(),R1(),r0=`return a * b;`,i0={kernelName:qn,backendName:`webgl`,kernelFunc:n0}}));function tme(e,t,n){let r=[_Z(e.shape),...vZ(e.shape)],i={dtype:e.dtype,shape:r,dataId:e.dataId},a=[_Z(t),...vZ(t)],o=new G$(a,r),s=[r],c=n.runWebGLProgram(o,[i],e.dtype,s,!0);return{dataId:c.dataId,shape:t,dtype:c.dtype}}var nme=o((()=>{K$(),RZ()}));function $(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{shape:a}=r,o=n,s=O(i.shape),c=Ce(a,s),l=O(c);D(s===l,()=>`The new shape (${c}) has ${l} elements and the old shape (${i.shape}) has ${s} elements. The new shape and old shape must have the same number of elements.`);let u=o.texData.get(i.dataId);return u.isPacked&&!SZ(i.shape,c)&&!(u.texture!==null&&SZ(u.shape,c))?tme(i,c,o):(o.incRef(i.dataId),{dataId:i.dataId,shape:c,dtype:i.dtype})}var o0,s0=o((()=>{Y(),nme(),RZ(),o0={kernelName:fr,backendName:`webgl`,kernelFunc:$}})),c0,rme=o((()=>{Y(),c0=class{constructor(e,t){this.variableNames=[`x`];let{windowSize:n,batchSize:r,inSize:i,outSize:a}=e;this.outputShape=[r,a];let o=Math.floor(n/4)*4,s=n%4,c=`sumValue += dot(values, ones);`;if(t!=null){let e=1/t;c=`sumValue += dot(values * ${_e(e)?e.toPrecision(2):e}, ones);`}let l=``;i%n>0&&(l=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${l}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${o}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${o};
        if (${s===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${s===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${s===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}}})),l0,ime=o((()=>{l0=class{constructor(e,t){this.variableNames=[`x`];let{windowSize:n,batchSize:r,inSize:i,outSize:a}=e;this.outputShape=[r,a];let o=`0.0`,s=``;t===`prod`?o=`1.0`:t===`min`?(o=`1.0 / 1e-20`,s=`min`):t===`max`&&(o=`-1.0 / 1e-20`,s=`max`);let c=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t===`sum`?c=`sumValue`:t===`prod`?c=`prodValue`:t===`all`?c=`allValue`:t===`any`&&(c=`anyValue`);let l=Math.floor(n/4)*4,u=n%4,d=`
      if (${t===`sum`}) {
        sumValue += dot(values, ones);
      } else if (${t===`prod`}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${s}(values, minMaxValue);
        if (${t===`min`} || ${t===`max`}) {
          minMaxValue = ${s}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,f=`vec4`;t===`all`?(o=`1.0`,d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,f=`bvec4`):t===`any`&&(o=`0.0`,d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,f=`bvec4`);let p=``;i%n>0&&(p=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${o};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${o});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${l}; i += 4) {
          int inIdx = inOffset + i;
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${l};
        if (${u===1}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${u===2}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${u===3}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${c});
      }
    `}}}));function ame(e){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let n=t.length?t[t.length-1].outSize:e[1],r=ES(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}function u0(e,t,n,r){let i=ame(e.shape),a=e;for(let o=0;o<i.length;o++){let{inSize:s,windowSize:c,outSize:l}=i[o],u,d;u=n===`mean`?o===0?new c0({windowSize:c,inSize:s,batchSize:e.shape[0],outSize:l},s):new c0({windowSize:c,inSize:s,batchSize:e.shape[0],outSize:l}):new l0({windowSize:c,inSize:s,batchSize:e.shape[0],outSize:l},n),d=a,a=r.runWebGLProgram(u,[a],t),d.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(d)}return a}var d0=o((()=>{Y(),rme(),ime()}));function ome(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=[`resRC.x`,`resRC.y`,`resRC.z`,`resRC.w`,`resRC.u`,`resRC.v`],r=Array(t);for(let t=0;t<e.length;t++)r[e[t]]=n[t];return r.join()}var f0,sme=o((()=>{cQ(),f0=class{constructor(e,t){this.variableNames=[`A`];let n=Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.rank=n.length;let r=$Z(this.rank),i=ome(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${i}));
    }
    `}}})),p0,cme=o((()=>{U$(),cQ(),p0=class{constructor(e,t){this.variableNames=[`A`],this.packedInputs=!0,this.packedOutput=!0;let n=Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let r=$Z(this.rank),i=V$(`rc`,this.rank),a=Array(this.rank);for(let e=0;e<t.length;e++)a[t[e]]=i[e];let o=`vec2(${a.slice(-2).join()})`,s=`++${i[this.rank-1]} < ${n[this.rank-1]}`,c=`getChannel(getA(${a.join()}), ${o})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${s}) {
        result[1] = ${c};
      }
      --${i[this.rank-1]};
      if(++${i[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${c};
        if(${s}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}}));function m0(e,t,n){let r=k().getBool(`WEBGL_PACK_ARRAY_OPERATIONS`)?new p0(e.shape,t):new f0(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}var h0=o((()=>{Y(),B$(),sme(),cme()}));function lme(e,t,n,r){let i=t,a=e.shape.length,o=we(i,e.shape),s=o,c=Rf(s,a),l=c!=null,u=e;l&&(u=m0(e,c,r),s=Bf(s.length,a)),Lf(`sum`,s,a);let[d,f]=Ff(u.shape,s),p=d;n&&(p=If(d,o));let m=O(f),h=O(e.shape)/m,g=$({inputs:{x:u},attrs:{shape:[h,m]},backend:r}),_=Da(e.dtype),v=u0(g,_,`sum`,r),y=$({inputs:{x:v},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(v),l&&r.disposeIntermediateTensorInfo(u),y}var ume=o((()=>{Y(),d0(),s0(),h0()}));function g0(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a,keepDims:o}=r;return lme(i,a,o,n)}var _0,v0=o((()=>{Y(),ume(),_0={kernelName:`Sum`,backendName:`webgl`,kernelFunc:g0}}));function y0(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{perm:a}=r,o=n,s=i.shape.length,c=Array(s);for(let e=0;e<c.length;e++)c[e]=i.shape[a[e]];let l;if(o.shouldExecuteOnCPU([i])){let e=o.texData.get(i.dataId).values,t=R$(e,i.shape,i.dtype,a,c);l=o.makeTensorInfo(c,i.dtype);let n=o.texData.get(l.dataId);n.values=t}else l=m0(i,a,o);return l}var b0,x0=o((()=>{Y(),h0(),b0={kernelName:Zr,backendName:`webgl`,kernelFunc:y0}}));function S0({a:e,b:t,transposeA:n,transposeB:r,backend:i,bias:a=null,preluActivationWeights:o=null,leakyreluAlpha:s=0,activation:c=null}){let l=e.shape.length,u=t.shape.length,d=n?e.shape[l-2]:e.shape[l-1],f=r?t.shape[u-1]:t.shape[u-2],p=n?e.shape[l-1]:e.shape[l-2],m=r?t.shape[u-2]:t.shape[u-1],h=e.shape.slice(0,-2),g=t.shape.slice(0,-2),_=O(h),v=O(g),y=nf(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([p,m]);D(d===f,()=>`Error in matMul: inner shapes (${d}) and (${f}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`);let b=n?[_,d,p]:[_,p,d],x=r?[v,m,f]:[v,f,m],S=$({inputs:{x:e},backend:i,attrs:{shape:b}}),C=$({inputs:{x:t},backend:i,attrs:{shape:x}}),w=[S,C],T=Math.max(_,v),ee=n?S.shape[1]:S.shape[2],E=a!=null,te=o!=null,ne=c===`leakyrelu`,re=c==null?null:Y1(c,!0),ie=E||te||ne||re!=null,ae;if((p===1||m===1)&&ee>1e3&&ie===!1){let e=S,t=C;n&&(e=y0({inputs:{x:S},backend:i,attrs:{perm:[0,2,1]}}),w.push(e)),r&&(t=y0({inputs:{x:C},backend:i,attrs:{perm:[0,2,1]}}),w.push(t));let a=m!==1,o=m===1,s=e;a&&(s=$({inputs:{x:e},backend:i,attrs:{shape:[T,ee,1]}}),w.push(s));let c=m===1?2:1,l=t;o&&(l=$({inputs:{x:t},backend:i,attrs:{shape:[T,1,ee]}}),w.push(l));let u=n0({inputs:{a:s,b:l},backend:i});ae=g0({inputs:{x:u},backend:i,attrs:{axis:c,keepDims:!0}}),w.push(u)}else{let c=Ea(e.dtype,t.dtype),l=new Q1(b,x,[T,p,m],n,r,E,re,te,ne),u=[S,C];if(a!=null&&u.push(a),te&&u.push(o),ne){let e=i.makeTensorInfo([],`float32`,qi(s,`float32`));u.push(e),w.push(e)}ae=i.runWebGLProgram(l,u,c)}let oe=$({inputs:{x:ae},backend:i,attrs:{shape:y}});w.push(ae);for(let e of w)i.disposeIntermediateTensorInfo(e);return oe}var C0=o((()=>{Y(),Z1(),$1(),a0(),s0(),v0(),x0()}));function dme(e){let{inputs:t,backend:n,attrs:r}=e,{a:i,b:a,bias:o,preluActivationWeights:s}=t,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:d}=r;return S0({a:i,b:a,transposeA:c,transposeB:l,backend:n,bias:o,preluActivationWeights:s,leakyreluAlpha:d,activation:u})}var w0,fme=o((()=>{Y(),C0(),w0={kernelName:oi,backendName:`webgl`,kernelFunc:dme}}));function pme(e){let{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&r.dtype!==`complex64`){let e=n.texData.get(r.dataId),t=w$(e.values);return n.makeTensorInfo(r.shape,r.dtype,t)}let i;return i=k().getBool(`WEBGL_PACK_UNARY_OPERATIONS`)?new f1(r.shape,T0):new Z$(r.shape,T0),n.runWebGLProgram(i,[r],r.dtype)}var T0,E0,mme=o((()=>{Y(),B$(),o1(),p1(),T0=`return abs(x);`,E0={kernelName:`Abs`,backendName:`webgl`,kernelFunc:pme}})),D0,O0,k0,hme=o((()=>{Y(),Z1(),o1(),D0=Q$+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,O0=q1({opSnippet:D0}),k0={kernelName:ut,backendName:`webgl`,kernelFunc:O0}})),A0,j0,M0,gme=o((()=>{Y(),Z1(),o1(),A0=Q$+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,j0=q1({opSnippet:A0}),M0={kernelName:dt,backendName:`webgl`,kernelFunc:j0}})),N0,P0,F0,_me=o((()=>{Y(),Z1(),B$(),N0=`return a + b;`,P0=J1({opSnippet:N0,packedOpSnippet:N0,supportsComplex:!0,cpuKernelImpl:GQ}),F0={kernelName:`Add`,backendName:`webgl`,kernelFunc:P0}})),I0,vme=o((()=>{I0=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((e,t)=>`T${t}`);let n=[];this.variableNames.forEach(e=>{n.push(`float v${e} = get${e}AtOutCoords();`)});let r=this.variableNames.map(e=>`v${e}`).join(` + `);this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}})),L0,yme=o((()=>{L0=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((e,t)=>`T${t}`);let n=[];this.variableNames.forEach(e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)});let r=this.variableNames.map(e=>`v${e}`).join(` + `);this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}}));function R0(e){let{inputs:t,backend:n}=e,r=t;if(r.length===1)return N1({inputs:{x:r[0]},backend:n});if(r.length>k().getNumber(`WEBGL_MAX_TEXTURES_IN_SHADER`)){let e=Math.floor(r.length/2),t=R0({inputs:r.slice(0,e),backend:n}),i=R0({inputs:r.slice(e),backend:n});return R0({inputs:[t,i],backend:n})}let i=r.map(e=>e.dtype).reduce((e,t)=>Ea(e,t)),a=r.map(e=>e.shape),o=k().getBool(`WEBGL_PACK`)?new L0(r[0].shape,a):new I0(r[0].shape,a);return n.runWebGLProgram(o,r,i)}var z0,bme=o((()=>{Y(),vme(),yme(),F1(),z0={kernelName:ft,backendName:`webgl`,kernelFunc:R0}}));function xme(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a,keepDims:o}=r,s=i.shape.length,c=we(a,i.shape),l=c,u=Rf(l,s),d=i;u!=null&&(d=y0({inputs:{x:i},backend:n,attrs:{perm:u}}),l=Bf(l.length,s)),Lf(`all`,l,s);let[f,p]=Ff(d.shape,l),m=O(p),h=$({inputs:{x:d},backend:n,attrs:{shape:[-1,m]}}),g=u0(h,h.dtype,`all`,n),_;if(o){let e=If(f,c);_=$({inputs:{x:g},backend:n,attrs:{shape:e}})}else _=$({inputs:{x:g},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(g),u!=null&&n.disposeIntermediateTensorInfo(d),_}var B0,Sme=o((()=>{Y(),d0(),s0(),x0(),B0={kernelName:`All`,backendName:`webgl`,kernelFunc:xme}}));function Cme(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a,keepDims:o}=r,s=i.shape.length,c=we(a,i.shape),l=c,u=Rf(l,s),d=i;u!=null&&(d=y0({inputs:{x:i},backend:n,attrs:{perm:u}}),l=Bf(l.length,s)),Lf(`any`,l,s);let[f,p]=Ff(d.shape,l),m=O(p),h=$({inputs:{x:d},backend:n,attrs:{shape:[-1,m]}}),g=u0(h,h.dtype,`any`,n),_;if(o){let e=If(f,c);_=$({inputs:{x:g},backend:n,attrs:{shape:e}})}else _=$({inputs:{x:g},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(g),u!=null&&n.disposeIntermediateTensorInfo(d),_}var V0,wme=o((()=>{Y(),d0(),s0(),x0(),V0={kernelName:`Any`,backendName:`webgl`,kernelFunc:Cme}})),H0,Tme=o((()=>{H0=class{constructor(e,t,n){this.variableNames=[`A`];let{windowSize:r,batchSize:i,outSize:a}=e;n||this.variableNames.push(`bestIndicesA`),this.outputShape=[i,a],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${n?`inOffset + i;`:`round(getBestIndicesA(batch, inOffset + i));`};
          float candidate = getA(batch, inIdx);
          if (candidate ${t===`max`?`>`:`<`} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}})),U0,Eme=o((()=>{Y(),U$(),cQ(),U0=class{constructor(e,t,n,r){this.variableNames=[`A`],this.packedInputs=!0,this.packedOutput=!0,D(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let i=e[e.length-1],a=Math.ceil(i/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push(`bestIndicesA`);let o=this.outputShape,s=o.length,c=$Z(s),l=H$(`coords`,s),u,d;if(a===1){d=s+1;let e=$Z(d);u=`
        ${e} sourceLocR = ${e}(${l.join()}, 0);
        ++${l[s-1]};
        ${e} sourceLocG = ${e}(${l.join()}, 0);
        ++${l[s-2]};
        ${e} sourceLocA = ${e}(${l.join()}, 0);
        --${l[s-1]};
        ${e} sourceLocB = ${e}(${l.join()}, 0);
        --${l[s-2]};`}else d=s,u=`
        ${c} sourceLocR = coords;
        ++${l[s-1]};
        ${c} sourceLocG = coords;
        ++${l[s-2]};
        ${c} sourceLocA = coords;
        --${l[s-1]};
        ${c} sourceLocB = coords;
        --${l[s-2]};`;let f=[`x`,`y`,`z`,`w`,`u`,`v`].slice(0,d),p=`.`+f[d-1],m=f.map(e=>`int `+e),h=H$(`sourceLocR`,d-1).concat(`inIdx.r`),g=H$(`sourceLocG`,d-1).concat(`inIdx.g`),_=H$(`sourceLocB`,d-1).concat(`inIdx.b`),v=H$(`sourceLocA`,d-1).concat(`inIdx.a`),y=n===`max`?`greaterThan`:`lessThan`,b=r?``:`
          inIdx = round(vec4(getBestIndicesAChannel(${h.join()}),
                             getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${_.join()}),
                             getBestIndicesAChannel(${v.join()})));`,x=`vec4(
            getAChannel(${h.join()}),
            hasNextCol ? getAChannel(${g.join()}) : 0.,
            hasNextRow ? getAChannel(${_.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${v.join()}) : 0.)`,S=r?``:`
      float getBestIndicesAChannel(${m.join()}) {
        return getChannel(getBestIndicesA(${f.join()}),
                                          vec2(${f.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${m.join()}) {
        return getChannel(getA(${f.join()}),
                               vec2(${f.slice(-2).join()}));
      }
      ${S}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${l[s-1]} < ${o[s-1]-1};
        bool hasNextRow = ${l[s-2]} < ${o[s-2]-1};
        ${u}
        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},
          sourceLocB${p}, sourceLocA${p}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${x};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${b}
          vec4 candidate = ${x};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${y}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}}));function W0(e,t,n,r=null){let i=t.shape[0],a=t.shape[1];r!=null&&(i=r.shape[0],a=r.shape[1]);let o=ES(a),s={windowSize:o,inSize:a,batchSize:i,outSize:Math.ceil(a/o)},c=new H0(s,n,r==null),l=[t];r!=null&&l.push(r);let u=e.runWebGLProgram(c,l,`int32`);if(u.shape[1]===1)return u;let d=W0(e,t,n,u);return e.disposeIntermediateTensorInfo(u),d}function G0(e,t,n,r=null){let i=r==null?t.shape:r.shape,a=i[i.length-1],o=ES(a),s=new U0(i,o,n,r==null),c=r==null?[t]:[t,r],l=e.runWebGLProgram(s,c,`int32`);if(l.shape.length===t.shape.length){let r=G0(e,t,n,l);return e.disposeIntermediateTensorInfo(l),r}return l}function K0(e,t,n,r){let i=[n];if(Lf(`arg`+r.charAt(0).toUpperCase()+r.slice(1),i,t.shape.length),!k().getBool(`WEBGL_PACK_REDUCE`)||t.shape.length<=2){let n=[],a=e.texData.get(t.dataId),o=a!==null&&a.isPacked,s=t;o&&(s=e.unpackTensor(t),n.push(s));let[c,l]=Ff(s.shape,i),u=O(l),d=$({inputs:{x:s},backend:e,attrs:{shape:[-1,u]}});n.push(d);let f=W0(e,d,r);n.push(f);let p=$({inputs:{x:f},backend:e,attrs:{shape:c}});return n.forEach(t=>e.disposeIntermediateTensorInfo(t)),p}return G0(e,t,r)}var q0=o((()=>{Y(),Tme(),Eme(),s0()}));function Dme(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a}=r,o=we(a,i.shape),s=Rf(o,i.shape.length),c=i,l=[];s!=null&&(c=y0({inputs:{x:i},backend:n,attrs:{perm:s}}),l.push(c),o=Bf(o.length,c.shape.length)),Lf(`argMax`,[o[0]],c.shape.length);let u=K0(n,c,o[0],`max`);return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),u}var J0,Ome=o((()=>{Y(),q0(),x0(),J0={kernelName:pt,backendName:`webgl`,kernelFunc:Dme}}));function kme(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a}=r,o=we(a,i.shape),s=Rf(o,i.shape.length),c=i,l=[];s!=null&&(c=y0({inputs:{x:i},backend:n,attrs:{perm:s}}),l.push(c),o=Bf(o.length,c.shape.length)),Lf(`argMin`,[o[0]],c.shape.length);let u=K0(n,c,o[0],`min`);return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),u}var Y0,Ame=o((()=>{Y(),q0(),x0(),Y0={kernelName:mt,backendName:`webgl`,kernelFunc:kme}})),X0,Z0,Q0,jme=o((()=>{Y(),Z1(),o1(),X0=Q$+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,Z0=q1({opSnippet:X0}),Q0={kernelName:ht,backendName:`webgl`,kernelFunc:Z0}})),$0,e2,t2,Mme=o((()=>{Y(),Z1(),o1(),$0=Q$+`return log(x + sqrt(x * x + 1.0));`,e2=q1({opSnippet:$0}),t2={kernelName:gt,backendName:`webgl`,kernelFunc:e2}})),n2,r2,i2,Nme=o((()=>{Y(),Z1(),o1(),n2=Q$+`
  return atan(x);
`,r2=q1({opSnippet:n2}),i2={kernelName:_t,backendName:`webgl`,kernelFunc:r2}})),a2,o2,s2,c2,Pme=o((()=>{Y(),k1(),M1(),Z1(),a2=D1+`
  return atan(a, b);
`,o2=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+A1+`
  return result;
`,s2=J1({opSnippet:a2,packedOpSnippet:o2}),c2={kernelName:yt,backendName:`webgl`,kernelFunc:s2}})),l2,u2,d2,Fme=o((()=>{Y(),Z1(),o1(),l2=Q$+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,u2=q1({opSnippet:l2}),d2={kernelName:vt,backendName:`webgl`,kernelFunc:u2}})),f2,p2,m2=o((()=>{f2=class{constructor(e,t,n,r=!1,i=!1){if(this.variableNames=[`x`],t===`avg`&&n)throw Error(`Cannot compute positions for average pool.`);let a=e.filterWidth,o=e.strideHeight,s=e.strideWidth,c=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterHeight,d=e.effectiveFilterWidth,f=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;let m=t===`avg`,h=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,_=`0.0`;if(m||(_=`-1.0 / 1e-20`),n){this.userCode=`
        const ivec2 strides = ivec2(${o}, ${s});
        const ivec2 pads = ivec2(${f}, ${p});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${u};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${l}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?i?h:g:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let v=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t===`avg`&&(v=`avgValue / max(count, 1.0)`);let y=Math.floor(a/4)*4,b=a%4,x=`
      if (${m}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = max(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${s});
      const ivec2 pads = ivec2(${f}, ${p});
      const float initializationValue = ${_};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${_});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${u};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${y}; wC += 4) {
            int xC = xCCorner + wC * ${l};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${l}, d),
              getValue(batch, xR, xC + 2 * ${l}, d),
              getValue(batch, xR, xC + 3 * ${l}, d)
            );

            ${x}
          }

          int xC = xCCorner + ${y};
          if (${b===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${x}
          } else if (${b===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${l}, d),
              initializationValue,
              initializationValue
            );

            ${x}
          } else if (${b===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${l}, d),
              getValue(batch, xR, xC + 2 * ${l}, d),
              initializationValue
            );

            ${x}
          }
        }
        setOutput(${v});
      }
    `}},p2=class{constructor(e,t,n,r=!1,i=!1){if(this.variableNames=[`x`],t===`avg`&&n)throw Error(`Cannot compute positions for average pool.`);let a=e.filterWidth,o=e.strideDepth,s=e.strideHeight,c=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,d=e.dilationWidth,f=e.effectiveFilterDepth,p=e.effectiveFilterHeight,m=e.effectiveFilterWidth,h=e.padInfo.front,g=e.padInfo.top,_=e.padInfo.left;this.outputShape=e.outShape;let v=t===`avg`,y=`0.0`;if(v||(y=`-1.0 / 1e-20`),n){this.userCode=`
        const ivec3 strides =
            ivec3(${o}, ${s}, ${c});
        const ivec3 pads = ivec3(${h}, ${g}, ${_});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${f};
              wD += ${l}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${p};
                wR += ${u}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${m};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?i?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${m} +
                      wR * ${m} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let b=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t===`avg`&&(b=`avgValue / max(count, 1.0)`);let x=Math.floor(a/4)*4,S=a%4,C=`
      if (${v}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = max(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${o}, ${s}, ${c});
      const ivec3 pads = ivec3(${h}, ${g}, ${_});
      const float initializationValue = ${y};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${y});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${l}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p};
            wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${x}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${C}
            }

            int xC = xCCorner + ${x};
            if (${S===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${C}
            } else if (${S===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${C}
            } else if (${S===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${C}
            }
          }
        }
        setOutput(${b});
      }
    `}}}));function Ime(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t;MZ(i,`avgPool`);let{filterSize:a,strides:o,pad:s,dimRoundingMode:c}=r;D(Pl(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);let l=bl(i.shape,a,o,1,s,c);if(l.filterWidth===1&&l.filterHeight===1&&ge(l.inShape,l.outShape))return N1({inputs:{x:i},backend:n});let u=new f2(l,`avg`,!1);return n.runWebGLProgram(u,[i],`float32`)}var h2,Lme=o((()=>{Y(),m2(),RZ(),F1(),h2={kernelName:bt,backendName:`webgl`,kernelFunc:Ime}}));function Rme(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{filterSize:a,strides:o,pad:s,dimRoundingMode:c,dataFormat:l}=r,u=xl(i.shape,a,o,[1,1,1],s,c,l),d=new p2(u,`avg`,!1);return n.runWebGLProgram(d,[i],`float32`)}var g2,zme=o((()=>{Y(),m2(),g2={kernelName:St,backendName:`webgl`,kernelFunc:Rme}})),_2,v2,y2=o((()=>{_2=class{constructor(e){this.variableNames=[`dy`],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,i=e.strideWidth,a=e.dilationHeight,o=e.dilationWidth,s=e.effectiveFilterHeight,c=e.effectiveFilterWidth,l=s-1-e.padInfo.top,u=c-1-e.padInfo.left,d=1/(t*n);this.userCode=`
      const ivec2 pads = ivec2(${l}, ${u});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${o}) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},v2=class{constructor(e){this.variableNames=[`dy`],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,i=e.strideDepth,a=e.strideHeight,o=e.strideWidth,s=e.dilationDepth,c=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,d=e.effectiveFilterHeight,f=e.effectiveFilterWidth,p=u-1-e.padInfo.front,m=d-1-e.padInfo.top,h=f-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`
      const ivec3 pads = ivec3(${p}, ${m}, ${h});
      const float avgMultiplier = float(${g});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
            wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${i}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${f};
                wC += ${l}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}}));function Bme(e){let{inputs:t,backend:n,attrs:r}=e,{dy:i,input:a}=t,o=a,{filterSize:s,strides:c,pad:l,dimRoundingMode:u}=r,d=xl(o.shape,s,c,[1,1,1],l,u),f=new v2(d);return n.runWebGLProgram(f,[i],o.dtype)}var b2,Vme=o((()=>{Y(),y2(),b2={kernelName:Ct,backendName:`webgl`,kernelFunc:Bme}}));function Hme(e){let{inputs:t,backend:n,attrs:r}=e,{dy:i,input:a}=t,o=a;MZ([i,a],`avgPoolGrad`);let{filterSize:s,strides:c,pad:l}=r,u=bl(o.shape,s,c,1,l),d=new _2(u);return n.runWebGLProgram(d,[i],o.dtype)}var x2,Ume=o((()=>{Y(),y2(),RZ(),x2={kernelName:xt,backendName:`webgl`,kernelFunc:Hme}}));function Wme(e){let{inputs:t,backend:n,attrs:r}=e,{a:i,b:a}=t,{transposeA:o,transposeB:s}=r;return S0({a:i,b:a,transposeA:o,transposeB:s,backend:n})}var S2,Gme=o((()=>{Y(),C0(),S2={kernelName:wt,backendName:`webgl`,kernelFunc:Wme}})),C2,Kme=o((()=>{Y(),C2=class{constructor(e,t,n,r,i,a){this.outputShape=[],this.variableNames=[`x`,`mean`,`variance`],nf(e,t),nf(e,n);let o=`0.0`;r!=null&&(nf(e,r),this.variableNames.push(`offset`),o=`getOffsetAtOutCoords()`);let s=`1.0`;i!=null&&(nf(e,i),this.variableNames.push(`scale`),s=`getScaleAtOutCoords()`),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${o};
        float scale = ${s};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}})),w2,qme=o((()=>{Y(),w2=class{constructor(e,t,n,r,i,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=[`x`,`mean`,`variance`],nf(e,t),nf(e,n);let o=`vec4(0.0)`;r!=null&&(nf(e,r),this.variableNames.push(`offset`),o=`getOffsetAtOutCoords()`);let s=`vec4(1.0)`;i!=null&&(nf(e,i),this.variableNames.push(`scale`),s=`getScaleAtOutCoords()`),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${o};
        vec4 scale = ${s};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}}})),T2,E2,Jme=o((()=>{Y(),Kme(),qme(),T2=({inputs:e,backend:t,attrs:n})=>{let{x:r,mean:i,variance:a,offset:o,scale:s}=e;D(i.shape.length===a.shape.length,()=>`Batch normalization gradient requires mean and variance to have equal ranks.`),D(o==null||i.shape.length===o.shape.length,()=>`Batch normalization gradient requires mean and offset to have equal ranks.`),D(s==null||i.shape.length===s.shape.length,()=>`Batch normalization gradient requires mean and scale to have equal ranks.`);let{varianceEpsilon:c}=n;c??=.001;let l=[r,i,a],u=null;o!=null&&(u=o.shape,l.push(o));let d=null;s!=null&&(d=s.shape,l.push(s));let f=k().getBool(`WEBGL_PACK_NORMALIZATION`)?new w2(r.shape,i.shape,a.shape,u,d,c):new C2(r.shape,i.shape,a.shape,u,d,c);return t.runWebGLProgram(f,l,l[0].dtype)},E2={kernelName:pn,backendName:`webgl`,kernelFunc:T2}}));function Yme(e){if(e===1)return`sourceLoc`;if(e<=6)return O2.slice(0,e).map(e=>`sourceLoc.`+e).join(`,`);throw Error(`Slicing for rank ${e} is not yet supported`)}var D2,O2,Xme=o((()=>{cQ(),D2=class{constructor(e){this.variableNames=[`source`],this.outputShape=e,this.rank=e.length;let t=$Z(this.rank);this.customUniforms=[{name:`start`,arrayIndex:this.rank,type:`int`}];let n=Yme(this.rank),r,i=e.map((e,t)=>`sourceLoc.${O2[t]} = start[${t}] + coords.${O2[t]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${i.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${n}));
      }
    `}},O2=[`x`,`y`,`z`,`w`,`u`,`v`]})),k2,Zme=o((()=>{U$(),cQ(),k2=class{constructor(e){this.variableNames=[`source`],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:`start`,arrayIndex:this.rank,type:`int`}];let t=$Z(this.rank),n=H$(`coords`,this.rank),r=H$(`sourceLoc`,this.rank),i=this.rank===1?`sourceLoc`:`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${i})`,o=`
      result.x = ${a};
      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${a};
        --${r[this.rank-1]};
      }
    `,s=this.rank===1?``:`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${a};
        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${a};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((e,t)=>`start[${t}]`).join()});`:e.map((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${o}
        ${s}
        setOutput(result);
      }
    `}}}));function Qme(e,t,n,r){let i=r.texData.get(e.dataId),a=r.makeTensorInfo(n,e.dtype),o=r.texData.get(a.dataId);Object.assign(o,i),o.refCount=1,o.shape=n,o.dtype=e.dtype;let s=oS(t,ze(e.shape));i.slice&&(s+=i.slice.flatOffset),o.slice={flatOffset:s,origDataId:i.slice&&i.slice.origDataId||e.dataId};let c=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,c+1),a}function A2(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{begin:a,size:o}=r,[s,c]=sS(i,a,o);if(Yx(i,s,c),O(c)===0)return n.makeTensorInfo(c,i.dtype,[]);if(n.shouldExecuteOnCPU([i])||i.dtype===`string`){let e=n.texData.get(i.dataId),t=T$(e.values,s,c,i.shape,i.dtype);return n.makeTensorInfo(c,i.dtype,t)}let{isPacked:l}=n.texData.get(i.dataId),u=aS(i.shape,s,c);if(l||!u){let e=k().getBool(`WEBGL_PACK_ARRAY_OPERATIONS`)?new k2(c):new D2(c),t=[s];return n.runWebGLProgram(e,[i],i.dtype,t)}return n.uploadToGPU(i.dataId),Qme(i,s,c,n)}var j2,M2=o((()=>{Y(),B$(),Xme(),Zme(),j2={kernelName:Er,backendName:`webgl`,kernelFunc:A2}})),N2,P2,$me=o((()=>{Y(),s0(),M2(),x0(),N2=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{blockShape:a,crops:o}=r;D(i.shape.length<=4,()=>`batchToSpaceND for rank > 4 with a WebGL backend not implemented yet`);let s=a.reduce((e,t)=>e*t),c=kS(i.shape,a,s),l=AS(c.length,a.length),u=jS(i.shape,a,s),d=MS(o,a.length),f=NS(u,o,a.length),p=[],m=$({inputs:{x:i},backend:n,attrs:{shape:c}}),h=y0({inputs:{x:m},backend:n,attrs:{perm:l}}),g=$({inputs:{x:h},backend:n,attrs:{shape:u}}),_=A2({inputs:{x:g},backend:n,attrs:{begin:d,size:f}});return p.push(m),p.push(h),p.push(g),p.forEach(e=>n.disposeIntermediateTensorInfo(e)),_},P2={kernelName:Tt,backendName:`webgl`,kernelFunc:N2}}));function ehe(e){let{inputs:t,backend:n,attrs:r}=e,{x:i,weights:a}=t,{size:o}=r,s=n.readSync(i.dataId),c=n.readSync(a.dataId),l=KQ(s,c,a.dtype,a.shape,o);return n.makeTensorInfo([o],a.dtype,l)}var F2,the=o((()=>{Y(),B$(),F2={kernelName:Et,backendName:`webgl`,kernelFunc:ehe}}));function nhe(e){let{inputs:t,backend:n}=e,{a:r,b:i}=t,a=k().getBool(`WEBGL_PACK_BINARY_OPERATIONS`),o=k().getNumber(`WEBGL_VERSION`);if(n.shouldExecuteOnCPU([r,i])||o===1){let e=n.texData.get(r.dataId).values,t=n.texData.get(i.dataId).values,[a,o]=JQ(r.shape,i.shape,e,t,r.dtype),s=n.makeTensorInfo(o,r.dtype),c=n.texData.get(s.dataId);return c.values=a,s}let s;return s=a?new j1(I2,r.shape,i.shape,!1):new O1(L2,r.shape,i.shape),n.runWebGLProgram(s,[r,i],r.dtype)}var I2,L2,R2,rhe=o((()=>{Y(),k1(),M1(),B$(),I2=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,L2=`
  return float(int(a.r) & int(b.r));
`,R2={kernelName:Dt,backendName:`webgl`,kernelFunc:nhe}}));function ihe(e){let{inputs:t,backend:n}=e,{s0:r,s1:i}=t,a=n.readSync(r.dataId),o=n.readSync(i.dataId),s=nf(Array.from(a),Array.from(o));return n.makeTensorInfo([s.length],`int32`,Int32Array.from(s))}var z2,ahe=o((()=>{Y(),z2={kernelName:kt,backendName:`webgl`,kernelFunc:ihe}})),B2,V2,H2,U2=o((()=>{Y(),Z1(),B$(),B2=`return float(a != b);`,V2=J1({opSnippet:B2,cpuKernelImpl:h$,dtype:`bool`}),H2={kernelName:Jn,backendName:`webgl`,kernelFunc:V2}}));function W2(e){let{inputs:t,backend:n}=e,{input:r}=t,i=n.texData.get(r.dataId);return N1({inputs:{x:i.complexTensorInfos.real},backend:n})}var G2,K2=o((()=>{Y(),F1(),G2={kernelName:lr,backendName:`webgl`,kernelFunc:W2}}));function ohe(e,t){let n=new Z$(e.shape,q2),r=t.runWebGLProgram(n,[e],`int32`);return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var q2,she=o((()=>{o1(),q2=`return float(int(x));`}));function J2(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{dtype:a}=r;if(a===`complex64`){if(i.dtype===`complex64`)return N1({inputs:{x:i},backend:n});let e=ah(i.shape),t=J2({inputs:{x:i},backend:n,attrs:{dtype:`float32`}}),r=I1({inputs:{real:t,imag:e},backend:n});return e.dispose(),n.disposeIntermediateTensorInfo(t),r}if(i.dtype===`complex64`){let e=W2({inputs:{input:i},backend:n}),t=J2({inputs:{x:e},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(e),t}if(!Ae(i.dtype,a)){let e=N1({inputs:{x:i},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:a}}if(n.shouldExecuteOnCPU([i])){let e=n.texData.get(i.dataId).values,[t,r,o]=YQ(e,i.shape,i.dtype,a);return n.makeTensorInfo(t,r,o)}if(a===`int32`)return ohe(i,n);if(a===`bool`){let e=n.makeTensorInfo([],`bool`,Ee(`bool`,1)),t=V2({inputs:{a:i,b:e},backend:n});return n.disposeIntermediateTensorInfo(e),t}throw Error(`Error in Cast: failed to cast ${i.dtype} to ${a}`)}var Y2,che=o((()=>{Y(),B$(),R1(),F1(),U2(),K2(),she(),Y2={kernelName:At,backendName:`webgl`,kernelFunc:J2}})),X2,Z2,Q2,lhe=o((()=>{Y(),Z1(),B$(),X2=`return ceil(x);`,Z2=q1({opSnippet:X2,packedOpSnippet:X2,cpuKernelImpl:XQ}),Q2={kernelName:jt,backendName:`webgl`,kernelFunc:Z2}})),$2,uhe=o((()=>{$2=class{constructor(e){this.variableNames=[`A`],this.customUniforms=[{name:`minVal`,type:`float`},{name:`maxVal`,type:`float`}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}})),e4,dhe=o((()=>{e4=class{constructor(e){this.variableNames=[`A`],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:`minVal`,type:`float`},{name:`maxVal`,type:`float`}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}}));function fhe(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{clipValueMin:a,clipValueMax:o}=r,s;s=k().getBool(`WEBGL_PACK_CLIP`)?new e4(i.shape):new $2(i.shape);let c=[[a],[o]];return n.runWebGLProgram(s,[i],i.dtype,c)}var t4,phe=o((()=>{Y(),uhe(),dhe(),t4={kernelName:Mt,backendName:`webgl`,kernelFunc:fhe}})),n4,mhe=o((()=>{n4=class{constructor(e){this.variableNames=[`real`,`imag`],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}}));function r4(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function hhe(e){let{inputs:t,backend:n}=e,{x:r}=t,i=n.texData.get(r.dataId),a=new n4(r.shape),o=[r4(r,i.complexTensorInfos.real),r4(r,i.complexTensorInfos.imag)];return n.runWebGLProgram(a,o,o[0].dtype)}var i4,ghe=o((()=>{Y(),mhe(),i4={kernelName:Pt,backendName:`webgl`,kernelFunc:hhe}})),a4,_he=o((()=>{Y(),a4=class{constructor(e){this.outputShape=[],this.outputShape=bS(e,1),this.variableNames=e.map((e,t)=>`T${t}`);let t=Array(e.length-1);t[0]=e[0][1];for(let n=1;n<t.length;n++)t[n]=t[n-1]+e[n][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let e=1;e<t.length;e++){let r=t[e-1];n.push(`else if (yC < ${t[e]}) setOutput(getT${e}(yR, yC-${r}));`)}let r=t.length,i=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${i}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}}}));function o4(e,t,n){let r=e.indexOf(t);return e.map((e,t)=>t===r?`${e} - ${n}`:e).join()}var s4,vhe=o((()=>{Y(),U$(),cQ(),s4=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=bS(e,t);let n=this.outputShape,r=n.length,i=$Z(r),a=H$(`coords`,r),o=[`x`,`y`,`z`,`w`,`u`,`v`].slice(0,r);this.variableNames=e.map((e,t)=>`T${t}`);let s=Array(e.length-1);s[0]=e[0][t];for(let n=1;n<s.length;n++)s[n]=s[n-1]+e[n][t];let c=o[t],l=o.slice(-2),u=o.join(),d=`if (${c} < ${s[0]}) {
        return getChannel(
            getT0(${u}), vec2(${l.join()}));
        }`;for(let e=1;e<s.length;e++){let t=s[e-1];d+=`
        if (${c} < ${s[e]}  && ${c} >= ${s[e-1]}) {
          return getChannel(
            getT${e}(${o4(o,c,t)}),
            vec2(${o4(l,c,t)}));
        }`}let f=s.length,p=s[s.length-1];d+=`
        return getChannel(
          getT${f}(${o4(o,c,p)}),
          vec2(${o4(l,c,p)}));`,this.userCode=`
      float getValue(${o.map(e=>`int `+e)}) {
        ${d}
      }

      void main() {
        ${i} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[r-1]} = ${a[r-1]} + 1;
        if (${a[r-1]} < ${n[r-1]}) {
          result.g = getValue(${a});
        }

        ${a[r-2]} = ${a[r-2]} + 1;
        if (${a[r-2]} < ${n[r-2]}) {
          result.a = getValue(${a});
        }

        ${a[r-1]} = ${a[r-1]} - 1;
        if (${a[r-2]} < ${n[r-2]} &&
            ${a[r-1]} < ${n[r-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}}}));function c4(e){let{inputs:t,backend:n}=e,{input:r}=t,i=n.texData.get(r.dataId);return N1({inputs:{x:i.complexTensorInfos.imag},backend:n})}var l4,u4=o((()=>{Y(),F1(),l4={kernelName:bn,backendName:`webgl`,kernelFunc:c4}}));function d4(e,t,n){let r=e[0].dtype;if(r===`complex64`){let r=e.map(e=>W2({inputs:{input:e},backend:n})),i=e.map(e=>c4({inputs:{input:e},backend:n})),a=d4(r,t,n),o=d4(i,t,n),s=I1({inputs:{real:a,imag:o},backend:n});return r.forEach(e=>n.disposeIntermediateTensorInfo(e)),i.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),s}let i=n.shouldExecuteOnCPU(e);if(r===`string`&&(i=!0),i){let i=e.map(e=>{let r=[-1,O(e.shape.slice(t))];return $({inputs:{x:e},backend:n,attrs:{shape:r}})}),a=i.map(e=>({vals:n.readSync(e.dataId),shape:e.shape})),o=bS(i.map(e=>e.shape),1),s=i[0].shape[0]===1,c=ZQ(a,o,r,s),l=bS(e.map(e=>e.shape),t),u=n.makeTensorInfo(l,r,c);return i.forEach(e=>n.disposeIntermediateTensorInfo(e)),u}let a=e.filter(e=>O(e.shape)>0),o=k().getBool(`WEBGL_PACK_ARRAY_OPERATIONS`)&&a[0].shape.length>1;if(a.length===1){let t=o?new Z$(e[0].shape,i1):new f1(e[0].shape,i1);return n.runWebGLProgram(t,e,r)}let s=k().getNumber(`WEBGL_MAX_TEXTURES_IN_SHADER`);if(a.length>s){let e=[];for(let r=0;r<a.length;r+=s){let i=a.slice(r,r+s);e.push(d4(i,t,n))}let r=d4(e,t,n);for(let t of e)n.disposeIntermediateTensorInfo(t);return r}if(o){let e=new s4(a.map(e=>e.shape),t);return n.runWebGLProgram(e,a,r)}let{tensors2D:c,outShape:l}=yhe(a,t,n),u=new a4(c.map(e=>e.shape)),d=n.runWebGLProgram(u,c,r);c.forEach(e=>n.disposeIntermediateTensorInfo(e));let f=$({inputs:{x:d},attrs:{shape:l},backend:n});return n.disposeIntermediateTensorInfo(d),f}function yhe(e,t,n){let r=bS(e.map(e=>e.shape),t);return{tensors2D:e.map(e=>$({inputs:{x:e},attrs:{shape:[-1,O(e.shape.slice(t))]},backend:n})),outShape:r}}var bhe=o((()=>{Y(),_he(),vhe(),B$(),o1(),p1(),R1(),u4(),K2(),s0()}));function f4(e){let{inputs:t,backend:n,attrs:r}=e,{axis:i}=r,a=we(i,t[0].shape)[0],o=t.map(e=>e.shape);yS(o,a);let s=bS(t.map(e=>e.shape),a);if(O(s)===0)return n.makeTensorInfo(s,t[0].dtype,[]);let c=t.filter(e=>O(e.shape)>0);return c.length===1?N1({inputs:{x:c[0]},backend:n}):d4(c,a,n)}var p4,m4=o((()=>{Y(),bhe(),F1(),p4={kernelName:Ft,backendName:`webgl`,kernelFunc:f4}})),h4,g4,_4=o((()=>{h4=class{constructor(e,t=!1,n=null,r=!1,i=!1){this.variableNames=[`x`,`W`],this.outputShape=e.outShape;let a=e.padInfo.top,o=e.padInfo.left,s=e.strideHeight,c=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,d=e.filterHeight,f=e.filterWidth,p=Math.floor(e.inChannels/4)*4,m=e.inChannels%4,h=e.dataFormat===`channelsLast`,g=h?1:2,_=h?2:3,v=h?3:1,y=``,b=``;n&&(y=r?`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:i?`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:`
          float activation(float x) {
            ${n}
          }
        `,b=`result = activation(result);`);let x=t?`result += getBiasAtOutCoords();`:``;t&&this.variableNames.push(`bias`),r&&this.variableNames.push(`preluActivationWeights`),i&&this.variableNames.push(`leakyreluAlpha`),this.userCode=`
      ${y}

      const ivec2 strides = ivec2(${s}, ${c});
      const ivec2 pads = ivec2(${a}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${v}];

        ivec2 xRCCorner =
            ivec2(coords[${g}], coords[${_}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${l};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${f}; wC++) {
            int xC = xCCorner + wC * ${u};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${p}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${h}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${m===1}) {

              if (${h}) {
                dotProd +=
                    getX(batch, xR, xC, ${p}) *
                    getW(wR, wC, ${p}, d2);
              } else {
                dotProd +=
                    getX(batch, ${p}, xR, xC) *
                    getW(wR, wC, ${p}, d2);
              }

            } else if (${m===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2)
              );

              if (${h}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${m===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2),
                getW(wR, wC, ${p} + 2, d2)
              );

              if (${h}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1),
                  getX(batch, xR, xC, ${p} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC),
                  getX(batch, ${p} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${x}
        ${b}
        setOutput(result);
      }
    `}},g4=class{constructor(e){this.variableNames=[`x`,`W`],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,i=e.strideDepth,a=e.strideHeight,o=e.strideWidth,s=e.dilationDepth,c=e.dilationHeight,l=e.dilationWidth,u=e.filterDepth,d=e.filterHeight,f=e.filterWidth,p=Math.floor(e.inChannels/4)*4,m=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${i}, ${a}, ${o});
      const ivec3 pads = ivec3(${t}, ${n}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${u}; wF++) {
          int xF = xFCorner + wF * ${s};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f}; wC++) {
              int xC = xCCorner + wC * ${l};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${p}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${m===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${p}) *
                  getW(wF, wR, wC, ${p}, d2);
              } else if (${m===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${m===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1),
                  getX(batch, xF, xR, xC, ${p} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2),
                  getW(wF, wR, wC, ${p} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}})),v4,y4=o((()=>{Y(),fQ(),v4=class{constructor(e,t=!1,n=null,r=!1,i=!1){this.variableNames=[`x`,`W`],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:`pads`,type:`ivec2`},{name:`strides`,type:`ivec2`},{name:`dilations`,type:`ivec2`},{name:`inDims`,type:`ivec2`}],this.outputShape=e.outShape,this.enableShapeUniforms=dQ(this.outputShape.length);let a=e.padInfo.left,o=e.strideWidth,s=e.dilationWidth,c=e.filterHeight,l=e.filterWidth,u=l,d=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let e=0;e<l;e++)d+=`
           vec4 xTexelC${e*2};
           int xTexelC${e*2}Ready;
           vec4 xTexelC${e*2+1};
           int xTexelC${e*2+1}Ready;
           vec4 xC${e};`;d+=`
     for (int r = 0; r < ${c}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let e=0;e<l;e++)d+=`
           xTexelC${e*2} = vec4(0.0);
           xTexelC${e*2}Ready = 0;
           xTexelC${e*2+1} = vec4(0.0);
           xTexelC${e*2+1}Ready = 0;
           xC${e} = vec4(0.0);`;d+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let t=0;t<(u+1)/2;t++){let n=t*2;if(d+=`
           xC = xCCorner + ${n*s};
           `,o===1){if(n<l&&(a%2==1?(d+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {
                   xTexelC${n} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${n}.zw = vec2(0.0);
                   }
                   xTexelC${n}Ready = 1;
                 }
               `,s===1&&n>0?d+=`
                 xC${n} = vec4(xTexelC${n-2}.zw, xTexelC${n}.xy);
                 `:d+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${n} = vec4(previous.zw, xTexelC${n}.xy);
                   } else {
                     xC${n} = vec4(0.0, 0.0, xTexelC${n}.xy);
                   }
                   `):d+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {
                   xTexelC${n} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${n}.zw = vec2(0.0);
                   }
                   xTexelC${n}Ready = 1;
                 }

                 xC${n} = xTexelC${n};
                 `,n+1<l)){let e=a%2==0?se(s):s;s%2==0&&a%2==1||s%2!=0&&a%2!=1?(d+=`
                   xCOffset = xC + imod(pads[1], 2) + ${e};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {
                     xTexelC${n+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${n+1}.zw = vec2(0.0);
                     }
                     xTexelC${n+1}Ready = 1;
                   }
                   `,s>1?d+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${n+1} = vec4(previous.zw, xTexelC${n+1}.xy);
                     } else {
                      xC${n+1} = vec4(0.0, 0.0, xTexelC${n+1}.xy);
                     }
                     `:d+=`
                     xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.xy);
                     `):e===1?d+=`
                     xC${n+1} = xTexelC${n};
                     `:d+=`
                     xCOffset = xC + ${e};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {
                       xTexelC${n+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${n+1}.zw = vec2(0.0);
                       }
                       xTexelC${n+1}Ready = 1;
                     }

                     xC${n+1} = xTexelC${n+1};
                     `}}else n<l&&(a%2==1?(d+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {
                   xTexelC${n} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${n}.zw = vec2(0.0);
                   }
                   xTexelC${n}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${n+1}Ready == 0) {
                   xTexelC${n+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${n+1}.zw = vec2(0.0);
                   }
                   xTexelC${n+1}Ready = 1;
                 }

                 xC${n} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);
               `,n+1<l&&(d+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${n+1} = vec4(xTexelC${n+1}.xy, final.xy);
                 `)):(d+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {
                   xTexelC${n} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${n}.zw = vec2(0.0);
                   }
                   xTexelC${n}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {
                   xTexelC${n+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${n+1}.zw = vec2(0.);
                   }
                   xTexelC${n+1}Ready = 1;
                 }

                 xC${n} = vec4(
                   xTexelC${n}.xy, xTexelC${n+1}.xy);
               `,n+1<l&&(d+=`
                   xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);
                 `)));n<l&&(d+=`
             wTexel = getW(r, ${n}, d1, d2);
             dotProd += xC${n}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${n}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,n+1<l&&(d+=`
               wTexel = getW(r, ${n+1}, d1, d2);
               dotProd += xC${n+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${n+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}d+=`
     }
   `,d+=`
     }
   `,d+=`
     }
   `;let f=``,p=``;n&&(f=r?`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${n}
         }`:i?`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${n}
         }`:`vec4 activation(vec4 x) {
           ${n}
         }`,p=`result = activation(result);`);let m=t?`result += getBiasAtOutCoords();`:``;t&&this.variableNames.push(`bias`),r&&this.variableNames.push(`preluActivationWeights`),i&&this.variableNames.push(`leakyreluAlpha`),this.userCode=`
       ${f}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${d}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${m}
         ${p}
         setOutput(result);
       }
     `}}})),b4,xhe=o((()=>{VZ(),fQ(),b4=class{constructor(e,t){this.variableNames=[`A`],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:`inputShape`,type:`ivec4`},{name:`pad`,type:`ivec2`},{name:`stride`,type:`ivec2`},{name:`dilation`,type:`ivec2`},{name:`inChannels`,type:`int`},{name:`itemsPerBlockRow`,type:`int`},{name:`outWidth`,type:`int`}],this.outputShape=e,this.enableShapeUniforms=dQ(this.outputShape.length);let{dataFormat:n}=t,r=BZ(),i=n===`channelsLast`,a=i?1:2,o=i?2:3,s=this.enableShapeUniforms?`if(blockIndex < outShape[2] && pos < outShape[1]) {`:`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,c=``;for(let e=0;e<=1;e++)for(let t=0;t<=1;t++)c+=`
          blockIndex = rc.z + ${t};
          pos = rc.y + ${e};

          ${s}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${o}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${i}) {
                  innerDims = vec2(d1, ch);
                  result[${e*2+t}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${e*2+t}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${r.output} = result;
      }
    `}}}));function x4(e,t){let n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&n===1&&e[0]>1?[e[0],1]:null}function S4({x:e,filter:t,convInfo:n,backend:r,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:s=null}){let c=e.shape,l=r.texData.get(e.dataId),u=n.inChannels,d=c[0]*c[1]*c[2],f=n.outChannels,p=n.dataFormat===`channelsLast`,m,h=[];if(a!=null){let e=x4(a.shape,p);e!=null&&(a=$({inputs:{x:a},backend:r,attrs:{shape:e}}),h.push(a))}if(i!=null){let e=x4(i.shape,p);e!=null&&(i=$({inputs:{x:i},backend:r,attrs:{shape:e}}),h.push(i))}if(!((d===1||f===1)&&u>1e3)&&l.isPacked&&p&&l.texture!=null&&c[2]%2!=0&&ge(l.shape.slice(-3),c.slice(-3))){let u=c[0]*c[1]*(c[2]+1),d={dataId:e.dataId,shape:[1,u,n.inChannels],dtype:e.dtype},f=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,D(SZ(l.shape,d.shape),()=>`packed reshape ${l.shape} to ${d.shape} isn't free`);let p=$({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});h.push(p);let g=S0({a:d,b:p,backend:r,transposeA:!1,transposeB:!1,bias:i,activation:s,preluActivationWeights:a,leakyreluAlpha:o}),_=r.texData.get(g.dataId);D(_.isPacked,()=>`batchMatMul result is expected to be packed`),l.shape=f,_.shape=n.outShape,m=N1({inputs:{x:g},backend:r}),m.shape=n.outShape,h.push(g)}else{let c=n.outHeight*n.outWidth,l=$({inputs:{x:e},backend:r,attrs:{shape:p?[n.batchSize,c,n.inChannels]:[n.batchSize,n.inChannels,c]}}),u=$({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),d=S0({a:p?l:u,b:p?u:l,transposeA:!p,transposeB:!1,backend:r,bias:i,activation:s,preluActivationWeights:a,leakyreluAlpha:o});m=$({inputs:{x:d},backend:r,attrs:{shape:n.outShape}}),h.push(l),h.push(u),h.push(d)}for(let e of h)r.disposeIntermediateTensorInfo(e);return m}function C4({x:e,filter:t,convInfo:n,backend:r,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:s=null}){let{filterWidth:c,filterHeight:l,inChannels:u,outWidth:d,outHeight:f,dataFormat:p}=n,m=p===`channelsLast`,h=c*l*u,g=f*d,_=[n.batchSize,h,g],v=[];if(a!=null){let e=x4(a.shape,m);e!=null&&(a=$({inputs:{x:a},backend:r,attrs:{shape:e}}),v.push(a))}if(i!=null){let e=x4(i.shape,m);e!=null&&(i=$({inputs:{x:i},backend:r,attrs:{shape:e}}),v.push(i))}let y=$({inputs:{x:t},backend:r,attrs:{shape:[1,h,O(t.shape)/h]}});v.push(y);let b=new b4(_,n),x=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],S=r.runWebGLProgram(b,[e],`float32`,x),C=$({inputs:{x:S},backend:r,attrs:{shape:_}});v.push(S),v.push(C);let w=i!=null,T=a!=null,ee=s===`leakyrelu`,E=s?Y1(s,!0):null,te=new Q1(m?C.shape:y.shape,m?y.shape:C.shape,m?[n.batchSize,g,n.outChannels]:[n.batchSize,n.outChannels,g],!0,!1,w,E,T,ee),ne=m?[C,y]:[y,C];if(i&&ne.push(i),T&&ne.push(a),ee){let e=r.makeTensorInfo([],`float32`,qi(o,`float32`));ne.push(e),v.push(e)}let re=r.runWebGLProgram(te,ne,`float32`),ie=$({inputs:{x:re},backend:r,attrs:{shape:n.outShape}});v.push(re);for(let e of v)r.disposeIntermediateTensorInfo(e);return ie}var w4=o((()=>{Y(),xhe(),Z1(),$1(),RZ(),C0(),F1(),s0()}));function She(e){let{inputs:t,backend:n,attrs:r}=e,{x:i,filter:a}=t,{strides:o,pad:s,dataFormat:c,dilations:l,dimRoundingMode:u}=r,d=Il(c),f=Sl(i.shape,a.shape,o,l,s,u,!1,d),p;if(f.filterHeight===1&&f.filterWidth===1&&f.dilationHeight===1&&f.dilationWidth===1&&f.strideHeight===1&&f.strideWidth===1&&(f.padInfo.type===`SAME`||f.padInfo.type===`VALID`))p=S4({x:i,filter:a,convInfo:f,backend:n});else if(f.strideWidth<=2&&d===`channelsLast`&&k().getBool(`WEBGL_EXP_CONV`)){let e=new v4(f),t=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];p=n.runWebGLProgram(e,[i,a],`float32`,t)}else if(k().getBool(`WEBGL_CONV_IM2COL`))p=C4({x:i,filter:a,convInfo:f,backend:n});else{let e=new h4(f);p=n.runWebGLProgram(e,[i,a],`float32`)}let m=$({inputs:{x:p},backend:n,attrs:{shape:f.outShape}});return n.disposeIntermediateTensorInfo(p),m}var T4,Che=o((()=>{Y(),_4(),y4(),w4(),s0(),T4={kernelName:It,backendName:`webgl`,kernelFunc:She}})),E4,D4,O4,k4,A4=o((()=>{E4=class{constructor(e){this.variableNames=[`x`,`dy`],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left,a=e.dataFormat===`channelsLast`;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${a?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},D4=class{constructor(e){this.variableNames=[`dy`,`W`],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,i=e.strideWidth,a=e.dataFormat===`channelsLast`,o=t-1-e.padInfo.top,s=n-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${s});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${a?3:1}];

        ivec2 dyCorner = ivec2(coords[${a?1:2}], coords[${a?2:3}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},O4=class{constructor(e){this.variableNames=[`x`,`dy`],this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,i=e.padInfo.front,a=e.padInfo.top,o=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${i};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${a};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${o};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},k4=class{constructor(e){this.variableNames=[`dy`,`W`],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,i=e.strideDepth,a=e.strideHeight,o=e.strideWidth,s=t-1-e.padInfo.front,c=n-1-e.padInfo.top,l=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${s}, ${c}, ${l});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${i}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}}));function whe(e){let{inputs:t,backend:n,attrs:r}=e,{x:i,dy:a}=t,{strides:o,pad:s,dataFormat:c,dimRoundingMode:l,filterShape:u}=r,d=Il(c),f=Sl(i.shape,u,o,1,s,l,!1,d),p=new E4(f);return n.runWebGLProgram(p,[i,a],`float32`)}var j4,The=o((()=>{Y(),A4(),j4={kernelName:Lt,backendName:`webgl`,kernelFunc:whe}})),M4,Ehe=o((()=>{fQ(),M4=class{constructor(e){this.variableNames=[`dy`,`W`],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:`strides`,type:`vec2`}],this.outputShape=e.inShape,this.enableShapeUniforms=dQ(this.outputShape.length);let t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,i=n-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            int wCPerm = ${n} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}}));function Dhe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:i,filter:a}=t,{inputShape:o,strides:s,pad:c,dataFormat:l,dimRoundingMode:u}=r,d=Il(l),f=Sl(o,a.shape,s,1,c,u,!1,d);if(k().getBool(`WEBGL_PACK_CONV2DTRANSPOSE`)&&d===`channelsLast`){let e=[[f.strideHeight,f.strideWidth]],t=new M4(f);return n.runWebGLProgram(t,[i,a],`float32`,e)}else{let e=new D4(f);return n.runWebGLProgram(e,[i,a],`float32`)}}var N4,Ohe=o((()=>{Y(),A4(),Ehe(),N4={kernelName:Rt,backendName:`webgl`,kernelFunc:Dhe}}));function khe(e){let{inputs:t,backend:n,attrs:r}=e,{x:i,filter:a}=t,{strides:o,pad:s,dilations:c}=r,l=Cl(i.shape,a.shape,o,c,s),u=new g4(l);return n.runWebGLProgram(u,[i,a],`float32`)}var P4,Ahe=o((()=>{Y(),_4(),P4={kernelName:zt,backendName:`webgl`,kernelFunc:khe}}));function jhe(e){let{inputs:t,backend:n,attrs:r}=e,{x:i,dy:a}=t,{strides:o,pad:s,filterShape:c}=r,l=Cl(i.shape,c,o,1,s),u=new O4(l);return n.runWebGLProgram(u,[i,a],`float32`)}var F4,Mhe=o((()=>{Y(),A4(),F4={kernelName:Bt,backendName:`webgl`,kernelFunc:jhe}}));function Nhe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:i,filter:a}=t,{pad:o,strides:s,inputShape:c}=r,l=Cl(c,a.shape,s,1,o),u=new k4(l);return n.runWebGLProgram(u,[i,a],`float32`)}var I4,Phe=o((()=>{Y(),A4(),I4={kernelName:Vt,backendName:`webgl`,kernelFunc:Nhe}})),L4,R4,z4,B4,Fhe=o((()=>{Y(),M1(),Z1(),L4=X1+`
  return cos(x);
`,R4=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${A1}
  return result;
`,z4=q1({opSnippet:L4,packedOpSnippet:R4}),B4={kernelName:`Cos`,backendName:`webgl`,kernelFunc:z4}})),V4,H4,U4,Ihe=o((()=>{Y(),Z1(),V4=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,H4=q1({opSnippet:V4}),U4={kernelName:Ht,backendName:`webgl`,kernelFunc:H4}})),W4,Lhe=o((()=>{W4=class{constructor(e,t,n,r,i){this.variableNames=[`Image`,`Boxes`,`BoxInd`],this.outputShape=[];let[a,o,s,c]=e,[l]=t,[u,d]=n;this.outputShape=[l,u,d,c];let f=r===`bilinear`?1:0,[p,m]=[`${o-1}.0`,`${s-1}.0`],[h,g,_]=u>1?[`${(o-1)/(u-1)}`,`(y2-y1) * height_ratio`,`y1*${p} + float(y)*(height_scale)`]:[`0.0`,`0.0`,`0.5 * (y1+y2) * ${p}`],[v,y,b]=d>1?[`${(s-1)/(d-1)}`,`(x2-x1) * width_ratio`,`x1*${m} + float(x)*(width_scale)`]:[`0.0`,`0.0`,`0.5 * (x1+x2) * ${m}`];this.userCode=`
      const float height_ratio = float(${h});
      const float width_ratio = float(${v});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${g};
        float width_scale = ${y};

        float in_y = ${_};
        if( in_y < 0.0 || in_y > ${p} ) {
          setOutput(float(${i}));
          return;
        }
        float in_x = ${b};
        if( in_x < 0.0 || in_x > ${m} ) {
          setOutput(float(${i}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${f} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}})),G4,K4,Rhe=o((()=>{Y(),Lhe(),G4=e=>{let{inputs:t,backend:n,attrs:r}=e,{image:i,boxes:a,boxInd:o}=t,{cropSize:s,method:c,extrapolationValue:l}=r,u=new W4(i.shape,a.shape,s,c,l);return n.runWebGLProgram(u,[i,a,o],`float32`)},K4={kernelName:Gt,backendName:`webgl`,kernelFunc:G4}}));function q4(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.x, ${t}.y`;if(e===3)return`${t}.x, ${t}.y, ${t}.z`;if(e===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function J4(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.y`;if(e===3)return`${t}.z`;if(e===4)return`${t}.w`;throw Error(`Cumulative ${n} for rank ${e} is not yet supported`)}var Y4,X4,Z4=o((()=>{cQ(),(function(e){e.Prod=`*`,e.Sum=`+`})(Y4||={}),X4=class{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=[`x`],this.customUniforms=[{name:`index`,type:`float`}];let i=this.outputShape.length,a=this.op===Y4.Prod?`1.0`:`0.0`,o=n?a:`getX(${q4(i,`coords`,this.op)})`,s=this.outputShape[this.outputShape.length-1],c=``,l=``;n?(c=r?`end != ${s-1}`:`end != 0`,l=r?`end + 1`:`end - 1`):(c=r?`end + pow2 < ${s}`:`end >= pow2`,l=r?`end + pow2`:`end - pow2`),this.userCode=`
      void main() {
        ${$Z(i)} coords = getOutputCoords();
        int end = ${J4(i,`coords`,this.op)};
        float val = ${o};
        int pow2 = int(pow(2.0, index));
        if (${c}) {
          int idx = ${l};
          ${J4(i,`coords`,this.op)} = idx;
          val ${this.op}= getX(${q4(i,`coords`,this.op)});
        }
        setOutput(val);
      }
    `}}}));function Q4(e,t,n,r,i,a){let o=t.shape.length,s=Rf([r],o),c=t;s!=null&&(c=y0({inputs:{x:t},backend:n,attrs:{perm:s}}));let l=Bf(1,o)[0];if(l!==o-1)throw Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);let u=c.shape[l],d=N1({inputs:{x:c},backend:n});for(let t=0;t<=Math.ceil(Math.log2(u))-1;t++){let r=new X4(e,c.shape,!1,a),i=[[t]],o=d;d=n.runWebGLProgram(r,[d],d.dtype,i),n.disposeIntermediateTensorInfo(o)}if(i){let t=new X4(e,c.shape,i,a),r=d;d=n.runWebGLProgram(t,[d],d.dtype),n.disposeIntermediateTensorInfo(r)}if(s!=null){let e=zf(s),t=y0({inputs:{x:d},backend:n,attrs:{perm:e}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),t}return d}var $4=o((()=>{Y(),Z4(),F1(),x0()}));function zhe(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a,exclusive:o,reverse:s}=r;return Q4(Y4.Prod,i,n,a,o,s)}var e3,Bhe=o((()=>{Y(),Z4(),$4(),e3={kernelName:Ut,backendName:`webgl`,kernelFunc:zhe}}));function Vhe(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a,exclusive:o,reverse:s}=r;return Q4(Y4.Sum,i,n,a,o,s)}var t3,Hhe=o((()=>{Y(),Z4(),$4(),t3={kernelName:Wt,backendName:`webgl`,kernelFunc:Vhe}}));function Uhe(e){let{inputs:t,backend:n,attrs:r}=e,{x:i,weights:a}=t,{size:o,binaryOutput:s}=r;if(i.shape.length===1){let e=n.readSync(i.dataId),t=n.readSync(a.dataId),r=KQ(e,t,a.dtype,a.shape,o);return n.makeTensorInfo([o],a.dtype,r)}else if(i.shape.length===2){let e=n.bufferSync(i),t=n.bufferSync(a),r=qQ(e,t,o,s);return n.makeTensorInfo(r.shape,a.dtype,r.values)}throw Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}var n3,Whe=o((()=>{Y(),B$(),n3={kernelName:Kt,backendName:`webgl`,kernelFunc:Uhe}})),r3,Ghe=o((()=>{r3=class{constructor(e,t,n){this.variableNames=[`x`],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat===`NHWC`?`coords[1]`:`coords[2]`}getWidthCoordString(){return this.dataFormat===`NHWC`?`coords[2]`:`coords[3]`}getDepthCoordString(){return this.dataFormat===`NHWC`?`coords[3]`:`coords[1]`}getOutputDepthSize(){return this.dataFormat===`NHWC`?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat===`NHWC`?`getX(b, in_h, in_w, in_d)`:`getX(b, in_d, in_h, in_w)`}}}));function Khe(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{blockSize:a,dataFormat:o}=r,s=i.shape[0],c=o===`NHWC`?i.shape[1]:i.shape[2],l=o===`NHWC`?i.shape[2]:i.shape[3],u=o===`NHWC`?i.shape[3]:i.shape[1],d=c*a,f=l*a,p=u/(a*a),m=new r3(o===`NHWC`?[s,d,f,p]:[s,p,d,f],a,o);return n.runWebGLProgram(m,[i],i.dtype)}var i3,qhe=o((()=>{Y(),Ghe(),i3={kernelName:qt,backendName:`webgl`,kernelFunc:Khe}})),a3,o3=o((()=>{fQ(),a3=class{constructor(e,t=!1,n=null,r=!1,i=!1){this.variableNames=[`x`,`W`],this.customUniforms=[{name:`pads`,type:`ivec2`},{name:`strides`,type:`ivec2`},{name:`dilations`,type:`ivec2`},{name:`inDims`,type:`ivec2`}],this.outputShape=e.outShape,this.enableShapeUniforms=dQ(this.outputShape.length);let a=e.filterHeight,o=e.filterWidth,s=e.outChannels/e.inChannels,c=``,l=``;n&&(c=r?`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:i?`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:`
          float activation(float x) {
            ${n}
          }
        `,l=`result = activation(result);`);let u=t?`result += getBiasAtOutCoords();`:``;t&&this.variableNames.push(`bias`),r&&this.variableNames.push(`preluActivationWeights`),i&&this.variableNames.push(`leakyreluAlpha`),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${s};
        int q = d2 - d1 * ${s};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${o}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${u}
        ${l}
        setOutput(result);
      }
    `}}})),s3,c3=o((()=>{Y(),fQ(),s3=class{constructor(e,t=!1,n=null,r=!1,i=!1){this.variableNames=[`x`,`W`],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:`pads`,type:`ivec2`},{name:`strides`,type:`ivec2`},{name:`dilations`,type:`ivec2`},{name:`inDims`,type:`ivec2`}],this.outputShape=e.outShape,this.enableShapeUniforms=dQ(this.outputShape.length);let a=e.outChannels/e.inChannels,o=e.padInfo.left,s=e.strideWidth,c=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,d=u,f=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let e=0;e<u;e++)f+=`
          vec4 xTexelC${e*2};
          int xTexelC${e*2}Ready;
          vec4 xTexelC${e*2+1};
          int xTexelC${e*2+1}Ready;
          vec4 xC${e};`;f+=`
    for (int r = 0; r < ${l}; r++) {
      `;for(let e=0;e<u;e++)f+=`
          xTexelC${e*2} = vec4(0.0);
          xTexelC${e*2}Ready = 0;
          xTexelC${e*2+1} = vec4(0.0);
          xTexelC${e*2+1}Ready = 0;
          xC${e} = vec4(0.0);`;f+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let e=0;e<(d+1)/2;e++){let t=e*2;if(f+=`
          xC = xCCorner + ${t*c};
          `,s===1){if(t<u&&(o%2==1?(f+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {
                  xTexelC${t} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${t}.zw = vec2(0.0);
                  }
                  xTexelC${t}Ready = 1;
                }
              `,c===1&&t>0?f+=`
                xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);
                `:f+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${t} = vec4(previous.zw, xTexelC${t}.xy);
                  } else {
                    xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);
                  }
                  `):f+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {
                  xTexelC${t} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${t}.zw = vec2(0.0);
                  }
                  xTexelC${t}Ready = 1;
                }

                xC${t} = xTexelC${t};
                `,t+1<u)){let e=o%2==0?se(c):c;c%2==0&&o%2==1||c%2!=0&&o%2!=1?(f+=`
                  xCOffset = xC + imod(pads[1], 2) + ${e};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {
                    xTexelC${t+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${t+1}.zw = vec2(0.0);
                    }
                    xTexelC${t+1}Ready = 1;
                  }
                  `,c>1?f+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);
                    } else {
                     xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);
                    }
                    `:f+=`
                    xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);
                    `):e===1?f+=`
                    xC${t+1} = xTexelC${t};
                    `:f+=`
                    xCOffset = xC + ${e};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {
                      xTexelC${t+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${t+1}.zw = vec2(0.0);
                      }
                      xTexelC${t+1}Ready = 1;
                    }

                    xC${t+1} = xTexelC${t+1};
                    `}}else t<u&&(o%2==1?(f+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {
                  xTexelC${t} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${t}.zw = vec2(0.0);
                  }
                  xTexelC${t}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {
                  xTexelC${t+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${t+1}.zw = vec2(0.0);
                  }
                  xTexelC${t+1}Ready = 1;
                }

                xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);
              `,t+1<u&&(f+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);
                `)):(f+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {
                  xTexelC${t} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${t}.zw = vec2(0.0);
                  }
                  xTexelC${t}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {
                  xTexelC${t+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${t+1}.zw = vec2(0.);
                  }
                  xTexelC${t+1}Ready = 1;
                }

                xC${t} = vec4(
                  xTexelC${t}.xy, xTexelC${t+1}.xy);
              `,t+1<u&&(f+=`
                  xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);
                `)));t<u&&(f+=`
            wTexel = getW(r, ${t}, d1, q);
            dotProd += xC${t} * vec4(wTexel.xz, wTexel.xz);
          `,t+1<u&&(f+=`
              wTexel = getW(r, ${t+1}, d1, q);
              dotProd += xC${t+1} * vec4(wTexel.xz, wTexel.xz);
            `))}f+=`
    }
  `,f+=`
      }
    `;let p=``,m=``;n&&(p=r?`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:i?`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:`vec4 activation(vec4 x) {
          ${n}
        }`,m=`result = activation(result);`);let h=t?`result += getBiasAtOutCoords();`:``;t&&this.variableNames.push(`bias`),r&&this.variableNames.push(`preluActivationWeights`),i&&this.variableNames.push(`leakyreluAlpha`),this.userCode=`
      ${p}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${f}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${h}
        ${m}
        setOutput(result);
      }
    `}}}));function Jhe(e){let{inputs:t,backend:n,attrs:r}=e,{x:i,filter:a}=t,{strides:o,pad:s,dilations:c,dimRoundingMode:l}=r,u=c;u??=[1,1],D(Pl(o,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);let d=Sl(i.shape,a.shape,o,u,s,l,!0),f;f=k().getBool(`WEBGL_PACK_DEPTHWISECONV`)&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?new s3(d):new a3(d);let p=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(f,[i,a],`float32`,p)}var l3,Yhe=o((()=>{Y(),o3(),c3(),l3={kernelName:Jt,backendName:`webgl`,kernelFunc:Jhe}})),u3,d3,f3=o((()=>{u3=class{constructor(e){this.variableNames=[`x`,`dy`],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${e.outChannels/e.inChannels} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},d3=class{constructor(e){this.variableNames=[`dy`,`W`],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,i=e.strideWidth,a=t-1-e.padInfo.top,o=n-1-e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${s}; dm++) {
              int d2 = d1 * ${s} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}}));function Xhe(e){let{inputs:t,backend:n,attrs:r}=e,{x:i,dy:a}=t,{strides:o,dilations:s,pad:c,dimRoundingMode:l,filterShape:u}=r,d=Sl(i.shape,u,o,s,c,l,!0),f=new u3(d);return n.runWebGLProgram(f,[i,a],`float32`)}var p3,Zhe=o((()=>{Y(),f3(),p3={kernelName:Yt,backendName:`webgl`,kernelFunc:Xhe}}));function Qhe(e){let{inputs:t,backend:n,attrs:r}=e,{dy:i,filter:a}=t,{strides:o,dilations:s,pad:c,dimRoundingMode:l,inputShape:u}=r,d=Sl(u,a.shape,o,s,c,l,!0),f=new d3(d);return n.runWebGLProgram(f,[i,a],`float32`)}var m3,$he=o((()=>{Y(),f3(),m3={kernelName:Xt,backendName:`webgl`,kernelFunc:Qhe}})),h3,ege=o((()=>{h3=class{constructor(e){this.variableNames=[`X`],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}}));function tge(e){let{inputs:t,backend:n}=e,{x:r}=t,i=[...r.shape,...r.shape],a=O(r.shape),o=$({inputs:{x:r},backend:n,attrs:{shape:[a]}}),s=new h3(a),c=n.runWebGLProgram(s,[o],o.dtype),l=$({inputs:{x:c},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(c),l}var g3,nge=o((()=>{Y(),ege(),s0(),g3={kernelName:Zt,backendName:`webgl`,kernelFunc:tge}})),_3,rge=o((()=>{_3=class{constructor(e){this.variableNames=[`x`,`W`],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:r,strideHeight:i,strideWidth:a,filterHeight:o,filterWidth:s,dilationHeight:c,dilationWidth:l}=e,{top:u,left:d}=r;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${a});
      const ivec2 pads = ivec2(${u}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${o}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${s}; w++) {
              int wIn = wBeg + w * ${l};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}}));function ige(e){let{inputs:t,backend:n,attrs:r}=e,{x:i,filter:a}=t,{strides:o,pad:s,dilations:c}=r,l=yl(i.shape,a.shape,o,s,`NHWC`,c),u,d=new _3(l);u=n.runWebGLProgram(d,[i,a],`float32`);let f=$({inputs:{x:u},backend:n,attrs:{shape:l.outShape}});return n.disposeIntermediateTensorInfo(u),f}var v3,age=o((()=>{Y(),rge(),s0(),v3={kernelName:Qt,backendName:`webgl`,kernelFunc:ige}}));function oge(e){let{inputs:t,backend:n,attrs:r}=e,{equation:i}=r,a=t,{allDims:o,summedDims:s,idDims:c}=ZS(i,a.length);$S(o.length,c,a);let{path:l,steps:u}=eC(s,c),d=u.length,f=null,p=o.length,m=[];for(let e=0;e<d;++e){for(let t of u[e]){let{permutationIndices:e,expandDims:r}=QS(p,c[t]),i;tC(e)?i=a[t]:(i=y0({inputs:{x:a[t]},backend:n,attrs:{perm:e}}),m.push(i));let o=i.shape.slice();for(let e=0;e<r.length;++e)o.splice(r[e],0,1);ge(i.shape,o)||(i=$({inputs:{x:i},backend:n,attrs:{shape:o}}),m.push(i)),f===null?f=i:(f=n0({inputs:{a:i,b:f},backend:n}),m.push(f))}e<d-1&&(l[e]>=0&&(f=g0({inputs:{x:f},backend:n,attrs:{axis:l[e]-(o.length-p),keepDims:!1}}),m.push(f)),p--)}for(let e of m)e!==f&&n.disposeIntermediateTensorInfo(e);return f}var y3,sge=o((()=>{Y(),a0(),s0(),v0(),x0(),y3={kernelName:rn,backendName:`webgl`,kernelFunc:oge}})),b3,x3,cge=o((()=>{Y(),Z1(),b3=q1({opSnippet:`return (x >= 0.0) ? x : (exp(x) - 1.0);`,packedOpSnippet:`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`}),x3={kernelName:`Elu`,backendName:`webgl`,kernelFunc:b3}})),S3,C3,w3,T3,lge=o((()=>{Y(),k1(),M1(),S3=`return (b >= 0.0) ? a : a * (b + 1.0);`,C3=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,w3=e=>{let{inputs:t,backend:n}=e,{dy:r,y:i}=t,a=k().getBool(`WEBGL_PACK_BINARY_OPERATIONS`)?new j1(C3,r.shape,i.shape):new O1(S3,r.shape,i.shape);return n.runWebGLProgram(a,[r,i],r.dtype)},T3={kernelName:an,backendName:`webgl`,kernelFunc:w3}})),E3,D3,O3,k3,uge=o((()=>{Y(),Z1(),B$(),E3=`
  return vec4(equal(a, b));
`,D3=`return float(a == b);`,O3=J1({opSnippet:D3,packedOpSnippet:E3,dtype:`bool`,cpuKernelImpl:QQ}),k3={kernelName:on,backendName:`webgl`,kernelFunc:O3}})),A3,j3,M3,dge=o((()=>{Y(),Z1(),A3=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${LS};
  float a1 = ${RS};
  float a2 = ${zS};
  float a3 = ${BS};
  float a4 = ${VS};
  float a5 = ${HS};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,j3=q1({opSnippet:A3}),M3={kernelName:`Erf`,backendName:`webgl`,kernelFunc:j3}})),N3,P3,F3,I3,L3=o((()=>{Y(),Z1(),B$(),N3=X1+`
  return exp(x);
`,P3=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,F3=q1({opSnippet:N3,packedOpSnippet:P3,cpuKernelImpl:$Q,dtype:`float32`}),I3={kernelName:`Exp`,backendName:`webgl`,kernelFunc:F3}}));function R3(e){let{inputs:t,attrs:n,backend:r}=e,{dim:i}=n,{input:a}=t,o=a.shape.length,s=a.shape.slice(),c=i;return i<0&&(D(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),c=o+i+1),s.splice(c,0,1),$({inputs:{x:a},backend:r,attrs:{shape:s}})}var z3,B3=o((()=>{Y(),s0(),z3={kernelName:sn,backendName:`webgl`,kernelFunc:R3}})),V3,H3,U3,fge=o((()=>{Y(),Z1(),B$(),V3=`return exp(x) - 1.0;`,H3=q1({opSnippet:V3,packedOpSnippet:V3,cpuKernelImpl:e$}),U3={kernelName:cn,backendName:`webgl`,kernelFunc:H3}})),W3,pge=o((()=>{W3=class{constructor(e,t,n){this.variableNames=[`real`,`imag`];let r=t[1];this.outputShape=t;let i=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=n?`${r}.0`:`1.0`,o;if(e===`real`)o=`return real * expR - imag * expI;`;else if(e===`imag`)o=`return real * expI + imag * expR;`;else throw Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${i};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${o}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}}));function G3(e,t,n){let r=n.texData.get(e.dataId),i=O(e.shape),a=e.shape[e.shape.length-1],o=i/a,s=$({inputs:{x:e},backend:n,attrs:{shape:[o,a]}}),c=s.shape,l=new W3(`real`,c,t),u=new W3(`imag`,c,t),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:c},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:c}],f=n.runWebGLProgram(l,d,`float32`),p=n.runWebGLProgram(u,d,`float32`),m=I1({inputs:{real:f,imag:p},backend:n});n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(p);let h=$({inputs:{x:m},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(m),h}var K3=o((()=>{Y(),pge(),R1(),s0()}));function mge(e){let{inputs:t,backend:n}=e,{input:r}=t;return G3(r,!1,n)}var q3,hge=o((()=>{Y(),K3(),q3={kernelName:`FFT`,backendName:`webgl`,kernelFunc:mge}})),J3,gge=o((()=>{J3=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:`value`,type:`float`}],this.variableNames=[`x`],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}}));function Y3(e){let{backend:t,attrs:n}=e,{shape:r,value:i}=n,{dtype:a}=n;if(a||=Ie(i),a===`string`){let e=De(a,O(r));return e.fill(i),t.makeTensorInfo(r,a,e)}else{let e=new J3(r,i),n=[[i]];return t.runWebGLProgram(e,[],a,n)}}var X3,Z3=o((()=>{Y(),gge(),X3={kernelName:ln,backendName:`webgl`,kernelFunc:Y3}})),Q3,_ge=o((()=>{Q3=class{constructor(e){this.variableNames=[`Image`],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}})),$3,vge=o((()=>{Y(),_ge(),$3={kernelName:un,backendName:`webgl`,kernelFunc:({inputs:e,backend:t})=>{let{image:n}=e,r=t,i=new Q3(n.shape);return r.runWebGLProgram(i,[n],n.dtype)}}})),e6,t6,n6,yge=o((()=>{Y(),Z1(),B$(),e6=`return floor(x);`,t6=q1({opSnippet:e6,packedOpSnippet:e6,cpuKernelImpl:t$}),n6={kernelName:dn,backendName:`webgl`,kernelFunc:t6}})),r6,i6,a6,o6,bge=o((()=>{Y(),Z1(),r6=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,i6=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,a6=J1({opSnippet:r6,packedOpSnippet:i6,dtype:`int32`}),o6={kernelName:fn,backendName:`webgl`,kernelFunc:a6}})),s6,xge=o((()=>{VZ(),s6=class{constructor(e){this.variableNames=[`A`];let t=BZ(),[n,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}})),c6,Sge=o((()=>{VZ(),c6=class{constructor(e){this.variableNames=[`A`],this.packedInputs=!1,this.packedOutput=!0;let t=BZ(),[n,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${n}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}}));function Cge(e){let{inputs:t,backend:n,attrs:r}=e,{pixels:i}=t,{numChannels:a}=r,o=typeof HTMLVideoElement<`u`&&i instanceof HTMLVideoElement,s=typeof HTMLImageElement<`u`&&i instanceof HTMLImageElement,[c,l]=o?[i.videoWidth,i.videoHeight]:[i.width,i.height],u=[l,c],d=[l,c,a];if(s||o){let e=k().getBool(`CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU`);(u6==null||e!==d6)&&(d6=e,u6=document.createElement(`canvas`).getContext(`2d`,{willReadFrequently:d6})),u6.canvas.width=c,u6.canvas.height=l,u6.drawImage(i,0,0,c,l),i=u6.canvas}let f=n.makeTensorInfo(u,`int32`);n.texData.get(f.dataId).usage=RX.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(f.dataId),i);let p=k().getBool(`WEBGL_PACK`)?new c6(d):new s6(d),m=n.runWebGLProgram(p,[f],`int32`);return n.disposeData(f.dataId),m}var l6,u6,d6,wge=o((()=>{Y(),BX(),xge(),Sge(),l6={kernelName:ii,backendName:`webgl`,kernelFunc:Cge},d6=k().getBool(`CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU`)}));function Tge(e){let{inputs:t,backend:n,attrs:r}=e,{x:i,filter:a,bias:o,preluActivationWeights:s}=t,{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:f,activation:p,leakyreluAlpha:m}=r,h=Il(u),g=Sl(i.shape,a.shape,c,d,l,f,!1,h),_,v=[],y=o!=null,b=s!=null,x=p===`leakyrelu`,S=()=>{let e=[i,a],t=(e,t)=>{if(t===`NCHW`&&e.shape.length===1&&e.shape[0]!==1){let t=$({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return v.push(t),t}return e};if(y&&e.push(t(o,u)),b&&e.push(t(s,u)),x){let t=n.makeTensorInfo([],`float32`,qi(m,`float32`));e.push(t),v.push(t)}return e};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type===`SAME`||g.padInfo.type===`VALID`))_=S4({x:i,filter:a,convInfo:g,backend:n,bias:o,activation:p,preluActivationWeights:s,leakyreluAlpha:m});else if(g.strideWidth<=2&&h===`channelsLast`&&k().getBool(`WEBGL_EXP_CONV`)){let e=p?Y1(p,!0):null,t=new v4(g,y,e,b,x),r=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],i=S();_=n.runWebGLProgram(t,i,`float32`,r)}else if(k().getBool(`WEBGL_CONV_IM2COL`))_=C4({x:i,filter:a,convInfo:g,backend:n,bias:o,activation:p,preluActivationWeights:s,leakyreluAlpha:m});else{let e=p?Y1(p,!1):null,t=new h4(g,y,e,b,x),r=S();_=n.runWebGLProgram(t,r,`float32`)}let C=$({inputs:{x:_},backend:n,attrs:{shape:g.outShape}});return v.push(_),v.forEach(e=>n.disposeIntermediateTensorInfo(e)),C}var f6,Ege=o((()=>{Y(),_4(),y4(),Z1(),w4(),s0(),f6={kernelName:si,backendName:`webgl`,kernelFunc:Tge}}));function Dge(e){let{inputs:t,backend:n,attrs:r}=e,{x:i,filter:a,bias:o,preluActivationWeights:s}=t,{strides:c,pad:l,dilations:u,dimRoundingMode:d,activation:f,leakyreluAlpha:p}=r,m=[],h=u;h??=[1,1],D(Pl(c,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${c} and dilations '${h}'`);let g=Sl(i.shape,a.shape,c,h,l,d,!0),_=k().getBool(`WEBGL_PACK_DEPTHWISECONV`)&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,v=f?Y1(f,_):null,y=[i,a],b=o!=null,x=s!=null,S=f===`leakyrelu`;if(b&&y.push(o),x&&y.push(s),S){let e=n.makeTensorInfo([],`float32`,qi(p,`float32`));y.push(e),m.push(e)}let C;C=_?new s3(g,b,v,x,S):new a3(g,b,v,x,S);let w=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],T=n.runWebGLProgram(C,y,`float32`,w);return m.forEach(e=>n.disposeIntermediateTensorInfo(e)),T}var p6,Oge=o((()=>{Y(),o3(),c3(),Z1(),p6={kernelName:ci,backendName:`webgl`,kernelFunc:Dge}})),m6,kge=o((()=>{cQ(),m6=class{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=[`x`,`indices`],this.outputShape=n;let i=$Z(n.length),a=`
    int index;`;for(let e=0;e<this.sliceDim;e++)a+=`
          index = round(getIndices(coords[0], ${e}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[e]};
          flattenIndex += index * ${this.strides[e]};`;this.userCode=`
         void main() {
          ${i} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${a}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}}));function Age(e){let{inputs:t,backend:n}=e,{params:r,indices:i}=t,a=i.shape,o=a[a.length-1],s=O(r.shape),[c,l,u,d]=Kx(r,i),f=$({inputs:{x:i},backend:n,attrs:{shape:[l,o]}}),p=$({inputs:{x:r},backend:n,attrs:{shape:[O(r.shape)/u,u]}});if(n.shouldExecuteOnCPU([r,i])||r.dtype===`string`){let e=n.readSync(i.dataId),t=n.bufferSync(r),a=n$(e,t,r.dtype,l,o,u,d,r.shape,s);return n.makeTensorInfo(c,r.dtype,a.values)}let m=new m6(o,d,[l,u],r.shape),h=n.runWebGLProgram(m,[p,f],p.dtype),g=$({inputs:{x:h},backend:n,attrs:{shape:c}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),g}var h6,jge=o((()=>{Y(),kge(),B$(),s0(),h6={kernelName:hn,backendName:`webgl`,kernelFunc:Age}}));function Mge(e,t){let n=[`resRC.x`,`resRC.y`,`resRC.z`,`resRC.w`],r=[];for(let t=0;t<e.length;t++)t===2?r.push(`index`):r.push(`${n[t]}`);return r.join()}var g6,Nge=o((()=>{cQ(),g6=class{constructor(e,t){this.variableNames=[`A`,`indices`],this.outputShape=t,this.rank=t.length;let n=$Z(this.rank),r=Mge(e,2);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}}}));function _6(e){let{inputs:t,backend:n,attrs:r}=e,{x:i,indices:a}=t,{axis:o,batchDims:s}=r,c=we(o,i.shape)[0];if(k().get(`DEBUG`)){let e=n.readSync(a.dataId),t=i.shape[c];for(let n=0;n<e.length;++n){let r=e[n];D(r<=t-1&&r>=0,()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`)}}let l=xC(i,a,c,s),u=O(a.shape),d=[],f=$({inputs:{x:i},backend:n,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),p=$({inputs:{x:a},backend:n,attrs:{shape:[l.batchSize,u/l.batchSize]}});d.push(f),d.push(p);let m=[l.batchSize,l.outerSize,u/l.batchSize,l.sliceSize];if(n.shouldExecuteOnCPU([i,a])||i.dtype===`string`){let e=n.bufferSync(p),t=n.bufferSync(f),r=r$(t,e,m);return d.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(l.outputShape,r.dtype,r.values)}let h=new g6(f.shape,m),g=n.runWebGLProgram(h,[f,p],f.dtype);d.push(g);let _=$({inputs:{x:g},backend:n,attrs:{shape:l.outputShape}});return d.forEach(e=>n.disposeIntermediateTensorInfo(e)),_}var v6,y6=o((()=>{Y(),Nge(),B$(),s0(),v6={kernelName:mn,backendName:`webgl`,kernelFunc:_6}})),b6,x6,S6,C6,Pge=o((()=>{Y(),Z1(),B$(),b6=`return float(a > b);`,x6=`
  return vec4(greaterThan(a, b));
`,S6=J1({opSnippet:b6,packedOpSnippet:x6,cpuKernelImpl:i$,dtype:`bool`}),C6={kernelName:gn,backendName:`webgl`,kernelFunc:S6}})),w6,T6,E6,D6,Fge=o((()=>{Y(),Z1(),B$(),w6=`return float(a >= b);`,T6=`
  return vec4(greaterThanEqual(a, b));
`,E6=J1({opSnippet:w6,packedOpSnippet:T6,dtype:`bool`,cpuKernelImpl:a$}),D6={kernelName:_n,backendName:`webgl`,kernelFunc:E6}}));function Ige(e){let{inputs:t,backend:n}=e,{input:r}=t;return G3(r,!0,n)}var O6,Lge=o((()=>{Y(),K3(),O6={kernelName:yn,backendName:`webgl`,kernelFunc:Ige}})),k6,A6,j6,Rge=o((()=>{Y(),Z1(),k6=`return float(!isnan(x) && !isinf(x));`,A6=q1({opSnippet:k6,dtype:`bool`}),j6={kernelName:xn,backendName:`webgl`,kernelFunc:A6}})),M6,N6,P6,zge=o((()=>{Y(),Z1(),M6=`return float(isinf(x));`,N6=q1({opSnippet:M6,dtype:`bool`}),P6={kernelName:Sn,backendName:`webgl`,kernelFunc:N6}})),F6,I6,L6,Bge=o((()=>{Y(),Z1(),F6=`return float(isnan(x));`,I6=q1({opSnippet:F6,dtype:`bool`}),L6={kernelName:Cn,backendName:`webgl`,kernelFunc:I6}})),R6,z6,B6,V6,Vge=o((()=>{Y(),Z1(),B$(),R6=`return float(a < b);`,z6=`
  return vec4(lessThan(a, b));
`,B6=J1({opSnippet:R6,packedOpSnippet:z6,cpuKernelImpl:o$,dtype:`bool`}),V6={kernelName:Tn,backendName:`webgl`,kernelFunc:B6}})),H6,U6,W6,G6,Hge=o((()=>{Y(),Z1(),B$(),H6=`return float(a <= b);`,U6=`
  return vec4(lessThanEqual(a, b));
`,W6=J1({opSnippet:H6,packedOpSnippet:U6,cpuKernelImpl:s$,dtype:`bool`}),G6={kernelName:En,backendName:`webgl`,kernelFunc:W6}}));function Uge(e){let{backend:t,attrs:n}=e,{start:r,stop:i,num:a}=n,o=c$(r,i,a);return t.makeTensorInfo([o.length],`float32`,o)}var K6,Wge=o((()=>{Y(),B$(),K6={kernelName:Dn,backendName:`webgl`,kernelFunc:Uge}})),q6,J6,Y6,X6,Gge=o((()=>{Y(),Z1(),B$(),q6=X1+`
  return x < 0.0 ? 0./0. : log(x);
`,J6=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,Y6=q1({opSnippet:q6,packedOpSnippet:J6,cpuKernelImpl:l$}),X6={kernelName:`Log`,backendName:`webgl`,kernelFunc:Y6}})),Z6,Q6,$6,Kge=o((()=>{Y(),Z1(),Z6=X1+`
  return log(1.0 + x);
`,Q6=q1({opSnippet:Z6}),$6={kernelName:On,backendName:`webgl`,kernelFunc:Q6}})),e8,t8,n8,r8,qge=o((()=>{Y(),Z1(),e8=`return float(a >= 1.0 && b >= 1.0);`,t8=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,n8=J1({opSnippet:e8,packedOpSnippet:t8,dtype:`bool`}),r8={kernelName:kn,backendName:`webgl`,kernelFunc:n8}})),i8,a8,o8,Jge=o((()=>{Y(),Z1(),i8=`return float(!(x >= 1.0));`,a8=q1({opSnippet:i8}),o8={kernelName:An,backendName:`webgl`,kernelFunc:a8}})),s8,c8,l8,u8,Yge=o((()=>{Y(),Z1(),s8=`return float(a >= 1.0 || b >= 1.0);`,c8=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,l8=J1({opSnippet:s8,packedOpSnippet:c8,dtype:`bool`}),u8={kernelName:jn,backendName:`webgl`,kernelFunc:l8}})),d8,Xge=o((()=>{d8=class{constructor(e,t,n,r,i){this.variableNames=[`x`],this.outputShape=[];let a=t,o=e[3]-1;this.outputShape=e;let s,c=`float(${n}) + float(${r}) * sum`;s=i===.5?`inversesqrt(${c})`:i===1?`1.0/(${c})`:`exp(log(${c}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${o}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${s};
        setOutput(val);
      }
    `}}})),f8,Zge=o((()=>{f8=class{constructor(e,t,n,r,i){this.variableNames=[`x`],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let a=t,o=e[3]-1;this.outputShape=e;let s,c=`float(${n}) + float(${r}) * sum`;s=i===.5?`inversesqrt(${c})`:i===1?`1.0/(${c})`:`exp(log(${c}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${s};
        setOutput(result);
      }
    `}}})),p8,m8,Qge=o((()=>{Y(),Xge(),Zge(),p8=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{depthRadius:a,bias:o,alpha:s,beta:c}=r,l=k().getBool(`WEBGL_PACK_NORMALIZATION`)?new f8(i.shape,a,o,s,c):new d8(i.shape,a,o,s,c);return n.runWebGLProgram(l,[i],i.dtype)},m8={kernelName:`LRN`,backendName:`webgl`,kernelFunc:p8}})),h8,$ge=o((()=>{h8=class{constructor(e,t,n,r,i){this.variableNames=[`inputImage`,`outputImage`,`dy`],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=i,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${i})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${i});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}})),g8,_8,e_e=o((()=>{Y(),$ge(),g8=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:i,y:a,dy:o}=t,{depthRadius:s,bias:c,alpha:l,beta:u}=r,d=new h8(i.shape,s,c,l,u);return n.runWebGLProgram(d,[i,a,o],i.dtype)},_8={kernelName:Fn,backendName:`webgl`,kernelFunc:g8}}));function t_e(e,t,n,r){let i=O(t),a=O(e.shape)/i,o=$({inputs:{x:e},attrs:{shape:[a,i]},backend:r}),s=u0(o,e.dtype,`max`,r),c=$({inputs:{x:s},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(s),c}var n_e=o((()=>{Y(),d0(),s0()}));function v8(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{reductionIndices:a,keepDims:o}=r,s=i.shape.length,c=we(a,i.shape),l=c,u=Rf(l,s),d=u!=null,f=n.shouldExecuteOnCPU([i]),p=i;if(d){if(f){let e=n.texData.get(p.dataId).values,t=Array(s);for(let e=0;e<t.length;e++)t[e]=i.shape[u[e]];let r=R$(e,i.shape,i.dtype,u,t);p=n.makeTensorInfo(t,i.dtype);let a=n.texData.get(p.dataId);a.values=r}else p=m0(i,u,n);l=Bf(l.length,s)}Lf(`max`,l,s);let[m,h]=Ff(p.shape,l),g=m;o&&(g=If(m,c));let _;if(f){let e=n.texData.get(p.dataId).values,t=u$(e,O(h),g,i.dtype);_=n.makeTensorInfo(g,i.dtype);let r=n.texData.get(_.dataId);r.values=t}else _=t_e(p,h,g,n);return d&&n.disposeIntermediateTensorInfo(p),_}var y8,b8=o((()=>{Y(),B$(),n_e(),h0(),y8={kernelName:`Max`,backendName:`webgl`,kernelFunc:v8}})),x8,S8,C8,w8,r_e=o((()=>{Y(),k1(),M1(),Z1(),B$(),x8=D1+`
  return max(a, b);
`,S8=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+A1+`
  return result;
`,C8=J1({opSnippet:x8,packedOpSnippet:S8,cpuKernelImpl:d$}),w8={kernelName:Ln,backendName:`webgl`,kernelFunc:C8}}));function i_e(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t;MZ(i,`maxPool`);let{filterSize:a,strides:o,pad:s,dimRoundingMode:c}=r;D(Pl(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);let l=bl(i.shape,a,o,1,s,c);if(l.filterWidth===1&&l.filterHeight===1&&ge(l.inShape,l.outShape))return N1({inputs:{x:i},backend:n});let u=new f2(l,`max`,!1);return n.runWebGLProgram(u,[i],i.dtype)}var T8,a_e=o((()=>{Y(),m2(),RZ(),F1(),T8={kernelName:Rn,backendName:`webgl`,kernelFunc:i_e}}));function o_e(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{filterSize:a,strides:o,pad:s,dataFormat:c,dimRoundingMode:l}=r,u=xl(i.shape,a,o,[1,1,1],s,l,c),d=new p2(u,`max`,!1);return n.runWebGLProgram(d,[i],i.dtype)}var E8,s_e=o((()=>{Y(),m2(),E8={kernelName:Bn,backendName:`webgl`,kernelFunc:o_e}})),D8,O8,k8=o((()=>{D8=class{constructor(e){this.variableNames=[`dy`,`maxPos`],this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,i=e.effectiveFilterHeight,a=e.effectiveFilterWidth,o=i-1-e.padInfo.top,s=a-1-e.padInfo.left,c=i*a-1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${s});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},O8=class{constructor(e){this.variableNames=[`dy`,`maxPos`],this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,i=e.dilationDepth,a=e.dilationHeight,o=e.dilationWidth,s=e.effectiveFilterDepth,c=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=s-1-e.padInfo.front,d=c-1-e.padInfo.top,f=l-1-e.padInfo.left,p=s*c*l-1;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${d}, ${f});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${s};
           wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${l};
                wC += ${o}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${p} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${l} +
                  wR * ${l} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}}));function c_e(e){let{inputs:t,backend:n,attrs:r}=e,{dy:i,input:a}=t,o=a,{filterSize:s,strides:c,pad:l,dimRoundingMode:u}=r,d=xl(o.shape,s,c,[1,1,1],l,u),f=new p2(d,`max`,!0),p=n.runWebGLProgram(f,[o],o.dtype),m=new O8(d),h=n.runWebGLProgram(m,[i,p],o.dtype);return n.disposeIntermediateTensorInfo(p),h}var A8,l_e=o((()=>{Y(),k8(),m2(),A8={kernelName:Vn,backendName:`webgl`,kernelFunc:c_e}}));function u_e(e){let{inputs:t,backend:n,attrs:r}=e,{dy:i,input:a,output:o}=t,s=a;MZ([a,o],`maxPoolGrad`);let{filterSize:c,strides:l,pad:u,dimRoundingMode:d}=r,f=bl(s.shape,c,l,1,u,d),p=new f2(f,`max`,!0),m=n.runWebGLProgram(p,[s],s.dtype),h=new D8(f),g=n.runWebGLProgram(h,[i,m],s.dtype);return n.disposeIntermediateTensorInfo(m),g}var j8,d_e=o((()=>{Y(),k8(),m2(),RZ(),j8={kernelName:zn,backendName:`webgl`,kernelFunc:u_e}}));function f_e(e,t,n,r){let i=new f2(n,`max`,!1),a=r.runWebGLProgram(i,[e],`float32`);i=new f2(n,`max`,!0,!0,t);let o=r.runWebGLProgram(i,[e],`float32`);return[a,o]}var p_e=o((()=>{m2()})),M8,m_e=o((()=>{Y(),p_e(),M8={kernelName:Hn,backendName:`webgl`,kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:i,strides:a,pad:o,includeBatchInIndex:s}=t,c=n;D(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);let l=[1,1];D(Pl(a,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`);let u=bl(r.shape,i,a,l,o),[d,f]=f_e(r,s,u,c);return[d,f]}}}));function h_e(e,t,n,r){let i=O(t),a=O(e.shape)/i,o=$({inputs:{x:e},attrs:{shape:[a,i]},backend:r}),s=u0(o,`float32`,`mean`,r),c=$({inputs:{x:s},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(s),c}var g_e=o((()=>{Y(),d0(),s0()})),N8,__e=o((()=>{Y(),g_e(),h0(),N8={kernelName:Un,backendName:`webgl`,kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{keepDims:i,axis:a}=t,o=n,s=r.shape.length,c=we(a,r.shape),l=c,u=Rf(l,s),d=u!=null,f=o.shouldExecuteOnCPU([r]),p=[],m=r;if(d){if(f){let e=o.texData.get(m.dataId).values,t=Array(s);for(let e=0;e<t.length;e++)t[e]=r.shape[u[e]];let n=R$(e,r.shape,r.dtype,u,t);m=o.makeTensorInfo(t,r.dtype);let i=o.texData.get(m.dataId);i.values=n}else m=m0(r,u,o);p.push(m),l=Bf(l.length,s)}Lf(`sum`,l,s);let[h,g]=Ff(m.shape,l),_=h;i&&(_=If(h,c));let v=h_e(m,g,_,o);for(let e of p)o.disposeIntermediateTensorInfo(e);return v}}}));function v_e(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a,keepDims:o}=r,s=i.shape.length,c=we(a,i.shape),l=c,u=Rf(l,s),d=i;u!=null&&(d=y0({inputs:{x:i},backend:n,attrs:{perm:u}}),l=Bf(l.length,i.shape.length)),Lf(`min`,l,s);let[f,p]=Ff(d.shape,l),m=O(p),h=$({inputs:{x:d},backend:n,attrs:{shape:[-1,m]}}),g=u0(h,h.dtype,`min`,n),_;if(o){let e=If(f,c);_=$({inputs:{x:g},backend:n,attrs:{shape:e}})}else _=$({inputs:{x:g},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(g),u!=null&&n.disposeIntermediateTensorInfo(d),_}var P8,y_e=o((()=>{Y(),d0(),s0(),x0(),P8={kernelName:`Min`,backendName:`webgl`,kernelFunc:v_e}})),F8,I8,L8,R8,b_e=o((()=>{Y(),k1(),M1(),Z1(),B$(),F8=D1+`
  return min(a, b);
`,I8=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+A1+`
  return result;
`,L8=J1({opSnippet:F8,packedOpSnippet:I8,cpuKernelImpl:f$}),R8={kernelName:Wn,backendName:`webgl`,kernelFunc:L8}})),z8,x_e=o((()=>{cQ(),z8=class{constructor(e,t,n){this.variableNames=[`x`],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);let r=e.length,i=$Z(r),a=t.map(e=>e[0]).join(`,`),o=t.map((t,n)=>t[0]+e[n]).join(`,`),s=[`coords[0]`,`coords[1]`,`coords[2]`,`coords[3]`].slice(0,r),c=n===`reflect`?0:1;if(r===1){this.userCode=`
        int start = ${a};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${a});
      ${i} end = ${i}(${o});

      void main() {
        ${i} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${i} coords = outC - start;
        setOutput(getX(${s}));
      }
    `}}})),B8,S_e=o((()=>{U$(),cQ(),B8=class{constructor(e,t,n){this.variableNames=[`x`],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);let r=e.length,i=$Z(r),a=t.map(e=>e[0]).join(`,`),o=t.map((t,n)=>t[0]+e[n]).join(`,`),s=H$(`rc`,r),c=H$(`source`,r),l=`${s[r-1]} < ${this.outputShape[r-1]}`,u=r===1?`source`:`vec2(${c.slice(-2).join()})`,d=n===`reflect`?0:1,f=``;if(r===1){let e=`
        ${i} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;f=`
        ${i} rc = outputLoc;
        ${e}
        result[0] = getChannel(getX(${c.join()}), ${u});
        ${s[r-1]} += 1;
        if(${l}) {
          ${e}
          result[1] = getChannel(getX(${c.join()}), ${u});
        }
      `}else{let e=`
        ${i} source = rc;
        ${i} lt = ${i}(lessThan(source, start));
        ${i} gte = ${i}(greaterThanEqual(source, end));
        ${i} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;f=`
        ${i} rc = outputLoc;
        ${e}
        result[0] = getChannel(getX(${c.join()}), ${u});
        ${s[r-1]} += 1;
        if(${l}) {
          ${e}
          result[1] = getChannel(getX(${c.join()}), ${u});
        }
        rc = outputLoc;
        ${s[r-2]} += 1;
        if(${s[r-2]} < ${this.outputShape[r-2]}) {
          ${e}
          result[2] = getChannel(getX(${c.join()}), ${u});
          ${s[r-1]} += 1;
          if(${l}) {
            ${e}
            result[3] = getChannel(getX(${c.join()}), ${u});
          }
        }
      `}this.userCode=`
      const ${i} start = ${i}(${a});
      const ${i} end = ${i}(${o});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}}})),V8,H8,C_e=o((()=>{Y(),x_e(),S_e(),V8=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{paddings:i,mode:a}=n,o=k().getBool(`WEBGL_PACK_ARRAY_OPERATIONS`)?new B8(r.shape,i,a):new z8(r.shape,i,a);return t.runWebGLProgram(o,[r],r.dtype)},H8={kernelName:Gn,backendName:`webgl`,kernelFunc:V8}})),U8,W8,G8,K8,w_e=o((()=>{Y(),M1(),Z1(),U8=`if (b == 0.0) return NAN;
  return mod(a, b);`,W8=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+A1+`
  return result;
`,G8=J1({opSnippet:U8,packedOpSnippet:W8}),K8={kernelName:`Mod`,backendName:`webgl`,kernelFunc:G8}})),q8,T_e=o((()=>{q8=class{constructor(e,t,n){this.variableNames=[`probs`],this.customUniforms=[{name:`seed`,type:`float`}],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}})),J8,Y8,X8,Z8,Q8=o((()=>{Y(),Z1(),J8=`
if (a == b) {
  return 1.0;
};
return a / b;`,Y8=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,X8=J1({opSnippet:J8,packedOpSnippet:Y8,checkOutOfBounds:!0}),Z8={kernelName:nn,backendName:`webgl`,kernelFunc:X8}})),$8,e5,t5,n5=o((()=>{Y(),Z1(),B$(),$8=`return a - b;`,e5=J1({opSnippet:$8,packedOpSnippet:$8,supportsComplex:!0,cpuKernelImpl:F$}),t5={kernelName:`Sub`,backendName:`webgl`,kernelFunc:e5}}));function r5(e){let{inputs:t,backend:n,attrs:r}=e,{logits:i}=t,{dim:a}=r,o=we([a],i.shape),s=v8({inputs:{x:i},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),c=If(s.shape,o),l=$({inputs:{x:s},backend:n,attrs:{shape:c}}),u=e5({inputs:{a:i,b:l},backend:n}),d=F3({inputs:{x:u},backend:n}),f=g0({inputs:{x:d},backend:n,attrs:{axis:o,keepDims:!1}}),p=$({inputs:{x:f},backend:n,attrs:{shape:c}}),m=X8({inputs:{a:d,b:p},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(p),m}var i5,a5=o((()=>{Y(),L3(),b8(),Q8(),s0(),n5(),v0(),i5={kernelName:Pr,backendName:`webgl`,kernelFunc:r5}}));function E_e(e){let{inputs:t,backend:n,attrs:r}=e,{logits:i}=t,{numSamples:a,seed:o,normalized:s}=r,c=s?i:r5({inputs:{logits:i},backend:n,attrs:{dim:i.shape.length-1}}),l=c.shape[0],u=c.shape[1],d=new q8(l,u,a),f=[[o]],p=n.runWebGLProgram(d,[c],`int32`,f);return s||n.disposeIntermediateTensorInfo(c),p}var o5,D_e=o((()=>{Y(),T_e(),a5(),o5={kernelName:Kn,backendName:`webgl`,kernelFunc:E_e}}));function O_e(e){let{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){let e=n.texData.get(r.dataId),[t,i]=m$(e.values,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,t)}let i;return i=k().getBool(`WEBGL_PACK_UNARY_OPERATIONS`)?new f1(r.shape,c5):new Z$(r.shape,s5),n.runWebGLProgram(i,[r],r.dtype)}var s5,c5,l5,k_e=o((()=>{Y(),B$(),o1(),p1(),s5=Q$+`
  return -x;
`,c5=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,l5={kernelName:`Neg`,backendName:`webgl`,kernelFunc:O_e}}));function A_e(e){li(`tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead`);let{inputs:t,backend:n,attrs:r}=e,{boxes:i,scores:a}=t,{maxOutputSize:o,iouThreshold:s,scoreThreshold:c}=r,l=n.readSync(i.dataId),u=n.readSync(a.dataId),{selectedIndices:d}=u5(l,u,o,s,c);return n.makeTensorInfo([d.length],`int32`,new Int32Array(d))}var u5,d5,j_e=o((()=>{Y(),u5=sy,d5={kernelName:Yn,backendName:`webgl`,kernelFunc:A_e}}));function M_e(e){li(`tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead`);let{inputs:t,backend:n,attrs:r}=e,{boxes:i,scores:a}=t,{maxOutputSize:o,iouThreshold:s,scoreThreshold:c,padToMaxOutputSize:l}=r,u=n.readSync(i.dataId),d=n.readSync(a.dataId),{selectedIndices:f,validOutputs:p}=f5(u,d,o,s,c,l);return[n.makeTensorInfo([f.length],`int32`,new Int32Array(f)),n.makeTensorInfo([],`int32`,new Int32Array([p]))]}var f5,p5,N_e=o((()=>{Y(),f5=cy,p5={kernelName:Xn,backendName:`webgl`,kernelFunc:M_e}}));function P_e(e){li(`tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead`);let{inputs:t,backend:n,attrs:r}=e,{boxes:i,scores:a}=t,{maxOutputSize:o,iouThreshold:s,scoreThreshold:c,softNmsSigma:l}=r,u=n.readSync(i.dataId),d=n.readSync(a.dataId),{selectedIndices:f,selectedScores:p}=m5(u,d,o,s,c,l);return[n.makeTensorInfo([f.length],`int32`,new Int32Array(f)),n.makeTensorInfo([p.length],`float32`,new Float32Array(p))]}var m5,h5,F_e=o((()=>{Y(),m5=ly,h5={kernelName:Zn,backendName:`webgl`,kernelFunc:P_e}})),g5,I_e=o((()=>{g5=class{constructor(e,t,n,r){this.variableNames=[`indices`],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${n}),
                      float(index == coords.y)));
      }
    `}}})),_5,v5,L_e=o((()=>{Y(),I_e(),s0(),_5=e=>{let{inputs:t,backend:n,attrs:r}=e,{indices:i}=t,{dtype:a,depth:o,onValue:s,offValue:c}=r,l=O(i.shape),u=new g5(l,o,s,c),d=$({inputs:{x:i},backend:n,attrs:{shape:[l]}}),f=n.runWebGLProgram(u,[d],a);n.disposeIntermediateTensorInfo(d);let p=[...i.shape,o],m=$({inputs:{x:f},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(f),m},v5={kernelName:$n,backendName:`webgl`,kernelFunc:_5}}));function y5(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype===`complex64`){let e=W2({inputs:{input:r},backend:n}),t=y5({inputs:{x:e},backend:n}),i=c4({inputs:{input:r},backend:n}),a=y5({inputs:{x:i},backend:n}),o=I1({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),o}else return Y3({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype===`string`?``:0},backend:n})}var b5,x5=o((()=>{Y(),R1(),Z3(),u4(),K2(),b5={kernelName:ni,backendName:`webgl`,kernelFunc:y5}}));function S5(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype===`string`)throw Error(`onesLike is not supported under string dtype`);if(r.dtype===`complex64`){let e=W2({inputs:{input:r},backend:n}),t=S5({inputs:{x:e},backend:n}),i=c4({inputs:{input:r},backend:n}),a=y5({inputs:{x:i},backend:n}),o=I1({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),o}else return Y3({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}var C5,R_e=o((()=>{Y(),R1(),Z3(),u4(),K2(),x5(),C5={kernelName:Qn,backendName:`webgl`,kernelFunc:S5}}));function z_e(e){let{inputs:t,backend:n,attrs:r}=e,{axis:i}=r;if(t.length===1)return R3({inputs:{input:t[0]},backend:n,attrs:{dim:i}});let a=t[0].shape,o=t[0].dtype;t.forEach(e=>{fe(a,e.shape,`All tensors passed to stack must have matching shapes`),D(o===e.dtype,()=>`All tensors passed to stack must have matching dtypes`)});let s=[],c=t.map(e=>{let t=R3({inputs:{input:e},backend:n,attrs:{dim:i}});return s.push(t),t}),l=f4({inputs:c,backend:n,attrs:{axis:i}});return s.forEach(e=>n.disposeIntermediateTensorInfo(e)),l}var w5,B_e=o((()=>{Y(),m4(),B3(),w5={kernelName:er,backendName:`webgl`,kernelFunc:z_e}})),T5,V_e=o((()=>{cQ(),T5=class{constructor(e,t,n){this.variableNames=[`x`],this.customUniforms=[{name:`value`,type:`float`}],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);let r=e.length,i=$Z(r),a=t.map(e=>e[0]).join(`,`),o=t.map((t,n)=>t[0]+e[n]).join(`,`),s=[`coords[0]`,`coords[1]`,`coords[2]`,`coords[3]`].slice(0,r);if(r===1){this.userCode=`
        int start = ${a};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${a});
      ${i} end = ${i}(${o});

      void main() {
        ${i} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${i} coords = outC - start;
          setOutput(getX(${s}));
        }
      }
    `}}})),E5,H_e=o((()=>{U$(),cQ(),E5=class{constructor(e,t,n){this.variableNames=[`x`],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:`value`,type:`float`}],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);let r=e.length,i=$Z(r),a=t.map(e=>e[0]).join(`,`),o=t.map((t,n)=>t[0]+e[n]).join(`,`),s=H$(`rc`,r),c=H$(`source`,r),l=`${s[r-1]} < ${this.outputShape[r-1]}`,u=r===1?`source`:`vec2(${c.slice(-2).join()})`,d=[`${i} rc = outputLoc;`,`${s[r-1]} += 1;
       if(${l}) {
      `,r===1?``:`}
       rc = outputLoc;
       ${s[r-2]} += 1;
       if(${s[r-2]} < ${this.outputShape[r-2]}) {`,r===1?``:`  ${s[r-1]} += 1;
         if(${l}) {`],f=r===1?`rc < start || rc >= end`:`any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))`,p=``;for(let e=0,t=r===1?2:4;e<t;e++)p+=`
        ${d[e]}
        if (${f}) {
          result[${e}] = float(value);
        } else {
          ${i} source = rc - start;
          result[${e}] = getChannel(getX(${c.join()}), ${u});
        }
      `;p+=r===1?`} `:`}}`,this.userCode=`
      const ${i} start = ${i}(${a});
      const ${i} end = ${i}(${o});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}})),D5,O5,k5=o((()=>{Y(),V_e(),H_e(),Z3(),D5=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{paddings:a,constantValue:o}=r;if(O(i.shape)===0){let e=a.map((e,t)=>e[0]+i.shape[t]+e[1]);return Y3({backend:n,attrs:{shape:e,value:o,dtype:i.dtype}})}let s=k().getBool(`WEBGL_PACK_ARRAY_OPERATIONS`)?new E5(i.shape,a,o):new T5(i.shape,a,o),c=[[o]];return n.runWebGLProgram(s,[i],i.dtype,c)},O5={kernelName:tr,backendName:`webgl`,kernelFunc:D5}})),A5,j5,M5,N5,U_e=o((()=>{Y(),M1(),Z1(),A5=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,j5=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+A1+`
  return result;
`,M5=J1({opSnippet:A5,packedOpSnippet:j5}),N5={kernelName:`Pow`,backendName:`webgl`,kernelFunc:M5}}));function W_e(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:a,keepDims:o}=r,s=i.shape.length,c=[],l=we(a,i.shape),u=l,d=Rf(u,s),f=i;d!=null&&(f=y0({inputs:{x:i},backend:n,attrs:{perm:d}}),u=Bf(u.length,s),c.push(f)),Lf(`prod`,u,s);let p;if(n.shouldExecuteOnCPU([f])){let e=n.texData.get(f.dataId).values,{outVals:t,outShape:r,outDtype:i}=g$(f.shape,f.dtype,e,u);p=n.makeTensorInfo(r,i,t)}else{let[e,t]=Ff(f.shape,u),r=O(t),a=$({inputs:{x:f},backend:n,attrs:{shape:[-1,r]}}),o=Da(i.dtype),s=u0(a,o,`prod`,n);p=$({inputs:{x:s},backend:n,attrs:{shape:e}}),c.push(a),c.push(s)}if(o){c.push(p);let e=If(p.shape,l);p=$({inputs:{x:p},backend:n,attrs:{shape:e}})}return c.forEach(e=>n.disposeIntermediateTensorInfo(e)),p}var P5,G_e=o((()=>{Y(),d0(),B$(),s0(),x0(),P5={kernelName:ir,backendName:`webgl`,kernelFunc:W_e}}));function K_e(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:i,paramsDenseValues:a,indices:o}=t,{outputRaggedRank:s}=r,c=i.map(e=>n.readSync(e.dataId)),l=i.map(e=>e.shape),u=n.readSync(a.dataId),d=n.readSync(o.dataId),[f,p,m]=_$(c,l,u,a.shape,a.dtype,d,o.shape,s),h=f.map(e=>n.makeTensorInfo([e.length],`int32`,e)),g=n.makeTensorInfo(m,a.dtype,p);return h.concat([g])}var F5,q_e=o((()=>{Y(),B$(),F5={kernelName:ar,backendName:`webgl`,kernelFunc:K_e}}));function J_e(e){let{inputs:t,backend:n}=e,{starts:r,limits:i,deltas:a}=t,o=n.readSync(r.dataId),s=n.readSync(i.dataId),c=n.readSync(a.dataId),[l,u]=v$(o,r.shape,r.dtype,s,i.shape,c,a.shape),d=n.makeTensorInfo([l.length],`int32`,l),f=n.makeTensorInfo([u.length],r.dtype,u);return[d,f]}var I5,Y_e=o((()=>{Y(),B$(),I5={kernelName:or,backendName:`webgl`,kernelFunc:J_e}}));function X_e(e){let{inputs:t,backend:n,attrs:r}=e,{shape:i,values:a,defaultValue:o,rowPartitionTensors:s}=t,{rowPartitionTypes:c}=r,l=n.readSync(i.dataId),u=n.readSync(a.dataId),d=n.readSync(o.dataId),f=s.map(e=>n.readSync(e.dataId)),p=s.map(e=>e.shape),[m,h]=y$(l,i.shape,u,a.shape,a.dtype,d,o.shape,f,p,c);return n.makeTensorInfo(m,a.dtype,h)}var L5,Z_e=o((()=>{Y(),B$(),L5={kernelName:sr,backendName:`webgl`,kernelFunc:X_e}})),R5,z5,B5=o((()=>{Y(),B$(),R5=e=>{let{backend:t,attrs:n}=e,{start:r,stop:i,step:a,dtype:o}=n,s=b$(r,i,a,o);return t.makeTensorInfo([s.length],o,s)},z5={kernelName:cr,backendName:`webgl`,kernelFunc:R5}})),V5,H5,U5,Q_e=o((()=>{Y(),Z1(),V5=`return 1.0 / x;`,H5=q1({opSnippet:V5}),U5={kernelName:ur,backendName:`webgl`,kernelFunc:H5}})),W5,G5,K5,q5,$_e=o((()=>{Y(),Z1(),o1(),W5=Q$+`
  return (x < 0.0) ? 0.0 : x;
`,G5=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,K5=q1({opSnippet:W5,packedOpSnippet:G5}),q5={kernelName:dr,backendName:`webgl`,kernelFunc:K5}})),J5,Y5,X5,Z5,eve=o((()=>{Y(),Z1(),o1(),J5=Q$+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Y5=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,X5=q1({opSnippet:J5,packedOpSnippet:Y5}),Z5={kernelName:_r,backendName:`webgl`,kernelFunc:X5}})),Q5,tve=o((()=>{Q5=class{constructor(e,t,n,r,i){this.variableNames=[`A`],this.outputShape=[];let[a,o,s,c]=e;this.outputShape=[a,t,n,c];let l=[r&&t>1?o-1:o,r&&n>1?s-1:s],u=[r&&t>1?t-1:t,r&&n>1?n-1:n],d;d=i?`(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)`:`vec2(yRC) * effectiveInputOverOutputRatioRC`,this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${l[0]/u[0]},
          ${l[1]/u[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${s}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}})),$5,nve=o((()=>{$5=class{constructor(e,t,n,r,i){this.variableNames=[`A`],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[a,o,s,c]=e;this.outputShape=[a,t,n,c];let l=[r&&t>1?o-1:o,r&&n>1?s-1:s],u=[r&&t>1?t-1:t,r&&n>1?n-1:n],d;d=i?`(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)`:`vec3(yRC) * effectiveInputOverOutputRatioRC`,this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${l[0]/u[0]},
          ${l[1]/u[1]},
          ${l[1]/u[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${s}.0,
                                     ${s}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}}));function rve(e){let{inputs:t,backend:n,attrs:r}=e,{images:i}=t,{alignCorners:a,halfPixelCenters:o,size:s}=r,[c,l]=s,u=k().getBool(`WEBGL_PACK_IMAGE_OPERATIONS`)?new $5(i.shape,c,l,a,o):new Q5(i.shape,c,l,a,o);return n.runWebGLProgram(u,[i],`float32`)}var e7,ive=o((()=>{Y(),tve(),nve(),e7={kernelName:hr,backendName:`webgl`,kernelFunc:rve}})),t7,ave=o((()=>{t7=class{constructor(e,t,n){this.variableNames=[`dy`],this.outputShape=[],this.outputShape=t;let[,r,i]=t,[,a,o]=e,s=[n&&a>1?r-1:r,n&&o>1?i-1:i],c=[n&&a>1?a-1:a,n&&o>1?o-1:o],l=s[0]/c[0],u=s[1]/c[1],d=1/l,f=1/u,p=Math.ceil(d)*2+2,m=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${l});
        const float widthScale = float(${u});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${f});

        const int winHeight = int(${p});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}}));function ove(e){let{inputs:t,backend:n,attrs:r}=e,{images:i,dy:a}=t,{alignCorners:o}=r,s=new t7(a.shape,i.shape,o);return n.runWebGLProgram(s,[a],a.dtype)}var n7,sve=o((()=>{Y(),ave(),n7={kernelName:gr,backendName:`webgl`,kernelFunc:ove}})),r7,cve=o((()=>{r7=class{constructor(e,t,n,r,i){this.variableNames=[`A`],this.outputShape=[];let[a,o,s,c]=e;this.outputShape=[a,t,n,c];let l=[r&&t>1?o-1:o,r&&n>1?s-1:s],u=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?`0.5`:`0.0`,f;f=i?`max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))`:`vec2(yRC) * effectiveInputOverOutputRatioRC`,this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${l[0]/u[0]},
          ${l[1]/u[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${s}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}})),i7,lve=o((()=>{i7=class{constructor(e,t,n,r,i){this.variableNames=[`A`],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[a,o,s,c]=e;this.outputShape=[a,t,n,c];let l=[r&&t>1?o-1:o,r&&n>1?s-1:s],u=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?`0.5`:`0.0`,f;f=i?`max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))`:`vec3(yRC) * effectiveInputOverOutputRatioRC`,this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${l[0]/u[0]},
          ${l[1]/u[1]},
          ${l[1]/u[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${s}.0,
                                     ${s}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}}));function uve(e){let{inputs:t,backend:n,attrs:r}=e,{images:i}=t,{alignCorners:a,halfPixelCenters:o,size:s}=r,[c,l]=s,u=k().getBool(`WEBGL_PACK_IMAGE_OPERATIONS`)?new i7(i.shape,c,l,a,o):new r7(i.shape,c,l,a,o);return n.runWebGLProgram(u,[i],i.dtype)}var a7,dve=o((()=>{Y(),cve(),lve(),a7={kernelName:pr,backendName:`webgl`,kernelFunc:uve}})),o7,fve=o((()=>{o7=class{constructor(e,t,n){this.variableNames=[`dy`],this.outputShape=[],this.outputShape=t;let[,r,i]=t,[,a,o]=e,s=[n&&a>1?r-1:r,n&&o>1?i-1:i],c=[n&&a>1?a-1:a,n&&o>1?o-1:o],l=s[0]/c[0],u=s[1]/c[1],d=1/l,f=1/u,p=Math.ceil(d)*2+2,m=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${l});
        const float widthScale = float(${u});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${f});

        const int winHeight = int(${p});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float sourceFracRow =
              float(${s[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${s[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${i}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}}));function pve(e){let{inputs:t,backend:n,attrs:r}=e,{images:i,dy:a}=t,{alignCorners:o}=r,s=new o7(a.shape,i.shape,o);return n.runWebGLProgram(s,[a],a.dtype)}var s7,mve=o((()=>{Y(),fve(),s7={kernelName:mr,backendName:`webgl`,kernelFunc:pve}})),c7,hve=o((()=>{cQ(),c7=class{constructor(e,t){this.variableNames=[`x`];let n=e.length;if(n>4)throw Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}let r=n=>t.indexOf(n)!==-1&&e[n]!==1?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`,i=e.map((e,t)=>r(t)).join(`,`);this.userCode=`
      void main() {
        ${$Z(n)} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}})),l7,gve=o((()=>{U$(),cQ(),l7=class{constructor(e,t){this.variableNames=[`x`],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let r=H$(`rc`,n),i=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,o=$Z(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${i}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${o} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${s(r.slice())};
          if(${i}){
            result.g = ${c(r.slice())};
          }
          if(${a}) {
            result.b = ${l(r.slice())};
            if(${i}) {
              result.a = ${u(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function s(e){return d(e)}function c(e){return e[n-1]=`(`+e[n-1]+` + 1)`,d(e)}function l(e){return e[n-2]=`(`+e[n-2]+` + 1)`,d(e)}function u(e){return e[n-1]=`(`+e[n-1]+` + 1)`,e[n-2]=`(`+e[n-2]+` + 1)`,d(e)}function d(t){let n=e.map((e,n)=>f(n,t)),r=n.join(`,`),i=n.slice(-2).join(`,`);return`getChannel(getX(${r}), vec2(${i}))`}function f(n,r){return t.indexOf(n)!==-1&&e[n]!==1?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}}}}));function _ve(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{dims:a}=r,o=i.shape.length,s=we(a,i.shape);if(o===0)return N1({inputs:{x:i},backend:n});let c=k().getBool(`WEBGL_PACK_ARRAY_OPERATIONS`)?new l7(i.shape,s):new c7(i.shape,s);return n.runWebGLProgram(c,[i],i.dtype)}var u7,vve=o((()=>{Y(),hve(),gve(),F1(),u7={kernelName:vr,backendName:`webgl`,kernelFunc:_ve}})),d7,yve=o((()=>{d7=class{constructor(e,t){this.variableNames=[`Image`],this.outputShape=[],this.customUniforms=[{name:`params`,type:`vec4`}];let n=e[1],r=e[2];this.outputShape=e;let i=``;i=typeof t==`number`?`float outputValue = ${t.toFixed(2)};`:`
        vec3 fill = vec3(${t.join(`,`)});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${i}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}})),f7,bve=o((()=>{Y(),yve(),f7={kernelName:ai,backendName:`webgl`,kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:i,fillValue:a,center:o}=t,s=n,c=new d7(r.shape,a),[l,u]=OS(o,r.shape[1],r.shape[2]),d=[[l,u,Math.sin(i),Math.cos(i)]];return s.runWebGLProgram(c,[r],r.dtype,d)}}})),p7,m7,h7,xve=o((()=>{Y(),Z1(),p7=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,m7=q1({opSnippet:p7}),h7={kernelName:yr,backendName:`webgl`,kernelFunc:m7}})),g7,_7,v7,Sve=o((()=>{Y(),Z1(),B$(),g7=`return inversesqrt(x);`,_7=q1({opSnippet:g7,cpuKernelImpl:x$}),v7={kernelName:br,backendName:`webgl`,kernelFunc:_7}})),y7,b7=o((()=>{cQ(),y7=class{constructor(e,t,n,r,i,a,o=!0,s=!1){this.variableNames=[`updates`,`indices`,`defaultValue`],this.outputShape=a;let c=$Z(i.length),l=$Z(a.length),u=``;n===1?u=`i`:n===2&&(u=`i, j`);let d=`getIndices(${u})`,f=``;r===1?f=`i`:r===2&&(f=`i, coords[1]`);let p=`getUpdates(${f})`,m=``;s&&(m=`coords[0], coords[1]`);let h=`getDefaultValue(${m})`;this.userCode=`
        ${c} strides = ${c}(${i});

        void main() {
          ${l} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${t>1?`strides[j]`:`strides`};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${p};
              found = true;
            }
          }
          setOutput(mix(${h}, sum, float(found)));
        }
      `}}})),x7,Cve=o((()=>{cQ(),x7=class{constructor(e,t,n,r,i,a,o=!0,s=!1){this.variableNames=[`updates`,`indices`,`defaultValue`],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;let c=$Z(i.length),l=$Z(a.length),u=``;n===1?u=`i`:n===2&&(u=`i, j`);let d=`getIndices(${u})`,f=``;r===1?f=`i`:r===2&&(f=`i, coords[1]`);let p=`getUpdates(${f})`,m=``;s&&(m=`coords[0], coords[1]`);let h=`getDefaultValue(${m})`;this.userCode=`
        ${c} strides = ${c}(${i});

        void main() {
          ${l} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${d});
              flattenedIndex += index.xz * ${t>1?`strides[j]`:`strides`};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${t>1?`strides[j + 1]`:`strides`};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${p};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${h}, sum, found));
        }
      `}}}));function wve(e){let{inputs:t,backend:n,attrs:r}=e,{indices:i,updates:a}=t,{shape:o}=r,{sliceRank:s,numUpdates:c,sliceSize:l,strides:u,outputSize:d}=Y_(a,i,o),f=[d/l,l];if(d===0)return n.makeTensorInfo(o,i.dtype);let p=$({inputs:{x:i},backend:n,attrs:{shape:[c,s]}}),m=$({inputs:{x:a},backend:n,attrs:{shape:[c,l]}}),h=n.makeTensorInfo([],`float32`,new Float32Array([0])),g;g=k().getBool(`WEBGL_PACK`)?new x7(c,s,p.shape.length,m.shape.length,u,f):new y7(c,s,p.shape.length,m.shape.length,u,f);let _=n.runWebGLProgram(g,[m,p,h],m.dtype),v=$({inputs:{x:_},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(_),n.disposeIntermediateTensorInfo(h),v}var S7,Tve=o((()=>{Y(),b7(),Cve(),s0(),S7={kernelName:xr,backendName:`webgl`,kernelFunc:wve}})),C7,Eve=o((()=>{Y(),C7=class{constructor(e,t,n,r){this.variableNames=[`sortedSequence`,`values`],this.customUniforms=[{name:`numInputs`,type:`int`}],this.outputShape=[e,n];let i=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`;this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${k().getNumber(`WEBGL_VERSION`)===2?`while (left < right) {`:i}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${r===`left`?`<`:`<=`} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}}));function Dve(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:i,values:a}=t,{side:o}=r,s=new C7(i.shape[0],i.shape[1],a.shape[1],o),c=[[i.shape[1]]];return n.runWebGLProgram(s,[i,a],`int32`,c)}var w7,Ove=o((()=>{Y(),Eve(),w7={kernelName:Cr,backendName:`webgl`,kernelFunc:Dve}})),T7,kve=o((()=>{cQ(),T7=class{constructor(e,t,n){this.variableNames=[`c`,`a`,`b`],this.outputShape=t;let r,i;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)i=`resRC`,r=`resRC`;else{let n=[`resRC.x`,`resRC.y`,`resRC.z`,`resRC.w`],a=[],o=[];for(let r=0;r<t.length;r++)o.push(`${n[r]}`),r<e&&a.push(`${n[r]}`);r=a.join(),i=o.join()}this.userCode=`
      void main() {
        ${$Z(n)} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${i}));
        } else {
          setOutput(getB(${i}));
        }
      }
    `}}}));function Ave(e){let{inputs:t,backend:n}=e,{condition:r,t:i,e:a}=t,o=new T7(r.shape.length,i.shape,i.shape.length);return n.runWebGLProgram(o,[r,i,a],Ea(i.dtype,a.dtype))}var E7,jve=o((()=>{Y(),kve(),E7={kernelName:wr,backendName:`webgl`,kernelFunc:Ave}})),D7,O7,k7,Mve=o((()=>{Y(),Z1(),D7=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${PS};
  float scale = ${FS};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,O7=q1({opSnippet:D7}),k7={kernelName:Tr,backendName:`webgl`,kernelFunc:O7}})),A7,j7,M7,N7,Nve=o((()=>{Y(),Z1(),B$(),A7=X1+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,j7=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,M7=q1({opSnippet:A7,packedOpSnippet:j7,cpuKernelImpl:C$}),N7={kernelName:kr,backendName:`webgl`,kernelFunc:M7}})),P7,F7,I7,Pve=o((()=>{Y(),Z1(),P7=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,F7=q1({opSnippet:P7}),I7={kernelName:Or,backendName:`webgl`,kernelFunc:F7}})),L7,R7,z7,B7,Fve=o((()=>{Y(),M1(),Z1(),L7=X1+`
  return sin(x);
`,R7=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${A1}
  return result;
`,z7=q1({opSnippet:L7,packedOpSnippet:R7}),B7={kernelName:`Sin`,backendName:`webgl`,kernelFunc:z7}})),V7,H7,U7,Ive=o((()=>{Y(),Z1(),V7=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,H7=q1({opSnippet:V7}),U7={kernelName:Dr,backendName:`webgl`,kernelFunc:H7}})),W7,G7,K7,Lve=o((()=>{Y(),Z1(),W7=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,G7=q1({opSnippet:W7}),K7={kernelName:Ar,backendName:`webgl`,kernelFunc:G7}})),q7,J7,Rve=o((()=>{Y(),k5(),s0(),x0(),q7=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{blockShape:a,paddings:o}=r;D(i.shape.length<=4,()=>`spaceToBatchND for rank > 4 with a WebGL backend not implemented yet`);let s=a.reduce((e,t)=>e*t),c=[[0,0]];c.push(...o);for(let e=1+a.length;e<i.shape.length;++e)c.push([0,0]);let l=[],u=D5({inputs:{x:i},backend:n,attrs:{paddings:c,constantValue:0}}),d=kS(u.shape,a,s,!1),f=AS(d.length,a.length,!1),p=jS(u.shape,a,s,!1),m=$({inputs:{x:u},backend:n,attrs:{shape:d}}),h=y0({inputs:{x:m},backend:n,attrs:{perm:f}}),g=$({inputs:{x:h},backend:n,attrs:{shape:p}});return l.push(u),l.push(m),l.push(h),l.forEach(e=>n.disposeIntermediateTensorInfo(e)),g},J7={kernelName:Mr,backendName:`webgl`,kernelFunc:q7}}));function zve(e){let{inputs:t,backend:n}=e,{indices:r,values:i,denseShape:a,defaultValue:o}=t;if(a.shape.length!==1)throw Error(`Dense shape must be a vector, saw:
         ${a.shape}`);if(r.shape.length!==2)throw Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(i.shape.length!==1)throw Error(`Values must be a vector, saw:
         ${i.shape}`);if(o.shape.length!==0)throw Error(`Default value must be a scalar, saw:
        ${o.shape}`);let s=n.readSync(r.dataId),c=n.readSync(i.dataId),l=n.readSync(a.dataId),u=n.readSync(o.dataId)[0],[d,f,p,m,h]=E$(s,r.shape,r.dtype,c,i.dtype,l,u);return[n.makeTensorInfo(f,r.dtype,d),n.makeTensorInfo([f[0]],i.dtype,p),n.makeTensorInfo([m.length],`bool`,new Uint8Array(m.map(e=>Number(e)))),n.makeTensorInfo([h.length],r.dtype,new Int32Array(h))]}var Y7,Bve=o((()=>{Y(),B$(),Y7={kernelName:Fr,backendName:`webgl`,kernelFunc:zve}}));function Vve(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:i,newShape:a}=t;if(r.shape.length!==2)throw Error(`Input indices should be a matrix but received shape ${r.shape}`);if(i.shape.length!==1)throw Error(`Input shape should be a vector but received shape ${i.shape}`);if(a.shape.length!==1)throw Error(`Target shape should be a vector but received shape ${a.shape}`);let o=Array.from(n.readSync(i.dataId)),s=n.readSync(r.dataId),c=Array.from(n.readSync(a.dataId)),[l,u,d]=D$(s,r.shape,r.dtype,o,c);return[n.makeTensorInfo(u,r.dtype,l),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}var X7,Hve=o((()=>{Y(),B$(),X7={kernelName:Ir,backendName:`webgl`,kernelFunc:Vve}}));function Uve(e){let{inputs:t,backend:n}=e,{data:r,indices:i,segmentIds:a}=t;if(r.shape.length<1)throw Error(`Data should be at least 1 dimensional but received scalar`);if(i.shape.length!==1)throw Error(`Indices should be a vector but received shape
              ${i.shape}`);if(a.shape.length!==1)throw Error(`Segment ids should be a vector but received shape
              ${a.shape}`);let o=n.readSync(r.dataId),s=n.readSync(i.dataId),c=n.readSync(a.dataId),[l,u]=O$(o,r.shape,r.dtype,s,c,!0);return n.makeTensorInfo(u,r.dtype,l)}var Z7,Wve=o((()=>{Y(),B$(),Z7={kernelName:Lr,backendName:`webgl`,kernelFunc:Uve}}));function Gve(e){let{inputs:t,backend:n}=e,{data:r,indices:i,segmentIds:a}=t;if(r.shape.length<1)throw Error(`Data should be at least 1 dimensional but received scalar`);if(i.shape.length!==1)throw Error(`Indices should be a vector but received shape
             ${i.shape}`);if(a.shape.length!==1)throw Error(`Segment ids should be a vector but received shape
             ${a.shape}`);let o=n.readSync(r.dataId),s=n.readSync(i.dataId),c=n.readSync(a.dataId),[l,u]=O$(o,r.shape,r.dtype,s,c);return n.makeTensorInfo(u,r.dtype,l)}var Q7,Kve=o((()=>{Y(),B$(),Q7={kernelName:Rr,backendName:`webgl`,kernelFunc:Gve}}));function qve(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:i,sparseValues:a,defaultValue:o}=t,{outputShape:s}=r,{sliceRank:c,numUpdates:l,sliceSize:u,strides:d,outputSize:f}=Y_(a,i,s);if(a.dtype===`string`){let e=n.bufferSync(i),t=n.bufferSync(a),r=$i(n.readSync(o.dataId)[0]),p=S$(e,t,s,f,u,l,c,d,r,!1);return n.makeTensorInfo(s,p.dtype,p.values)}let p=new y7(l,c,i.shape.length,a.shape.length,d,[f,1],!1),m=n.runWebGLProgram(p,[a,i,o],a.dtype),h=$({inputs:{x:m},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(m),h}var $7,Jve=o((()=>{Y(),B$(),b7(),s0(),$7={kernelName:zr,backendName:`webgl`,kernelFunc:qve}}));function Yve(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{numOrSizeSplits:a,axis:o}=r,s=we(o,i.shape)[0],c=oC(i,a,s),l=i.shape.length,u=Array(l).fill(0),d=i.shape.slice();return c.map(e=>{let t=[...d];t[s]=e;let r=A2({inputs:{x:i},backend:n,attrs:{begin:u,size:t}});return u[s]+=e,r})}var e9,Xve=o((()=>{Y(),M2(),e9={kernelName:Nr,backendName:`webgl`,kernelFunc:Yve}})),t9,n9,r9,Zve=o((()=>{Y(),Z1(),B$(),t9=`return sqrt(x);`,n9=q1({opSnippet:t9,packedOpSnippet:t9,cpuKernelImpl:k$}),r9={kernelName:jr,backendName:`webgl`,kernelFunc:n9}})),i9,a9,o9,Qve=o((()=>{Y(),Z1(),i9=`return x * x;`,a9=q1({opSnippet:i9}),o9={kernelName:Vr,backendName:`webgl`,kernelFunc:a9}})),s9,c9,l9,$ve=o((()=>{Y(),Z1(),s9=`return (a - b) * (a - b);`,c9=J1({opSnippet:s9,packedOpSnippet:s9}),l9={kernelName:Br,backendName:`webgl`,kernelFunc:c9}}));function eye(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t;if(i.dtype!==`string`)throw Error(`Input must be of datatype string`);let a=n.readSync(i.dataId),o=CC(a),s=A$(o,`string`,r);return n.makeTensorInfo(i.shape,`string`,s)}var u9,tye=o((()=>{Y(),B$(),u9={kernelName:Hr,backendName:`webgl`,kernelFunc:eye}}));function nye({inputs:e,attrs:t,backend:n}){let{x:r}=e,i=Q$+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,a=new Z$(r.shape,i);return n.runWebGLProgram(a,[r],r.dtype)}var d9,rye=o((()=>{Y(),o1(),d9={kernelName:ri,backendName:`webgl`,kernelFunc:nye}})),f9,iye=o((()=>{cQ(),f9=class{constructor(e,t,n){this.variableNames=[`x`],this.outputShape=n;let r=n.length,i=$Z(n.length),a=$Z(n.length),o=``;if(r===1)o=`coords * strides + begin`;else{let e=0;o=n.map((t,r)=>(e++,n.length===1?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`)).join(`,`)}this.userCode=`
      ${i} begin = ${i}(${e});
      ${i} strides = ${i}(${t});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}}));function aye(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{begin:a,end:o,strides:s,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:f}=r,{finalShapeSparse:p,finalShape:m,isIdentity:h,sliceDim0:g,isSimpleSlice:_,begin:v,end:y,strides:b}=cS(i.shape,a,o,s,c,l,u,d,f),x;if(h)x=$({inputs:{x:i},backend:n,attrs:{shape:m}});else if(g||_){D(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);let e=Xx(v,y,b),t=A2({inputs:{x:i},backend:n,attrs:{begin:v,size:e}});x=$({inputs:{x:t},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(t)}else if(n.shouldExecuteOnCPU([i])){let e=n.readSync(i.dataId),t=mc(i.shape,i.dtype,e),r=j$(p,t,b,v);x=n.makeTensorInfo(m,i.dtype,r.values)}else{let e=new f9(v,b,p);x=n.runWebGLProgram(e,[i],i.dtype)}let S=$({inputs:{x},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(x),S}var p9,oye=o((()=>{Y(),B$(),iye(),s0(),M2(),p9={kernelName:Ur,backendName:`webgl`,kernelFunc:aye}}));function sye(e){let{inputs:t,backend:n,attrs:r}=e,{separator:i,nGramWidths:a,leftPad:o,rightPad:s,padWidth:c,preserveShortSequences:l}=r,{data:u,dataSplits:d}=t,f=n.readSync(u.dataId),p=n.readSync(d.dataId),[m,h]=M$(f,p,i,a,o,s,c,l);return[n.makeTensorInfo([m.length],`string`,m),n.makeTensorInfo(d.shape,`int32`,h)]}var m9,cye=o((()=>{Y(),B$(),m9={kernelName:Wr,backendName:`webgl`,kernelFunc:sye}}));function lye(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:i}=r,{input:a,delimiter:o}=t;if(a.dtype!==`string`)throw Error(`Input must be of datatype string`);if(a.shape.length!==1)throw Error(`Input must be a vector, got shape: ${a.shape}`);if(o.shape.length!==0)throw Error(`Delimiter must be a scalar, got shape: ${o.shape}`);let s=n.readSync(a.dataId),c=n.readSync(o.dataId)[0],[l,u,d]=N$(s,c,i),f=u.length;return[n.makeTensorInfo([f,2],`int32`,l),n.makeTensorInfo([f],`string`,u),n.makeTensorInfo([2],`int32`,new Int32Array(d))]}var h9,uye=o((()=>{Y(),B$(),h9={kernelName:Gr,backendName:`webgl`,kernelFunc:lye}}));function dye(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:i}=r,{input:a}=t;if(a.dtype!==`string`)throw Error(`Input must be of datatype string`);if(i<=0)throw Error(`Number of buckets must be at least 1`);let o=n.readSync(a.dataId),s=P$(o,i);return n.makeTensorInfo(a.shape,`int32`,s)}var g9,fye=o((()=>{Y(),B$(),g9={kernelName:Kr,backendName:`webgl`,kernelFunc:dye}})),_9,v9,y9,pye=o((()=>{Y(),Z1(),_9=`return tan(x);`,v9=q1({opSnippet:_9}),y9={kernelName:`Tan`,backendName:`webgl`,kernelFunc:v9}})),b9,x9,S9,mye=o((()=>{Y(),Z1(),b9=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,x9=q1({opSnippet:b9}),S9={kernelName:qr,backendName:`webgl`,kernelFunc:x9}}));function hye(e){let{inputs:t,backend:n,attrs:r}=e,{tensor:i,indices:a,updates:o}=t,{}=r,{sliceRank:s,numUpdates:c,sliceSize:l,strides:u,outputSize:d}=Y_(o,a,i.shape),f=[d/l,l];if(d===0)return n.makeTensorInfo(i.shape,a.dtype);let p=$({inputs:{x:a},backend:n,attrs:{shape:[c,s]}}),m=$({inputs:{x:o},backend:n,attrs:{shape:[c,l]}}),h=$({inputs:{x:i},backend:n,attrs:{shape:f}}),g=new y7(c,s,p.shape.length,m.shape.length,u,f,!1,!0),_=n.runWebGLProgram(g,[m,p,h],h.dtype),v=$({inputs:{x:_},backend:n,attrs:{shape:i.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(_),v}var C9,gye=o((()=>{Y(),b7(),s0(),C9={kernelName:Sr,backendName:`webgl`,kernelFunc:hye}}));function _ye(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${e[0]})`;let n=[`resRC.x`,`resRC.y`,`resRC.z`,`resRC.w`,`resRC.u`],r=[];for(let t=0;t<e.length;t++)r.push(`imod(${n[t]}, ${e[t]})`);return r.join()}var w9,vye=o((()=>{cQ(),w9=class{constructor(e,t){this.variableNames=[`A`];let n=Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.rank=n.length;let r=$Z(this.rank),i=_ye(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${i}));
      }
    `}}}));function T9(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{reps:a}=r;if(i.dtype===`string`||i.shape.length>5){let e=n.readSync(i.dataId),t=i.dtype===`string`?e.map(e=>$i(e)):e,r=mc(i.shape,i.dtype,t),o=I$(r,a);return n.makeTensorInfo(o.shape,o.dtype,o.values)}let o=new w9(i.shape,a);return n.runWebGLProgram(o,[i],i.dtype)}var E9,D9=o((()=>{Y(),B$(),vye(),E9={kernelName:Jr,backendName:`webgl`,kernelFunc:T9}})),O9,k9,yye=o((()=>{O9=class{constructor(e){this.variableNames=[`x`,`indices`],this.customUniforms=[{name:`n`,type:`int`},{name:`firstPass`,type:`int`},{name:`negativeInf`,type:`float`},{name:`dir`,type:`int`},{name:`inc`,type:`int`}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},k9=class{constructor(e){this.variableNames=[`x`,`indices`],this.customUniforms=[{name:`n`,type:`int`},{name:`firstPass`,type:`int`},{name:`k`,type:`int`}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}}));function A9(e,t){t!==null&&e.disposeIntermediateTensorInfo(t)}function j9(e){let t=1;for(;t<e;)t*=2;return t}function bye(e){let{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{k:a,sorted:o}=r,s=k().getNumber(`TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD`),c=k().getNumber(`TOPK_K_CPU_HANDOFF_THRESHOLD`),l=i.shape,u=l[l.length-1];if(n.shouldExecuteOnCPU([i])||u<s||a>c){let e=n.readSync(i.dataId),[t,r]=L$(e,l,i.dtype,a,o);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(a===0)return l[l.length-1]=0,[n.makeTensorInfo(l,i.dtype,[]),n.makeTensorInfo(l,`int32`,[])];if(u===1)return[i,Y3({attrs:{shape:l,dtype:`int32`,value:0},backend:n})];let d=n.texData.get(i.dataId),f=d!==null&&d.isPacked,p=f?n.unpackTensor(i):i,m=O(l)/u,h=$({inputs:{x:p},attrs:{shape:[m,u]},backend:n});f&&A9(n,p);let g=j9(a),_=j9(u),v=null,y=()=>v===null?[h,h]:[h,v],b=(e,t,r)=>{let i=y(),a=new O9(r),o=[[u],[v===null?1:0],[-1/0],[e],[t]],s=v;v=n.runWebGLProgram(a,i,`int32`,o),A9(n,s)};for(let e=1;e<g;e*=2){let t=e*2;for(let n=e;n>=1;n/=2)b(t,n,[m,_])}for(let e=_;e>g;e/=2){let t=y(),r=new k9([m,e/2]),i=[[u],[v===null?1:0],[g]],a=v;v=n.runWebGLProgram(r,t,`int32`,i),A9(n,a);let o=g/2,s=o*2;for(let e=o;e>=1;e/=2)b(s,e,v.shape)}let x=v;v=A2({inputs:{x:v},backend:n,attrs:{begin:0,size:[m,a]}}),A9(n,x);let S=_6({inputs:{x:h,indices:v},backend:n,attrs:{axis:1,batchDims:1}});A9(n,h);let C=l.slice(0,-1);C.push(a),x=v,v=$({inputs:{x:v},attrs:{shape:C},backend:n}),A9(n,x);let w=S;return S=$({inputs:{x:S},attrs:{shape:C},backend:n}),A9(n,w),[S,v]}var M9,xye=o((()=>{Y(),B$(),yye(),Z3(),y6(),s0(),M2(),M9={kernelName:Yr,backendName:`webgl`,kernelFunc:bye}})),N9,Sye=o((()=>{N9=class{constructor(e,t,n,r,i,a){this.variableNames=[`Image`,`Transforms`],this.outputShape=a;let o=n===`nearest`?1:2,s;switch(r){case`constant`:s=1;break;case`reflect`:s=2;break;case`wrap`:s=3;break;case`nearest`:s=4;break;default:s=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${s} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${s} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${s} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${i});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${i});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${o} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}}));function Cye(e){let{inputs:t,backend:n,attrs:r}=e,{image:i,transforms:a}=t,{interpolation:o,fillMode:s,fillValue:c,outputShape:l}=r,[u,d,f,p]=i.shape,[m,h]=l??[d,f],g=new N9(d,f,o,s,c,[u,m,h,p]);return n.runWebGLProgram(g,[i,a],`float32`)}var P9,wye=o((()=>{Y(),Sye(),P9={kernelName:Xr,backendName:`webgl`,kernelFunc:Cye}}));function Tye(e){let{inputs:t,attrs:n,backend:r}=e,{axis:i}=n,{x:a}=t;MZ(a,`unique`),console.warn(`WARNING: `,`UI might be locked temporarily as data is being downloaded`);let o=r.readSync(a.dataId),{outputValues:s,outputShape:c,indices:l}=z$(o,i,a.shape,a.dtype);return[r.makeTensorInfo(c,a.dtype,s),r.makeTensorInfo([l.length],`int32`,l)]}var F9,Eye=o((()=>{Y(),B$(),RZ(),F9={kernelName:Qr,backendName:`webgl`,kernelFunc:Tye}}));function Dye(e){let{inputs:t,backend:n,attrs:r}=e,{value:i}=t,{axis:a}=r;a<0&&(a+=i.shape.length);let o=i,s=o.shape.length,c=i.shape[a],l=Array(s-1),u=0;for(let e=0;e<s;e++)e!==a&&(l[u++]=o.shape[e]);let d=[],f=Array(s).fill(0),p=o.shape.slice();p[a]=1;let m=Array(c);for(let e=0;e<m.length;e++){f[a]=e;let t=A2({inputs:{x:o},backend:n,attrs:{begin:f,size:p}});m[e]=$({inputs:{x:t},backend:n,attrs:{shape:l}}),d.push(t)}return d.forEach(e=>n.disposeIntermediateTensorInfo(e)),m}var I9,Oye=o((()=>{Y(),s0(),M2(),I9={kernelName:$r,backendName:`webgl`,kernelFunc:Dye}})),L9,kye=o((()=>{L9=class{constructor(e,t){this.variableNames=[`x`,`segmentIds`];let n=e.windowSize,r=e.batchSize,i=e.inSize,a=e.numSegments,o=a*Math.ceil(i/n);this.outputShape=[r,o];let s=Math.floor(n/4)*4,c=n%4,l=`
        sumValue += dot(values, segFilter);
    `,u=``;i%n>0&&(u=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `);let d=``;i%n>0&&(d=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = 0.0;

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${d}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${s}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${l}
        }

        int inIdx = inOffset + ${s};
        if (${c===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${l}
        } else if (${c===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${l}
        } else if (${c===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${l}
        }
        setOutput(sumValue);
      }
    `}}}));function Aye(e){let{inputs:t,backend:n,attrs:r}=e,{x:i,segmentIds:a}=t,{numSegments:o}=r,s=i.shape.length,c=[],l=0,u=Rf([l],s),d=i;u!=null&&(d=y0({inputs:{x:i},backend:n,attrs:{perm:u}}),c.push(d),l=Bf(1,s)[0]);let f=bC(d.shape,l,o),p=O([d.shape[l]]),m=$({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}});c.push(m);let h=Da(i.dtype),g=(e,t,r,i,a)=>{let o=e.shape[0],s=e.shape[1],l=yC(s,a),u=new L9({windowSize:l,inSize:s,batchSize:o,numSegments:a},t),d=n.compileAndRun(u,[e,r],i);if(c.push(d),d.shape[1]===a)return d;let f=R5({backend:n,attrs:{start:0,stop:a,step:1,dtype:`float32`}}),p=T9({inputs:{x:f},backend:n,attrs:{reps:[s/l]}});return c.push(f),c.push(p),g(d,t,p,i,a)},_=g(m,`unsortedSegmentSum`,a,h,o),v=$({inputs:{x:_},backend:n,attrs:{shape:f}}),y=v;if(u!=null){c.push(v);let e=zf(u);y=y0({inputs:{x:y},backend:n,attrs:{perm:e}})}return c.forEach(e=>n.disposeIntermediateTensorInfo(e)),y}var R9,jye=o((()=>{Y(),kye(),B5(),s0(),D9(),x0(),R9={kernelName:ei,backendName:`webgl`,kernelFunc:Aye}})),z9,Mye=o((()=>{Y(),fme(),mme(),hme(),gme(),_me(),bme(),Sme(),wme(),Ome(),Ame(),jme(),Mme(),Nme(),Pme(),Fme(),Lme(),zme(),Vme(),Ume(),Gme(),Jme(),$me(),the(),rhe(),ahe(),che(),lhe(),phe(),R1(),ghe(),m4(),Che(),The(),Ohe(),Ahe(),Mhe(),Phe(),Fhe(),Ihe(),Rhe(),Bhe(),Hhe(),Whe(),qhe(),Yhe(),Zhe(),$he(),nge(),age(),sge(),cge(),lge(),uge(),dge(),L3(),B3(),fge(),hge(),Z3(),vge(),yge(),bge(),wge(),Ege(),Oge(),jge(),y6(),Pge(),Fge(),F1(),Lge(),u4(),Rge(),zge(),Bge(),H1(),Vge(),Hge(),Wge(),Gge(),Kge(),qge(),Jge(),Yge(),Qge(),e_e(),b8(),r_e(),a_e(),s_e(),l_e(),d_e(),m_e(),__e(),y_e(),b_e(),C_e(),w_e(),D_e(),a0(),k_e(),j_e(),N_e(),F_e(),U2(),L_e(),R_e(),B_e(),k5(),U_e(),K1(),G_e(),q_e(),Y_e(),Z_e(),B5(),K2(),Q8(),Q_e(),$_e(),eve(),s0(),ive(),sve(),dve(),mve(),vve(),bve(),xve(),Sve(),Tve(),Ove(),jve(),Mve(),Nve(),Pve(),Fve(),Ive(),M2(),a5(),Lve(),Rve(),Bve(),Hve(),Wve(),Kve(),Jve(),Xve(),Zve(),Qve(),$ve(),tye(),rye(),oye(),cye(),uye(),fye(),n5(),v0(),pye(),mye(),gye(),D9(),xye(),wye(),x0(),Eye(),Oye(),jye(),x5(),z9=[w0,E0,k0,M0,F0,z0,B0,V0,J0,Y0,Q0,t2,i2,c2,d2,h2,g2,b2,x2,S2,E2,P2,F2,R2,z2,Y2,Q2,t4,L1,i4,p4,T4,j4,N4,P4,F4,I4,B4,U4,K4,e3,t3,n3,i3,l3,p3,m3,g3,v3,y3,x3,T3,k3,M3,I3,z3,U3,q3,X3,$3,n6,o6,l6,f6,p6,h6,v6,C6,D6,P1,O6,l4,j6,P6,L6,V1,V6,G6,K6,X6,$6,r8,o8,u8,m8,_8,y8,w8,T8,E8,A8,j8,M8,N8,P8,R8,H8,K8,o5,i0,l5,d5,p5,h5,H2,v5,C5,w5,O5,N5,G1,P5,F5,I5,L5,z5,G2,Z8,U5,q5,Z5,o0,e7,n7,a7,s7,u7,f7,h7,v7,S7,w7,E7,k7,N7,I7,B7,U7,j2,i5,K7,J7,Y7,X7,Z7,Q7,$7,e9,r9,o9,l9,u9,d9,p9,m9,h9,g9,t5,_0,y9,S9,C9,E9,M9,P9,b0,F9,I9,R9,b5];for(let e of z9)hi(e)})),B9=o((()=>{Zpe(),Mye()})),V9,Nye=o((()=>{V9=`4.22.0`})),H9=c({Abs:()=>`Abs`,Acos:()=>ut,Acosh:()=>dt,AdadeltaOptimizer:()=>Mb,AdagradOptimizer:()=>Pb,AdamOptimizer:()=>Ib,AdamaxOptimizer:()=>Rb,Add:()=>`Add`,AddN:()=>ft,All:()=>`All`,Any:()=>`Any`,ArgMax:()=>pt,ArgMin:()=>mt,Asin:()=>ht,Asinh:()=>gt,Atan:()=>_t,Atan2:()=>yt,Atanh:()=>vt,AvgPool:()=>bt,AvgPool3D:()=>St,AvgPool3DGrad:()=>Ct,AvgPoolGrad:()=>xt,BatchMatMul:()=>wt,BatchToSpaceND:()=>Tt,Bincount:()=>Et,BitwiseAnd:()=>Dt,BroadcastArgs:()=>kt,BroadcastTo:()=>Ot,Callback:()=>oF,CallbackList:()=>Ak,Cast:()=>At,Ceil:()=>jt,ClipByValue:()=>Mt,Complex:()=>Nt,ComplexAbs:()=>Pt,Concat:()=>Ft,Conv2D:()=>It,Conv2DBackpropFilter:()=>Lt,Conv2DBackpropInput:()=>Rt,Conv3D:()=>zt,Conv3DBackpropFilterV2:()=>Bt,Conv3DBackpropInputV2:()=>Vt,Cos:()=>`Cos`,Cosh:()=>Ht,CropAndResize:()=>Gt,Cumprod:()=>Ut,Cumsum:()=>Wt,CustomCallback:()=>Nk,DataStorage:()=>te,DenseBincount:()=>Kt,DepthToSpace:()=>qt,DepthwiseConv2dNative:()=>Jt,DepthwiseConv2dNativeBackpropFilter:()=>Yt,DepthwiseConv2dNativeBackpropInput:()=>Xt,Diag:()=>Zt,Dilation2D:()=>Qt,Dilation2DBackpropFilter:()=>en,Dilation2DBackpropInput:()=>$t,Draw:()=>tn,ENV:()=>rt,EarlyStopping:()=>sF,Einsum:()=>rn,Elu:()=>`Elu`,EluGrad:()=>an,Environment:()=>nt,Equal:()=>on,Erf:()=>`Erf`,Exp:()=>`Exp`,ExpandDims:()=>sn,Expm1:()=>cn,FFT:()=>`FFT`,Fill:()=>ln,FlipLeftRight:()=>un,Floor:()=>dn,FloorDiv:()=>fn,FromPixels:()=>ii,FusedBatchNorm:()=>pn,FusedConv2D:()=>si,FusedDepthwiseConv2D:()=>ci,GPGPUContext:()=>UQ,GatherNd:()=>hn,GatherV2:()=>mn,GraphModel:()=>JI,Greater:()=>gn,GreaterEqual:()=>_n,History:()=>Mk,IFFT:()=>yn,Identity:()=>vn,Imag:()=>bn,InputSpec:()=>XO,IsFinite:()=>xn,IsInf:()=>Sn,IsNan:()=>Cn,KernelBackend:()=>ne,LRN:()=>`LRN`,LRNGrad:()=>Fn,LayerVariable:()=>qO,LayersModel:()=>UA,LeakyRelu:()=>wn,Less:()=>Tn,LessEqual:()=>En,LinSpace:()=>Dn,Log:()=>`Log`,Log1p:()=>On,LogSoftmax:()=>Nn,LogicalAnd:()=>kn,LogicalNot:()=>An,LogicalOr:()=>jn,LogicalXor:()=>Mn,LowerBound:()=>Pn,MathBackendCPU:()=>fR,MathBackendWebGL:()=>x1,MatrixBandPart:()=>In,Max:()=>`Max`,MaxPool:()=>Rn,MaxPool3D:()=>Bn,MaxPool3DGrad:()=>Vn,MaxPoolGrad:()=>zn,MaxPoolWithArgmax:()=>Hn,Maximum:()=>Ln,Mean:()=>Un,Min:()=>`Min`,Minimum:()=>Wn,MirrorPad:()=>Gn,Mod:()=>`Mod`,MomentumOptimizer:()=>Hb,Multinomial:()=>Kn,Multiply:()=>qn,Neg:()=>`Neg`,NonMaxSuppressionV3:()=>Yn,NonMaxSuppressionV4:()=>Xn,NonMaxSuppressionV5:()=>Zn,NotEqual:()=>Jn,OP_SCOPE_SUFFIX:()=>uo,OneHot:()=>$n,OnesLike:()=>Qn,Optimizer:()=>Ab,OptimizerConstructors:()=>mS,Pack:()=>er,PadV2:()=>tr,Pool:()=>nr,Pow:()=>`Pow`,Prelu:()=>rr,Prod:()=>ir,RMSPropOptimizer:()=>Wb,RNN:()=>mM,RaggedGather:()=>ar,RaggedRange:()=>or,RaggedTensorToTensor:()=>sr,Range:()=>cr,Rank:()=>Aa,Real:()=>lr,RealDiv:()=>nn,Reciprocal:()=>ur,Reduction:()=>Oy,Relu:()=>dr,Relu6:()=>_r,Reshape:()=>fr,ResizeBilinear:()=>hr,ResizeBilinearGrad:()=>gr,ResizeNearestNeighbor:()=>pr,ResizeNearestNeighborGrad:()=>mr,Reverse:()=>vr,RotateWithOffset:()=>ai,Round:()=>yr,Rsqrt:()=>br,SGDOptimizer:()=>Bb,ScatterNd:()=>xr,SearchSorted:()=>Cr,Select:()=>wr,Selu:()=>Tr,Sequential:()=>XA,Sigmoid:()=>kr,Sign:()=>Or,Sin:()=>`Sin`,Sinh:()=>Dr,Slice:()=>Er,Softmax:()=>Pr,Softplus:()=>Ar,SpaceToBatchND:()=>Mr,SparseFillEmptyRows:()=>Fr,SparseReshape:()=>Ir,SparseSegmentMean:()=>Lr,SparseSegmentSum:()=>Rr,SparseToDense:()=>zr,SplitV:()=>Nr,Sqrt:()=>jr,Square:()=>Vr,SquaredDifference:()=>Br,StaticRegexReplace:()=>Hr,Step:()=>ri,StridedSlice:()=>Ur,StringNGrams:()=>Wr,StringSplit:()=>Gr,StringToHashBucketFast:()=>Kr,Sub:()=>`Sub`,Sum:()=>`Sum`,SymbolicTensor:()=>ZO,Tan:()=>`Tan`,Tanh:()=>qr,Tensor:()=>wa,TensorBuffer:()=>xa,TensorScatterUpdate:()=>Sr,Tile:()=>Jr,TopK:()=>Yr,Transform:()=>Xr,Transpose:()=>Zr,Unique:()=>Qr,Unpack:()=>$r,UnsortedSegmentSum:()=>ei,UpperBound:()=>ti,Variable:()=>Ta,ZerosLike:()=>ni,_FusedMatMul:()=>oi,abs:()=>Fc,acos:()=>Rc,acosh:()=>Vc,add:()=>H,addN:()=>Wc,all:()=>qc,any:()=>Xc,argMax:()=>$c,argMin:()=>nl,asin:()=>al,asinh:()=>cl,atan:()=>dl,atan2:()=>ml,atanh:()=>_l,avgPool:()=>Vl,avgPool3d:()=>Wl,backend:()=>Ho,backend_util:()=>SC,basicLSTMCell:()=>cu,batchNorm:()=>gu,batchNorm2d:()=>yu,batchNorm3d:()=>Su,batchNorm4d:()=>Tu,batchToSpaceND:()=>du,bincount:()=>Ou,bitwiseAnd:()=>ju,booleanMaskAsync:()=>yv,broadcastArgs:()=>Pu,broadcastTo:()=>Lu,broadcast_util:()=>$d,browser:()=>Ix,buffer:()=>mc,callbacks:()=>cF,cast:()=>V,ceil:()=>Bu,clipByValue:()=>Gu,clone:()=>yc,complex:()=>po,concat:()=>ql,concat1d:()=>Ju,concat2d:()=>Zu,concat3d:()=>ed,concat4d:()=>rd,constraints:()=>sce,conv1d:()=>ld,conv2d:()=>od,conv2dTranspose:()=>hd,conv3d:()=>vd,conv3dTranspose:()=>wd,copyRegisteredKernels:()=>yi,cos:()=>Dd,cosh:()=>Ad,cosineWindow:()=>Ov,cumprod:()=>Nd,cumsum:()=>Id,customGrad:()=>gm,data:()=>Cfe,denseBincount:()=>zd,deprecationWarn:()=>Do,depthToSpace:()=>Hd,depthwiseConv2d:()=>Gd,deregisterOp:()=>pue,device_util:()=>Za,diag:()=>Jd,dilation2d:()=>Zd,disableDeprecationWarnings:()=>Eo,dispose:()=>Mo,disposeVariables:()=>Oo,div:()=>Ac,divNoNan:()=>gf,dot:()=>yf,dropout:()=>Ev,einsum:()=>Sf,elu:()=>Tf,enableDebugMode:()=>To,enableProdMode:()=>wo,enclosingPowerOfTwo:()=>Dv,engine:()=>ko,ensureShape:()=>Of,env:()=>k,equal:()=>sf,erf:()=>jf,euclideanNorm:()=>fp,exp:()=>hp,expandDims:()=>vp,expm1:()=>xp,eye:()=>Dp,fft:()=>u_,fill:()=>Hu,findBackend:()=>zo,findBackendFactory:()=>Bo,floor:()=>Ap,floorDiv:()=>Dc,forceHalfFloat:()=>w1,fused:()=>Kv,gather:()=>Np,gatherND:()=>Tv,gather_util:()=>Vre,getBackend:()=>Lo,getGradient:()=>pi,getKernel:()=>fi,getKernelsForBackend:()=>mi,gpgpu_util:()=>Lpe,grad:()=>iee,grads:()=>aee,greater:()=>Ip,greaterEqual:()=>zp,ifft:()=>f_,imag:()=>Hp,image:()=>_b,inTopKAsync:()=>Av,initializers:()=>pce,input:()=>ej,io:()=>kx,irfft:()=>m_,isFinite:()=>Gp,isInf:()=>Jp,isNaN:()=>Zp,keep:()=>No,kernel_impls:()=>EC,layers:()=>rP,leakyRelu:()=>em,less:()=>rm,lessEqual:()=>om,linalg:()=>vb,linspace:()=>cm,loadGraphModel:()=>Rde,loadGraphModelSync:()=>zde,loadLayersModel:()=>qA,localResponseNormalization:()=>lm,log:()=>dm,log1p:()=>pm,logSigmoid:()=>Em,logSoftmax:()=>jm,logSumExp:()=>Pm,logicalAnd:()=>Lm,logicalNot:()=>Bm,logicalOr:()=>Um,logicalXor:()=>Gm,losses:()=>yb,lowerBound:()=>Xm,matMul:()=>Xl,math:()=>Px,max:()=>Uf,maxPool:()=>Zm,maxPool3d:()=>$m,maxPoolWithArgmax:()=>eh,maximum:()=>th,mean:()=>rh,memory:()=>Ao,meshgrid:()=>lh,metrics:()=>Ile,min:()=>Kf,minimum:()=>uh,mirrorPad:()=>fh,mod:()=>mh,model:()=>QA,models:()=>eue,moments:()=>gh,movingAverage:()=>Sv,mul:()=>U,multiRNNCell:()=>_h,multinomial:()=>vh,neg:()=>bm,nextFrame:()=>_S,norm:()=>lp,notEqual:()=>yh,oneHot:()=>xh,ones:()=>sh,onesLike:()=>wh,op:()=>R,outerProduct:()=>Dh,pad:()=>Ah,pad1d:()=>Nh,pad2d:()=>Ih,pad3d:()=>zh,pad4d:()=>Bh,pool:()=>Uh,pow:()=>Yf,prelu:()=>Gh,print:()=>xc,prod:()=>qh,profile:()=>jo,raggedGather:()=>Yh,raggedRange:()=>Xh,raggedTensorToTensor:()=>Zh,rand:()=>Qh,randomGamma:()=>ug,randomNormal:()=>dg,randomStandardNormal:()=>pg,randomUniform:()=>mg,randomUniformInt:()=>gg,range:()=>_g,ready:()=>Io,real:()=>bg,reciprocal:()=>Sg,registerBackend:()=>Vo,registerCallbackConstructor:()=>tj,registerGradient:()=>gi,registerKernel:()=>hi,registerOp:()=>fue,regularizers:()=>nue,relu:()=>Tg,relu6:()=>Dg,removeBackend:()=>Ro,reshape:()=>W,reverse:()=>Ag,reverse1d:()=>Ng,reverse2d:()=>Pg,reverse3d:()=>Fg,reverse4d:()=>Ig,rfft:()=>__,round:()=>Lg,rsqrt:()=>zg,scalar:()=>Zf,scatterND:()=>Cv,scatter_util:()=>K_,searchSorted:()=>Jm,selu:()=>Hg,separableConv2d:()=>Gg,sequential:()=>$A,serialization:()=>Cb,setBackend:()=>Fo,setPlatform:()=>Uo,setWebGLContext:()=>wX,setdiff1dAsync:()=>Jg,shared:()=>HV,sigmoid:()=>$l,sign:()=>Zg,signal:()=>gb,sin:()=>e_,sinh:()=>n_,slice:()=>nu,slice1d:()=>i_,slice2d:()=>a_,slice3d:()=>o_,slice4d:()=>s_,slice_util:()=>Jx,softmax:()=>c_,softplus:()=>Cm,spaceToBatchND:()=>Vh,sparse:()=>bb,sparseToDense:()=>wv,spectral:()=>hb,split:()=>h_,sqrt:()=>ep,square:()=>rp,squaredDifference:()=>y_,squeeze:()=>x_,stack:()=>C_,step:()=>E_,stridedSlice:()=>k_,string:()=>xb,sub:()=>q,sum:()=>K,sumOutType:()=>Da,tan:()=>M_,tanh:()=>au,tensor:()=>_o,tensor1d:()=>P_,tensor2d:()=>I_,tensor3d:()=>R_,tensor4d:()=>B_,tensor5d:()=>H_,tensor6d:()=>W_,tensorScatterUpdate:()=>Q_,tensor_util:()=>La,test_util:()=>tte,tidy:()=>B,tile:()=>wp,time:()=>Po,topk:()=>tv,train:()=>gS,transpose:()=>bv,truncatedNormal:()=>iv,unique:()=>sv,unregisterGradient:()=>vi,unregisterKernel:()=>_i,unsortedSegmentSum:()=>lv,unstack:()=>dv,upcastType:()=>Ea,upperBound:()=>pv,util:()=>Ki,valueAndGrad:()=>oee,valueAndGrads:()=>see,variable:()=>mv,variableGrads:()=>hm,version:()=>U9,version_converter:()=>YI,version_core:()=>pS,version_cpu:()=>WV,version_layers:()=>xA,version_webgl:()=>C1,webgl:()=>E1,webgl_util:()=>VX,where:()=>uf,whereAsync:()=>_v,zeros:()=>ah,zerosLike:()=>pf}),U9,W9=o((()=>{Y(),WT(),Mse(),Y(),lF(),XI(),wfe(),CX(),B9(),CX(),B9(),lF(),XI(),Nye(),U9={"tfjs-core":pS,"tfjs-backend-cpu":WV,"tfjs-backend-webgl":C1,"tfjs-data":cR,"tfjs-layers":xA,"tfjs-converter":YI,tfjs:V9}})),G9=s((e=>{
/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/
Object.defineProperty(e,`__esModule`,{value:!0});var t=(W9(),d(H9));function n(e,n){return t.tidy(function(){var i=t.browser.fromPixels(e);return r(i,n).expandDims(0).toFloat().div(t.scalar(127)).sub(t.scalar(1))})}e.capture=n;function r(e,n,r){var i=Math.min(e.shape[0],e.shape[1]),a=e.shape[0]/2-i/2,o=e.shape[1]/2-i/2;if(n&&!r){var s=e.slice([a,o,0],[i,i,3]);return s=s.reshape([i*i,1,3]),s=t.mul(s,[.2989,.587,.114]),s=s.reshape([i,i,3]),s=t.sum(s,-1),s=t.expandDims(s,-1),s}return e.slice([a,o,0],[i,i,3])}e.cropTensor=r})),K9=s((e=>{
/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/
Object.defineProperty(e,`__esModule`,{value:!0});var t=function(){return document.createElement(`canvas`)};function n(e,n,r){return r===void 0&&(r=t()),r.width=e.width*n,r.height=e.height*n,r.getContext(`2d`).drawImage(e,0,0,r.width,r.height),r}e.resize=n;function r(e,r,i){i===void 0&&(i=t());var a=Math.max(e.width,e.height);return n(e,r/a,i)}e.resizeMaxTo=r;function i(e,r,i){i===void 0&&(i=t());var a=Math.min(e.width,e.height);return n(e,r/a,i)}e.resizeMinTo=i;function a(e,n,r,i){r===void 0&&(r=!1),i===void 0&&(i=t());var a=e.width,o=e.height;e instanceof HTMLVideoElement&&(a=e.videoWidth,o=e.videoHeight);var s=n/Math.min(a,o),c=Math.ceil(a*s),l=Math.ceil(o*s),u=c-n,d=l-n;i.width=i.height=n;var f=i.getContext(`2d`);return f.drawImage(e,~~(u/2)*-1,~~(d/2)*-1,c,l),r&&(f.scale(-1,1),f.drawImage(i,n*-1,0)),i}e.cropTo=a})),q9=s((e=>{Object.defineProperty(e,`__esModule`,{value:!0}),e.version=`0.8.4-alpha2`})),J9=s((e=>{
/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/
var t=e&&e.__awaiter||function(e,t,n,r){function i(e){return e instanceof n?e:new n(function(t){t(e)})}return new(n||=Promise)(function(n,a){function o(e){try{c(r.next(e))}catch(e){a(e)}}function s(e){try{c(r.throw(e))}catch(e){a(e)}}function c(e){e.done?n(e.value):i(e.value).then(o,s)}c((r=r.apply(e,t||[])).next())})},n=e&&e.__generator||function(e,t){var n={label:0,sent:function(){if(a[0]&1)throw a[1];return a[1]},trys:[],ops:[]},r,i,a,o;return o={next:s(0),throw:s(1),return:s(2)},typeof Symbol==`function`&&(o[Symbol.iterator]=function(){return this}),o;function s(e){return function(t){return c([e,t])}}function c(o){if(r)throw TypeError(`Generator is already executing.`);for(;n;)try{if(r=1,i&&(a=o[0]&2?i.return:o[0]?i.throw||((a=i.return)&&a.call(i),0):i.next)&&!(a=a.call(i,o[1])).done)return a;switch(i=0,a&&(o=[o[0]&2,a.value]),o[0]){case 0:case 1:a=o;break;case 4:return n.label++,{value:o[1],done:!1};case 5:n.label++,i=o[1],o=[0];continue;case 7:o=n.ops.pop(),n.trys.pop();continue;default:if((a=n.trys,!(a=a.length>0&&a[a.length-1]))&&(o[0]===6||o[0]===2)){n=0;continue}if(o[0]===3&&(!a||o[1]>a[0]&&o[1]<a[3])){n.label=o[1];break}if(o[0]===6&&n.label<a[1]){n.label=a[1],a=o;break}if(a&&n.label<a[2]){n.label=a[2],n.ops.push(o);break}a[2]&&n.ops.pop(),n.trys.pop();continue}o=t.call(e,n)}catch(e){o=[6,e],i=0}finally{r=a=0}if(o[0]&5)throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}};Object.defineProperty(e,`__esModule`,{value:!0}),e.loadFromFiles=e.load=e.loadTruncatedMobileNet=e.CustomMobileNet=e.getTopKClasses=e.IMAGE_SIZE=void 0;var r=(W9(),d(H9)),i=(W9(),d(H9)),a=G9(),o=K9(),s=q9(),c=1,l=`conv_pw_13_relu`,u=`out_relu`,f=.25,p=.35;e.IMAGE_SIZE=224;var m=function(t){return t.packageVersion=t.packageVersion||s.version,t.packageName=t.packageName||`@teachablemachine/image`,t.timeStamp=t.timeStamp||new Date().toISOString(),t.userMetadata=t.userMetadata||{},t.modelName=t.modelName||`untitled`,t.labels=t.labels||[],t.imageSize=t.imageSize||e.IMAGE_SIZE,t},h=function(e){return!!e&&Array.isArray(e.labels)},g=function(e,t){if(e===1){if(t!==.25&&t!==.5&&t!==.75&&t!==1)return console.warn(`Invalid alpha. Options are: 0.25, 0.50, 0.75 or 1.00.`),console.log(`Loading model with alpha: `,f.toFixed(2)),f}else if(t!==.35&&t!==.5&&t!==.75&&t!==1)return console.warn(`Invalid alpha. Options are: 0.35, 0.50, 0.75 or 1.00.`),console.log(`Loading model with alpha: `,p.toFixed(2)),p;return t},_=function(t){if(t||={},t.checkpointUrl&&t.trainingLayer)return(t.alpha||t.version)&&console.warn(`Checkpoint URL passed to modelOptions, alpha options are ignored`),[t.checkpointUrl,t.trainingLayer];if(t.version=t.version||c,t.version===1){t.alpha=t.alpha||f,t.alpha=g(t.version,t.alpha),console.log(`Loading mobilenet `+t.version+` and alpha `+t.alpha);var n=t.alpha.toFixed(2);return n===`1.00`&&(n=`1.0`),[`https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_`+n+`_`+e.IMAGE_SIZE+`/model.json`,l]}else if(t.version===2)return t.alpha=t.alpha||p,t.alpha=g(t.version,t.alpha),console.log(`Loading mobilenet `+t.version+` and alpha `+t.alpha),[`https://storage.googleapis.com/teachable-machine-models/mobilenet_v2_weights_tf_dim_ordering_tf_kernels_`+t.alpha.toFixed(2)+`_`+e.IMAGE_SIZE+`_no_top/model.json`,u];else throw Error(`MobileNet V`+t.version+` doesn't exist`)},v=function(e){return t(void 0,void 0,void 0,function(){var t,r;return n(this,function(n){switch(n.label){case 0:return typeof e==`string`?[4,fetch(e)]:[3,3];case 1:return r=n.sent(),[4,r.json()];case 2:return t=n.sent(),[3,4];case 3:if(h(e))t=e;else throw Error(`Invalid Metadata provided`);n.label=4;case 4:return[2,m(t)]}})})};function y(e,i,a){return a===void 0&&(a=3),t(this,void 0,void 0,function(){var t;return n(this,function(n){switch(n.label){case 0:return[4,i.data()];case 1:return t=n.sent(),[2,r.tidy(function(){a=Math.min(a,t.length);for(var n=[],r=0;r<t.length;r++)n.push({value:t[r],index:r});n.sort(function(e,t){return t.value-e.value});for(var i=new Float32Array(a),o=new Int32Array(a),r=0;r<a;r++)i[r]=n[r].value,o[r]=n[r].index;for(var s=[],r=0;r<o.length;r++)s.push({className:e[o[r]],probability:i[r]});return s})]}})})}e.getTopKClasses=y;var b=function(){function s(e,t){this.model=e,this._metadata=m(t)}return Object.defineProperty(s,`EXPECTED_IMAGE_SIZE`,{get:function(){return e.IMAGE_SIZE},enumerable:!1,configurable:!0}),s.prototype.getMetadata=function(){return this._metadata},s.prototype.getTotalClasses=function(){return this.model.output.shape[1]},s.prototype.getClassLabels=function(){return this._metadata.labels},s.prototype.predictTopK=function(e,s,c){return s===void 0&&(s=10),c===void 0&&(c=!1),t(this,void 0,void 0,function(){var t,l,u,d=this;return n(this,function(n){switch(n.label){case 0:return t=o.cropTo(e,this._metadata.imageSize,c),l=r.tidy(function(){var e=a.capture(t,d._metadata.grayscale);return d.model.predict(e)}),[4,y(this._metadata.labels,l,s)];case 1:return u=n.sent(),i.dispose(l),[2,u]}})})},s.prototype.predict=function(e,s){return s===void 0&&(s=!1),t(this,void 0,void 0,function(){var t,c,l,u,d,f=this;return n(this,function(n){switch(n.label){case 0:return t=o.cropTo(e,this._metadata.imageSize,s),c=r.tidy(function(){var e=a.capture(t,f._metadata.grayscale);return f.model.predict(e)}),[4,c.data()];case 1:for(l=n.sent(),u=[],d=0;d<l.length;d++)u.push({className:this._metadata.labels[d],probability:l[d]});return i.dispose(c),[2,u]}})})},s.prototype.dispose=function(){this.truncatedModel.dispose()},s}();e.CustomMobileNet=b;function x(e){return t(this,void 0,void 0,function(){var t,i,a,o,s,c,l,s,c,l;return n(this,function(n){switch(n.label){case 0:return t=_(e),i=t[0],a=t[1],[4,r.loadLayersModel(i)];case 1:return o=n.sent(),e&&e.version===1?(s=o.getLayer(a),c=r.model({inputs:o.inputs,outputs:s.output}),l=r.sequential(),l.add(c),l.add(r.layers.flatten()),[2,l]):(s=o.getLayer(a),c=r.model({inputs:o.inputs,outputs:s.output}),l=r.sequential(),l.add(c),l.add(r.layers.globalAveragePooling2d({})),[2,l])}})})}e.loadTruncatedMobileNet=x;function S(e,i){return t(this,void 0,void 0,function(){var t,a,o;return n(this,function(n){switch(n.label){case 0:return[4,r.loadLayersModel(e)];case 1:return t=n.sent(),i?[4,v(i)]:[3,3];case 2:return o=n.sent(),[3,4];case 3:o=null,n.label=4;case 4:return a=o,[2,new b(t,a)]}})})}e.load=S;function C(e,i,a){return t(this,void 0,void 0,function(){var t,o,s,c;return n(this,function(n){switch(n.label){case 0:return[4,r.loadLayersModel(r.io.browserFiles([e,i]))];case 1:return t=n.sent(),[4,new Response(a).json()];case 2:return o=n.sent(),a?[4,v(o)]:[3,4];case 3:return c=n.sent(),[3,5];case 4:c=null,n.label=5;case 5:return s=c,[2,new b(t,s)]}})})}e.loadFromFiles=C})),Pye=s(((e,t)=>{(function(e,t,n){function r(e){var t=this,n=o();t.next=function(){var e=2091639*t.s0+t.c*23283064365386963e-26;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=e|0)},t.c=1,t.s0=n(` `),t.s1=n(` `),t.s2=n(` `),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function a(e,t){var n=new r(e),a=t&&t.state,o=n.next;return o.int32=function(){return n.next()*4294967296|0},o.double=function(){return o()+(o()*2097152|0)*11102230246251565e-32},o.quick=o,a&&(typeof a==`object`&&i(a,n),o.state=function(){return i(n,{})}),o}function o(){var e=4022871197;return function(t){t=t.toString();for(var n=0;n<t.length;n++){e+=t.charCodeAt(n);var r=.02519603282416938*e;e=r>>>0,r-=e,r*=e,e=r>>>0,r-=e,e+=r*4294967296}return(e>>>0)*23283064365386963e-26}}t&&t.exports?t.exports=a:n&&n.amd?n(function(){return a}):this.alea=a})(e,typeof t==`object`&&t,typeof define==`function`&&define)})),Fye=s(((e,t)=>{(function(e,t,n){function r(e){var t=this,n=``;t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(e|0)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=n.charCodeAt(r)|0,t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function a(e,t){var n=new r(e),a=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21);while(r===0);return r},o.int32=n.next,o.quick=o,a&&(typeof a==`object`&&i(a,n),o.state=function(){return i(n,{})}),o}t&&t.exports?t.exports=a:n&&n.amd?n(function(){return a}):this.xor128=a})(e,typeof t==`object`&&t,typeof define==`function`&&define)})),Iye=s(((e,t)=>{(function(e,t,n){function r(e){var t=this,n=``;t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^(e^e<<1))|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(e|0)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=n.charCodeAt(r)|0,r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function a(e,t){var n=new r(e),a=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21);while(r===0);return r},o.int32=n.next,o.quick=o,a&&(typeof a==`object`&&i(a,n),o.state=function(){return i(n,{})}),o}t&&t.exports?t.exports=a:n&&n.amd?n(function(){return a}):this.xorwow=a})(e,typeof t==`object`&&t,typeof define==`function`&&define)})),Lye=s(((e,t)=>{(function(e,t,n){function r(e){var t=this;t.next=function(){var e=t.x,n=t.i,r=e[n],i;return r^=r>>>7,i=r^r<<24,r=e[n+1&7],i^=r^r>>>10,r=e[n+3&7],i^=r^r>>>3,r=e[n+4&7],i^=r^r<<7,r=e[n+7&7],r^=r<<13,i^=r^r<<9,e[n]=i,t.i=n+1&7,i};function n(e,t){var n,r=[];if(t===(t|0))r[0]=t;else for(t=``+t,n=0;n<t.length;++n)r[n&7]=r[n&7]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&r[n]===0;++n);for(n==8?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}n(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function a(e,t){e??=+new Date;var n=new r(e),a=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21);while(r===0);return r},o.int32=n.next,o.quick=o,a&&(a.x&&i(a,n),o.state=function(){return i(n,{})}),o}t&&t.exports?t.exports=a:n&&n.amd?n(function(){return a}):this.xorshift7=a})(e,typeof t==`object`&&t,typeof define==`function`&&define)})),Rye=s(((e,t)=>{(function(e,t,n){function r(e){var t=this;t.next=function(){var e=t.w,n=t.X,r=t.i,i,a;return t.w=e=e+1640531527|0,a=n[r+34&127],i=n[r=r+1&127],a^=a<<13,i^=i<<17,a^=a>>>15,i^=i>>>12,a=n[r]=a^i,t.i=r,a+(e^e>>>16)|0};function n(e,t){var n,r,i,a,o,s=[],c=128;for(t===(t|0)?(r=t,t=null):(t+=`\0`,r=0,c=Math.max(c,t.length)),i=0,a=-32;a<c;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),a===0&&(o=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(o=o+1640531527|0,n=s[a&127]^=r+o,i=n==0?i+1:0);for(i>=128&&(s[(t&&t.length||0)&127]=-1),i=127,a=512;a>0;--a)r=s[i+34&127],n=s[i=i+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[i]=r^n;e.w=o,e.X=s,e.i=i}n(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function a(e,t){e??=+new Date;var n=new r(e),a=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21);while(r===0);return r},o.int32=n.next,o.quick=o,a&&(a.X&&i(a,n),o.state=function(){return i(n,{})}),o}t&&t.exports?t.exports=a:n&&n.amd?n(function(){return a}):this.xor4096=a})(e,typeof t==`object`&&t,typeof define==`function`&&define)})),zye=s(((e,t)=>{(function(e,t,n){function r(e){var t=this,n=``;t.next=function(){var e=t.b,n=t.c,r=t.d,i=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^i,i=i-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^i,t.a=i-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=e|0):n+=e;for(var r=0;r<n.length+20;r++)t.b^=n.charCodeAt(r)|0,t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function a(e,t){var n=new r(e),a=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21);while(r===0);return r},o.int32=n.next,o.quick=o,a&&(typeof a==`object`&&i(a,n),o.state=function(){return i(n,{})}),o}t&&t.exports?t.exports=a:n&&n.amd?n(function(){return a}):this.tychei=a})(e,typeof t==`object`&&t,typeof define==`function`&&define)})),Bye=s(((e,t)=>{(function(e,n){var r=(0,eval)(`this`),i=256,a=6,o=52,s=`random`,c=n.pow(i,a),l=n.pow(2,o),u=l*2,d=i-1,f;function p(t,r,o){var d=[];r=r==1?{entropy:!0}:r||{};var f=_(g(r.entropy?[t,y(e)]:t??v(),3),d),p=new m(d),b=function(){for(var e=p.g(a),t=c,n=0;e<l;)e=(e+n)*i,t*=i,n=p.g(1);for(;e>=u;)e/=2,t/=2,n>>>=1;return(e+n)/t};return b.int32=function(){return p.g(4)|0},b.quick=function(){return p.g(4)/4294967296},b.double=b,_(y(p.S),e),(r.pass||o||function(e,t,r,i){return i&&(i.S&&h(i,p),e.state=function(){return h(p,{})}),r?(n[s]=e,t):e})(b,f,`global`in r?r.global:this==n,r.state)}n[`seed`+s]=p;function m(e){var t,n=e.length,r=this,a=0,o=r.i=r.j=0,s=r.S=[];for(n||(e=[n++]);a<i;)s[a]=a++;for(a=0;a<i;a++)s[a]=s[o=d&o+e[a%n]+(t=s[a])],s[o]=t;(r.g=function(e){for(var t,n=0,a=r.i,o=r.j,s=r.S;e--;)t=s[a=d&a+1],n=n*i+s[d&(s[a]=s[o=d&o+t])+(s[o]=t)];return r.i=a,r.j=o,n})(i)}function h(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n=[],r=typeof e,i;if(t&&r==`object`)for(i in e)try{n.push(g(e[i],t-1))}catch{}return n.length?n:r==`string`?e:e+`\0`}function _(e,t){for(var n=e+``,r,i=0;i<n.length;)t[d&i]=d&(r^=t[d&i]*19)+n.charCodeAt(i++);return y(t)}function v(){try{var t;return f&&(t=f.randomBytes)?t=t(i):(t=new Uint8Array(i),(r.crypto||r.msCrypto).getRandomValues(t)),y(t)}catch{var n=r.navigator,a=n&&n.plugins;return[+new Date,r,a,r.screen,y(e)]}}function y(e){return String.fromCharCode.apply(0,e)}if(_(n.random(),e),typeof t==`object`&&t.exports){t.exports=p;try{f=lc()}catch{}}else typeof define==`function`&&define.amd&&define(function(){return p})})([],Math)})),Y9=s(((e,t)=>{var n=Pye(),r=Fye(),i=Iye(),a=Lye(),o=Rye(),s=zye(),c=Bye();c.alea=n,c.xor128=r,c.xorwow=i,c.xorshift7=a,c.xor4096=o,c.tychei=s,t.exports=c})),Vye=s((e=>{
/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/
var t=e&&e.__extends||(function(){var e=function(t,n){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])},e(t,n)};return function(t,n){e(t,n);function r(){this.constructor=t}t.prototype=n===null?Object.create(n):(r.prototype=n.prototype,new r)}})(),n=e&&e.__awaiter||function(e,t,n,r){function i(e){return e instanceof n?e:new n(function(t){t(e)})}return new(n||=Promise)(function(n,a){function o(e){try{c(r.next(e))}catch(e){a(e)}}function s(e){try{c(r.throw(e))}catch(e){a(e)}}function c(e){e.done?n(e.value):i(e.value).then(o,s)}c((r=r.apply(e,t||[])).next())})},r=e&&e.__generator||function(e,t){var n={label:0,sent:function(){if(a[0]&1)throw a[1];return a[1]},trys:[],ops:[]},r,i,a,o;return o={next:s(0),throw:s(1),return:s(2)},typeof Symbol==`function`&&(o[Symbol.iterator]=function(){return this}),o;function s(e){return function(t){return c([e,t])}}function c(o){if(r)throw TypeError(`Generator is already executing.`);for(;n;)try{if(r=1,i&&(a=o[0]&2?i.return:o[0]?i.throw||((a=i.return)&&a.call(i),0):i.next)&&!(a=a.call(i,o[1])).done)return a;switch(i=0,a&&(o=[o[0]&2,a.value]),o[0]){case 0:case 1:a=o;break;case 4:return n.label++,{value:o[1],done:!1};case 5:n.label++,i=o[1],o=[0];continue;case 7:o=n.ops.pop(),n.trys.pop();continue;default:if((a=n.trys,!(a=a.length>0&&a[a.length-1]))&&(o[0]===6||o[0]===2)){n=0;continue}if(o[0]===3&&(!a||o[1]>a[0]&&o[1]<a[3])){n.label=o[1];break}if(o[0]===6&&n.label<a[1]){n.label=a[1],a=o;break}if(a&&n.label<a[2]){n.label=a[2],n.ops.push(o);break}a[2]&&n.ops.pop(),n.trys.pop();continue}o=t.call(e,n)}catch(e){o=[6,e],i=0}finally{r=a=0}if(o[0]&5)throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}};Object.defineProperty(e,`__esModule`,{value:!0});var i=(W9(),d(H9)),a=(W9(),d(H9)),o=G9(),s=J9(),c=Y9(),l=.15,u=function(e){return typeof e.dataId==`object`&&typeof e.shape==`object`};function f(e,t){var n=Array(t).fill(0);return n[e]=1,n}function p(e,t){for(var n,r=e.length,i=e.slice(),a=r-1;a>0;--a){var o=void 0;o=t?Math.floor(t()*(a+1)):Math.floor(Math.random()*(a+1)),n=[i[o],i[a]],i[a]=n[0],i[o]=n[1]}return i}var m=function(e){t(s,e);function s(t,n){var r=e.call(this,i.sequential(),n)||this;return r.totalSamples=0,r.examples=[],r.truncatedModel=t,r}return Object.defineProperty(s.prototype,`asSequentialModel`,{get:function(){return this.model},enumerable:!1,configurable:!0}),Object.defineProperty(s.prototype,`isTrained`,{get:function(){return!!this.model&&this.model.layers&&this.model.layers.length>2},enumerable:!1,configurable:!0}),Object.defineProperty(s.prototype,`isPrepared`,{get:function(){return!!this.trainDataset},enumerable:!1,configurable:!0}),Object.defineProperty(s.prototype,`numClasses`,{get:function(){return this._metadata.labels.length},enumerable:!1,configurable:!0}),s.prototype.addExample=function(e,t){return n(this,void 0,void 0,function(){var n,i,a;return r(this,function(r){return n=u(t)?t:o.capture(t,this._metadata.grayscale),i=this.truncatedModel.predict(n),a=i.dataSync(),n.dispose(),i.dispose(),this.examples[e].push(a),this.totalSamples++,[2]})})},s.prototype.predict=function(t,i){return i===void 0&&(i=!1),n(this,void 0,void 0,function(){return r(this,function(n){if(!this.model)throw Error(`Model has not been trained yet, called train() first`);return[2,e.prototype.predict.call(this,t,i)]})})},s.prototype.predictTopK=function(t,i,a){return i===void 0&&(i=10),a===void 0&&(a=!1),n(this,void 0,void 0,function(){return r(this,function(n){if(!this.model)throw Error(`Model has not been trained yet, called train() first`);return[2,e.prototype.predictTopK.call(this,t,i,a)]})})},s.prototype.prepare=function(){for(var e in this.examples)if(e.length===0)throw Error(`Add some examples before training`);var t=this.convertToTfDataset();this.trainDataset=t.trainDataset,this.validationDataset=t.validationDataset},s.prototype.convertToTfDataset=function(){for(var e=0;e<this.examples.length;e++)this.examples[e]=p(this.examples[e],this.seed);for(var t=[],n=[],r=function(e){var r=f(e,a.numClasses),i=a.examples[e].length,o=Math.ceil(l*i),s=i-o,c=a.examples[e].slice(0,s).map(function(e){return{data:e,label:r}}),u=a.examples[e].slice(s).map(function(e){return{data:e,label:r}});t=t.concat(c),n=n.concat(u)},a=this,e=0;e<this.examples.length;e++)r(e);t=p(t,this.seed),n=p(n,this.seed);var o=i.data.array(t.map(function(e){return e.data})),s=i.data.array(n.map(function(e){return e.data})),c=i.data.array(t.map(function(e){return e.label})),u=i.data.array(n.map(function(e){return e.label}));return{trainDataset:i.data.zip({xs:o,ys:c}),validationDataset:i.data.zip({xs:s,ys:u})}},s.prototype.save=function(e,t){return n(this,void 0,void 0,function(){return r(this,function(n){return[2,this.model.save(e,t)]})})},s.prototype.train=function(e,t){return t===void 0&&(t={}),n(this,void 0,void 0,function(){var n,o,s,c,l,u,d,f,p,m=this;return r(this,function(r){switch(r.label){case 0:if(n=t.onTrainEnd||(function(){}),t.onTrainEnd=function(e){m.__stopTrainingResolve&&=(m.__stopTrainingResolve(),null),n(e)},this.isPrepared||this.prepare(),o=this.getLabels().length,a.util.assert(o===this.numClasses,function(){return`Can not train, has `+o+` labels and `+m.numClasses+` classes`}),s=this.truncatedModel.outputs[0].shape.slice(1),c=i.util.sizeFromShape(s),l=this.seed?i.initializers.varianceScaling({seed:3.14}):i.initializers.varianceScaling({}),this.trainingModel=i.sequential({layers:[i.layers.dense({inputShape:[c],units:e.denseUnits,activation:`relu`,kernelInitializer:l,useBias:!0}),i.layers.dense({kernelInitializer:l,useBias:!1,activation:`softmax`,units:this.numClasses})]}),u=i.train.adam(e.learningRate),this.trainingModel.compile({optimizer:u,loss:`categoricalCrossentropy`,metrics:[`accuracy`]}),!(e.batchSize>0))throw Error(`Batch size is 0 or NaN. Please choose a non-zero fraction`);return d=this.trainDataset.batch(e.batchSize),f=this.validationDataset.batch(e.batchSize),[4,this.trainingModel.fitDataset(d,{epochs:e.epochs,validationData:f,callbacks:t})];case 1:return r.sent(),p=i.sequential(),p.add(this.truncatedModel),p.add(this.trainingModel),this.model=p,u.dispose(),[2,this.model]}})})},s.prototype.prepareDataset=function(){for(var e=0;e<this.numClasses;e++)this.examples[e]=[]},s.prototype.setLabel=function(e,t){this._metadata.labels[e]=t},s.prototype.setLabels=function(e){this._metadata.labels=e,this.prepareDataset()},s.prototype.getLabel=function(e){return this._metadata.labels[e]},s.prototype.getLabels=function(){return this._metadata.labels},s.prototype.setName=function(e){this._metadata.modelName=e},s.prototype.getName=function(){return this._metadata.modelName},s.prototype.stopTraining=function(){var e=this;return new Promise(function(t,n){e.trainingModel.stopTraining=!0,e.__stopTrainingResolve=t})},s.prototype.dispose=function(){this.trainingModel.dispose(),e.prototype.dispose.call(this)},s.prototype.calculateAccuracyPerClass=function(){return n(this,void 0,void 0,function(){var e,t,a,o,s,c,l,u,d,f,p,m,h,g,_,v,y,b,p,x=this;return r(this,function(S){switch(S.label){case 0:return e=this.validationDataset.mapAsync(function(e){return n(x,void 0,void 0,function(){return r(this,function(t){return[2,e.xs]})})}),t=this.validationDataset.mapAsync(function(e){return n(x,void 0,void 0,function(){return r(this,function(t){return[2,e.ys]})})}),a=Math.min(t.size,32),o=Math.ceil(t.size/a),s=e.batch(a),c=t.batch(a),[4,s.iterator()];case 1:return l=S.sent(),[4,c.iterator()];case 2:u=S.sent(),d=[],f=[],p=0,S.label=3;case 3:return p<o?[4,l.next()]:[3,7];case 4:return m=S.sent(),h=this.trainingModel.predict(m.value),g=h.argMax(1),d.push(g),[4,u.next()];case 5:_=S.sent(),v=_.value.argMax(1),f.push(v),m.value.dispose(),h.dispose(),_.value.dispose(),S.label=6;case 6:return p++,[3,3];case 7:if(y=i.concat(f),b=i.concat(d),o!==1)for(p=0;p<d.length;p++)d[p].dispose(),f[p].dispose();return[2,{reference:y,predictions:b}]}})})},s.prototype.setSeed=function(e){this.seed=c(e)},s}(s.CustomMobileNet);e.TeachableMobileNet=m;function h(e,t){return n(this,void 0,void 0,function(){var n;return r(this,function(r){switch(r.label){case 0:return[4,s.loadTruncatedMobileNet(t)];case 1:return n=r.sent(),[2,new m(n,e)]}})})}e.createTeachable=h})),Hye=c({boundClass:()=>Q9,boundMethod:()=>Z9,default:()=>Uye});function X9(e){return X9=typeof Symbol==`function`&&typeof Symbol.iterator==`symbol`?function(e){return typeof e}:function(e){return e&&typeof Symbol==`function`&&e.constructor===Symbol&&e!==Symbol.prototype?`symbol`:typeof e},X9(e)}function Z9(e,t,n){var r=n.value;if(typeof r!=`function`)throw TypeError(`@boundMethod decorator can only be applied to methods not: ${X9(r)}`);var i=!1;return{configurable:!0,get:function(){if(i||this===e.prototype||this.hasOwnProperty(t)||typeof r!=`function`)return r;var n=r.bind(this);return i=!0,Object.defineProperty(this,t,{configurable:!0,get:function(){return n},set:function(e){r=e,delete this[t]}}),i=!1,n},set:function(e){r=e}}}function Q9(e){var t;return typeof Reflect<`u`&&typeof Reflect.ownKeys==`function`?t=Reflect.ownKeys(e.prototype):(t=Object.getOwnPropertyNames(e.prototype),typeof Object.getOwnPropertySymbols==`function`&&(t=t.concat(Object.getOwnPropertySymbols(e.prototype)))),t.forEach(function(t){if(t!==`constructor`){var n=Object.getOwnPropertyDescriptor(e.prototype,t);typeof n.value==`function`&&Object.defineProperty(e.prototype,t,Z9(e,t,n))}}),e}function Uye(){return arguments.length===1?Q9.apply(void 0,arguments):Z9.apply(void 0,arguments)}var Wye=o((()=>{})),Gye=s((e=>{
/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/
var t=e&&e.__decorate||function(e,t,n,r){var i=arguments.length,a=i<3?t:r===null?r=Object.getOwnPropertyDescriptor(t,n):r,o;if(typeof Reflect==`object`&&typeof Reflect.decorate==`function`)a=Reflect.decorate(e,t,n,r);else for(var s=e.length-1;s>=0;s--)(o=e[s])&&(a=(i<3?o(a):i>3?o(t,n,a):o(t,n))||a);return i>3&&a&&Object.defineProperty(t,n,a),a},n=e&&e.__awaiter||function(e,t,n,r){function i(e){return e instanceof n?e:new n(function(t){t(e)})}return new(n||=Promise)(function(n,a){function o(e){try{c(r.next(e))}catch(e){a(e)}}function s(e){try{c(r.throw(e))}catch(e){a(e)}}function c(e){e.done?n(e.value):i(e.value).then(o,s)}c((r=r.apply(e,t||[])).next())})},r=e&&e.__generator||function(e,t){var n={label:0,sent:function(){if(a[0]&1)throw a[1];return a[1]},trys:[],ops:[]},r,i,a,o;return o={next:s(0),throw:s(1),return:s(2)},typeof Symbol==`function`&&(o[Symbol.iterator]=function(){return this}),o;function s(e){return function(t){return c([e,t])}}function c(o){if(r)throw TypeError(`Generator is already executing.`);for(;n;)try{if(r=1,i&&(a=o[0]&2?i.return:o[0]?i.throw||((a=i.return)&&a.call(i),0):i.next)&&!(a=a.call(i,o[1])).done)return a;switch(i=0,a&&(o=[o[0]&2,a.value]),o[0]){case 0:case 1:a=o;break;case 4:return n.label++,{value:o[1],done:!1};case 5:n.label++,i=o[1],o=[0];continue;case 7:o=n.ops.pop(),n.trys.pop();continue;default:if((a=n.trys,!(a=a.length>0&&a[a.length-1]))&&(o[0]===6||o[0]===2)){n=0;continue}if(o[0]===3&&(!a||o[1]>a[0]&&o[1]<a[3])){n.label=o[1];break}if(o[0]===6&&n.label<a[1]){n.label=a[1],a=o;break}if(a&&n.label<a[2]){n.label=a[2],n.ops.push(o);break}a[2]&&n.ops.pop(),n.trys.pop();continue}o=t.call(e,n)}catch(e){o=[6,e],i=0}finally{r=a=0}if(o[0]&5)throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}};Object.defineProperty(e,`__esModule`,{value:!0});var i=(Wye(),d(Hye)),a=K9(),o={facingMode:`user`,frameRate:24},s=function(e){return e.facingMode=e.facingMode||o.facingMode,e.frameRate=e.frameRate||o.frameRate,e.aspectRatio=e.aspectRatio||o.aspectRatio,e};e.Webcam=function(){function e(e,t,n){e===void 0&&(e=400),t===void 0&&(t=400),n===void 0&&(n=!1),this.width=e,this.height=t,this.flip=n}return e.prototype.getWebcam=function(e){if(e===void 0&&(e={}),!window.navigator.mediaDevices||!window.navigator.mediaDevices.getUserMedia)return Promise.reject(`Your browser does not support WebRTC. Please try another one.`);e.width=640;var t=s(e),n=document.createElement(`video`);return window.navigator.mediaDevices.getUserMedia({video:t}).then(function(e){return n.srcObject=e,n.addEventListener(`loadedmetadata`,function(e){var t=n.videoWidth,r=n.videoHeight;n.width=t,n.height=r}),n},function(){return Promise.reject(`Could not open your camera. You may have denied access.`)})},e.prototype.setup=function(e){return e===void 0&&(e={}),n(this,void 0,void 0,function(){var t;return r(this,function(n){switch(n.label){case 0:return this.webcam?[3,2]:(t=this,[4,this.getWebcam(e)]);case 1:t.webcam=n.sent(),this.canvas||(this.canvas=document.createElement(`canvas`),this.canvas.width=this.width,this.canvas.height=this.height),n.label=2;case 2:return[2]}})})},e.prototype.play=function(){return this.webcam.play()},e.prototype.pause=function(){this.webcam.pause()},e.prototype.stop=function(){this.stopStreamedVideo(this.webcam)},e.prototype.update=function(){this.renderCameraToCanvas()},e.prototype.stopStreamedVideo=function(e){e.srcObject.getTracks().forEach(function(e){e.stop()}),e.srcObject=null},e.prototype.renderCameraToCanvas=function(){if(this.canvas&&this.webcam){var e=this.canvas.getContext(`2d`);if(this.webcam.videoWidth!==0){var t=a.cropTo(this.webcam,this.width,this.flip);e.drawImage(t,0,0)}}},t([i.default],e.prototype,`getWebcam`,null),t([i.default],e.prototype,`setup`,null),t([i.default],e.prototype,`play`,null),t([i.default],e.prototype,`pause`,null),t([i.default],e.prototype,`stop`,null),t([i.default],e.prototype,`update`,null),t([i.default],e.prototype,`stopStreamedVideo`,null),t([i.default],e.prototype,`renderCameraToCanvas`,null),e}()})),Kye=s((e=>{
/**
* @license
* Copyright 2019 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/
Object.defineProperty(e,`__esModule`,{value:!0});var t=J9();Object.defineProperty(e,`IMAGE_SIZE`,{enumerable:!0,get:function(){return t.IMAGE_SIZE}}),Object.defineProperty(e,`CustomMobileNet`,{enumerable:!0,get:function(){return t.CustomMobileNet}}),Object.defineProperty(e,`load`,{enumerable:!0,get:function(){return t.load}}),Object.defineProperty(e,`loadFromFiles`,{enumerable:!0,get:function(){return t.loadFromFiles}}),Object.defineProperty(e,`loadTruncatedMobileNet`,{enumerable:!0,get:function(){return t.loadTruncatedMobileNet}});var n=Vye();Object.defineProperty(e,`TeachableMobileNet`,{enumerable:!0,get:function(){return n.TeachableMobileNet}}),Object.defineProperty(e,`createTeachable`,{enumerable:!0,get:function(){return n.createTeachable}});var r=Gye();Object.defineProperty(e,`Webcam`,{enumerable:!0,get:function(){return r.Webcam}});var i=q9();Object.defineProperty(e,`version`,{enumerable:!0,get:function(){return i.version}})}));W9();var qye=u(Kye()),Jye=500,Yye=.93,Xye=1,$9=[{url:`https://teachablemachine.withgoogle.com/models/YBFEWlPng/`,name:`Grupo A-E`}],Zye=({videoStreamRef:e,onTextRecognized:t})=>{let[n,r]=(0,b.useState)([]),[i,a]=(0,b.useState)(!1),[o,s]=(0,b.useState)(`Carregando modelos TensorFlow...`),[c,l]=(0,b.useState)(null),u=(0,b.useRef)([]);(0,b.useEffect)(()=>{(async()=>{let e=0,t=[];for(let n of $9){s(`Carregando ${n.name}...`);try{let r=await qye.load(n.url+`model.json`,n.url+`metadata.json`);t.push({model:r,name:n.name}),e++}catch(e){console.error(`Erro ao carregar o modelo ${n.name}:`,e),s(`Falha ao carregar ${n.name}. Verifique o link.`)}}e===$9.length?(a(!0),r(t),u.current=t,s(`Todos os ${e} modelos foram carregados com sucesso!`)):e>0?(a(!0),r(t),u.current=t,s(`Ateno: Apenas ${e}/${$9.length} modelos foram carregados.`)):s(`Nenhum modelo pde ser carregado. Verifique os links.`)})()},[]);let d=(0,b.useCallback)(async()=>{let n=e.current;if(u.current.length===0||!n||n.readyState!==4)return;let r={className:``,probability:0,modelName:``};for(let e of u.current)try{let t=await e.model.predict(n,Xye),i={className:``,probability:0};t.forEach(e=>{e.probability>i.probability&&(i=e)}),i.probability>r.probability&&(r={className:i.className.trim(),probability:i.probability,modelName:e.name})}catch(t){console.error(`Erro de previso no ${e.name}:`,t)}if(r.probability>Yye){let e=r.className,n=e.toLowerCase().includes(`background`);e!==c&&!n&&(t(e),l(e),console.log(`NOVO Reconhecido [${r.modelName}]: ${e} (${(r.probability*100).toFixed(2)}%)`))}else c!==null&&l(null)},[e,t,c]);return(0,b.useEffect)(()=>{if(!i)return;let t,n=()=>{e.current&&e.current.readyState>=3?t=setInterval(d,Jye):setTimeout(n,100)};return n(),()=>{t&&clearInterval(t)}},[i,d,e]),(0,S.jsx)(S.Fragment,{children:(0,S.jsx)(`p`,{style:{color:i?`#4A90E2`:`gray`,fontSize:`0.9em`,textAlign:`center`,margin:`0`,padding:`10px 0`},children:o})})};function Qye(){let[e,t]=(0,b.useState)(``),[n,r]=(0,b.useState)(``),i=(0,b.useRef)(null),[a,o]=(0,b.useState)(!1),s=(0,b.useCallback)(e=>{r(t=>t+e)},[]),c=()=>{r(``)},l=()=>{o(e=>!e),a&&r(``)},u=()=>{if(e.trim()===``){console.error(`Por favor, digite um texto para traduzir.`);return}window.accessibility&&window.accessibility.sendContent?(console.log(`VLibras acionado para ler o contedo da textarea.`),window.accessibility.sendContent(`textarea-vlibras`)):console.error(` O widget VLibras precisa ser ATIVADO primeiro (clique no cone no canto).`)};return(0,S.jsxs)(S.Fragment,{children:[(0,S.jsx)(`header`,{children:(0,S.jsx)(`h1`,{className:`main-title`,children:` DSign Tradutor de LIBRAS `})}),(0,S.jsxs)(`div`,{className:`cards-container`,children:[(0,S.jsxs)(w,{title:`Surdo-Ouvinte (Datilologia para Texto)`,children:[(0,S.jsx)(`div`,{className:`camera-control-row`,children:(0,S.jsx)(`button`,{className:a?`camera-off-button`:`camera-on-button`,onClick:l,children:a?` Desligar Cmera`:` Ligar Cmera`})}),(0,S.jsx)(`div`,{className:`video-placeholder`,children:a?(0,S.jsx)(C,{ref:i}):(0,S.jsx)(`div`,{className:`camera-off-message`,children:(0,S.jsx)(`p`,{children:`Cmera Desligada. Pressione "Ligar Cmera" para comear a sinalizar.`})})}),a&&(0,S.jsx)(Zye,{videoStreamRef:i,onTextRecognized:s}),(0,S.jsx)(`div`,{className:`action-row`,children:(0,S.jsx)(`button`,{className:`clear-button`,onClick:c,disabled:n.length===0,children:`Limpar Texto`})}),(0,S.jsx)(`div`,{className:`result-area`,children:(0,S.jsx)(`p`,{className:`result-text`,children:n||`Texto reconhecido aparecer aqui...`})})]}),(0,S.jsxs)(w,{title:`Ouvinte-Surdo (Texto para LIBRAS)`,children:[(0,S.jsx)(`textarea`,{className:`input-textarea`,id:`textarea-vlibras`,placeholder:`Digite sua mensagem para traduo...`,rows:`5`,value:e,onChange:e=>t(e.target.value),"data-vlibras":!0}),(0,S.jsx)(`button`,{className:`translate-button`,onClick:u,"aria-hidden":`true`,children:`Traduzir para LIBRAS`}),(0,S.jsx)(`div`,{className:`vlibras-placeholder`,children:(0,S.jsx)(`p`,{children:`O avatar VLibras aparecer no canto da tela.`})})]})]})]})}var $ye=Qye;(0,y.createRoot)(document.getElementById(`root`)).render((0,S.jsx)(b.StrictMode,{children:(0,S.jsx)($ye,{})}));